'use strict';

var require$$0 = require('events');
var require$$4 = require('timers');
var require$$0$4 = require('util');
var require$$0$1 = require('stream');
var require$$0$2 = require('tty');
var require$$0$3 = require('os');
var require$$0$5 = require('path');
var require$$1 = require('fs');
var require$$1$1 = require('url');
var require$$0$6 = require('assert');
var require$$0$7 = require('dns');
var require$$1$2 = require('net');
var require$$0$8 = require('crypto');
var require$$2 = require('tls');
var require$$0$a = require('https');
var require$$0$9 = require('zlib');
var require$$0$b = require('vm');

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

var tarnExports = {};
var tarn = {
  get exports(){ return tarnExports; },
  set exports(v){ tarnExports = v; },
};

var Pool$2 = {};

var PendingOperation$1 = {};

var TimeoutError$2 = {};

Object.defineProperty(TimeoutError$2, "__esModule", { value: true });
let TimeoutError$1 = class TimeoutError extends Error {
};
TimeoutError$2.TimeoutError = TimeoutError$1;

var utils$L = {};

var PromiseInspection$1 = {};

Object.defineProperty(PromiseInspection$1, "__esModule", { value: true });
class PromiseInspection {
    constructor(args) {
        this._value = args.value;
        this._error = args.error;
    }
    value() {
        return this._value;
    }
    reason() {
        return this._error;
    }
    isRejected() {
        return !!this._error;
    }
    isFulfilled() {
        return !!this._value;
    }
}
PromiseInspection$1.PromiseInspection = PromiseInspection;

Object.defineProperty(utils$L, "__esModule", { value: true });
const PromiseInspection_1 = PromiseInspection$1;
function defer() {
    let resolve = null;
    let reject = null;
    const promise = new Promise((resolver, rejecter) => {
        resolve = resolver;
        reject = rejecter;
    });
    return {
        promise,
        resolve,
        reject
    };
}
utils$L.defer = defer;
function now() {
    return Date.now();
}
utils$L.now = now;
function duration$1(t1, t2) {
    return Math.abs(t2 - t1);
}
utils$L.duration = duration$1;
function checkOptionalTime(time) {
    if (typeof time === 'undefined') {
        return true;
    }
    return checkRequiredTime(time);
}
utils$L.checkOptionalTime = checkOptionalTime;
function checkRequiredTime(time) {
    return typeof time === 'number' && time === Math.round(time) && time > 0;
}
utils$L.checkRequiredTime = checkRequiredTime;
function delay$3(millis) {
    return new Promise(resolve => setTimeout(resolve, millis));
}
utils$L.delay = delay$3;
function reflect(promise) {
    return promise
        .then(value => {
        return new PromiseInspection_1.PromiseInspection({ value });
    })
        .catch(error => {
        return new PromiseInspection_1.PromiseInspection({ error });
    });
}
utils$L.reflect = reflect;
function tryPromise(cb) {
    try {
        const result = cb();
        return Promise.resolve(result);
    }
    catch (err) {
        return Promise.reject(err);
    }
}
utils$L.tryPromise = tryPromise;

Object.defineProperty(PendingOperation$1, "__esModule", { value: true });
const TimeoutError_1 = TimeoutError$2;
const utils_1$2 = utils$L;
class PendingOperation {
    constructor(timeoutMillis) {
        this.timeoutMillis = timeoutMillis;
        this.deferred = utils_1$2.defer();
        this.possibleTimeoutCause = null;
        this.isRejected = false;
        this.promise = timeout$4(this.deferred.promise, timeoutMillis).catch(err => {
            if (err instanceof TimeoutError_1.TimeoutError) {
                if (this.possibleTimeoutCause) {
                    err = new TimeoutError_1.TimeoutError(this.possibleTimeoutCause.message);
                }
                else {
                    err = new TimeoutError_1.TimeoutError('operation timed out for an unknown reason');
                }
            }
            this.isRejected = true;
            return Promise.reject(err);
        });
    }
    abort() {
        this.reject(new Error('aborted'));
    }
    reject(err) {
        this.deferred.reject(err);
    }
    resolve(value) {
        this.deferred.resolve(value);
    }
}
PendingOperation$1.PendingOperation = PendingOperation;
function timeout$4(promise, time) {
    return new Promise((resolve, reject) => {
        const timeoutHandle = setTimeout(() => reject(new TimeoutError_1.TimeoutError()), time);
        promise
            .then(result => {
            clearTimeout(timeoutHandle);
            resolve(result);
        })
            .catch(err => {
            clearTimeout(timeoutHandle);
            reject(err);
        });
    });
}

var Resource$1 = {};

Object.defineProperty(Resource$1, "__esModule", { value: true });
const utils_1$1 = utils$L;
class Resource {
    constructor(resource) {
        this.resource = resource;
        this.resource = resource;
        this.timestamp = utils_1$1.now();
        this.deferred = utils_1$1.defer();
    }
    get promise() {
        return this.deferred.promise;
    }
    resolve() {
        this.deferred.resolve(undefined);
        return new Resource(this.resource);
    }
}
Resource$1.Resource = Resource;

Object.defineProperty(Pool$2, "__esModule", { value: true });
const PendingOperation_1 = PendingOperation$1;
const Resource_1 = Resource$1;
const utils_1 = utils$L;
const events_1 = require$$0;
const timers_1 = require$$4;
let Pool$1 = class Pool {
    constructor(opt) {
        this.destroyed = false;
        this.emitter = new events_1.EventEmitter();
        opt = opt || {};
        if (!opt.create) {
            throw new Error('Tarn: opt.create function most be provided');
        }
        if (!opt.destroy) {
            throw new Error('Tarn: opt.destroy function most be provided');
        }
        if (typeof opt.min !== 'number' || opt.min < 0 || opt.min !== Math.round(opt.min)) {
            throw new Error('Tarn: opt.min must be an integer >= 0');
        }
        if (typeof opt.max !== 'number' || opt.max <= 0 || opt.max !== Math.round(opt.max)) {
            throw new Error('Tarn: opt.max must be an integer > 0');
        }
        if (opt.min > opt.max) {
            throw new Error('Tarn: opt.max is smaller than opt.min');
        }
        if (!utils_1.checkOptionalTime(opt.acquireTimeoutMillis)) {
            throw new Error('Tarn: invalid opt.acquireTimeoutMillis ' + JSON.stringify(opt.acquireTimeoutMillis));
        }
        if (!utils_1.checkOptionalTime(opt.createTimeoutMillis)) {
            throw new Error('Tarn: invalid opt.createTimeoutMillis ' + JSON.stringify(opt.createTimeoutMillis));
        }
        if (!utils_1.checkOptionalTime(opt.destroyTimeoutMillis)) {
            throw new Error('Tarn: invalid opt.destroyTimeoutMillis ' + JSON.stringify(opt.destroyTimeoutMillis));
        }
        if (!utils_1.checkOptionalTime(opt.idleTimeoutMillis)) {
            throw new Error('Tarn: invalid opt.idleTimeoutMillis ' + JSON.stringify(opt.idleTimeoutMillis));
        }
        if (!utils_1.checkOptionalTime(opt.reapIntervalMillis)) {
            throw new Error('Tarn: invalid opt.reapIntervalMillis ' + JSON.stringify(opt.reapIntervalMillis));
        }
        if (!utils_1.checkOptionalTime(opt.createRetryIntervalMillis)) {
            throw new Error('Tarn: invalid opt.createRetryIntervalMillis ' +
                JSON.stringify(opt.createRetryIntervalMillis));
        }
        const allowedKeys = {
            create: true,
            validate: true,
            destroy: true,
            log: true,
            min: true,
            max: true,
            acquireTimeoutMillis: true,
            createTimeoutMillis: true,
            destroyTimeoutMillis: true,
            idleTimeoutMillis: true,
            reapIntervalMillis: true,
            createRetryIntervalMillis: true,
            propagateCreateError: true
        };
        for (const key of Object.keys(opt)) {
            if (!allowedKeys[key]) {
                throw new Error(`Tarn: unsupported option opt.${key}`);
            }
        }
        this.creator = opt.create;
        this.destroyer = opt.destroy;
        this.validate = typeof opt.validate === 'function' ? opt.validate : () => true;
        this.log = opt.log || (() => { });
        this.acquireTimeoutMillis = opt.acquireTimeoutMillis || 30000;
        this.createTimeoutMillis = opt.createTimeoutMillis || 30000;
        this.destroyTimeoutMillis = opt.destroyTimeoutMillis || 5000;
        this.idleTimeoutMillis = opt.idleTimeoutMillis || 30000;
        this.reapIntervalMillis = opt.reapIntervalMillis || 1000;
        this.createRetryIntervalMillis = opt.createRetryIntervalMillis || 200;
        this.propagateCreateError = !!opt.propagateCreateError;
        this.min = opt.min;
        this.max = opt.max;
        // All the resources, which are either already acquired or which are
        // considered for being passed to acquire in async validation phase.
        this.used = [];
        // All the resources, which are either just created and free or returned
        // back to pool after using.
        this.free = [];
        this.pendingCreates = [];
        this.pendingAcquires = [];
        this.pendingDestroys = [];
        // When acquire is pending, but also still in validation phase
        this.pendingValidations = [];
        this.destroyed = false;
        this.interval = null;
        this.eventId = 1;
    }
    numUsed() {
        return this.used.length;
    }
    numFree() {
        return this.free.length;
    }
    numPendingAcquires() {
        return this.pendingAcquires.length;
    }
    numPendingValidations() {
        return this.pendingValidations.length;
    }
    numPendingCreates() {
        return this.pendingCreates.length;
    }
    acquire() {
        const eventId = this.eventId++;
        this._executeEventHandlers('acquireRequest', eventId);
        const pendingAcquire = new PendingOperation_1.PendingOperation(this.acquireTimeoutMillis);
        this.pendingAcquires.push(pendingAcquire);
        // If the acquire fails for whatever reason
        // remove it from the pending queue.
        pendingAcquire.promise = pendingAcquire.promise
            .then(resource => {
            this._executeEventHandlers('acquireSuccess', eventId, resource);
            return resource;
        })
            .catch(err => {
            this._executeEventHandlers('acquireFail', eventId, err);
            remove(this.pendingAcquires, pendingAcquire);
            return Promise.reject(err);
        });
        this._tryAcquireOrCreate();
        return pendingAcquire;
    }
    release(resource) {
        this._executeEventHandlers('release', resource);
        for (let i = 0, l = this.used.length; i < l; ++i) {
            const used = this.used[i];
            if (used.resource === resource) {
                this.used.splice(i, 1);
                this.free.push(used.resolve());
                this._tryAcquireOrCreate();
                return true;
            }
        }
        return false;
    }
    isEmpty() {
        return ([
            this.numFree(),
            this.numUsed(),
            this.numPendingAcquires(),
            this.numPendingValidations(),
            this.numPendingCreates()
        ].reduce((total, value) => total + value) === 0);
    }
    /**
     * Reaping cycle.
     */
    check() {
        const timestamp = utils_1.now();
        const newFree = [];
        const minKeep = this.min - this.used.length;
        const maxDestroy = this.free.length - minKeep;
        let numDestroyed = 0;
        this.free.forEach(free => {
            if (utils_1.duration(timestamp, free.timestamp) >= this.idleTimeoutMillis &&
                numDestroyed < maxDestroy) {
                numDestroyed++;
                this._destroy(free.resource);
            }
            else {
                newFree.push(free);
            }
        });
        this.free = newFree;
        // Pool is completely empty, stop reaping.
        // Next .acquire will start reaping interval again.
        if (this.isEmpty()) {
            this._stopReaping();
        }
    }
    destroy() {
        const eventId = this.eventId++;
        this._executeEventHandlers('poolDestroyRequest', eventId);
        this._stopReaping();
        this.destroyed = true;
        // First wait for all the pending creates get ready.
        return utils_1.reflect(Promise.all(this.pendingCreates.map(create => utils_1.reflect(create.promise)))
            .then(() => {
            // eslint-disable-next-line
            return new Promise((resolve, reject) => {
                // poll every 100ms and wait that all validations are ready
                if (this.numPendingValidations() === 0) {
                    resolve();
                    return;
                }
                const interval = setInterval(() => {
                    if (this.numPendingValidations() === 0) {
                        timers_1.clearInterval(interval);
                        resolve();
                    }
                }, 100);
            });
        })
            .then(() => {
            // Wait for all the used resources to be freed.
            return Promise.all(this.used.map(used => utils_1.reflect(used.promise)));
        })
            .then(() => {
            // Abort all pending acquires.
            return Promise.all(this.pendingAcquires.map(acquire => {
                acquire.abort();
                return utils_1.reflect(acquire.promise);
            }));
        })
            .then(() => {
            // Now we can destroy all the freed resources.
            return Promise.all(this.free.map(free => utils_1.reflect(this._destroy(free.resource))));
        })
            .then(() => {
            // Also wait rest of the pending destroys to finish
            return Promise.all(this.pendingDestroys.map(pd => pd.promise));
        })
            .then(() => {
            this.free = [];
            this.pendingAcquires = [];
        })).then(res => {
            this._executeEventHandlers('poolDestroySuccess', eventId);
            this.emitter.removeAllListeners();
            return res;
        });
    }
    on(event, listener) {
        this.emitter.on(event, listener);
    }
    removeListener(event, listener) {
        this.emitter.removeListener(event, listener);
    }
    removeAllListeners(event) {
        this.emitter.removeAllListeners(event);
    }
    /**
     * The most important method that is called always when resources
     * are created / destroyed / acquired / released. In other words
     * every time when resources are moved from used to free or vice
     * versa.
     *
     * Either assigns free resources to pendingAcquires or creates new
     * resources if there is room for it in the pool.
     */
    _tryAcquireOrCreate() {
        if (this.destroyed) {
            return;
        }
        if (this._hasFreeResources()) {
            this._doAcquire();
        }
        else if (this._shouldCreateMoreResources()) {
            this._doCreate();
        }
    }
    _hasFreeResources() {
        return this.free.length > 0;
    }
    _doAcquire() {
        // Acquire as many pending acquires as possible concurrently
        while (this._canAcquire()) {
            // To allow async validation, we actually need to move free resource
            // and pending acquire temporary from their respective arrays and depending
            // on validation result to either leave the free resource to used resources array
            // or destroy the free resource if validation did fail.
            const pendingAcquire = this.pendingAcquires.shift();
            const free = this.free.pop();
            if (free === undefined || pendingAcquire === undefined) {
                const errMessage = 'this.free was empty while trying to acquire resource';
                this.log(`Tarn: ${errMessage}`, 'warn');
                throw new Error(`Internal error, should never happen. ${errMessage}`);
            }
            // Make sure that pendingAcquire that is being validated is not lost and
            // can be freed when pool is destroyed.
            this.pendingValidations.push(pendingAcquire);
            // Must be added here pre-emptively to prevent logic that decides
            // if new resources are created will keep on working correctly.
            this.used.push(free);
            // if acquire fails also pending validation, must be aborted so that pre reserved
            // resource will be returned to free resources immediately
            const abortAbleValidation = new PendingOperation_1.PendingOperation(this.acquireTimeoutMillis);
            // eslint-disable-next-line
            pendingAcquire.promise.catch(err => {
                abortAbleValidation.abort();
            });
            abortAbleValidation.promise
                .catch(err => {
                // There's nothing we can do here but log the error. This would otherwise
                // leak out as an unhandled exception.
                this.log('Tarn: resource validator threw an exception ' + err.stack, 'warn');
                return false;
            })
                .then(validationSuccess => {
                try {
                    if (validationSuccess && !pendingAcquire.isRejected) {
                        // At least one active resource exist, start reaping.
                        this._startReaping();
                        pendingAcquire.resolve(free.resource);
                    }
                    else {
                        remove(this.used, free);
                        // Only destroy the resource if the validation has failed
                        if (!validationSuccess) {
                            this._destroy(free.resource);
                            // Since we destroyed an invalid resource and were not able to fulfill
                            // all the pending acquires, we may need to create new ones or at
                            // least run this acquire loop again to verify it. But not immediately
                            // to prevent starving event loop.
                            setTimeout(() => {
                                this._tryAcquireOrCreate();
                            }, 0);
                        }
                        else {
                            this.free.push(free);
                        }
                        // is acquire was canceled, failed or timed out already
                        // no need to return it to pending queries
                        if (!pendingAcquire.isRejected) {
                            this.pendingAcquires.unshift(pendingAcquire);
                        }
                    }
                }
                finally {
                    remove(this.pendingValidations, pendingAcquire);
                }
            });
            // try to validate
            this._validateResource(free.resource)
                .then(validationSuccess => {
                abortAbleValidation.resolve(validationSuccess);
            })
                .catch(err => {
                abortAbleValidation.reject(err);
            });
        }
    }
    _canAcquire() {
        return this.free.length > 0 && this.pendingAcquires.length > 0;
    }
    _validateResource(resource) {
        try {
            return Promise.resolve(this.validate(resource));
        }
        catch (err) {
            // prevent leaking of sync exception
            return Promise.reject(err);
        }
    }
    _shouldCreateMoreResources() {
        return (this.used.length + this.pendingCreates.length < this.max &&
            this.pendingCreates.length < this.pendingAcquires.length);
    }
    _doCreate() {
        const pendingAcquiresBeforeCreate = this.pendingAcquires.slice();
        const pendingCreate = this._create();
        pendingCreate.promise
            .then(() => {
            // Not returned on purpose.
            this._tryAcquireOrCreate();
            return null;
        })
            .catch(err => {
            if (this.propagateCreateError && this.pendingAcquires.length !== 0) {
                // If propagateCreateError is true, we don't retry the create
                // but reject the first pending acquire immediately. Intentionally
                // use `this.pendingAcquires` instead of `pendingAcquiresBeforeCreate`
                // in case some acquires in pendingAcquiresBeforeCreate have already
                // been resolved.
                this.pendingAcquires[0].reject(err);
            }
            // Save the create error to all pending acquires so that we can use it
            // as the error to reject the acquire if it times out.
            pendingAcquiresBeforeCreate.forEach(pendingAcquire => {
                pendingAcquire.possibleTimeoutCause = err;
            });
            // Not returned on purpose.
            utils_1.delay(this.createRetryIntervalMillis).then(() => this._tryAcquireOrCreate());
        });
    }
    _create() {
        const eventId = this.eventId++;
        this._executeEventHandlers('createRequest', eventId);
        const pendingCreate = new PendingOperation_1.PendingOperation(this.createTimeoutMillis);
        // If an error occurs (likely a create timeout) remove this creation from
        // the list of pending creations so we try to create a new one.
        pendingCreate.promise = pendingCreate.promise.catch(err => {
            if (remove(this.pendingCreates, pendingCreate)) {
                // TODO: figure out more consistent way for different error handlers in next rewrite
                this._executeEventHandlers('createFail', eventId, err);
            }
            throw err;
        });
        this.pendingCreates.push(pendingCreate);
        callbackOrPromise(this.creator)
            .then(resource => {
            if (pendingCreate.isRejected) {
                this.destroyer(resource);
                return null;
            }
            remove(this.pendingCreates, pendingCreate);
            this.free.push(new Resource_1.Resource(resource));
            // Not returned on purpose.
            pendingCreate.resolve(resource);
            this._executeEventHandlers('createSuccess', eventId, resource);
            return null;
        })
            .catch(err => {
            if (pendingCreate.isRejected) {
                return null;
            }
            if (remove(this.pendingCreates, pendingCreate)) {
                this._executeEventHandlers('createFail', eventId, err);
            }
            // Not returned on purpose.
            pendingCreate.reject(err);
            return null;
        });
        return pendingCreate;
    }
    _destroy(resource) {
        const eventId = this.eventId++;
        this._executeEventHandlers('destroyRequest', eventId, resource);
        // this.destroyer can be both synchronous and asynchronous.
        // so we wrap it to promise to get all exceptions through same pipeline
        const pendingDestroy = new PendingOperation_1.PendingOperation(this.destroyTimeoutMillis);
        const retVal = Promise.resolve().then(() => this.destroyer(resource));
        retVal
            .then(() => {
            pendingDestroy.resolve(resource);
        })
            .catch((err) => {
            pendingDestroy.reject(err);
        });
        this.pendingDestroys.push(pendingDestroy);
        // In case of an error there's nothing we can do here but log it.
        return pendingDestroy.promise
            .then(res => {
            this._executeEventHandlers('destroySuccess', eventId, resource);
            return res;
        })
            .catch(err => this._logDestroyerError(eventId, resource, err))
            .then(res => {
            const index = this.pendingDestroys.findIndex(pd => pd === pendingDestroy);
            this.pendingDestroys.splice(index, 1);
            return res;
        });
    }
    _logDestroyerError(eventId, resource, err) {
        this._executeEventHandlers('destroyFail', eventId, resource, err);
        this.log('Tarn: resource destroyer threw an exception ' + err.stack, 'warn');
    }
    _startReaping() {
        if (!this.interval) {
            this._executeEventHandlers('startReaping');
            this.interval = setInterval(() => this.check(), this.reapIntervalMillis);
        }
    }
    _stopReaping() {
        if (this.interval !== null) {
            this._executeEventHandlers('stopReaping');
            timers_1.clearInterval(this.interval);
        }
        this.interval = null;
    }
    _executeEventHandlers(eventName, ...args) {
        const listeners = this.emitter.listeners(eventName);
        // just calling .emit() would stop running rest of the listeners if one them fails
        listeners.forEach(listener => {
            try {
                listener(...args);
            }
            catch (err) {
                // There's nothing we can do here but log the error. This would otherwise
                // leak out as an unhandled exception.
                this.log(`Tarn: event handler "${eventName}" threw an exception ${err.stack}`, 'warn');
            }
        });
    }
};
Pool$2.Pool = Pool$1;
function remove(arr, item) {
    const idx = arr.indexOf(item);
    if (idx === -1) {
        return false;
    }
    else {
        arr.splice(idx, 1);
        return true;
    }
}
function callbackOrPromise(func) {
    return new Promise((resolve, reject) => {
        const callback = (err, resource) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(resource);
            }
        };
        utils_1.tryPromise(() => func(callback))
            .then(res => {
            // If the result is falsy, we assume that the callback will
            // be called instead of interpreting the falsy value as a
            // result value.
            if (res) {
                resolve(res);
            }
        })
            .catch(err => {
            reject(err);
        });
    });
}

(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	const Pool_1 = Pool$2;
	exports.Pool = Pool_1.Pool;
	const TimeoutError_1 = TimeoutError$2;
	exports.TimeoutError = TimeoutError_1.TimeoutError;
	module.exports = {
	    Pool: Pool_1.Pool,
	    TimeoutError: TimeoutError_1.TimeoutError
	};
} (tarn, tarnExports));

/*eslint max-len: 0, no-var:0 */

const charsRegex = /[\0\b\t\n\r\x1a"'\\]/g; // eslint-disable-line no-control-regex
const charsMap = {
  '\0': '\\0',
  '\b': '\\b',
  '\t': '\\t',
  '\n': '\\n',
  '\r': '\\r',
  '\x1a': '\\Z',
  '"': '\\"',
  "'": "\\'",
  '\\': '\\\\',
};

function wrapEscape(escapeFn) {
  return function finalEscape(val, ctx = {}) {
    return escapeFn(val, finalEscape, ctx);
  };
}

function makeEscape$1(config = {}) {
  const finalEscapeDate = config.escapeDate || dateToString;
  const finalEscapeArray = config.escapeArray || arrayToList;
  const finalEscapeBuffer = config.escapeBuffer || bufferToString;
  const finalEscapeString = config.escapeString || escapeString;
  const finalEscapeObject = config.escapeObject || escapeObject;
  const finalWrap = config.wrap || wrapEscape;

  function escapeFn(val, finalEscape, ctx) {
    if (val === undefined || val === null) {
      return 'NULL';
    }
    switch (typeof val) {
      case 'boolean':
        return val ? 'true' : 'false';
      case 'number':
        return val + '';
      case 'object':
        if (val instanceof Date) {
          val = finalEscapeDate(val, finalEscape, ctx);
        } else if (Array.isArray(val)) {
          return finalEscapeArray(val, finalEscape, ctx);
        } else if (Buffer.isBuffer(val)) {
          return finalEscapeBuffer(val, finalEscape, ctx);
        } else {
          return finalEscapeObject(val, finalEscape, ctx);
        }
    }
    return finalEscapeString(val, finalEscape, ctx);
  }

  return finalWrap ? finalWrap(escapeFn) : escapeFn;
}

function escapeObject(val, finalEscape, ctx) {
  if (val && typeof val.toSQL === 'function') {
    return val.toSQL(ctx);
  } else {
    return JSON.stringify(val);
  }
}

function arrayToList(array, finalEscape, ctx) {
  let sql = '';
  for (let i = 0; i < array.length; i++) {
    const val = array[i];
    if (Array.isArray(val)) {
      sql +=
        (i === 0 ? '' : ', ') + '(' + arrayToList(val, finalEscape, ctx) + ')';
    } else {
      sql += (i === 0 ? '' : ', ') + finalEscape(val, ctx);
    }
  }
  return sql;
}

function bufferToString(buffer) {
  return 'X' + escapeString(buffer.toString('hex'));
}

function escapeString(val, finalEscape, ctx) {
  let chunkIndex = (charsRegex.lastIndex = 0);
  let escapedVal = '';
  let match;

  while ((match = charsRegex.exec(val))) {
    escapedVal += val.slice(chunkIndex, match.index) + charsMap[match[0]];
    chunkIndex = charsRegex.lastIndex;
  }

  if (chunkIndex === 0) {
    // Nothing was escaped
    return "'" + val + "'";
  }

  if (chunkIndex < val.length) {
    return "'" + escapedVal + val.slice(chunkIndex) + "'";
  }

  return "'" + escapedVal + "'";
}

function dateToString(date, finalEscape, ctx = {}) {
  const timeZone = ctx.timeZone || 'local';

  const dt = new Date(date);
  let year;
  let month;
  let day;
  let hour;
  let minute;
  let second;
  let millisecond;

  if (timeZone === 'local') {
    year = dt.getFullYear();
    month = dt.getMonth() + 1;
    day = dt.getDate();
    hour = dt.getHours();
    minute = dt.getMinutes();
    second = dt.getSeconds();
    millisecond = dt.getMilliseconds();
  } else {
    const tz = convertTimezone(timeZone);

    if (tz !== false && tz !== 0) {
      dt.setTime(dt.getTime() + tz * 60000);
    }

    year = dt.getUTCFullYear();
    month = dt.getUTCMonth() + 1;
    day = dt.getUTCDate();
    hour = dt.getUTCHours();
    minute = dt.getUTCMinutes();
    second = dt.getUTCSeconds();
    millisecond = dt.getUTCMilliseconds();
  }

  // YYYY-MM-DD HH:mm:ss.mmm
  return (
    zeroPad(year, 4) +
    '-' +
    zeroPad(month, 2) +
    '-' +
    zeroPad(day, 2) +
    ' ' +
    zeroPad(hour, 2) +
    ':' +
    zeroPad(minute, 2) +
    ':' +
    zeroPad(second, 2) +
    '.' +
    zeroPad(millisecond, 3)
  );
}

function zeroPad(number, length) {
  number = number.toString();
  while (number.length < length) {
    number = '0' + number;
  }
  return number;
}

function convertTimezone(tz) {
  if (tz === 'Z') {
    return 0;
  }
  const m = tz.match(/([+\-\s])(\d\d):?(\d\d)?/);
  if (m) {
    return (
      (m[1] == '-' ? -1 : 1) *
      (parseInt(m[2], 10) + (m[3] ? parseInt(m[3], 10) : 0) / 60) *
      60
    );
  }
  return false;
}

var string = {
  arrayToList,
  bufferToString,
  dateToString,
  escapeString,
  charsRegex,
  charsMap,
  escapeObject,
  makeEscape: makeEscape$1,
};

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */

function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}

var _listCacheClear = listCacheClear$1;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */

function eq$7(value, other) {
  return value === other || (value !== value && other !== other);
}

var eq_1 = eq$7;

var eq$6 = eq_1;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf$4(array, key) {
  var length = array.length;
  while (length--) {
    if (eq$6(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

var _assocIndexOf = assocIndexOf$4;

var assocIndexOf$3 = _assocIndexOf;

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete$1(key) {
  var data = this.__data__,
      index = assocIndexOf$3(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

var _listCacheDelete = listCacheDelete$1;

var assocIndexOf$2 = _assocIndexOf;

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet$1(key) {
  var data = this.__data__,
      index = assocIndexOf$2(data, key);

  return index < 0 ? undefined : data[index][1];
}

var _listCacheGet = listCacheGet$1;

var assocIndexOf$1 = _assocIndexOf;

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}

var _listCacheHas = listCacheHas$1;

var assocIndexOf = _assocIndexOf;

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet$1(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

var _listCacheSet = listCacheSet$1;

var listCacheClear = _listCacheClear,
    listCacheDelete = _listCacheDelete,
    listCacheGet = _listCacheGet,
    listCacheHas = _listCacheHas,
    listCacheSet = _listCacheSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache$4(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache$4.prototype.clear = listCacheClear;
ListCache$4.prototype['delete'] = listCacheDelete;
ListCache$4.prototype.get = listCacheGet;
ListCache$4.prototype.has = listCacheHas;
ListCache$4.prototype.set = listCacheSet;

var _ListCache = ListCache$4;

var ListCache$3 = _ListCache;

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear$1() {
  this.__data__ = new ListCache$3;
  this.size = 0;
}

var _stackClear = stackClear$1;

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function stackDelete$1(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

var _stackDelete = stackDelete$1;

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function stackGet$1(key) {
  return this.__data__.get(key);
}

var _stackGet = stackGet$1;

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function stackHas$1(key) {
  return this.__data__.has(key);
}

var _stackHas = stackHas$1;

/** Detect free variable `global` from Node.js. */

var freeGlobal$1 = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

var _freeGlobal = freeGlobal$1;

var freeGlobal = _freeGlobal;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root$8 = freeGlobal || freeSelf || Function('return this')();

var _root = root$8;

var root$7 = _root;

/** Built-in value references. */
var Symbol$8 = root$7.Symbol;

var _Symbol = Symbol$8;

var Symbol$7 = _Symbol;

/** Used for built-in method references. */
var objectProto$m = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$j = objectProto$m.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$m.toString;

/** Built-in value references. */
var symToStringTag$1 = Symbol$7 ? Symbol$7.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag$1(value) {
  var isOwn = hasOwnProperty$j.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];

  try {
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}

var _getRawTag = getRawTag$1;

/** Used for built-in method references. */

var objectProto$l = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto$l.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}

var _objectToString = objectToString$1;

var Symbol$6 = _Symbol,
    getRawTag = _getRawTag,
    objectToString = _objectToString;

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol$6 ? Symbol$6.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag$8(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

var _baseGetTag = baseGetTag$8;

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */

function isObject$i(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

var isObject_1 = isObject$i;

var baseGetTag$7 = _baseGetTag,
    isObject$h = isObject_1;

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag$2 = '[object Function]',
    genTag$1 = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction$a(value) {
  if (!isObject$h(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag$7(value);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}

var isFunction_1 = isFunction$a;

var root$6 = _root;

/** Used to detect overreaching core-js shims. */
var coreJsData$1 = root$6['__core-js_shared__'];

var _coreJsData = coreJsData$1;

var coreJsData = _coreJsData;

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked$1(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

var _isMasked = isMasked$1;

/** Used for built-in method references. */

var funcProto$2 = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$2 = funcProto$2.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource$2(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

var _toSource = toSource$2;

var isFunction$9 = isFunction_1,
    isMasked = _isMasked,
    isObject$g = isObject_1,
    toSource$1 = _toSource;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto$1 = Function.prototype,
    objectProto$k = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$1 = funcProto$1.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$i = objectProto$k.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString$1.call(hasOwnProperty$i).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative$1(value) {
  if (!isObject$g(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$9(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource$1(value));
}

var _baseIsNative = baseIsNative$1;

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */

function getValue$1(object, key) {
  return object == null ? undefined : object[key];
}

var _getValue = getValue$1;

var baseIsNative = _baseIsNative,
    getValue = _getValue;

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative$7(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

var _getNative = getNative$7;

var getNative$6 = _getNative,
    root$5 = _root;

/* Built-in method references that are verified to be native. */
var Map$4 = getNative$6(root$5, 'Map');

var _Map = Map$4;

var getNative$5 = _getNative;

/* Built-in method references that are verified to be native. */
var nativeCreate$4 = getNative$5(Object, 'create');

var _nativeCreate = nativeCreate$4;

var nativeCreate$3 = _nativeCreate;

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}

var _hashClear = hashClear$1;

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function hashDelete$1(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

var _hashDelete = hashDelete$1;

var nativeCreate$2 = _nativeCreate;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto$j = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$h = objectProto$j.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet$1(key) {
  var data = this.__data__;
  if (nativeCreate$2) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? undefined : result;
  }
  return hasOwnProperty$h.call(data, key) ? data[key] : undefined;
}

var _hashGet = hashGet$1;

var nativeCreate$1 = _nativeCreate;

/** Used for built-in method references. */
var objectProto$i = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$g = objectProto$i.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas$1(key) {
  var data = this.__data__;
  return nativeCreate$1 ? (data[key] !== undefined) : hasOwnProperty$g.call(data, key);
}

var _hashHas = hashHas$1;

var nativeCreate = _nativeCreate;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet$1(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
  return this;
}

var _hashSet = hashSet$1;

var hashClear = _hashClear,
    hashDelete = _hashDelete,
    hashGet = _hashGet,
    hashHas = _hashHas,
    hashSet = _hashSet;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash$1(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash$1.prototype.clear = hashClear;
Hash$1.prototype['delete'] = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;

var _Hash = Hash$1;

var Hash = _Hash,
    ListCache$2 = _ListCache,
    Map$3 = _Map;

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map$3 || ListCache$2),
    'string': new Hash
  };
}

var _mapCacheClear = mapCacheClear$1;

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */

function isKeyable$1(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

var _isKeyable = isKeyable$1;

var isKeyable = _isKeyable;

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData$4(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

var _getMapData = getMapData$4;

var getMapData$3 = _getMapData;

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete$1(key) {
  var result = getMapData$3(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

var _mapCacheDelete = mapCacheDelete$1;

var getMapData$2 = _getMapData;

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet$1(key) {
  return getMapData$2(this, key).get(key);
}

var _mapCacheGet = mapCacheGet$1;

var getMapData$1 = _getMapData;

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}

var _mapCacheHas = mapCacheHas$1;

var getMapData = _getMapData;

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet$1(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

var _mapCacheSet = mapCacheSet$1;

var mapCacheClear = _mapCacheClear,
    mapCacheDelete = _mapCacheDelete,
    mapCacheGet = _mapCacheGet,
    mapCacheHas = _mapCacheHas,
    mapCacheSet = _mapCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache$3(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache$3.prototype.clear = mapCacheClear;
MapCache$3.prototype['delete'] = mapCacheDelete;
MapCache$3.prototype.get = mapCacheGet;
MapCache$3.prototype.has = mapCacheHas;
MapCache$3.prototype.set = mapCacheSet;

var _MapCache = MapCache$3;

var ListCache$1 = _ListCache,
    Map$2 = _Map,
    MapCache$2 = _MapCache;

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE$1 = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet$1(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache$1) {
    var pairs = data.__data__;
    if (!Map$2 || (pairs.length < LARGE_ARRAY_SIZE$1 - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache$2(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

var _stackSet = stackSet$1;

var ListCache = _ListCache,
    stackClear = _stackClear,
    stackDelete = _stackDelete,
    stackGet = _stackGet,
    stackHas = _stackHas,
    stackSet = _stackSet;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack$4(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack$4.prototype.clear = stackClear;
Stack$4.prototype['delete'] = stackDelete;
Stack$4.prototype.get = stackGet;
Stack$4.prototype.has = stackHas;
Stack$4.prototype.set = stackSet;

var _Stack = Stack$4;

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */

function arrayEach$3(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

var _arrayEach = arrayEach$3;

var getNative$4 = _getNative;

var defineProperty$2 = (function() {
  try {
    var func = getNative$4(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

var _defineProperty = defineProperty$2;

var defineProperty$1 = _defineProperty;

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue$4(object, key, value) {
  if (key == '__proto__' && defineProperty$1) {
    defineProperty$1(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

var _baseAssignValue = baseAssignValue$4;

var baseAssignValue$3 = _baseAssignValue,
    eq$5 = eq_1;

/** Used for built-in method references. */
var objectProto$h = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$f = objectProto$h.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue$4(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$f.call(object, key) && eq$5(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue$3(object, key, value);
  }
}

var _assignValue = assignValue$4;

var assignValue$3 = _assignValue,
    baseAssignValue$2 = _baseAssignValue;

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject$8(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue$2(object, key, newValue);
    } else {
      assignValue$3(object, key, newValue);
    }
  }
  return object;
}

var _copyObject = copyObject$8;

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */

function baseTimes$1(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

var _baseTimes = baseTimes$1;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */

function isObjectLike$b(value) {
  return value != null && typeof value == 'object';
}

var isObjectLike_1 = isObjectLike$b;

var baseGetTag$6 = _baseGetTag,
    isObjectLike$a = isObjectLike_1;

/** `Object#toString` result references. */
var argsTag$3 = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments$1(value) {
  return isObjectLike$a(value) && baseGetTag$6(value) == argsTag$3;
}

var _baseIsArguments = baseIsArguments$1;

var baseIsArguments = _baseIsArguments,
    isObjectLike$9 = isObjectLike_1;

/** Used for built-in method references. */
var objectProto$g = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$e = objectProto$g.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable$1 = objectProto$g.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments$5 = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike$9(value) && hasOwnProperty$e.call(value, 'callee') &&
    !propertyIsEnumerable$1.call(value, 'callee');
};

var isArguments_1 = isArguments$5;

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */

var isArray$k = Array.isArray;

var isArray_1 = isArray$k;

var isBufferExports = {};
var isBuffer$6 = {
  get exports(){ return isBufferExports; },
  set exports(v){ isBufferExports = v; },
};

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */

function stubFalse() {
  return false;
}

var stubFalse_1 = stubFalse;

(function (module, exports) {
	var root = _root,
	    stubFalse = stubFalse_1;

	/** Detect free variable `exports`. */
	var freeExports = exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Built-in value references. */
	var Buffer = moduleExports ? root.Buffer : undefined;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer = nativeIsBuffer || stubFalse;

	module.exports = isBuffer;
} (isBuffer$6, isBufferExports));

/** Used as references for various `Number` constants. */

var MAX_SAFE_INTEGER$1 = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex$4(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

var _isIndex = isIndex$4;

/** Used as references for various `Number` constants. */

var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength$3(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

var isLength_1 = isLength$3;

var baseGetTag$5 = _baseGetTag,
    isLength$2 = isLength_1,
    isObjectLike$8 = isObjectLike_1;

/** `Object#toString` result references. */
var argsTag$2 = '[object Arguments]',
    arrayTag$2 = '[object Array]',
    boolTag$3 = '[object Boolean]',
    dateTag$3 = '[object Date]',
    errorTag$3 = '[object Error]',
    funcTag$1 = '[object Function]',
    mapTag$7 = '[object Map]',
    numberTag$3 = '[object Number]',
    objectTag$4 = '[object Object]',
    regexpTag$3 = '[object RegExp]',
    setTag$7 = '[object Set]',
    stringTag$4 = '[object String]',
    weakMapTag$2 = '[object WeakMap]';

var arrayBufferTag$3 = '[object ArrayBuffer]',
    dataViewTag$4 = '[object DataView]',
    float32Tag$2 = '[object Float32Array]',
    float64Tag$2 = '[object Float64Array]',
    int8Tag$2 = '[object Int8Array]',
    int16Tag$2 = '[object Int16Array]',
    int32Tag$2 = '[object Int32Array]',
    uint8Tag$2 = '[object Uint8Array]',
    uint8ClampedTag$2 = '[object Uint8ClampedArray]',
    uint16Tag$2 = '[object Uint16Array]',
    uint32Tag$2 = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] =
typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] =
typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] =
typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] =
typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] =
typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] =
typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] =
typedArrayTags[errorTag$3] = typedArrayTags[funcTag$1] =
typedArrayTags[mapTag$7] = typedArrayTags[numberTag$3] =
typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$3] =
typedArrayTags[setTag$7] = typedArrayTags[stringTag$4] =
typedArrayTags[weakMapTag$2] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray$1(value) {
  return isObjectLike$8(value) &&
    isLength$2(value.length) && !!typedArrayTags[baseGetTag$5(value)];
}

var _baseIsTypedArray = baseIsTypedArray$1;

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */

function baseUnary$5(func) {
  return function(value) {
    return func(value);
  };
}

var _baseUnary = baseUnary$5;

var _nodeUtilExports = {};
var _nodeUtil = {
  get exports(){ return _nodeUtilExports; },
  set exports(v){ _nodeUtilExports = v; },
};

(function (module, exports) {
	var freeGlobal = _freeGlobal;

	/** Detect free variable `exports`. */
	var freeExports = exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports && freeGlobal.process;

	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    // Use `util.types` for Node.js 10+.
	    var types = freeModule && freeModule.require && freeModule.require('util').types;

	    if (types) {
	      return types;
	    }

	    // Legacy `process.binding('util')` for Node.js < 10.
	    return freeProcess && freeProcess.binding && freeProcess.binding('util');
	  } catch (e) {}
	}());

	module.exports = nodeUtil;
} (_nodeUtil, _nodeUtilExports));

var baseIsTypedArray = _baseIsTypedArray,
    baseUnary$4 = _baseUnary,
    nodeUtil$2 = _nodeUtilExports;

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil$2 && nodeUtil$2.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray$6 = nodeIsTypedArray ? baseUnary$4(nodeIsTypedArray) : baseIsTypedArray;

var isTypedArray_1 = isTypedArray$6;

var baseTimes = _baseTimes,
    isArguments$4 = isArguments_1,
    isArray$j = isArray_1,
    isBuffer$5 = isBufferExports,
    isIndex$3 = _isIndex,
    isTypedArray$5 = isTypedArray_1;

/** Used for built-in method references. */
var objectProto$f = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$d = objectProto$f.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys$2(value, inherited) {
  var isArr = isArray$j(value),
      isArg = !isArr && isArguments$4(value),
      isBuff = !isArr && !isArg && isBuffer$5(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray$5(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty$d.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex$3(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

var _arrayLikeKeys = arrayLikeKeys$2;

/** Used for built-in method references. */

var objectProto$e = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype$5(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$e;

  return value === proto;
}

var _isPrototype = isPrototype$5;

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */

function overArg$2(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

var _overArg = overArg$2;

var overArg$1 = _overArg;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys$1 = overArg$1(Object.keys, Object);

var _nativeKeys = nativeKeys$1;

var isPrototype$4 = _isPrototype,
    nativeKeys = _nativeKeys;

/** Used for built-in method references. */
var objectProto$d = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$c = objectProto$d.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys$2(object) {
  if (!isPrototype$4(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$c.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

var _baseKeys = baseKeys$2;

var isFunction$8 = isFunction_1,
    isLength$1 = isLength_1;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike$a(value) {
  return value != null && isLength$1(value.length) && !isFunction$8(value);
}

var isArrayLike_1 = isArrayLike$a;

var arrayLikeKeys$1 = _arrayLikeKeys,
    baseKeys$1 = _baseKeys,
    isArrayLike$9 = isArrayLike_1;

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys$8(object) {
  return isArrayLike$9(object) ? arrayLikeKeys$1(object) : baseKeys$1(object);
}

var keys_1 = keys$8;

var copyObject$7 = _copyObject,
    keys$7 = keys_1;

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign$1(object, source) {
  return object && copyObject$7(source, keys$7(source), object);
}

var _baseAssign = baseAssign$1;

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function nativeKeysIn$1(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

var _nativeKeysIn = nativeKeysIn$1;

var isObject$f = isObject_1,
    isPrototype$3 = _isPrototype,
    nativeKeysIn = _nativeKeysIn;

/** Used for built-in method references. */
var objectProto$c = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$b = objectProto$c.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn$1(object) {
  if (!isObject$f(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype$3(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty$b.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

var _baseKeysIn = baseKeysIn$1;

var arrayLikeKeys = _arrayLikeKeys,
    baseKeysIn = _baseKeysIn,
    isArrayLike$8 = isArrayLike_1;

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn$8(object) {
  return isArrayLike$8(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

var keysIn_1 = keysIn$8;

var copyObject$6 = _copyObject,
    keysIn$7 = keysIn_1;

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn$1(object, source) {
  return object && copyObject$6(source, keysIn$7(source), object);
}

var _baseAssignIn = baseAssignIn$1;

var _cloneBufferExports = {};
var _cloneBuffer = {
  get exports(){ return _cloneBufferExports; },
  set exports(v){ _cloneBufferExports = v; },
};

(function (module, exports) {
	var root = _root;

	/** Detect free variable `exports`. */
	var freeExports = exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Built-in value references. */
	var Buffer = moduleExports ? root.Buffer : undefined,
	    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

	/**
	 * Creates a clone of  `buffer`.
	 *
	 * @private
	 * @param {Buffer} buffer The buffer to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Buffer} Returns the cloned buffer.
	 */
	function cloneBuffer(buffer, isDeep) {
	  if (isDeep) {
	    return buffer.slice();
	  }
	  var length = buffer.length,
	      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

	  buffer.copy(result);
	  return result;
	}

	module.exports = cloneBuffer;
} (_cloneBuffer, _cloneBufferExports));

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */

function copyArray$3(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

var _copyArray = copyArray$3;

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */

function arrayFilter$2(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

var _arrayFilter = arrayFilter$2;

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */

function stubArray$2() {
  return [];
}

var stubArray_1 = stubArray$2;

var arrayFilter$1 = _arrayFilter,
    stubArray$1 = stubArray_1;

/** Used for built-in method references. */
var objectProto$b = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto$b.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols$3 = !nativeGetSymbols$1 ? stubArray$1 : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter$1(nativeGetSymbols$1(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

var _getSymbols = getSymbols$3;

var copyObject$5 = _copyObject,
    getSymbols$2 = _getSymbols;

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols$1(source, object) {
  return copyObject$5(source, getSymbols$2(source), object);
}

var _copySymbols = copySymbols$1;

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */

function arrayPush$3(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

var _arrayPush = arrayPush$3;

var overArg = _overArg;

/** Built-in value references. */
var getPrototype$4 = overArg(Object.getPrototypeOf, Object);

var _getPrototype = getPrototype$4;

var arrayPush$2 = _arrayPush,
    getPrototype$3 = _getPrototype,
    getSymbols$1 = _getSymbols,
    stubArray = stubArray_1;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn$2 = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush$2(result, getSymbols$1(object));
    object = getPrototype$3(object);
  }
  return result;
};

var _getSymbolsIn = getSymbolsIn$2;

var copyObject$4 = _copyObject,
    getSymbolsIn$1 = _getSymbolsIn;

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn$1(source, object) {
  return copyObject$4(source, getSymbolsIn$1(source), object);
}

var _copySymbolsIn = copySymbolsIn$1;

var arrayPush$1 = _arrayPush,
    isArray$i = isArray_1;

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys$2(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$i(object) ? result : arrayPush$1(result, symbolsFunc(object));
}

var _baseGetAllKeys = baseGetAllKeys$2;

var baseGetAllKeys$1 = _baseGetAllKeys,
    getSymbols = _getSymbols,
    keys$6 = keys_1;

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys$2(object) {
  return baseGetAllKeys$1(object, keys$6, getSymbols);
}

var _getAllKeys = getAllKeys$2;

var baseGetAllKeys = _baseGetAllKeys,
    getSymbolsIn = _getSymbolsIn,
    keysIn$6 = keysIn_1;

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn$2(object) {
  return baseGetAllKeys(object, keysIn$6, getSymbolsIn);
}

var _getAllKeysIn = getAllKeysIn$2;

var getNative$3 = _getNative,
    root$4 = _root;

/* Built-in method references that are verified to be native. */
var DataView$1 = getNative$3(root$4, 'DataView');

var _DataView = DataView$1;

var getNative$2 = _getNative,
    root$3 = _root;

/* Built-in method references that are verified to be native. */
var Promise$2 = getNative$2(root$3, 'Promise');

var _Promise = Promise$2;

var getNative$1 = _getNative,
    root$2 = _root;

/* Built-in method references that are verified to be native. */
var Set$2 = getNative$1(root$2, 'Set');

var _Set = Set$2;

var getNative = _getNative,
    root$1 = _root;

/* Built-in method references that are verified to be native. */
var WeakMap$1 = getNative(root$1, 'WeakMap');

var _WeakMap = WeakMap$1;

var DataView = _DataView,
    Map$1 = _Map,
    Promise$1 = _Promise,
    Set$1 = _Set,
    WeakMap = _WeakMap,
    baseGetTag$4 = _baseGetTag,
    toSource = _toSource;

/** `Object#toString` result references. */
var mapTag$6 = '[object Map]',
    objectTag$3 = '[object Object]',
    promiseTag = '[object Promise]',
    setTag$6 = '[object Set]',
    weakMapTag$1 = '[object WeakMap]';

var dataViewTag$3 = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map$1),
    promiseCtorString = toSource(Promise$1),
    setCtorString = toSource(Set$1),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag$6 = baseGetTag$4;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag$6(new DataView(new ArrayBuffer(1))) != dataViewTag$3) ||
    (Map$1 && getTag$6(new Map$1) != mapTag$6) ||
    (Promise$1 && getTag$6(Promise$1.resolve()) != promiseTag) ||
    (Set$1 && getTag$6(new Set$1) != setTag$6) ||
    (WeakMap && getTag$6(new WeakMap) != weakMapTag$1)) {
  getTag$6 = function(value) {
    var result = baseGetTag$4(value),
        Ctor = result == objectTag$3 ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag$3;
        case mapCtorString: return mapTag$6;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag$6;
        case weakMapCtorString: return weakMapTag$1;
      }
    }
    return result;
  };
}

var _getTag = getTag$6;

/** Used for built-in method references. */

var objectProto$a = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$a = objectProto$a.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray$1(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty$a.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

var _initCloneArray = initCloneArray$1;

var root = _root;

/** Built-in value references. */
var Uint8Array$3 = root.Uint8Array;

var _Uint8Array = Uint8Array$3;

var Uint8Array$2 = _Uint8Array;

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer$3(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
  return result;
}

var _cloneArrayBuffer = cloneArrayBuffer$3;

var cloneArrayBuffer$2 = _cloneArrayBuffer;

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView$1(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$2(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

var _cloneDataView = cloneDataView$1;

/** Used to match `RegExp` flags from their coerced string values. */

var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp$1(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

var _cloneRegExp = cloneRegExp$1;

var Symbol$5 = _Symbol;

/** Used to convert symbols to primitives and strings. */
var symbolProto$2 = Symbol$5 ? Symbol$5.prototype : undefined,
    symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol$1(symbol) {
  return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
}

var _cloneSymbol = cloneSymbol$1;

var cloneArrayBuffer$1 = _cloneArrayBuffer;

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray$2(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$1(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

var _cloneTypedArray = cloneTypedArray$2;

var cloneArrayBuffer = _cloneArrayBuffer,
    cloneDataView = _cloneDataView,
    cloneRegExp = _cloneRegExp,
    cloneSymbol = _cloneSymbol,
    cloneTypedArray$1 = _cloneTypedArray;

/** `Object#toString` result references. */
var boolTag$2 = '[object Boolean]',
    dateTag$2 = '[object Date]',
    mapTag$5 = '[object Map]',
    numberTag$2 = '[object Number]',
    regexpTag$2 = '[object RegExp]',
    setTag$5 = '[object Set]',
    stringTag$3 = '[object String]',
    symbolTag$3 = '[object Symbol]';

var arrayBufferTag$2 = '[object ArrayBuffer]',
    dataViewTag$2 = '[object DataView]',
    float32Tag$1 = '[object Float32Array]',
    float64Tag$1 = '[object Float64Array]',
    int8Tag$1 = '[object Int8Array]',
    int16Tag$1 = '[object Int16Array]',
    int32Tag$1 = '[object Int32Array]',
    uint8Tag$1 = '[object Uint8Array]',
    uint8ClampedTag$1 = '[object Uint8ClampedArray]',
    uint16Tag$1 = '[object Uint16Array]',
    uint32Tag$1 = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag$1(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$2:
      return cloneArrayBuffer(object);

    case boolTag$2:
    case dateTag$2:
      return new Ctor(+object);

    case dataViewTag$2:
      return cloneDataView(object, isDeep);

    case float32Tag$1: case float64Tag$1:
    case int8Tag$1: case int16Tag$1: case int32Tag$1:
    case uint8Tag$1: case uint8ClampedTag$1: case uint16Tag$1: case uint32Tag$1:
      return cloneTypedArray$1(object, isDeep);

    case mapTag$5:
      return new Ctor;

    case numberTag$2:
    case stringTag$3:
      return new Ctor(object);

    case regexpTag$2:
      return cloneRegExp(object);

    case setTag$5:
      return new Ctor;

    case symbolTag$3:
      return cloneSymbol(object);
  }
}

var _initCloneByTag = initCloneByTag$1;

var isObject$e = isObject_1;

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate$2 = (function() {
  function object() {}
  return function(proto) {
    if (!isObject$e(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

var _baseCreate = baseCreate$2;

var baseCreate$1 = _baseCreate,
    getPrototype$2 = _getPrototype,
    isPrototype$2 = _isPrototype;

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject$2(object) {
  return (typeof object.constructor == 'function' && !isPrototype$2(object))
    ? baseCreate$1(getPrototype$2(object))
    : {};
}

var _initCloneObject = initCloneObject$2;

var getTag$5 = _getTag,
    isObjectLike$7 = isObjectLike_1;

/** `Object#toString` result references. */
var mapTag$4 = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap$1(value) {
  return isObjectLike$7(value) && getTag$5(value) == mapTag$4;
}

var _baseIsMap = baseIsMap$1;

var baseIsMap = _baseIsMap,
    baseUnary$3 = _baseUnary,
    nodeUtil$1 = _nodeUtilExports;

/* Node.js helper references. */
var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap$1 = nodeIsMap ? baseUnary$3(nodeIsMap) : baseIsMap;

var isMap_1 = isMap$1;

var getTag$4 = _getTag,
    isObjectLike$6 = isObjectLike_1;

/** `Object#toString` result references. */
var setTag$4 = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet$1(value) {
  return isObjectLike$6(value) && getTag$4(value) == setTag$4;
}

var _baseIsSet = baseIsSet$1;

var baseIsSet = _baseIsSet,
    baseUnary$2 = _baseUnary,
    nodeUtil = _nodeUtilExports;

/* Node.js helper references. */
var nodeIsSet = nodeUtil && nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet$1 = nodeIsSet ? baseUnary$2(nodeIsSet) : baseIsSet;

var isSet_1 = isSet$1;

var Stack$3 = _Stack,
    arrayEach$2 = _arrayEach,
    assignValue$2 = _assignValue,
    baseAssign = _baseAssign,
    baseAssignIn = _baseAssignIn,
    cloneBuffer$1 = _cloneBufferExports,
    copyArray$2 = _copyArray,
    copySymbols = _copySymbols,
    copySymbolsIn = _copySymbolsIn,
    getAllKeys$1 = _getAllKeys,
    getAllKeysIn$1 = _getAllKeysIn,
    getTag$3 = _getTag,
    initCloneArray = _initCloneArray,
    initCloneByTag = _initCloneByTag,
    initCloneObject$1 = _initCloneObject,
    isArray$h = isArray_1,
    isBuffer$4 = isBufferExports,
    isMap = isMap_1,
    isObject$d = isObject_1,
    isSet = isSet_1,
    keys$5 = keys_1,
    keysIn$5 = keysIn_1;

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG$1 = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG$2 = 4;

/** `Object#toString` result references. */
var argsTag$1 = '[object Arguments]',
    arrayTag$1 = '[object Array]',
    boolTag$1 = '[object Boolean]',
    dateTag$1 = '[object Date]',
    errorTag$2 = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag$3 = '[object Map]',
    numberTag$1 = '[object Number]',
    objectTag$2 = '[object Object]',
    regexpTag$1 = '[object RegExp]',
    setTag$3 = '[object Set]',
    stringTag$2 = '[object String]',
    symbolTag$2 = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag$1 = '[object ArrayBuffer]',
    dataViewTag$1 = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] =
cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] =
cloneableTags[boolTag$1] = cloneableTags[dateTag$1] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag$3] =
cloneableTags[numberTag$1] = cloneableTags[objectTag$2] =
cloneableTags[regexpTag$1] = cloneableTags[setTag$3] =
cloneableTags[stringTag$2] = cloneableTags[symbolTag$2] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag$2] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone$2(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG$1,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG$2;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject$d(value)) {
    return value;
  }
  var isArr = isArray$h(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray$2(value, result);
    }
  } else {
    var tag = getTag$3(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer$4(value)) {
      return cloneBuffer$1(value, isDeep);
    }
    if (tag == objectTag$2 || tag == argsTag$1 || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject$1(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack$3);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone$2(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone$2(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn$1 : getAllKeys$1)
    : (isFlat ? keysIn$5 : keys$5);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach$2(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue$2(result, key, baseClone$2(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

var _baseClone = baseClone$2;

var baseClone$1 = _baseClone;

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG$1 = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep$1(value) {
  return baseClone$1(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG$1);
}

var cloneDeep_1 = cloneDeep$1;

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */

function identity$6(value) {
  return value;
}

var identity_1 = identity$6;

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */

function apply$2(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

var _apply = apply$2;

var apply$1 = _apply;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$3 = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest$1(func, start, transform) {
  start = nativeMax$3(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax$3(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply$1(func, this, otherArgs);
  };
}

var _overRest = overRest$1;

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */

function constant$1(value) {
  return function() {
    return value;
  };
}

var constant_1 = constant$1;

var constant = constant_1,
    defineProperty = _defineProperty,
    identity$5 = identity_1;

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString$1 = !defineProperty ? identity$5 : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

var _baseSetToString = baseSetToString$1;

/** Used to detect hot functions by number of calls within a span of milliseconds. */

var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut$1(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

var _shortOut = shortOut$1;

var baseSetToString = _baseSetToString,
    shortOut = _shortOut;

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString$1 = shortOut(baseSetToString);

var _setToString = setToString$1;

var identity$4 = identity_1,
    overRest = _overRest,
    setToString = _setToString;

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest$5(func, start) {
  return setToString(overRest(func, start, identity$4), func + '');
}

var _baseRest = baseRest$5;

var eq$4 = eq_1,
    isArrayLike$7 = isArrayLike_1,
    isIndex$2 = _isIndex,
    isObject$c = isObject_1;

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall$5(value, index, object) {
  if (!isObject$c(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike$7(object) && isIndex$2(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq$4(object[index], value);
  }
  return false;
}

var _isIterateeCall = isIterateeCall$5;

var baseRest$4 = _baseRest,
    eq$3 = eq_1,
    isIterateeCall$4 = _isIterateeCall,
    keysIn$4 = keysIn_1;

/** Used for built-in method references. */
var objectProto$9 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$9 = objectProto$9.hasOwnProperty;

/**
 * Assigns own and inherited enumerable string keyed properties of source
 * objects to the destination object for all destination properties that
 * resolve to `undefined`. Source objects are applied from left to right.
 * Once a property is set, additional values of the same property are ignored.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.defaultsDeep
 * @example
 *
 * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var defaults$1 = baseRest$4(function(object, sources) {
  object = Object(object);

  var index = -1;
  var length = sources.length;
  var guard = length > 2 ? sources[2] : undefined;

  if (guard && isIterateeCall$4(sources[0], sources[1], guard)) {
    length = 1;
  }

  while (++index < length) {
    var source = sources[index];
    var props = keysIn$4(source);
    var propsIndex = -1;
    var propsLength = props.length;

    while (++propsIndex < propsLength) {
      var key = props[propsIndex];
      var value = object[key];

      if (value === undefined ||
          (eq$3(value, objectProto$9[key]) && !hasOwnProperty$9.call(object, key))) {
        object[key] = source[key];
      }
    }
  }

  return object;
});

var defaults_1 = defaults$1;

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */

function arrayMap$6(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

var _arrayMap = arrayMap$6;

var baseGetTag$3 = _baseGetTag,
    isObjectLike$5 = isObjectLike_1;

/** `Object#toString` result references. */
var symbolTag$1 = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol$6(value) {
  return typeof value == 'symbol' ||
    (isObjectLike$5(value) && baseGetTag$3(value) == symbolTag$1);
}

var isSymbol_1 = isSymbol$6;

var Symbol$4 = _Symbol,
    arrayMap$5 = _arrayMap,
    isArray$g = isArray_1,
    isSymbol$5 = isSymbol_1;

/** Used as references for various `Number` constants. */
var INFINITY$2 = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto$1 = Symbol$4 ? Symbol$4.prototype : undefined,
    symbolToString = symbolProto$1 ? symbolProto$1.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString$1(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray$g(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap$5(value, baseToString$1) + '';
  }
  if (isSymbol$5(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY$2) ? '-0' : result;
}

var _baseToString = baseToString$1;

var baseToString = _baseToString;

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString$4(value) {
  return value == null ? '' : baseToString(value);
}

var toString_1 = toString$4;

var toString$3 = toString_1;

/** Used to generate unique IDs. */
var idCounter = 0;

/**
 * Generates a unique ID. If `prefix` is given, the ID is appended to it.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {string} [prefix=''] The value to prefix the ID with.
 * @returns {string} Returns the unique ID.
 * @example
 *
 * _.uniqueId('contact_');
 * // => 'contact_104'
 *
 * _.uniqueId();
 * // => '105'
 */
function uniqueId$2(prefix) {
  var id = ++idCounter;
  return toString$3(prefix) + id;
}

var uniqueId_1 = uniqueId$2;

var timeout$3 = {};

let KnexTimeoutError$3 = class KnexTimeoutError extends Error {
  constructor(message) {
    super(message);
    this.name = 'KnexTimeoutError';
  }
};

function timeout$2(promise, ms) {
  return new Promise(function (resolve, reject) {
    const id = setTimeout(function () {
      reject(new KnexTimeoutError$3('operation timed out'));
    }, ms);

    function wrappedResolve(value) {
      clearTimeout(id);
      resolve(value);
    }

    function wrappedReject(err) {
      clearTimeout(id);
      reject(err);
    }

    promise.then(wrappedResolve, wrappedReject);
  });
}

timeout$3.KnexTimeoutError = KnexTimeoutError$3;
timeout$3.timeout = timeout$2;

function ensureConnectionCallback$1(runner) {
  runner.client.emit('start', runner.builder);
  runner.builder.emit('start', runner.builder);
  const sql = runner.builder.toSQL();

  if (runner.builder._debug) {
    runner.client.logger.debug(sql);
  }

  if (Array.isArray(sql)) {
    return runner.queryArray(sql);
  }
  return runner.query(sql);
}

function ensureConnectionStreamCallback$1(runner, params) {
  try {
    const sql = runner.builder.toSQL();

    if (Array.isArray(sql) && params.hasHandler) {
      throw new Error(
        'The stream may only be used with a single query statement.'
      );
    }

    return runner.client.stream(
      runner.connection,
      sql,
      params.stream,
      params.options
    );
  } catch (e) {
    params.stream.emit('error', e);
    throw e;
  }
}

var ensureConnectionCallback_1 = {
  ensureConnectionCallback: ensureConnectionCallback$1,
  ensureConnectionStreamCallback: ensureConnectionStreamCallback$1,
};

const { KnexTimeoutError: KnexTimeoutError$2 } = timeout$3;
const { timeout: timeout$1 } = timeout$3;
const {
  ensureConnectionCallback,
  ensureConnectionStreamCallback,
} = ensureConnectionCallback_1;

let Transform$1;

// The "Runner" constructor takes a "builder" (query, schema, or raw)
// and runs through each of the query statements, calling any additional
// "output" method provided alongside the query and bindings.
let Runner$1 = class Runner {
  constructor(client, builder) {
    this.client = client;
    this.builder = builder;
    this.queries = [];

    // The "connection" object is set on the runner when
    // "run" is called.
    this.connection = undefined;
  }

  // "Run" the target, calling "toSQL" on the builder, returning
  // an object or array of queries to run, each of which are run on
  // a single connection.
  async run() {
    const runner = this;
    try {
      const res = await this.ensureConnection(ensureConnectionCallback);

      // Fire a single "end" event on the builder when
      // all queries have successfully completed.
      runner.builder.emit('end');
      return res;

      // If there are any "error" listeners, we fire an error event
      // and then re-throw the error to be eventually handled by
      // the promise chain. Useful if you're wrapping in a custom `Promise`.
    } catch (err) {
      if (runner.builder._events && runner.builder._events.error) {
        runner.builder.emit('error', err);
      }
      throw err;
    }
  }

  // Stream the result set, by passing through to the dialect's streaming
  // capabilities. If the options are
  stream(optionsOrHandler, handlerOrNil) {
    const firstOptionIsHandler =
      typeof optionsOrHandler === 'function' && arguments.length === 1;

    const options = firstOptionIsHandler ? {} : optionsOrHandler;
    const handler = firstOptionIsHandler ? optionsOrHandler : handlerOrNil;

    // Determines whether we emit an error or throw here.
    const hasHandler = typeof handler === 'function';

    // Lazy-load the "Transform" dependency.
    Transform$1 = Transform$1 || require$$0$1.Transform;

    const queryContext = this.builder.queryContext();

    const stream = new Transform$1({
      objectMode: true,
      transform: (chunk, _, callback) => {
        callback(null, this.client.postProcessResponse(chunk, queryContext));
      },
    });
    stream.on('close', () => {
      this.client.releaseConnection(this.connection);
    });

    const connectionAcquirePromise = this.ensureConnection(
      ensureConnectionStreamCallback,
      {
        options,
        hasHandler,
        stream,
      }
    )
      // Emit errors on the stream if the error occurred before a connection
      // could be acquired.
      // If the connection was acquired, assume the error occurred in the client
      // code and has already been emitted on the stream. Don't emit it twice.
      .catch((err) => {
        if (!this.connection) {
          stream.emit('error', err);
        }
      });

    // If a function is passed to handle the stream, send the stream
    // there and return the promise, otherwise just return the stream
    // and the promise will take care of itself.
    if (hasHandler) {
      handler(stream);
      return connectionAcquirePromise;
    }
    return stream;
  }

  // Allow you to pipe the stream to a writable stream.
  pipe(writable, options) {
    return this.stream(options).pipe(writable);
  }

  // "Runs" a query, returning a promise. All queries specified by the builder are guaranteed
  // to run in sequence, and on the same connection, especially helpful when schema building
  // and dealing with foreign key constraints, etc.
  async query(obj) {
    const { __knexUid, __knexTxId } = this.connection;

    this.builder.emit('query', Object.assign({ __knexUid, __knexTxId }, obj));

    const runner = this;
    const queryContext = this.builder.queryContext();
    // query-error events are emitted before the queryPromise continuations.
    // pass queryContext into client.query so it can be raised properly.
    if (obj !== null && typeof obj === 'object') {
      obj.queryContext = queryContext;
    }
    let queryPromise = this.client.query(this.connection, obj);

    if (obj.timeout) {
      queryPromise = timeout$1(queryPromise, obj.timeout);
    }

    // Await the return value of client.processResponse; in the case of sqlite3's
    // dropColumn()/renameColumn(), it will be a Promise for the transaction
    // containing the complete rename procedure.
    return queryPromise
      .then((resp) => this.client.processResponse(resp, runner))
      .then((processedResponse) => {
        const postProcessedResponse = this.client.postProcessResponse(
          processedResponse,
          queryContext
        );

        this.builder.emit(
          'query-response',
          postProcessedResponse,
          Object.assign({ __knexUid, __knexTxId }, obj),
          this.builder
        );

        this.client.emit(
          'query-response',
          postProcessedResponse,
          Object.assign({ __knexUid, __knexTxId }, obj),
          this.builder
        );

        return postProcessedResponse;
      })
      .catch((error) => {
        if (!(error instanceof KnexTimeoutError$2)) {
          return Promise.reject(error);
        }
        const { timeout, sql, bindings } = obj;

        let cancelQuery;
        if (obj.cancelOnTimeout) {
          cancelQuery = this.client.cancelQuery(this.connection);
        } else {
          // If we don't cancel the query, we need to mark the connection as disposed so that
          // it gets destroyed by the pool and is never used again. If we don't do this and
          // return the connection to the pool, it will be useless until the current operation
          // that timed out, finally finishes.
          this.connection.__knex__disposed = error;
          cancelQuery = Promise.resolve();
        }

        return cancelQuery
          .catch((cancelError) => {
            // If the cancellation failed, we need to mark the connection as disposed so that
            // it gets destroyed by the pool and is never used again. If we don't do this and
            // return the connection to the pool, it will be useless until the current operation
            // that timed out, finally finishes.
            this.connection.__knex__disposed = error;

            // cancellation failed
            throw Object.assign(cancelError, {
              message: `After query timeout of ${timeout}ms exceeded, cancelling of query failed.`,
              sql,
              bindings,
              timeout,
            });
          })
          .then(() => {
            // cancellation succeeded, rethrow timeout error
            throw Object.assign(error, {
              message: `Defined query timeout of ${timeout}ms exceeded when running query.`,
              sql,
              bindings,
              timeout,
            });
          });
      })
      .catch((error) => {
        this.builder.emit(
          'query-error',
          error,
          Object.assign({ __knexUid, __knexTxId, queryContext }, obj)
        );
        throw error;
      });
  }

  // In the case of the "schema builder" we call `queryArray`, which runs each
  // of the queries in sequence.
  async queryArray(queries) {
    if (queries.length === 1) {
      const query = queries[0];

      if (!query.statementsProducer) {
        return this.query(query);
      }

      const statements = await query.statementsProducer(
        undefined,
        this.connection
      );

      const sqlQueryObjects = statements.sql.map((statement) => ({
        sql: statement,
        bindings: query.bindings,
      }));
      const preQueryObjects = statements.pre.map((statement) => ({
        sql: statement,
        bindings: query.bindings,
      }));
      const postQueryObjects = statements.post.map((statement) => ({
        sql: statement,
        bindings: query.bindings,
      }));

      let results = [];

      await this.queryArray(preQueryObjects);

      try {
        await this.client.transaction(
          async (trx) => {
            const transactionRunner = new Runner(trx.client, this.builder);
            transactionRunner.connection = this.connection;

            results = await transactionRunner.queryArray(sqlQueryObjects);

            if (statements.check) {
              const foreignViolations = await trx.raw(statements.check);

              if (foreignViolations.length > 0) {
                throw new Error('FOREIGN KEY constraint failed');
              }
            }
          },
          { connection: this.connection }
        );
      } finally {
        await this.queryArray(postQueryObjects);
      }

      return results;
    }

    const results = [];
    for (const query of queries) {
      results.push(await this.queryArray([query]));
    }
    return results;
  }

  // Check whether there's a transaction flag, and that it has a connection.
  async ensureConnection(cb, cbParams) {
    // Use override from a builder if passed
    if (this.builder._connection) {
      this.connection = this.builder._connection;
    }

    if (this.connection) {
      return cb(this, cbParams);
    }

    let acquiredConnection;
    try {
      acquiredConnection = await this.client.acquireConnection();
    } catch (error) {
      if (!(error instanceof KnexTimeoutError$2)) {
        return Promise.reject(error);
      }
      if (this.builder) {
        error.sql = this.builder.sql;
        error.bindings = this.builder.bindings;
      }
      throw error;
    }
    try {
      this.connection = acquiredConnection;
      return await cb(this, cbParams);
    } finally {
      await this.client.releaseConnection(acquiredConnection);
    }
  }
};

var runner = Runner$1;

var srcExports = {};
var src = {
  get exports(){ return srcExports; },
  set exports(v){ srcExports = v; },
};

var browserExports = {};
var browser = {
  get exports(){ return browserExports; },
  set exports(v){ browserExports = v; },
};

/**
 * Helpers.
 */

var ms;
var hasRequiredMs;

function requireMs () {
	if (hasRequiredMs) return ms;
	hasRequiredMs = 1;
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var w = d * 7;
	var y = d * 365.25;

	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} [options]
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */

	ms = function(val, options) {
	  options = options || {};
	  var type = typeof val;
	  if (type === 'string' && val.length > 0) {
	    return parse(val);
	  } else if (type === 'number' && isFinite(val)) {
	    return options.long ? fmtLong(val) : fmtShort(val);
	  }
	  throw new Error(
	    'val is not a non-empty string or a valid number. val=' +
	      JSON.stringify(val)
	  );
	};

	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */

	function parse(str) {
	  str = String(str);
	  if (str.length > 100) {
	    return;
	  }
	  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
	    str
	  );
	  if (!match) {
	    return;
	  }
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'weeks':
	    case 'week':
	    case 'w':
	      return n * w;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	    default:
	      return undefined;
	  }
	}

	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtShort(ms) {
	  var msAbs = Math.abs(ms);
	  if (msAbs >= d) {
	    return Math.round(ms / d) + 'd';
	  }
	  if (msAbs >= h) {
	    return Math.round(ms / h) + 'h';
	  }
	  if (msAbs >= m) {
	    return Math.round(ms / m) + 'm';
	  }
	  if (msAbs >= s) {
	    return Math.round(ms / s) + 's';
	  }
	  return ms + 'ms';
	}

	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtLong(ms) {
	  var msAbs = Math.abs(ms);
	  if (msAbs >= d) {
	    return plural(ms, msAbs, d, 'day');
	  }
	  if (msAbs >= h) {
	    return plural(ms, msAbs, h, 'hour');
	  }
	  if (msAbs >= m) {
	    return plural(ms, msAbs, m, 'minute');
	  }
	  if (msAbs >= s) {
	    return plural(ms, msAbs, s, 'second');
	  }
	  return ms + ' ms';
	}

	/**
	 * Pluralization helper.
	 */

	function plural(ms, msAbs, n, name) {
	  var isPlural = msAbs >= n * 1.5;
	  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
	}
	return ms;
}

var common;
var hasRequiredCommon;

function requireCommon () {
	if (hasRequiredCommon) return common;
	hasRequiredCommon = 1;
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 */

	function setup(env) {
		createDebug.debug = createDebug;
		createDebug.default = createDebug;
		createDebug.coerce = coerce;
		createDebug.disable = disable;
		createDebug.enable = enable;
		createDebug.enabled = enabled;
		createDebug.humanize = requireMs();
		createDebug.destroy = destroy;

		Object.keys(env).forEach(key => {
			createDebug[key] = env[key];
		});

		/**
		* The currently active debug mode names, and names to skip.
		*/

		createDebug.names = [];
		createDebug.skips = [];

		/**
		* Map of special "%n" handling functions, for the debug "format" argument.
		*
		* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
		*/
		createDebug.formatters = {};

		/**
		* Selects a color for a debug namespace
		* @param {String} namespace The namespace string for the debug instance to be colored
		* @return {Number|String} An ANSI color code for the given namespace
		* @api private
		*/
		function selectColor(namespace) {
			let hash = 0;

			for (let i = 0; i < namespace.length; i++) {
				hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
				hash |= 0; // Convert to 32bit integer
			}

			return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
		}
		createDebug.selectColor = selectColor;

		/**
		* Create a debugger with the given `namespace`.
		*
		* @param {String} namespace
		* @return {Function}
		* @api public
		*/
		function createDebug(namespace) {
			let prevTime;
			let enableOverride = null;
			let namespacesCache;
			let enabledCache;

			function debug(...args) {
				// Disabled?
				if (!debug.enabled) {
					return;
				}

				const self = debug;

				// Set `diff` timestamp
				const curr = Number(new Date());
				const ms = curr - (prevTime || curr);
				self.diff = ms;
				self.prev = prevTime;
				self.curr = curr;
				prevTime = curr;

				args[0] = createDebug.coerce(args[0]);

				if (typeof args[0] !== 'string') {
					// Anything else let's inspect with %O
					args.unshift('%O');
				}

				// Apply any `formatters` transformations
				let index = 0;
				args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
					// If we encounter an escaped % then don't increase the array index
					if (match === '%%') {
						return '%';
					}
					index++;
					const formatter = createDebug.formatters[format];
					if (typeof formatter === 'function') {
						const val = args[index];
						match = formatter.call(self, val);

						// Now we need to remove `args[index]` since it's inlined in the `format`
						args.splice(index, 1);
						index--;
					}
					return match;
				});

				// Apply env-specific formatting (colors, etc.)
				createDebug.formatArgs.call(self, args);

				const logFn = self.log || createDebug.log;
				logFn.apply(self, args);
			}

			debug.namespace = namespace;
			debug.useColors = createDebug.useColors();
			debug.color = createDebug.selectColor(namespace);
			debug.extend = extend;
			debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

			Object.defineProperty(debug, 'enabled', {
				enumerable: true,
				configurable: false,
				get: () => {
					if (enableOverride !== null) {
						return enableOverride;
					}
					if (namespacesCache !== createDebug.namespaces) {
						namespacesCache = createDebug.namespaces;
						enabledCache = createDebug.enabled(namespace);
					}

					return enabledCache;
				},
				set: v => {
					enableOverride = v;
				}
			});

			// Env-specific initialization logic for debug instances
			if (typeof createDebug.init === 'function') {
				createDebug.init(debug);
			}

			return debug;
		}

		function extend(namespace, delimiter) {
			const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
			newDebug.log = this.log;
			return newDebug;
		}

		/**
		* Enables a debug mode by namespaces. This can include modes
		* separated by a colon and wildcards.
		*
		* @param {String} namespaces
		* @api public
		*/
		function enable(namespaces) {
			createDebug.save(namespaces);
			createDebug.namespaces = namespaces;

			createDebug.names = [];
			createDebug.skips = [];

			let i;
			const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
			const len = split.length;

			for (i = 0; i < len; i++) {
				if (!split[i]) {
					// ignore empty strings
					continue;
				}

				namespaces = split[i].replace(/\*/g, '.*?');

				if (namespaces[0] === '-') {
					createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
				} else {
					createDebug.names.push(new RegExp('^' + namespaces + '$'));
				}
			}
		}

		/**
		* Disable debug output.
		*
		* @return {String} namespaces
		* @api public
		*/
		function disable() {
			const namespaces = [
				...createDebug.names.map(toNamespace),
				...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
			].join(',');
			createDebug.enable('');
			return namespaces;
		}

		/**
		* Returns true if the given mode name is enabled, false otherwise.
		*
		* @param {String} name
		* @return {Boolean}
		* @api public
		*/
		function enabled(name) {
			if (name[name.length - 1] === '*') {
				return true;
			}

			let i;
			let len;

			for (i = 0, len = createDebug.skips.length; i < len; i++) {
				if (createDebug.skips[i].test(name)) {
					return false;
				}
			}

			for (i = 0, len = createDebug.names.length; i < len; i++) {
				if (createDebug.names[i].test(name)) {
					return true;
				}
			}

			return false;
		}

		/**
		* Convert regexp to namespace
		*
		* @param {RegExp} regxep
		* @return {String} namespace
		* @api private
		*/
		function toNamespace(regexp) {
			return regexp.toString()
				.substring(2, regexp.toString().length - 2)
				.replace(/\.\*\?$/, '*');
		}

		/**
		* Coerce `val`.
		*
		* @param {Mixed} val
		* @return {Mixed}
		* @api private
		*/
		function coerce(val) {
			if (val instanceof Error) {
				return val.stack || val.message;
			}
			return val;
		}

		/**
		* XXX DO NOT USE. This is a temporary stub function.
		* XXX It WILL be removed in the next major release.
		*/
		function destroy() {
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}

		createDebug.enable(createDebug.load());

		return createDebug;
	}

	common = setup;
	return common;
}

/* eslint-env browser */

var hasRequiredBrowser;

function requireBrowser () {
	if (hasRequiredBrowser) return browserExports;
	hasRequiredBrowser = 1;
	(function (module, exports) {
		/**
		 * This is the web browser implementation of `debug()`.
		 */

		exports.formatArgs = formatArgs;
		exports.save = save;
		exports.load = load;
		exports.useColors = useColors;
		exports.storage = localstorage();
		exports.destroy = (() => {
			let warned = false;

			return () => {
				if (!warned) {
					warned = true;
					console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
				}
			};
		})();

		/**
		 * Colors.
		 */

		exports.colors = [
			'#0000CC',
			'#0000FF',
			'#0033CC',
			'#0033FF',
			'#0066CC',
			'#0066FF',
			'#0099CC',
			'#0099FF',
			'#00CC00',
			'#00CC33',
			'#00CC66',
			'#00CC99',
			'#00CCCC',
			'#00CCFF',
			'#3300CC',
			'#3300FF',
			'#3333CC',
			'#3333FF',
			'#3366CC',
			'#3366FF',
			'#3399CC',
			'#3399FF',
			'#33CC00',
			'#33CC33',
			'#33CC66',
			'#33CC99',
			'#33CCCC',
			'#33CCFF',
			'#6600CC',
			'#6600FF',
			'#6633CC',
			'#6633FF',
			'#66CC00',
			'#66CC33',
			'#9900CC',
			'#9900FF',
			'#9933CC',
			'#9933FF',
			'#99CC00',
			'#99CC33',
			'#CC0000',
			'#CC0033',
			'#CC0066',
			'#CC0099',
			'#CC00CC',
			'#CC00FF',
			'#CC3300',
			'#CC3333',
			'#CC3366',
			'#CC3399',
			'#CC33CC',
			'#CC33FF',
			'#CC6600',
			'#CC6633',
			'#CC9900',
			'#CC9933',
			'#CCCC00',
			'#CCCC33',
			'#FF0000',
			'#FF0033',
			'#FF0066',
			'#FF0099',
			'#FF00CC',
			'#FF00FF',
			'#FF3300',
			'#FF3333',
			'#FF3366',
			'#FF3399',
			'#FF33CC',
			'#FF33FF',
			'#FF6600',
			'#FF6633',
			'#FF9900',
			'#FF9933',
			'#FFCC00',
			'#FFCC33'
		];

		/**
		 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
		 * and the Firebug extension (any Firefox version) are known
		 * to support "%c" CSS customizations.
		 *
		 * TODO: add a `localStorage` variable to explicitly enable/disable colors
		 */

		// eslint-disable-next-line complexity
		function useColors() {
			// NB: In an Electron preload script, document will be defined but not fully
			// initialized. Since we know we're in Chrome, we'll just detect this case
			// explicitly
			if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
				return true;
			}

			// Internet Explorer and Edge do not support colors.
			if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
				return false;
			}

			// Is webkit? http://stackoverflow.com/a/16459606/376773
			// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
			return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
				// Is firebug? http://stackoverflow.com/a/398120/376773
				(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
				// Is firefox >= v31?
				// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
				(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
				// Double check webkit in userAgent just in case we are in a worker
				(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
		}

		/**
		 * Colorize log arguments if enabled.
		 *
		 * @api public
		 */

		function formatArgs(args) {
			args[0] = (this.useColors ? '%c' : '') +
				this.namespace +
				(this.useColors ? ' %c' : ' ') +
				args[0] +
				(this.useColors ? '%c ' : ' ') +
				'+' + module.exports.humanize(this.diff);

			if (!this.useColors) {
				return;
			}

			const c = 'color: ' + this.color;
			args.splice(1, 0, c, 'color: inherit');

			// The final "%c" is somewhat tricky, because there could be other
			// arguments passed either before or after the %c, so we need to
			// figure out the correct index to insert the CSS into
			let index = 0;
			let lastC = 0;
			args[0].replace(/%[a-zA-Z%]/g, match => {
				if (match === '%%') {
					return;
				}
				index++;
				if (match === '%c') {
					// We only are interested in the *last* %c
					// (the user may have provided their own)
					lastC = index;
				}
			});

			args.splice(lastC, 0, c);
		}

		/**
		 * Invokes `console.debug()` when available.
		 * No-op when `console.debug` is not a "function".
		 * If `console.debug` is not available, falls back
		 * to `console.log`.
		 *
		 * @api public
		 */
		exports.log = console.debug || console.log || (() => {});

		/**
		 * Save `namespaces`.
		 *
		 * @param {String} namespaces
		 * @api private
		 */
		function save(namespaces) {
			try {
				if (namespaces) {
					exports.storage.setItem('debug', namespaces);
				} else {
					exports.storage.removeItem('debug');
				}
			} catch (error) {
				// Swallow
				// XXX (@Qix-) should we be logging these?
			}
		}

		/**
		 * Load `namespaces`.
		 *
		 * @return {String} returns the previously persisted debug modes
		 * @api private
		 */
		function load() {
			let r;
			try {
				r = exports.storage.getItem('debug');
			} catch (error) {
				// Swallow
				// XXX (@Qix-) should we be logging these?
			}

			// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
			if (!r && typeof process !== 'undefined' && 'env' in process) {
				r = process.env.DEBUG;
			}

			return r;
		}

		/**
		 * Localstorage attempts to return the localstorage.
		 *
		 * This is necessary because safari throws
		 * when a user disables cookies/localstorage
		 * and you attempt to access it.
		 *
		 * @return {LocalStorage}
		 * @api private
		 */

		function localstorage() {
			try {
				// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
				// The Browser also has localStorage in the global context.
				return localStorage;
			} catch (error) {
				// Swallow
				// XXX (@Qix-) should we be logging these?
			}
		}

		module.exports = requireCommon()(exports);

		const {formatters} = module.exports;

		/**
		 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
		 */

		formatters.j = function (v) {
			try {
				return JSON.stringify(v);
			} catch (error) {
				return '[UnexpectedJSONParseError]: ' + error.message;
			}
		};
} (browser, browserExports));
	return browserExports;
}

var nodeExports = {};
var node = {
  get exports(){ return nodeExports; },
  set exports(v){ nodeExports = v; },
};

var hasFlag;
var hasRequiredHasFlag;

function requireHasFlag () {
	if (hasRequiredHasFlag) return hasFlag;
	hasRequiredHasFlag = 1;

	hasFlag = (flag, argv = process.argv) => {
		const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
		const position = argv.indexOf(prefix + flag);
		const terminatorPosition = argv.indexOf('--');
		return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
	};
	return hasFlag;
}

var supportsColor_1;
var hasRequiredSupportsColor;

function requireSupportsColor () {
	if (hasRequiredSupportsColor) return supportsColor_1;
	hasRequiredSupportsColor = 1;
	const os = require$$0$3;
	const tty = require$$0$2;
	const hasFlag = requireHasFlag();

	const {env} = process;

	let forceColor;
	if (hasFlag('no-color') ||
		hasFlag('no-colors') ||
		hasFlag('color=false') ||
		hasFlag('color=never')) {
		forceColor = 0;
	} else if (hasFlag('color') ||
		hasFlag('colors') ||
		hasFlag('color=true') ||
		hasFlag('color=always')) {
		forceColor = 1;
	}

	if ('FORCE_COLOR' in env) {
		if (env.FORCE_COLOR === 'true') {
			forceColor = 1;
		} else if (env.FORCE_COLOR === 'false') {
			forceColor = 0;
		} else {
			forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
		}
	}

	function translateLevel(level) {
		if (level === 0) {
			return false;
		}

		return {
			level,
			hasBasic: true,
			has256: level >= 2,
			has16m: level >= 3
		};
	}

	function supportsColor(haveStream, streamIsTTY) {
		if (forceColor === 0) {
			return 0;
		}

		if (hasFlag('color=16m') ||
			hasFlag('color=full') ||
			hasFlag('color=truecolor')) {
			return 3;
		}

		if (hasFlag('color=256')) {
			return 2;
		}

		if (haveStream && !streamIsTTY && forceColor === undefined) {
			return 0;
		}

		const min = forceColor || 0;

		if (env.TERM === 'dumb') {
			return min;
		}

		if (process.platform === 'win32') {
			// Windows 10 build 10586 is the first Windows release that supports 256 colors.
			// Windows 10 build 14931 is the first release that supports 16m/TrueColor.
			const osRelease = os.release().split('.');
			if (
				Number(osRelease[0]) >= 10 &&
				Number(osRelease[2]) >= 10586
			) {
				return Number(osRelease[2]) >= 14931 ? 3 : 2;
			}

			return 1;
		}

		if ('CI' in env) {
			if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
				return 1;
			}

			return min;
		}

		if ('TEAMCITY_VERSION' in env) {
			return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
		}

		if (env.COLORTERM === 'truecolor') {
			return 3;
		}

		if ('TERM_PROGRAM' in env) {
			const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

			switch (env.TERM_PROGRAM) {
				case 'iTerm.app':
					return version >= 3 ? 3 : 2;
				case 'Apple_Terminal':
					return 2;
				// No default
			}
		}

		if (/-256(color)?$/i.test(env.TERM)) {
			return 2;
		}

		if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
			return 1;
		}

		if ('COLORTERM' in env) {
			return 1;
		}

		return min;
	}

	function getSupportLevel(stream) {
		const level = supportsColor(stream, stream && stream.isTTY);
		return translateLevel(level);
	}

	supportsColor_1 = {
		supportsColor: getSupportLevel,
		stdout: translateLevel(supportsColor(true, tty.isatty(1))),
		stderr: translateLevel(supportsColor(true, tty.isatty(2)))
	};
	return supportsColor_1;
}

/**
 * Module dependencies.
 */

var hasRequiredNode;

function requireNode () {
	if (hasRequiredNode) return nodeExports;
	hasRequiredNode = 1;
	(function (module, exports) {
		const tty = require$$0$2;
		const util = require$$0$4;

		/**
		 * This is the Node.js implementation of `debug()`.
		 */

		exports.init = init;
		exports.log = log;
		exports.formatArgs = formatArgs;
		exports.save = save;
		exports.load = load;
		exports.useColors = useColors;
		exports.destroy = util.deprecate(
			() => {},
			'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
		);

		/**
		 * Colors.
		 */

		exports.colors = [6, 2, 3, 4, 5, 1];

		try {
			// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
			// eslint-disable-next-line import/no-extraneous-dependencies
			const supportsColor = requireSupportsColor();

			if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
				exports.colors = [
					20,
					21,
					26,
					27,
					32,
					33,
					38,
					39,
					40,
					41,
					42,
					43,
					44,
					45,
					56,
					57,
					62,
					63,
					68,
					69,
					74,
					75,
					76,
					77,
					78,
					79,
					80,
					81,
					92,
					93,
					98,
					99,
					112,
					113,
					128,
					129,
					134,
					135,
					148,
					149,
					160,
					161,
					162,
					163,
					164,
					165,
					166,
					167,
					168,
					169,
					170,
					171,
					172,
					173,
					178,
					179,
					184,
					185,
					196,
					197,
					198,
					199,
					200,
					201,
					202,
					203,
					204,
					205,
					206,
					207,
					208,
					209,
					214,
					215,
					220,
					221
				];
			}
		} catch (error) {
			// Swallow - we only care if `supports-color` is available; it doesn't have to be.
		}

		/**
		 * Build up the default `inspectOpts` object from the environment variables.
		 *
		 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
		 */

		exports.inspectOpts = Object.keys(process.env).filter(key => {
			return /^debug_/i.test(key);
		}).reduce((obj, key) => {
			// Camel-case
			const prop = key
				.substring(6)
				.toLowerCase()
				.replace(/_([a-z])/g, (_, k) => {
					return k.toUpperCase();
				});

			// Coerce string value into JS value
			let val = process.env[key];
			if (/^(yes|on|true|enabled)$/i.test(val)) {
				val = true;
			} else if (/^(no|off|false|disabled)$/i.test(val)) {
				val = false;
			} else if (val === 'null') {
				val = null;
			} else {
				val = Number(val);
			}

			obj[prop] = val;
			return obj;
		}, {});

		/**
		 * Is stdout a TTY? Colored output is enabled when `true`.
		 */

		function useColors() {
			return 'colors' in exports.inspectOpts ?
				Boolean(exports.inspectOpts.colors) :
				tty.isatty(process.stderr.fd);
		}

		/**
		 * Adds ANSI color escape codes if enabled.
		 *
		 * @api public
		 */

		function formatArgs(args) {
			const {namespace: name, useColors} = this;

			if (useColors) {
				const c = this.color;
				const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
				const prefix = `  ${colorCode};1m${name} \u001B[0m`;

				args[0] = prefix + args[0].split('\n').join('\n' + prefix);
				args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
			} else {
				args[0] = getDate() + name + ' ' + args[0];
			}
		}

		function getDate() {
			if (exports.inspectOpts.hideDate) {
				return '';
			}
			return new Date().toISOString() + ' ';
		}

		/**
		 * Invokes `util.format()` with the specified arguments and writes to stderr.
		 */

		function log(...args) {
			return process.stderr.write(util.format(...args) + '\n');
		}

		/**
		 * Save `namespaces`.
		 *
		 * @param {String} namespaces
		 * @api private
		 */
		function save(namespaces) {
			if (namespaces) {
				process.env.DEBUG = namespaces;
			} else {
				// If you set a process.env field to null or undefined, it gets cast to the
				// string 'null' or 'undefined'. Just delete instead.
				delete process.env.DEBUG;
			}
		}

		/**
		 * Load `namespaces`.
		 *
		 * @return {String} returns the previously persisted debug modes
		 * @api private
		 */

		function load() {
			return process.env.DEBUG;
		}

		/**
		 * Init logic for `debug` instances.
		 *
		 * Create a new `inspectOpts` object in case `useColors` is set
		 * differently for a particular `debug` instance.
		 */

		function init(debug) {
			debug.inspectOpts = {};

			const keys = Object.keys(exports.inspectOpts);
			for (let i = 0; i < keys.length; i++) {
				debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
			}
		}

		module.exports = requireCommon()(exports);

		const {formatters} = module.exports;

		/**
		 * Map %o to `util.inspect()`, all on a single line.
		 */

		formatters.o = function (v) {
			this.inspectOpts.colors = this.useColors;
			return util.inspect(v, this.inspectOpts)
				.split('\n')
				.map(str => str.trim())
				.join(' ');
		};

		/**
		 * Map %O to `util.inspect()`, allowing multiple lines if needed.
		 */

		formatters.O = function (v) {
			this.inspectOpts.colors = this.useColors;
			return util.inspect(v, this.inspectOpts);
		};
} (node, nodeExports));
	return nodeExports;
}

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

(function (module) {
	if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
		module.exports = requireBrowser();
	} else {
		module.exports = requireNode();
	}
} (src));

/** Used to stand-in for `undefined` hash values. */

var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd$1(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

var _setCacheAdd = setCacheAdd$1;

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */

function setCacheHas$1(value) {
  return this.__data__.has(value);
}

var _setCacheHas = setCacheHas$1;

var MapCache$1 = _MapCache,
    setCacheAdd = _setCacheAdd,
    setCacheHas = _setCacheHas;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache$2(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache$1;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache$2.prototype.add = SetCache$2.prototype.push = setCacheAdd;
SetCache$2.prototype.has = setCacheHas;

var _SetCache = SetCache$2;

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */

function baseFindIndex$1(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

var _baseFindIndex = baseFindIndex$1;

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */

function baseIsNaN$1(value) {
  return value !== value;
}

var _baseIsNaN = baseIsNaN$1;

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */

function strictIndexOf$1(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

var _strictIndexOf = strictIndexOf$1;

var baseFindIndex = _baseFindIndex,
    baseIsNaN = _baseIsNaN,
    strictIndexOf = _strictIndexOf;

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf$3(array, value, fromIndex) {
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex);
}

var _baseIndexOf = baseIndexOf$3;

var baseIndexOf$2 = _baseIndexOf;

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes$1(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf$2(array, value, 0) > -1;
}

var _arrayIncludes = arrayIncludes$1;

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */

function arrayIncludesWith$1(array, value, comparator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

var _arrayIncludesWith = arrayIncludesWith$1;

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function cacheHas$2(cache, key) {
  return cache.has(key);
}

var _cacheHas = cacheHas$2;

var SetCache$1 = _SetCache,
    arrayIncludes = _arrayIncludes,
    arrayIncludesWith = _arrayIncludesWith,
    arrayMap$4 = _arrayMap,
    baseUnary$1 = _baseUnary,
    cacheHas$1 = _cacheHas;

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of methods like `_.difference` without support
 * for excluding multiple arrays or iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Array} values The values to exclude.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 */
function baseDifference$1(array, values, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      isCommon = true,
      length = array.length,
      result = [],
      valuesLength = values.length;

  if (!length) {
    return result;
  }
  if (iteratee) {
    values = arrayMap$4(values, baseUnary$1(iteratee));
  }
  if (comparator) {
    includes = arrayIncludesWith;
    isCommon = false;
  }
  else if (values.length >= LARGE_ARRAY_SIZE) {
    includes = cacheHas$1;
    isCommon = false;
    values = new SetCache$1(values);
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee == null ? value : iteratee(value);

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var valuesIndex = valuesLength;
      while (valuesIndex--) {
        if (values[valuesIndex] === computed) {
          continue outer;
        }
      }
      result.push(value);
    }
    else if (!includes(values, computed, comparator)) {
      result.push(value);
    }
  }
  return result;
}

var _baseDifference = baseDifference$1;

var Symbol$3 = _Symbol,
    isArguments$3 = isArguments_1,
    isArray$f = isArray_1;

/** Built-in value references. */
var spreadableSymbol = Symbol$3 ? Symbol$3.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable$1(value) {
  return isArray$f(value) || isArguments$3(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

var _isFlattenable = isFlattenable$1;

var arrayPush = _arrayPush,
    isFlattenable = _isFlattenable;

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten$3(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten$3(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

var _baseFlatten = baseFlatten$3;

var isArrayLike$6 = isArrayLike_1,
    isObjectLike$4 = isObjectLike_1;

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject$2(value) {
  return isObjectLike$4(value) && isArrayLike$6(value);
}

var isArrayLikeObject_1 = isArrayLikeObject$2;

/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */

function last$2(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : undefined;
}

var last_1 = last$2;

var baseDifference = _baseDifference,
    baseFlatten$2 = _baseFlatten,
    baseRest$3 = _baseRest,
    isArrayLikeObject$1 = isArrayLikeObject_1,
    last$1 = last_1;

/**
 * This method is like `_.difference` except that it accepts `comparator`
 * which is invoked to compare elements of `array` to `values`. The order and
 * references of result values are determined by the first array. The comparator
 * is invoked with two arguments: (arrVal, othVal).
 *
 * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...Array} [values] The values to exclude.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 * @example
 *
 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
 *
 * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
 * // => [{ 'x': 2, 'y': 1 }]
 */
var differenceWith$1 = baseRest$3(function(array, values) {
  var comparator = last$1(values);
  if (isArrayLikeObject$1(comparator)) {
    comparator = undefined;
  }
  return isArrayLikeObject$1(array)
    ? baseDifference(array, baseFlatten$2(values, 1, isArrayLikeObject$1, true), undefined, comparator)
    : [];
});

var differenceWith_1 = differenceWith$1;

var isArray$e = isArray_1,
    isSymbol$4 = isSymbol_1;

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey$3(value, object) {
  if (isArray$e(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol$4(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

var _isKey = isKey$3;

var MapCache = _MapCache;

/** Error message constants. */
var FUNC_ERROR_TEXT$1 = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize$1(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize$1.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize$1.Cache = MapCache;

var memoize_1 = memoize$1;

var memoize = memoize_1;

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped$1(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

var _memoizeCapped = memoizeCapped$1;

var memoizeCapped = _memoizeCapped;

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath$1 = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

var _stringToPath = stringToPath$1;

var isArray$d = isArray_1,
    isKey$2 = _isKey,
    stringToPath = _stringToPath,
    toString$2 = toString_1;

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath$4(value, object) {
  if (isArray$d(value)) {
    return value;
  }
  return isKey$2(value, object) ? [value] : stringToPath(toString$2(value));
}

var _castPath = castPath$4;

var isSymbol$3 = isSymbol_1;

/** Used as references for various `Number` constants. */
var INFINITY$1 = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey$5(value) {
  if (typeof value == 'string' || isSymbol$3(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;
}

var _toKey = toKey$5;

var castPath$3 = _castPath,
    toKey$4 = _toKey;

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet$4(object, path) {
  path = castPath$3(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey$4(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

var _baseGet = baseGet$4;

var baseGet$3 = _baseGet;

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get$2(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet$3(object, path);
  return result === undefined ? defaultValue : result;
}

var get_1 = get$2;

var baseKeys = _baseKeys,
    getTag$2 = _getTag,
    isArguments$2 = isArguments_1,
    isArray$c = isArray_1,
    isArrayLike$5 = isArrayLike_1,
    isBuffer$3 = isBufferExports,
    isPrototype$1 = _isPrototype,
    isTypedArray$4 = isTypedArray_1;

/** `Object#toString` result references. */
var mapTag$2 = '[object Map]',
    setTag$2 = '[object Set]';

/** Used for built-in method references. */
var objectProto$8 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$8 = objectProto$8.hasOwnProperty;

/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */
function isEmpty$5(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike$5(value) &&
      (isArray$c(value) || typeof value == 'string' || typeof value.splice == 'function' ||
        isBuffer$3(value) || isTypedArray$4(value) || isArguments$2(value))) {
    return !value.length;
  }
  var tag = getTag$2(value);
  if (tag == mapTag$2 || tag == setTag$2) {
    return !value.size;
  }
  if (isPrototype$1(value)) {
    return !baseKeys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty$8.call(value, key)) {
      return false;
    }
  }
  return true;
}

var isEmpty_1 = isEmpty$5;

var isSymbol$2 = isSymbol_1;

/**
 * The base implementation of methods like `_.max` and `_.min` which accepts a
 * `comparator` to determine the extremum value.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The iteratee invoked per iteration.
 * @param {Function} comparator The comparator used to compare values.
 * @returns {*} Returns the extremum value.
 */
function baseExtremum$1(array, iteratee, comparator) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    var value = array[index],
        current = iteratee(value);

    if (current != null && (computed === undefined
          ? (current === current && !isSymbol$2(current))
          : comparator(current, computed)
        )) {
      var computed = current,
          result = value;
    }
  }
  return result;
}

var _baseExtremum = baseExtremum$1;

/**
 * The base implementation of `_.gt` which doesn't coerce arguments.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if `value` is greater than `other`,
 *  else `false`.
 */

function baseGt$1(value, other) {
  return value > other;
}

var _baseGt = baseGt$1;

var baseExtremum = _baseExtremum,
    baseGt = _baseGt,
    identity$3 = identity_1;

/**
 * Computes the maximum value of `array`. If `array` is empty or falsey,
 * `undefined` is returned.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {*} Returns the maximum value.
 * @example
 *
 * _.max([4, 2, 8, 6]);
 * // => 8
 *
 * _.max([]);
 * // => undefined
 */
function max$1(array) {
  return (array && array.length)
    ? baseExtremum(array, identity$3, baseGt)
    : undefined;
}

var max_1 = max$1;

//Get schema-aware table name
function getTableName$3(tableName, schemaName) {
  return schemaName ? `${schemaName}.${tableName}` : tableName;
}

//Get schema-aware query builder for a given table and schema name
function getTable$2(trxOrKnex, tableName, schemaName) {
  return schemaName
    ? trxOrKnex(tableName).withSchema(schemaName)
    : trxOrKnex(tableName);
}
function getLockTableName$2(tableName) {
  return tableName + '_lock';
}

function getLockTableNameWithSchema$1(tableName, schemaName) {
  return schemaName
    ? schemaName + '.' + getLockTableName$2(tableName)
    : getLockTableName$2(tableName);
}

var tableResolver = {
  getLockTableName: getLockTableName$2,
  getLockTableNameWithSchema: getLockTableNameWithSchema$1,
  getTable: getTable$2,
  getTableName: getTableName$3,
};

const {
  getTable: getTable$1,
  getLockTableName: getLockTableName$1,
  getLockTableNameWithSchema,
  getTableName: getTableName$2,
} = tableResolver;

function ensureTable$1(tableName, schemaName, trxOrKnex) {
  const lockTable = getLockTableName$1(tableName);
  return getSchemaBuilder$1(trxOrKnex, schemaName)
    .hasTable(tableName)
    .then((exists) => {
      return !exists && _createMigrationTable(tableName, schemaName, trxOrKnex);
    })
    .then(() => {
      return getSchemaBuilder$1(trxOrKnex, schemaName).hasTable(lockTable);
    })
    .then((exists) => {
      return (
        !exists && _createMigrationLockTable(lockTable, schemaName, trxOrKnex)
      );
    })
    .then(() => {
      return getTable$1(trxOrKnex, lockTable, schemaName).select('*');
    })
    .then((data) => {
      return (
        !data.length && _insertLockRowIfNeeded(tableName, schemaName, trxOrKnex)
      );
    });
}

function _createMigrationTable(tableName, schemaName, trxOrKnex) {
  return getSchemaBuilder$1(trxOrKnex, schemaName).createTable(
    getTableName$2(tableName),
    function (t) {
      t.increments();
      t.string('name');
      t.integer('batch');
      t.timestamp('migration_time');
    }
  );
}

function _createMigrationLockTable(tableName, schemaName, trxOrKnex) {
  return getSchemaBuilder$1(trxOrKnex, schemaName).createTable(
    tableName,
    function (t) {
      t.increments('index').primary();
      t.integer('is_locked');
    }
  );
}

function _insertLockRowIfNeeded(tableName, schemaName, trxOrKnex) {
  const lockTableWithSchema = getLockTableNameWithSchema(tableName, schemaName);
  return trxOrKnex
    .select('*')
    .from(lockTableWithSchema)
    .then((data) => {
      return !data.length
        ? trxOrKnex.from(lockTableWithSchema).insert({ is_locked: 0 })
        : null;
    });
}

//Get schema-aware schema builder for a given schema nam
function getSchemaBuilder$1(trxOrKnex, schemaName) {
  return schemaName
    ? trxOrKnex.schema.withSchema(schemaName)
    : trxOrKnex.schema;
}

var tableCreator = {
  ensureTable: ensureTable$1,
  getSchemaBuilder: getSchemaBuilder$1,
};

const { getTableName: getTableName$1 } = tableResolver;
const { ensureTable } = tableCreator;

// Lists all available migration versions, as a sorted array.
function listAll(migrationSource, loadExtensions) {
  return migrationSource.getMigrations(loadExtensions);
}

// Lists all migrations that have been completed for the current db, as an
// array.
async function listCompleted(tableName, schemaName, trxOrKnex) {
  await ensureTable(tableName, schemaName, trxOrKnex);

  return await trxOrKnex
    .from(getTableName$1(tableName, schemaName))
    .orderBy('id')
    .select('name');
}

// Gets the migration list from the migration directory specified in config, as well as
// the list of completed migrations to check what should be run.
function listAllAndCompleted(config, trxOrKnex) {
  return Promise.all([
    listAll(config.migrationSource, config.loadExtensions),
    listCompleted(config.tableName, config.schemaName, trxOrKnex),
  ]);
}

var migrationListResolver$1 = {
  listAll,
  listAllAndCompleted,
  listCompleted,
};

var baseRest$2 = _baseRest,
    isIterateeCall$3 = _isIterateeCall;

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner$4(assigner) {
  return baseRest$2(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall$3(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

var _createAssigner = createAssigner$4;

var copyObject$3 = _copyObject,
    createAssigner$3 = _createAssigner,
    keysIn$3 = keysIn_1;

/**
 * This method is like `_.assignIn` except that it accepts `customizer`
 * which is invoked to produce the assigned values. If `customizer` returns
 * `undefined`, assignment is handled by the method instead. The `customizer`
 * is invoked with five arguments: (objValue, srcValue, key, object, source).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extendWith
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} [customizer] The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @see _.assignWith
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   return _.isUndefined(objValue) ? srcValue : objValue;
 * }
 *
 * var defaults = _.partialRight(_.assignInWith, customizer);
 *
 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var assignInWith$1 = createAssigner$3(function(object, source, srcIndex, customizer) {
  copyObject$3(source, keysIn$3(source), object, customizer);
});

var assignInWith_1 = assignInWith$1;

var baseGetTag$2 = _baseGetTag,
    getPrototype$1 = _getPrototype,
    isObjectLike$3 = isObjectLike_1;

/** `Object#toString` result references. */
var objectTag$1 = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto$7 = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$7 = objectProto$7.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject$6(value) {
  if (!isObjectLike$3(value) || baseGetTag$2(value) != objectTag$1) {
    return false;
  }
  var proto = getPrototype$1(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$7.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

var isPlainObject_1 = isPlainObject$6;

var baseGetTag$1 = _baseGetTag,
    isObjectLike$2 = isObjectLike_1,
    isPlainObject$5 = isPlainObject_1;

/** `Object#toString` result references. */
var domExcTag = '[object DOMException]',
    errorTag$1 = '[object Error]';

/**
 * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
 * `SyntaxError`, `TypeError`, or `URIError` object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
 * @example
 *
 * _.isError(new Error);
 * // => true
 *
 * _.isError(Error);
 * // => false
 */
function isError$2(value) {
  if (!isObjectLike$2(value)) {
    return false;
  }
  var tag = baseGetTag$1(value);
  return tag == errorTag$1 || tag == domExcTag ||
    (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject$5(value));
}

var isError_1 = isError$2;

var apply = _apply,
    baseRest$1 = _baseRest,
    isError$1 = isError_1;

/**
 * Attempts to invoke `func`, returning either the result or the caught error
 * object. Any additional arguments are provided to `func` when it's invoked.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Util
 * @param {Function} func The function to attempt.
 * @param {...*} [args] The arguments to invoke `func` with.
 * @returns {*} Returns the `func` result or error object.
 * @example
 *
 * // Avoid throwing errors for invalid selectors.
 * var elements = _.attempt(function(selector) {
 *   return document.querySelectorAll(selector);
 * }, '>_>');
 *
 * if (_.isError(elements)) {
 *   elements = [];
 * }
 */
var attempt$1 = baseRest$1(function(func, args) {
  try {
    return apply(func, undefined, args);
  } catch (e) {
    return isError$1(e) ? e : new Error(e);
  }
});

var attempt_1 = attempt$1;

var arrayMap$3 = _arrayMap;

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues$2(object, props) {
  return arrayMap$3(props, function(key) {
    return object[key];
  });
}

var _baseValues = baseValues$2;

var eq$2 = eq_1;

/** Used for built-in method references. */
var objectProto$6 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$6 = objectProto$6.hasOwnProperty;

/**
 * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
 * of source objects to the destination object for all destination properties
 * that resolve to `undefined`.
 *
 * @private
 * @param {*} objValue The destination value.
 * @param {*} srcValue The source value.
 * @param {string} key The key of the property to assign.
 * @param {Object} object The parent object of `objValue`.
 * @returns {*} Returns the value to assign.
 */
function customDefaultsAssignIn$1(objValue, srcValue, key, object) {
  if (objValue === undefined ||
      (eq$2(objValue, objectProto$6[key]) && !hasOwnProperty$6.call(object, key))) {
    return srcValue;
  }
  return objValue;
}

var _customDefaultsAssignIn = customDefaultsAssignIn$1;

/** Used to escape characters for inclusion in compiled string literals. */

var stringEscapes = {
  '\\': '\\',
  "'": "'",
  '\n': 'n',
  '\r': 'r',
  '\u2028': 'u2028',
  '\u2029': 'u2029'
};

/**
 * Used by `_.template` to escape characters for inclusion in compiled string literals.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */
function escapeStringChar$1(chr) {
  return '\\' + stringEscapes[chr];
}

var _escapeStringChar = escapeStringChar$1;

/** Used to match template delimiters. */

var reInterpolate$2 = /<%=([\s\S]+?)%>/g;

var _reInterpolate = reInterpolate$2;

/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */

function basePropertyOf$1(object) {
  return function(key) {
    return object == null ? undefined : object[key];
  };
}

var _basePropertyOf = basePropertyOf$1;

var basePropertyOf = _basePropertyOf;

/** Used to map characters to HTML entities. */
var htmlEscapes = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;'
};

/**
 * Used by `_.escape` to convert characters to HTML entities.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */
var escapeHtmlChar$1 = basePropertyOf(htmlEscapes);

var _escapeHtmlChar = escapeHtmlChar$1;

var escapeHtmlChar = _escapeHtmlChar,
    toString$1 = toString_1;

/** Used to match HTML entities and HTML characters. */
var reUnescapedHtml = /[&<>"']/g,
    reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

/**
 * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
 * corresponding HTML entities.
 *
 * **Note:** No other characters are escaped. To escape additional
 * characters use a third-party library like [_he_](https://mths.be/he).
 *
 * Though the ">" character is escaped for symmetry, characters like
 * ">" and "/" don't need escaping in HTML and have no special meaning
 * unless they're part of a tag or unquoted attribute value. See
 * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
 * (under "semi-related fun fact") for more details.
 *
 * When working with HTML you should always
 * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
 * XSS vectors.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escape('fred, barney, & pebbles');
 * // => 'fred, barney, &amp; pebbles'
 */
function escape$1(string) {
  string = toString$1(string);
  return (string && reHasUnescapedHtml.test(string))
    ? string.replace(reUnescapedHtml, escapeHtmlChar)
    : string;
}

var _escape = escape$1;

/** Used to match template delimiters. */

var reEscape$1 = /<%-([\s\S]+?)%>/g;

var _reEscape = reEscape$1;

/** Used to match template delimiters. */

var reEvaluate$1 = /<%([\s\S]+?)%>/g;

var _reEvaluate = reEvaluate$1;

var escape = _escape,
    reEscape = _reEscape,
    reEvaluate = _reEvaluate,
    reInterpolate$1 = _reInterpolate;

/**
 * By default, the template delimiters used by lodash are like those in
 * embedded Ruby (ERB) as well as ES2015 template strings. Change the
 * following template settings to use alternative delimiters.
 *
 * @static
 * @memberOf _
 * @type {Object}
 */
var templateSettings$1 = {

  /**
   * Used to detect `data` property values to be HTML-escaped.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'escape': reEscape,

  /**
   * Used to detect code to be evaluated.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'evaluate': reEvaluate,

  /**
   * Used to detect `data` property values to inject.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'interpolate': reInterpolate$1,

  /**
   * Used to reference the data object in the template text.
   *
   * @memberOf _.templateSettings
   * @type {string}
   */
  'variable': '',

  /**
   * Used to import variables into the compiled template.
   *
   * @memberOf _.templateSettings
   * @type {Object}
   */
  'imports': {

    /**
     * A reference to the `lodash` function.
     *
     * @memberOf _.templateSettings.imports
     * @type {Function}
     */
    '_': { 'escape': escape }
  }
};

var templateSettings_1 = templateSettings$1;

var assignInWith = assignInWith_1,
    attempt = attempt_1,
    baseValues$1 = _baseValues,
    customDefaultsAssignIn = _customDefaultsAssignIn,
    escapeStringChar = _escapeStringChar,
    isError = isError_1,
    isIterateeCall$2 = _isIterateeCall,
    keys$4 = keys_1,
    reInterpolate = _reInterpolate,
    templateSettings = templateSettings_1,
    toString = toString_1;

/** Error message constants. */
var INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';

/** Used to match empty string literals in compiled template source. */
var reEmptyStringLeading = /\b__p \+= '';/g,
    reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
    reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

/**
 * Used to validate the `validate` option in `_.template` variable.
 *
 * Forbids characters which could potentially change the meaning of the function argument definition:
 * - "()," (modification of function parameters)
 * - "=" (default value)
 * - "[]{}" (destructuring of function parameters)
 * - "/" (beginning of a comment)
 * - whitespace
 */
var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;

/**
 * Used to match
 * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
 */
var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

/** Used to ensure capturing order of template delimiters. */
var reNoMatch = /($^)/;

/** Used to match unescaped characters in compiled string literals. */
var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

/** Used for built-in method references. */
var objectProto$5 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$5 = objectProto$5.hasOwnProperty;

/**
 * Creates a compiled template function that can interpolate data properties
 * in "interpolate" delimiters, HTML-escape interpolated data properties in
 * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
 * properties may be accessed as free variables in the template. If a setting
 * object is given, it takes precedence over `_.templateSettings` values.
 *
 * **Note:** In the development build `_.template` utilizes
 * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
 * for easier debugging.
 *
 * For more information on precompiling templates see
 * [lodash's custom builds documentation](https://lodash.com/custom-builds).
 *
 * For more information on Chrome extension sandboxes see
 * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The template string.
 * @param {Object} [options={}] The options object.
 * @param {RegExp} [options.escape=_.templateSettings.escape]
 *  The HTML "escape" delimiter.
 * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
 *  The "evaluate" delimiter.
 * @param {Object} [options.imports=_.templateSettings.imports]
 *  An object to import into the template as free variables.
 * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
 *  The "interpolate" delimiter.
 * @param {string} [options.sourceURL='templateSources[n]']
 *  The sourceURL of the compiled template.
 * @param {string} [options.variable='obj']
 *  The data object variable name.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Function} Returns the compiled template function.
 * @example
 *
 * // Use the "interpolate" delimiter to create a compiled template.
 * var compiled = _.template('hello <%= user %>!');
 * compiled({ 'user': 'fred' });
 * // => 'hello fred!'
 *
 * // Use the HTML "escape" delimiter to escape data property values.
 * var compiled = _.template('<b><%- value %></b>');
 * compiled({ 'value': '<script>' });
 * // => '<b>&lt;script&gt;</b>'
 *
 * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
 * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the internal `print` function in "evaluate" delimiters.
 * var compiled = _.template('<% print("hello " + user); %>!');
 * compiled({ 'user': 'barney' });
 * // => 'hello barney!'
 *
 * // Use the ES template literal delimiter as an "interpolate" delimiter.
 * // Disable support by replacing the "interpolate" delimiter.
 * var compiled = _.template('hello ${ user }!');
 * compiled({ 'user': 'pebbles' });
 * // => 'hello pebbles!'
 *
 * // Use backslashes to treat delimiters as plain text.
 * var compiled = _.template('<%= "\\<%- value %\\>" %>');
 * compiled({ 'value': 'ignored' });
 * // => '<%- value %>'
 *
 * // Use the `imports` option to import `jQuery` as `jq`.
 * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
 * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the `sourceURL` option to specify a custom sourceURL for the template.
 * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
 * compiled(data);
 * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
 *
 * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
 * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
 * compiled.source;
 * // => function(data) {
 * //   var __t, __p = '';
 * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
 * //   return __p;
 * // }
 *
 * // Use custom template delimiters.
 * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
 * var compiled = _.template('hello {{ user }}!');
 * compiled({ 'user': 'mustache' });
 * // => 'hello mustache!'
 *
 * // Use the `source` property to inline compiled templates for meaningful
 * // line numbers in error messages and stack traces.
 * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
 *   var JST = {\
 *     "main": ' + _.template(mainText).source + '\
 *   };\
 * ');
 */
function template$1(string, options, guard) {
  // Based on John Resig's `tmpl` implementation
  // (http://ejohn.org/blog/javascript-micro-templating/)
  // and Laura Doktorova's doT.js (https://github.com/olado/doT).
  var settings = templateSettings.imports._.templateSettings || templateSettings;

  if (guard && isIterateeCall$2(string, options, guard)) {
    options = undefined;
  }
  string = toString(string);
  options = assignInWith({}, options, settings, customDefaultsAssignIn);

  var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
      importsKeys = keys$4(imports),
      importsValues = baseValues$1(imports, importsKeys);

  var isEscaping,
      isEvaluating,
      index = 0,
      interpolate = options.interpolate || reNoMatch,
      source = "__p += '";

  // Compile the regexp to match each delimiter.
  var reDelimiters = RegExp(
    (options.escape || reNoMatch).source + '|' +
    interpolate.source + '|' +
    (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
    (options.evaluate || reNoMatch).source + '|$'
  , 'g');

  // Use a sourceURL for easier debugging.
  // The sourceURL gets injected into the source that's eval-ed, so be careful
  // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
  // and escape the comment, thus injecting code that gets evaled.
  var sourceURL = hasOwnProperty$5.call(options, 'sourceURL')
    ? ('//# sourceURL=' +
       (options.sourceURL + '').replace(/\s/g, ' ') +
       '\n')
    : '';

  string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
    interpolateValue || (interpolateValue = esTemplateValue);

    // Escape characters that can't be included in string literals.
    source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

    // Replace delimiters with snippets.
    if (escapeValue) {
      isEscaping = true;
      source += "' +\n__e(" + escapeValue + ") +\n'";
    }
    if (evaluateValue) {
      isEvaluating = true;
      source += "';\n" + evaluateValue + ";\n__p += '";
    }
    if (interpolateValue) {
      source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
    }
    index = offset + match.length;

    // The JS engine embedded in Adobe products needs `match` returned in
    // order to produce the correct `offset` value.
    return match;
  });

  source += "';\n";

  // If `variable` is not specified wrap a with-statement around the generated
  // code to add the data object to the top of the scope chain.
  var variable = hasOwnProperty$5.call(options, 'variable') && options.variable;
  if (!variable) {
    source = 'with (obj) {\n' + source + '\n}\n';
  }
  // Throw an error if a forbidden character was found in `variable`, to prevent
  // potential command injection attacks.
  else if (reForbiddenIdentifierChars.test(variable)) {
    throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
  }

  // Cleanup code by stripping empty strings.
  source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
    .replace(reEmptyStringMiddle, '$1')
    .replace(reEmptyStringTrailing, '$1;');

  // Frame code as the function body.
  source = 'function(' + (variable || 'obj') + ') {\n' +
    (variable
      ? ''
      : 'obj || (obj = {});\n'
    ) +
    "var __t, __p = ''" +
    (isEscaping
       ? ', __e = _.escape'
       : ''
    ) +
    (isEvaluating
      ? ', __j = Array.prototype.join;\n' +
        "function print() { __p += __j.call(arguments, '') }\n"
      : ';\n'
    ) +
    source +
    'return __p\n}';

  var result = attempt(function() {
    return Function(importsKeys, sourceURL + 'return ' + source)
      .apply(undefined, importsValues);
  });

  // Provide the compiled function's source by its `toString` method or
  // the `source` property as a convenience for inlining compiled templates.
  result.source = source;
  if (isError(result)) {
    throw result;
  }
  return result;
}

var template_1$1 = template$1;

var baseFlatten$1 = _baseFlatten;

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten$3(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten$1(array, 1) : [];
}

var flatten_1 = flatten$3;

const fs$3 = require$$1;
const flatten$2 = flatten_1;
const os$1 = require$$0$3;
const path$6 = require$$0$5;
const { promisify: promisify$1 } = require$$0$4;

// Promisify common fs functions.
const stat = promisify$1(fs$3.stat);
const readFile$2 = promisify$1(fs$3.readFile);
const writeFile$1 = promisify$1(fs$3.writeFile);
const readdir$1 = promisify$1(fs$3.readdir);
const mkdir = promisify$1(fs$3.mkdir);

function existsSync(path) {
  try {
    fs$3.accessSync(path);
    return true;
  } catch (e) {
    return false;
  }
}

/**
 * Creates a temporary directory and returns it path.
 *
 * @returns {Promise<string>}
 */
function createTemp() {
  return promisify$1(fs$3.mkdtemp)(`${os$1.tmpdir()}${path$6.sep}`);
}

/**
 * Ensures the given path exists.
 *  - If the path already exist, it's fine - it does nothing.
 *  - If the path doesn't exist, it will create it.
 *
 * @param {string} path
 * @returns {Promise}
 */
function ensureDirectoryExists$2(dir) {
  return stat(dir).catch(() => mkdir(dir, { recursive: true }));
}

/**
 * Read a directory,
 * sorting folders and files by alphabetically order.
 * Can be browsed recursively.
 *
 * @param {string} dir
 * The directory to analyse
 *
 * @param {boolean} recursive
 * Browse directory recursively
 *
 * @returns {Promise<[string]>}
 * All found files, concatenated to the current dir
 */
async function getFilepathsInFolder$1(dir, recursive = false) {
  const pathsList = await readdir$1(dir);
  return flatten$2(
    await Promise.all(
      pathsList.sort().map(async (currentPath) => {
        const currentFile = path$6.resolve(dir, currentPath);
        const statFile = await stat(currentFile);
        if (statFile && statFile.isDirectory()) {
          if (recursive) {
            return await getFilepathsInFolder$1(currentFile, true);
          }
          return [];
        }
        return [currentFile];
      })
    )
  );
}

var fs_1 = {
  existsSync,
  stat,
  readdir: readdir$1,
  readFile: readFile$2,
  writeFile: writeFile$1,
  createTemp,
  ensureDirectoryExists: ensureDirectoryExists$2,
  getFilepathsInFolder: getFilepathsInFolder$1,
};

const template = template_1$1;

const { readFile: readFile$1, writeFile } = fs_1;

/**
 * Light wrapper over lodash templates making it safer to be used with javascript source code.
 *
 * In particular, doesn't interfere with use of interpolated strings in javascript.
 *
 * @param {string} content Template source
 * @param {_.TemplateOptions} options Template options
 */
const jsSourceTemplate = (content, options) =>
  template(content, {
    interpolate: /<%=([\s\S]+?)%>/g,
    ...options,
  });

/**
 * Compile the contents of specified (javascript) file as a lodash template
 *
 * @param {string} filePath Path of file to be used as template
 * @param {_.TemplateOptions} options Lodash template options
 */
const jsFileTemplate = async (filePath, options) => {
  const contentBuffer = await readFile$1(filePath);
  return jsSourceTemplate(contentBuffer.toString(), options);
};

/**
 * Write a javascript file using another file as a (lodash) template
 *
 * @param {string} targetFilePath
 * @param {string} sourceFilePath
 * @param {_.TemplateOptions} options options passed to lodash templates
 */
const writeJsFileUsingTemplate$2 = async (
  targetFilePath,
  sourceFilePath,
  options,
  variables
) =>
  writeFile(
    targetFilePath,
    (await jsFileTemplate(sourceFilePath, options))(variables)
  );

var template_1 = {
  jsSourceTemplate,
  jsFileTemplate,
  writeJsFileUsingTemplate: writeJsFileUsingTemplate$2,
};

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */

function arraySome$1(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

var _arraySome = arraySome$1;

var SetCache = _SetCache,
    arraySome = _arraySome,
    cacheHas = _cacheHas;

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$5 = 1,
    COMPARE_UNORDERED_FLAG$3 = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays$2(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Check that cyclic values are equal.
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG$3) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

var _equalArrays = equalArrays$2;

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */

function mapToArray$2(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

var _mapToArray = mapToArray$2;

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */

function setToArray$2(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

var _setToArray = setToArray$2;

var Symbol$2 = _Symbol,
    Uint8Array$1 = _Uint8Array,
    eq$1 = eq_1,
    equalArrays$1 = _equalArrays,
    mapToArray$1 = _mapToArray,
    setToArray$1 = _setToArray;

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$4 = 1,
    COMPARE_UNORDERED_FLAG$2 = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag$1 = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag$1 = '[object Set]',
    stringTag$1 = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol$2 ? Symbol$2.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag$1(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq$1(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag$1:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag$1:
      var convert = mapToArray$1;

    case setTag$1:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert || (convert = setToArray$1);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$2;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays$1(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

var _equalByTag = equalByTag$1;

var getAllKeys = _getAllKeys;

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$3 = 1;

/** Used for built-in method references. */
var objectProto$4 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects$1(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty$4.call(other, key))) {
      return false;
    }
  }
  // Check that cyclic values are equal.
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

var _equalObjects = equalObjects$1;

var Stack$2 = _Stack,
    equalArrays = _equalArrays,
    equalByTag = _equalByTag,
    equalObjects = _equalObjects,
    getTag$1 = _getTag,
    isArray$b = isArray_1,
    isBuffer$2 = isBufferExports,
    isTypedArray$3 = isTypedArray_1;

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$2 = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto$3 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep$1(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$b(object),
      othIsArr = isArray$b(other),
      objTag = objIsArr ? arrayTag : getTag$1(object),
      othTag = othIsArr ? arrayTag : getTag$1(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer$2(object)) {
    if (!isBuffer$2(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack$2);
    return (objIsArr || isTypedArray$3(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty$3.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty$3.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack$2);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack$2);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

var _baseIsEqualDeep = baseIsEqualDeep$1;

var baseIsEqualDeep = _baseIsEqualDeep,
    isObjectLike$1 = isObjectLike_1;

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual$2(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike$1(value) && !isObjectLike$1(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$2, stack);
}

var _baseIsEqual = baseIsEqual$2;

var Stack$1 = _Stack,
    baseIsEqual$1 = _baseIsEqual;

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$1 = 1,
    COMPARE_UNORDERED_FLAG$1 = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch$1(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack$1;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual$1(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

var _baseIsMatch = baseIsMatch$1;

var isObject$b = isObject_1;

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable$2(value) {
  return value === value && !isObject$b(value);
}

var _isStrictComparable = isStrictComparable$2;

var isStrictComparable$1 = _isStrictComparable,
    keys$3 = keys_1;

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData$1(object) {
  var result = keys$3(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable$1(value)];
  }
  return result;
}

var _getMatchData = getMatchData$1;

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */

function matchesStrictComparable$2(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

var _matchesStrictComparable = matchesStrictComparable$2;

var baseIsMatch = _baseIsMatch,
    getMatchData = _getMatchData,
    matchesStrictComparable$1 = _matchesStrictComparable;

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches$1(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable$1(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

var _baseMatches = baseMatches$1;

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */

function baseHasIn$1(object, key) {
  return object != null && key in Object(object);
}

var _baseHasIn = baseHasIn$1;

var castPath$2 = _castPath,
    isArguments$1 = isArguments_1,
    isArray$a = isArray_1,
    isIndex$1 = _isIndex,
    isLength = isLength_1,
    toKey$3 = _toKey;

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath$2(object, path, hasFunc) {
  path = castPath$2(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey$3(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex$1(key, length) &&
    (isArray$a(object) || isArguments$1(object));
}

var _hasPath = hasPath$2;

var baseHasIn = _baseHasIn,
    hasPath$1 = _hasPath;

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn$1(object, path) {
  return object != null && hasPath$1(object, path, baseHasIn);
}

var hasIn_1 = hasIn$1;

var baseIsEqual = _baseIsEqual,
    get$1 = get_1,
    hasIn = hasIn_1,
    isKey$1 = _isKey,
    isStrictComparable = _isStrictComparable,
    matchesStrictComparable = _matchesStrictComparable,
    toKey$2 = _toKey;

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty$1(path, srcValue) {
  if (isKey$1(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey$2(path), srcValue);
  }
  return function(object) {
    var objValue = get$1(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

var _baseMatchesProperty = baseMatchesProperty$1;

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */

function baseProperty$1(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

var _baseProperty = baseProperty$1;

var baseGet$2 = _baseGet;

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep$1(path) {
  return function(object) {
    return baseGet$2(object, path);
  };
}

var _basePropertyDeep = basePropertyDeep$1;

var baseProperty = _baseProperty,
    basePropertyDeep = _basePropertyDeep,
    isKey = _isKey,
    toKey$1 = _toKey;

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property$1(path) {
  return isKey(path) ? baseProperty(toKey$1(path)) : basePropertyDeep(path);
}

var property_1 = property$1;

var baseMatches = _baseMatches,
    baseMatchesProperty = _baseMatchesProperty,
    identity$2 = identity_1,
    isArray$9 = isArray_1,
    property = property_1;

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee$8(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity$2;
  }
  if (typeof value == 'object') {
    return isArray$9(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

var _baseIteratee = baseIteratee$8;

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */

function createBaseFor$1(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

var _createBaseFor = createBaseFor$1;

var createBaseFor = _createBaseFor;

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor$2 = createBaseFor();

var _baseFor = baseFor$2;

var baseFor$1 = _baseFor,
    keys$2 = keys_1;

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn$2(object, iteratee) {
  return object && baseFor$1(object, iteratee, keys$2);
}

var _baseForOwn = baseForOwn$2;

var isArrayLike$4 = isArrayLike_1;

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach$1(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike$4(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

var _createBaseEach = createBaseEach$1;

var baseForOwn$1 = _baseForOwn,
    createBaseEach = _createBaseEach;

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach$5 = createBaseEach(baseForOwn$1);

var _baseEach = baseEach$5;

var baseEach$4 = _baseEach,
    isArrayLike$3 = isArrayLike_1;

/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function baseMap$2(collection, iteratee) {
  var index = -1,
      result = isArrayLike$3(collection) ? Array(collection.length) : [];

  baseEach$4(collection, function(value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

var _baseMap = baseMap$2;

/**
 * The base implementation of `_.sortBy` which uses `comparer` to define the
 * sort order of `array` and replaces criteria objects with their corresponding
 * values.
 *
 * @private
 * @param {Array} array The array to sort.
 * @param {Function} comparer The function to define sort order.
 * @returns {Array} Returns `array`.
 */

function baseSortBy$1(array, comparer) {
  var length = array.length;

  array.sort(comparer);
  while (length--) {
    array[length] = array[length].value;
  }
  return array;
}

var _baseSortBy = baseSortBy$1;

var isSymbol$1 = isSymbol_1;

/**
 * Compares values to sort them in ascending order.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {number} Returns the sort order indicator for `value`.
 */
function compareAscending$1(value, other) {
  if (value !== other) {
    var valIsDefined = value !== undefined,
        valIsNull = value === null,
        valIsReflexive = value === value,
        valIsSymbol = isSymbol$1(value);

    var othIsDefined = other !== undefined,
        othIsNull = other === null,
        othIsReflexive = other === other,
        othIsSymbol = isSymbol$1(other);

    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
        (valIsNull && othIsDefined && othIsReflexive) ||
        (!valIsDefined && othIsReflexive) ||
        !valIsReflexive) {
      return 1;
    }
    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
        (othIsNull && valIsDefined && valIsReflexive) ||
        (!othIsDefined && valIsReflexive) ||
        !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}

var _compareAscending = compareAscending$1;

var compareAscending = _compareAscending;

/**
 * Used by `_.orderBy` to compare multiple properties of a value to another
 * and stable sort them.
 *
 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
 * specify an order of "desc" for descending or "asc" for ascending sort order
 * of corresponding values.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {boolean[]|string[]} orders The order to sort by for each property.
 * @returns {number} Returns the sort order indicator for `object`.
 */
function compareMultiple$1(object, other, orders) {
  var index = -1,
      objCriteria = object.criteria,
      othCriteria = other.criteria,
      length = objCriteria.length,
      ordersLength = orders.length;

  while (++index < length) {
    var result = compareAscending(objCriteria[index], othCriteria[index]);
    if (result) {
      if (index >= ordersLength) {
        return result;
      }
      var order = orders[index];
      return result * (order == 'desc' ? -1 : 1);
    }
  }
  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
  // that causes it, under certain circumstances, to provide the same value for
  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
  // for more details.
  //
  // This also ensures a stable sort in V8 and other engines.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
  return object.index - other.index;
}

var _compareMultiple = compareMultiple$1;

var arrayMap$2 = _arrayMap,
    baseGet$1 = _baseGet,
    baseIteratee$7 = _baseIteratee,
    baseMap$1 = _baseMap,
    baseSortBy = _baseSortBy,
    baseUnary = _baseUnary,
    compareMultiple = _compareMultiple,
    identity$1 = identity_1,
    isArray$8 = isArray_1;

/**
 * The base implementation of `_.orderBy` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
 * @param {string[]} orders The sort orders of `iteratees`.
 * @returns {Array} Returns the new sorted array.
 */
function baseOrderBy$1(collection, iteratees, orders) {
  if (iteratees.length) {
    iteratees = arrayMap$2(iteratees, function(iteratee) {
      if (isArray$8(iteratee)) {
        return function(value) {
          return baseGet$1(value, iteratee.length === 1 ? iteratee[0] : iteratee);
        }
      }
      return iteratee;
    });
  } else {
    iteratees = [identity$1];
  }

  var index = -1;
  iteratees = arrayMap$2(iteratees, baseUnary(baseIteratee$7));

  var result = baseMap$1(collection, function(value, key, collection) {
    var criteria = arrayMap$2(iteratees, function(iteratee) {
      return iteratee(value);
    });
    return { 'criteria': criteria, 'index': ++index, 'value': value };
  });

  return baseSortBy(result, function(object, other) {
    return compareMultiple(object, other, orders);
  });
}

var _baseOrderBy = baseOrderBy$1;

var baseFlatten = _baseFlatten,
    baseOrderBy = _baseOrderBy,
    baseRest = _baseRest,
    isIterateeCall$1 = _isIterateeCall;

/**
 * Creates an array of elements, sorted in ascending order by the results of
 * running each element in a collection thru each iteratee. This method
 * performs a stable sort, that is, it preserves the original sort order of
 * equal elements. The iteratees are invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {...(Function|Function[])} [iteratees=[_.identity]]
 *  The iteratees to sort by.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * var users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 36 },
 *   { 'user': 'fred',   'age': 30 },
 *   { 'user': 'barney', 'age': 34 }
 * ];
 *
 * _.sortBy(users, [function(o) { return o.user; }]);
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
 *
 * _.sortBy(users, ['user', 'age']);
 * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
 */
var sortBy$1 = baseRest(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length = iteratees.length;
  if (length > 1 && isIterateeCall$1(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length > 2 && isIterateeCall$1(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
});

var sortBy_1 = sortBy$1;

function commonjsRequire(path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var getPackageTypeExports = {};
var getPackageType = {
  get exports(){ return getPackageTypeExports; },
  set exports(v){ getPackageTypeExports = v; },
};

var isNodeModules_1;
var hasRequiredIsNodeModules;

function requireIsNodeModules () {
	if (hasRequiredIsNodeModules) return isNodeModules_1;
	hasRequiredIsNodeModules = 1;

	const path = require$$0$5;

	function isNodeModules(directory) {
		let basename = path.basename(directory);
		/* istanbul ignore next: platform specific branch */
		if (path.sep === '\\') {
			basename = basename.toLowerCase();
		}

		return basename === 'node_modules';
	}

	isNodeModules_1 = isNodeModules;
	return isNodeModules_1;
}

var cache$1;
var hasRequiredCache;

function requireCache () {
	if (hasRequiredCache) return cache$1;
	hasRequiredCache = 1;

	cache$1 = new Map();
	return cache$1;
}

var async;
var hasRequiredAsync;

function requireAsync () {
	if (hasRequiredAsync) return async;
	hasRequiredAsync = 1;

	const path = require$$0$5;
	const {promisify} = require$$0$4;
	const readFile = promisify(require$$1.readFile);

	const isNodeModules = requireIsNodeModules();
	const resultsCache = requireCache();

	const promiseCache = new Map();

	async function getDirectoryTypeActual(directory) {
		if (isNodeModules(directory)) {
			return 'commonjs';
		}

		try {
			return JSON.parse(await readFile(path.resolve(directory, 'package.json'))).type || 'commonjs';
		} catch (_) {
		}

		const parent = path.dirname(directory);
		if (parent === directory) {
			return 'commonjs';
		}

		return getDirectoryType(parent);
	}

	async function getDirectoryType(directory) {
		if (resultsCache.has(directory)) {
			return resultsCache.get(directory);
		}

		if (promiseCache.has(directory)) {
			return promiseCache.get(directory);
		}

		const promise = getDirectoryTypeActual(directory);
		promiseCache.set(directory, promise);
		const result = await promise;
		resultsCache.set(directory, result);
		promiseCache.delete(directory);

		return result;
	}

	function getPackageType(filename) {
		return getDirectoryType(path.resolve(path.dirname(filename)));
	}

	async = getPackageType;
	return async;
}

var sync;
var hasRequiredSync;

function requireSync () {
	if (hasRequiredSync) return sync;
	hasRequiredSync = 1;

	const path = require$$0$5;
	const {readFileSync} = require$$1;

	const isNodeModules = requireIsNodeModules();
	const resultsCache = requireCache();

	function getDirectoryTypeActual(directory) {
		if (isNodeModules(directory)) {
			return 'commonjs';
		}

		try {
			return JSON.parse(readFileSync(path.resolve(directory, 'package.json'))).type || 'commonjs';
		} catch (_) {
		}

		const parent = path.dirname(directory);
		if (parent === directory) {
			return 'commonjs';
		}

		return getDirectoryType(parent);
	}

	function getDirectoryType(directory) {
		if (resultsCache.has(directory)) {
			return resultsCache.get(directory);
		}

		const result = getDirectoryTypeActual(directory);
		resultsCache.set(directory, result);

		return result;
	}

	function getPackageTypeSync(filename) {
		return getDirectoryType(path.resolve(path.dirname(filename)));
	}

	sync = getPackageTypeSync;
	return sync;
}

var hasRequiredGetPackageType;

function requireGetPackageType () {
	if (hasRequiredGetPackageType) return getPackageTypeExports;
	hasRequiredGetPackageType = 1;

	const getPackageType$1 = requireAsync();
	const getPackageTypeSync = requireSync();

	getPackageType.exports = filename => getPackageType$1(filename);
	getPackageTypeExports.sync = getPackageTypeSync;
	return getPackageTypeExports;
}

var isModuleType;
var hasRequiredIsModuleType;

function requireIsModuleType () {
	if (hasRequiredIsModuleType) return isModuleType;
	hasRequiredIsModuleType = 1;
	const getPackageType = requireGetPackageType();

	isModuleType = async function isModuleType(filepath) {
	  return (
	    filepath.endsWith('.mjs') ||
	    (!filepath.endsWith('.cjs') &&
	      (await getPackageType(filepath)) === 'module')
	  );
	};
	return isModuleType;
}

var importFile;
var hasRequiredImportFile;

function requireImportFile () {
	if (hasRequiredImportFile) return importFile;
	hasRequiredImportFile = 1;
	const isModuleType = requireIsModuleType();

	/**
	 * imports 'mjs', else requires.
	 * NOTE: require me late!
	 * @param {string} filepath
	 */
	importFile = async function importFile(filepath) {
	  return (await isModuleType(filepath))
	    ? import(require$$1$1.pathToFileURL(filepath))
	    : commonjsRequire(filepath);
	};
	return importFile;
}

const path$5 = require$$0$5;
const DEFAULT_LOAD_EXTENSIONS$2 = Object.freeze([
  '.co',
  '.coffee',
  '.eg',
  '.iced',
  '.js',
  '.cjs',
  '.litcoffee',
  '.ls',
  '.ts',
]);

let AbstractMigrationsLoader$2 = class AbstractMigrationsLoader {
  constructor(migrationDirectories, sortDirsSeparately, loadExtensions) {
    this.sortDirsSeparately = sortDirsSeparately;

    if (!Array.isArray(migrationDirectories)) {
      migrationDirectories = [migrationDirectories];
    }
    this.migrationsPaths = migrationDirectories;
    this.loadExtensions = loadExtensions || DEFAULT_LOAD_EXTENSIONS$2;
  }

  getFile(migrationsInfo) {
    const absoluteDir = path$5.resolve(process.cwd(), migrationsInfo.directory);
    const _path = path$5.join(absoluteDir, migrationsInfo.file);
    const importFile = requireImportFile(); // late import
    return importFile(_path);
  }
};

var MigrationsLoader = {
  DEFAULT_LOAD_EXTENSIONS: DEFAULT_LOAD_EXTENSIONS$2,
  AbstractMigrationsLoader: AbstractMigrationsLoader$2,
};

const path$4 = require$$0$5;
const sortBy = sortBy_1;

const { readdir } = fs_1;
const { AbstractMigrationsLoader: AbstractMigrationsLoader$1 } = MigrationsLoader;

let FsMigrations$1 = class FsMigrations extends AbstractMigrationsLoader$1 {
  /**
   * Gets the migration names
   * @returns Promise<string[]>
   */
  getMigrations(loadExtensions) {
    // Get a list of files in all specified migration directories
    const readMigrationsPromises = this.migrationsPaths.map((configDir) => {
      const absoluteDir = path$4.resolve(process.cwd(), configDir);
      return readdir(absoluteDir).then((files) => ({
        files,
        configDir,
        absoluteDir,
      }));
    });

    return Promise.all(readMigrationsPromises).then((allMigrations) => {
      const migrations = allMigrations.reduce((acc, migrationDirectory) => {
        // When true, files inside the folder should be sorted
        if (this.sortDirsSeparately) {
          migrationDirectory.files = migrationDirectory.files.sort();
        }

        migrationDirectory.files.forEach((file) =>
          acc.push({ file, directory: migrationDirectory.configDir })
        );

        return acc;
      }, []);

      // If true we have already sorted the migrations inside the folders
      // return the migrations fully qualified
      if (this.sortDirsSeparately) {
        return filterMigrations(
          this,
          migrations,
          loadExtensions || this.loadExtensions
        );
      }

      return filterMigrations(
        this,
        sortBy(migrations, 'file'),
        loadExtensions || this.loadExtensions
      );
    });
  }

  getMigrationName(migration) {
    return migration.file;
  }

  getMigration(migrationInfo) {
    return this.getFile(migrationInfo);
  }
};

function filterMigrations(migrationSource, migrations, loadExtensions) {
  return migrations.filter((migration) => {
    const migrationName = migrationSource.getMigrationName(migration);
    const extension = path$4.extname(migrationName);
    return loadExtensions.includes(extension);
  });
}

var fsMigrations = {
  FsMigrations: FsMigrations$1,
};

var colorette = {};

Object.defineProperty(colorette, '__esModule', { value: true });

var tty = require$$0$2;

function _interopNamespace$1(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var tty__namespace = /*#__PURE__*/_interopNamespace$1(tty);

const {
  env = {},
  argv = [],
  platform = "",
} = typeof process === "undefined" ? {} : process;

const isDisabled = "NO_COLOR" in env || argv.includes("--no-color");
const isForced = "FORCE_COLOR" in env || argv.includes("--color");
const isWindows = platform === "win32";
const isDumbTerminal = env.TERM === "dumb";

const isCompatibleTerminal =
  tty__namespace && tty__namespace.isatty && tty__namespace.isatty(1) && env.TERM && !isDumbTerminal;

const isCI =
  "CI" in env &&
  ("GITHUB_ACTIONS" in env || "GITLAB_CI" in env || "CIRCLECI" in env);

const isColorSupported =
  !isDisabled &&
  (isForced || (isWindows && !isDumbTerminal) || isCompatibleTerminal || isCI);

const replaceClose = (
  index,
  string,
  close,
  replace,
  head = string.substring(0, index) + replace,
  tail = string.substring(index + close.length),
  next = tail.indexOf(close)
) => head + (next < 0 ? tail : replaceClose(next, tail, close, replace));

const clearBleed = (index, string, open, close, replace) =>
  index < 0
    ? open + string + close
    : open + replaceClose(index, string, close, replace) + close;

const filterEmpty =
  (open, close, replace = open, at = open.length + 1) =>
  (string) =>
    string || !(string === "" || string === undefined)
      ? clearBleed(
          ("" + string).indexOf(close, at),
          string,
          open,
          close,
          replace
        )
      : "";

const init$1 = (open, close, replace) =>
  filterEmpty(`\x1b[${open}m`, `\x1b[${close}m`, replace);

const colors = {
  reset: init$1(0, 0),
  bold: init$1(1, 22, "\x1b[22m\x1b[1m"),
  dim: init$1(2, 22, "\x1b[22m\x1b[2m"),
  italic: init$1(3, 23),
  underline: init$1(4, 24),
  inverse: init$1(7, 27),
  hidden: init$1(8, 28),
  strikethrough: init$1(9, 29),
  black: init$1(30, 39),
  red: init$1(31, 39),
  green: init$1(32, 39),
  yellow: init$1(33, 39),
  blue: init$1(34, 39),
  magenta: init$1(35, 39),
  cyan: init$1(36, 39),
  white: init$1(37, 39),
  gray: init$1(90, 39),
  bgBlack: init$1(40, 49),
  bgRed: init$1(41, 49),
  bgGreen: init$1(42, 49),
  bgYellow: init$1(43, 49),
  bgBlue: init$1(44, 49),
  bgMagenta: init$1(45, 49),
  bgCyan: init$1(46, 49),
  bgWhite: init$1(47, 49),
  blackBright: init$1(90, 39),
  redBright: init$1(91, 39),
  greenBright: init$1(92, 39),
  yellowBright: init$1(93, 39),
  blueBright: init$1(94, 39),
  magentaBright: init$1(95, 39),
  cyanBright: init$1(96, 39),
  whiteBright: init$1(97, 39),
  bgBlackBright: init$1(100, 49),
  bgRedBright: init$1(101, 49),
  bgGreenBright: init$1(102, 49),
  bgYellowBright: init$1(103, 49),
  bgBlueBright: init$1(104, 49),
  bgMagentaBright: init$1(105, 49),
  bgCyanBright: init$1(106, 49),
  bgWhiteBright: init$1(107, 49),
};

const createColors = ({ useColor = isColorSupported } = {}) =>
  useColor
    ? colors
    : Object.keys(colors).reduce(
        (colors, key) => ({ ...colors, [key]: String }),
        {}
      );

const {
  reset,
  bold,
  dim,
  italic,
  underline,
  inverse,
  hidden,
  strikethrough,
  black,
  red,
  green,
  yellow,
  blue,
  magenta,
  cyan,
  white,
  gray,
  bgBlack,
  bgRed,
  bgGreen,
  bgYellow,
  bgBlue,
  bgMagenta,
  bgCyan,
  bgWhite,
  blackBright,
  redBright,
  greenBright,
  yellowBright,
  blueBright,
  magentaBright,
  cyanBright,
  whiteBright,
  bgBlackBright,
  bgRedBright,
  bgGreenBright,
  bgYellowBright,
  bgBlueBright,
  bgMagentaBright,
  bgCyanBright,
  bgWhiteBright,
} = createColors();

colorette.bgBlack = bgBlack;
colorette.bgBlackBright = bgBlackBright;
colorette.bgBlue = bgBlue;
colorette.bgBlueBright = bgBlueBright;
colorette.bgCyan = bgCyan;
colorette.bgCyanBright = bgCyanBright;
colorette.bgGreen = bgGreen;
colorette.bgGreenBright = bgGreenBright;
colorette.bgMagenta = bgMagenta;
colorette.bgMagentaBright = bgMagentaBright;
colorette.bgRed = bgRed;
colorette.bgRedBright = bgRedBright;
colorette.bgWhite = bgWhite;
colorette.bgWhiteBright = bgWhiteBright;
colorette.bgYellow = bgYellow;
colorette.bgYellowBright = bgYellowBright;
colorette.black = black;
colorette.blackBright = blackBright;
colorette.blue = blue;
colorette.blueBright = blueBright;
colorette.bold = bold;
colorette.createColors = createColors;
colorette.cyan = cyan;
colorette.cyanBright = cyanBright;
colorette.dim = dim;
colorette.gray = gray;
colorette.green = green;
colorette.greenBright = greenBright;
colorette.hidden = hidden;
colorette.inverse = inverse;
colorette.isColorSupported = isColorSupported;
colorette.italic = italic;
colorette.magenta = magenta;
colorette.magentaBright = magentaBright;
colorette.red = red;
colorette.redBright = redBright;
colorette.reset = reset;
colorette.strikethrough = strikethrough;
colorette.underline = underline;
colorette.white = white;
colorette.whiteBright = whiteBright;
colorette.yellow = yellow;
colorette.yellowBright = yellowBright;

function isString$a(value) {
  return typeof value === 'string';
}

function isNumber$3(value) {
  return typeof value === 'number';
}

function isBoolean$2(value) {
  return typeof value === 'boolean';
}

function isUndefined$1(value) {
  return typeof value === 'undefined';
}

function isObject$a(value) {
  return typeof value === 'object' && value !== null;
}

function isFunction$7(value) {
  return typeof value === 'function';
}

var is = {
  isString: isString$a,
  isNumber: isNumber$3,
  isBoolean: isBoolean$2,
  isUndefined: isUndefined$1,
  isObject: isObject$a,
  isFunction: isFunction$7,
};

const color = colorette;
const { inspect } = require$$0$4;
const { isString: isString$9, isFunction: isFunction$6 } = is;

let Logger$3 = class Logger {
  constructor(config = {}) {
    const {
      log: {
        debug,
        warn,
        error,
        deprecate,
        inspectionDepth,
        enableColors,
      } = {},
    } = config;
    this._inspectionDepth = inspectionDepth || 5;
    this._enableColors = resolveIsEnabledColors(enableColors);
    this._debug = debug;
    this._warn = warn;
    this._error = error;
    this._deprecate = deprecate;
  }

  _log(message, userFn, colorFn) {
    if (userFn != null && !isFunction$6(userFn)) {
      throw new TypeError('Extensions to knex logger must be functions!');
    }

    if (isFunction$6(userFn)) {
      userFn(message);
      return;
    }

    if (!isString$9(message)) {
      message = inspect(message, {
        depth: this._inspectionDepth,
        colors: this._enableColors,
      });
    }

    console.log(colorFn ? colorFn(message) : message);
  }

  debug(message) {
    this._log(message, this._debug);
  }

  warn(message) {
    this._log(message, this._warn, color.yellow);
  }

  error(message) {
    this._log(message, this._error, color.red);
  }

  deprecate(method, alternative) {
    const message = `${method} is deprecated, please use ${alternative}`;

    this._log(message, this._deprecate, color.yellow);
  }
};

function resolveIsEnabledColors(enableColorsParam) {
  if (enableColorsParam != null) {
    return enableColorsParam;
  }

  if (process && process.stdout) {
    return process.stdout.isTTY;
  }

  return false;
}

var logger = Logger$3;

const { FsMigrations } = fsMigrations;
const Logger$2 = logger;
const { DEFAULT_LOAD_EXTENSIONS: DEFAULT_LOAD_EXTENSIONS$1 } = MigrationsLoader;
const defaultLogger$1 = new Logger$2();

const CONFIG_DEFAULT$1 = Object.freeze({
  extension: 'js',
  loadExtensions: DEFAULT_LOAD_EXTENSIONS$1,
  tableName: 'knex_migrations',
  schemaName: null,
  directory: './migrations',
  disableTransactions: false,
  disableMigrationsListValidation: false,
  sortDirsSeparately: false,
});

function getMergedConfig$4(config, currentConfig, logger = defaultLogger$1) {
  // config is the user specified config, mergedConfig has defaults and current config
  // applied to it.
  const mergedConfig = Object.assign(
    {},
    CONFIG_DEFAULT$1,
    currentConfig || {},
    config
  );

  if (
    config &&
    // If user specifies any FS related config,
    // clear specified migrationSource to avoid ambiguity
    (config.directory ||
      config.sortDirsSeparately !== undefined ||
      config.loadExtensions)
  ) {
    if (config.migrationSource) {
      logger.warn(
        'FS-related option specified for migration configuration. This resets migrationSource to default FsMigrations'
      );
    }
    mergedConfig.migrationSource = null;
  }

  // If the user has not specified any configs, we need to
  // default to fs migrations to maintain compatibility
  if (!mergedConfig.migrationSource) {
    mergedConfig.migrationSource = new FsMigrations(
      mergedConfig.directory,
      mergedConfig.sortDirsSeparately,
      mergedConfig.loadExtensions
    );
  }

  return mergedConfig;
}

var migratorConfigurationMerger = {
  getMergedConfig: getMergedConfig$4,
};

function yyyymmddhhmmss$2() {
  const now = new Date();

  return (
    now.getUTCFullYear().toString() +
    (now.getUTCMonth() + 1).toString().padStart(2, '0') +
    now.getUTCDate().toString().padStart(2, '0') +
    now.getUTCHours().toString().padStart(2, '0') +
    now.getUTCMinutes().toString().padStart(2, '0') +
    now.getUTCSeconds().toString().padStart(2, '0')
  );
}

var timestamp = { yyyymmddhhmmss: yyyymmddhhmmss$2 };

const path$3 = require$$0$5;
const { writeJsFileUsingTemplate: writeJsFileUsingTemplate$1 } = template_1;
const { getMergedConfig: getMergedConfig$3 } = migratorConfigurationMerger;
const { ensureDirectoryExists: ensureDirectoryExists$1 } = fs_1;
const { yyyymmddhhmmss: yyyymmddhhmmss$1 } = timestamp;

let MigrationGenerator$1 = class MigrationGenerator {
  constructor(migrationConfig, logger) {
    this.config = getMergedConfig$3(migrationConfig, undefined, logger);
  }

  // Creates a new migration, with a given name.
  async make(name, config, logger) {
    this.config = getMergedConfig$3(config, this.config, logger);
    if (!name) {
      return Promise.reject(
        new Error('A name must be specified for the generated migration')
      );
    }
    await this._ensureFolder();
    const createdMigrationFilePath = await this._writeNewMigration(name);
    return createdMigrationFilePath;
  }

  // Ensures a folder for the migrations exist, dependent on the migration
  // config settings.
  _ensureFolder() {
    const dirs = this._absoluteConfigDirs();

    const promises = dirs.map(ensureDirectoryExists$1);

    return Promise.all(promises);
  }

  _getStubPath() {
    return (
      this.config.stub ||
      path$3.join(__dirname, 'stub', this.config.extension + '.stub')
    );
  }

  _getNewMigrationName(name) {
    if (name[0] === '-') name = name.slice(1);
    return (
      yyyymmddhhmmss$1() + '_' + name + '.' + this.config.extension.split('-')[0]
    );
  }

  _getNewMigrationPath(name) {
    const fileName = this._getNewMigrationName(name);
    const dirs = this._absoluteConfigDirs();
    const dir = dirs.slice(-1)[0]; // Get last specified directory
    return path$3.join(dir, fileName);
  }

  // Write a new migration to disk, using the config and generated filename,
  // passing any `variables` given in the config to the template.
  async _writeNewMigration(name) {
    const migrationPath = this._getNewMigrationPath(name);
    await writeJsFileUsingTemplate$1(
      migrationPath,
      this._getStubPath(),
      { variable: 'd' },
      this.config.variables || {}
    );
    return migrationPath;
  }

  _absoluteConfigDirs() {
    const directories = Array.isArray(this.config.directory)
      ? this.config.directory
      : [this.config.directory];
    return directories.map((directory) => {
      if (!directory) {
        console.warn(
          'Failed to resolve config file, knex cannot determine where to generate migrations'
        );
      }
      return path$3.resolve(process.cwd(), directory);
    });
  }
};

var MigrationGenerator_1 = MigrationGenerator$1;

// Migrator
// -------
const differenceWith = differenceWith_1;
const get = get_1;
const isEmpty$4 = isEmpty_1;
const max = max_1;
const {
  getLockTableName,
  getTable,
  getTableName,
} = tableResolver;
const { getSchemaBuilder } = tableCreator;
const migrationListResolver = migrationListResolver$1;
const MigrationGenerator = MigrationGenerator_1;
const { getMergedConfig: getMergedConfig$2 } = migratorConfigurationMerger;
const { isBoolean: isBoolean$1, isFunction: isFunction$5 } = is;

class LockError extends Error {
  constructor(msg) {
    super(msg);
    this.name = 'MigrationLocked';
  }
}

// The new migration we're performing, typically called from the `knex.migrate`
// interface on the main `knex` object. Passes the `knex` instance performing
// the migration.
let Migrator$1 = class Migrator {
  constructor(knex) {
    // Clone knex instance and remove post-processing that is unnecessary for internal queries from a cloned config
    if (isFunction$5(knex)) {
      if (!knex.isTransaction) {
        this.knex = knex.withUserParams({
          ...knex.userParams,
        });
      } else {
        this.knex = knex;
      }
    } else {
      this.knex = Object.assign({}, knex);
      this.knex.userParams = this.knex.userParams || {};
    }

    this.config = getMergedConfig$2(
      this.knex.client.config.migrations,
      undefined,
      this.knex.client.logger
    );
    this.generator = new MigrationGenerator(
      this.knex.client.config.migrations,
      this.knex.client.logger
    );
    this._activeMigration = {
      fileName: null,
    };
  }

  // Migrators to the latest configuration.
  async latest(config) {
    this._disableProcessing();
    this.config = getMergedConfig$2(config, this.config, this.knex.client.logger);

    const allAndCompleted = await migrationListResolver.listAllAndCompleted(
      this.config,
      this.knex
    );

    if (!this.config.disableMigrationsListValidation) {
      validateMigrationList(this.config.migrationSource, allAndCompleted);
    }

    const [all, completed] = allAndCompleted;

    const migrations = getNewMigrations(
      this.config.migrationSource,
      all,
      completed
    );

    const transactionForAll =
      !this.config.disableTransactions &&
      !(
        await Promise.all(
          migrations.map(async (migration) => {
            const migrationContents =
              await this.config.migrationSource.getMigration(migration);
            return !this._useTransaction(migrationContents);
          })
        )
      ).some((isTransactionUsed) => isTransactionUsed);

    if (transactionForAll) {
      return this.knex.transaction((trx) => {
        return this._runBatch(migrations, 'up', trx);
      });
    } else {
      return this._runBatch(migrations, 'up');
    }
  }

  // Runs the next migration that has not yet been run
  async up(config) {
    this._disableProcessing();
    this.config = getMergedConfig$2(config, this.config, this.knex.client.logger);

    const allAndCompleted = await migrationListResolver.listAllAndCompleted(
      this.config,
      this.knex
    );

    if (!this.config.disableMigrationsListValidation) {
      validateMigrationList(this.config.migrationSource, allAndCompleted);
    }
    const [all, completed] = allAndCompleted;

    const newMigrations = getNewMigrations(
      this.config.migrationSource,
      all,
      completed
    );

    let migrationToRun;
    const name = this.config.name;
    if (name) {
      if (!completed.includes(name)) {
        migrationToRun = newMigrations.find((migration) => {
          return (
            this.config.migrationSource.getMigrationName(migration) === name
          );
        });
        if (!migrationToRun) {
          throw new Error(`Migration "${name}" not found.`);
        }
      }
    } else {
      migrationToRun = newMigrations[0];
    }

    const useTransaction =
      !migrationToRun ||
      this._useTransaction(
        await this.config.migrationSource.getMigration(migrationToRun)
      );

    const migrationsToRun = [];
    if (migrationToRun) {
      migrationsToRun.push(migrationToRun);
    }

    const transactionForAll =
      !this.config.disableTransactions && (!migrationToRun || useTransaction);

    if (transactionForAll) {
      return await this.knex.transaction((trx) => {
        return this._runBatch(migrationsToRun, 'up', trx);
      });
    } else {
      return await this._runBatch(migrationsToRun, 'up');
    }
  }

  // Rollback the last "batch", or all, of migrations that were run.
  rollback(config, all = false) {
    this._disableProcessing();
    return new Promise((resolve, reject) => {
      try {
        this.config = getMergedConfig$2(
          config,
          this.config,
          this.knex.client.logger
        );
      } catch (e) {
        reject(e);
      }
      migrationListResolver
        .listAllAndCompleted(this.config, this.knex)
        .then((value) => {
          if (!this.config.disableMigrationsListValidation) {
            validateMigrationList(this.config.migrationSource, value);
          }
          return value;
        })
        .then((val) => {
          const [allMigrations, completedMigrations] = val;

          return all
            ? allMigrations
                .filter((migration) => {
                  return completedMigrations
                    .map((migration) => migration.name)
                    .includes(
                      this.config.migrationSource.getMigrationName(migration)
                    );
                })
                .reverse()
            : this._getLastBatch(val);
        })
        .then((migrations) => {
          return this._runBatch(migrations, 'down');
        })
        .then(resolve, reject);
    });
  }

  down(config) {
    this._disableProcessing();
    this.config = getMergedConfig$2(config, this.config, this.knex.client.logger);

    return migrationListResolver
      .listAllAndCompleted(this.config, this.knex)
      .then((value) => {
        if (!this.config.disableMigrationsListValidation) {
          validateMigrationList(this.config.migrationSource, value);
        }
        return value;
      })
      .then(([all, completed]) => {
        const completedMigrations = all.filter((migration) => {
          return completed
            .map((migration) => migration.name)
            .includes(this.config.migrationSource.getMigrationName(migration));
        });

        let migrationToRun;
        const name = this.config.name;
        if (name) {
          migrationToRun = completedMigrations.find((migration) => {
            return (
              this.config.migrationSource.getMigrationName(migration) === name
            );
          });
          if (!migrationToRun) {
            throw new Error(`Migration "${name}" was not run.`);
          }
        } else {
          migrationToRun = completedMigrations[completedMigrations.length - 1];
        }

        const migrationsToRun = [];
        if (migrationToRun) {
          migrationsToRun.push(migrationToRun);
        }

        return this._runBatch(migrationsToRun, 'down');
      });
  }

  status(config) {
    this._disableProcessing();
    this.config = getMergedConfig$2(config, this.config, this.knex.client.logger);

    return Promise.all([
      getTable(this.knex, this.config.tableName, this.config.schemaName).select(
        '*'
      ),
      migrationListResolver.listAll(this.config.migrationSource),
    ]).then(([db, code]) => db.length - code.length);
  }

  // Retrieves and returns the current migration version we're on, as a promise.
  // If no migrations have been run yet, return "none".
  currentVersion(config) {
    this._disableProcessing();
    this.config = getMergedConfig$2(config, this.config, this.knex.client.logger);

    return migrationListResolver
      .listCompleted(this.config.tableName, this.config.schemaName, this.knex)
      .then((completed) => {
        const val = max(completed.map((value) => value.name.split('_')[0]));
        return val === undefined ? 'none' : val;
      });
  }

  // list all migrations
  async list(config) {
    this._disableProcessing();
    this.config = getMergedConfig$2(config, this.config, this.knex.client.logger);

    const [all, completed] = await migrationListResolver.listAllAndCompleted(
      this.config,
      this.knex
    );

    if (!this.config.disableMigrationsListValidation) {
      validateMigrationList(this.config.migrationSource, [all, completed]);
    }

    const newMigrations = getNewMigrations(
      this.config.migrationSource,
      all,
      completed
    );
    return [completed, newMigrations];
  }

  async forceFreeMigrationsLock(config) {
    this.config = getMergedConfig$2(config, this.config, this.knex.client.logger);
    const { schemaName, tableName } = this.config;
    const lockTableName = getLockTableName(tableName);
    const { knex } = this;
    const getLockTable = () => getTable(knex, lockTableName, schemaName);
    const tableExists = await getSchemaBuilder(knex, schemaName).hasTable(
      lockTableName
    );
    if (tableExists) {
      await getLockTable().del();
      await getLockTable().insert({
        is_locked: 0,
      });
    }
  }

  // Creates a new migration, with a given name.
  make(name, config) {
    return this.generator.make(name, config, this.knex.client.logger);
  }

  _disableProcessing() {
    if (this.knex.disableProcessing) {
      this.knex.disableProcessing();
    }
  }

  _lockMigrations(trx) {
    const tableName = getLockTableName(this.config.tableName);
    return getTable(this.knex, tableName, this.config.schemaName)
      .transacting(trx)
      .where('is_locked', '=', 0)
      .update({ is_locked: 1 })
      .then((rowCount) => {
        if (rowCount !== 1) {
          throw new Error('Migration table is already locked');
        }
      });
  }

  _getLock(trx) {
    const transact = trx ? (fn) => fn(trx) : (fn) => this.knex.transaction(fn);
    return transact((trx) => {
      return this._lockMigrations(trx);
    }).catch((err) => {
      throw new LockError(err.message);
    });
  }

  _freeLock(trx = this.knex) {
    const tableName = getLockTableName(this.config.tableName);
    return getTable(trx, tableName, this.config.schemaName).update({
      is_locked: 0,
    });
  }

  // Run a batch of current migrations, in sequence.
  async _runBatch(migrations, direction, trx) {
    const canGetLockInTransaction =
      this.knex.client.driverName !== 'cockroachdb';
    try {
      await this._getLock(canGetLockInTransaction ? trx : undefined);
      // When there is a wrapping transaction, some migrations
      // could have been done while waiting for the lock:
      const completed = trx
        ? await migrationListResolver.listCompleted(
            this.config.tableName,
            this.config.schemaName,
            trx
          )
        : [];

      migrations = getNewMigrations(
        this.config.migrationSource,
        migrations,
        completed
      );

      await Promise.all(
        migrations.map(this._validateMigrationStructure.bind(this))
      );

      let batchNo = await this._latestBatchNumber(trx);
      if (direction === 'up') batchNo++;
      const res = await this._waterfallBatch(
        batchNo,
        migrations,
        direction,
        trx
      );
      await this._freeLock(canGetLockInTransaction ? trx : undefined);
      return res;
    } catch (error) {
      let cleanupReady = Promise.resolve();

      if (error instanceof LockError) {
        // If locking error do not free the lock.
        this.knex.client.logger.warn(
          `Can't take lock to run migrations: ${error.message}`
        );
        this.knex.client.logger.warn(
          'If you are sure migrations are not running you can release the ' +
            "lock manually by running 'knex migrate:unlock'"
        );
      } else {
        if (this._activeMigration.fileName) {
          this.knex.client.logger.warn(
            `migration file "${this._activeMigration.fileName}" failed`
          );
        }
        this.knex.client.logger.warn(
          `migration failed with error: ${error.message}`
        );
        // If the error was not due to a locking issue, then remove the lock.
        cleanupReady = this._freeLock(
          canGetLockInTransaction ? trx : undefined
        );
      }

      try {
        await cleanupReady;
        // eslint-disable-next-line no-empty
      } catch (e) {}
      throw error;
    }
  }

  // Validates some migrations by requiring and checking for an `up` and `down`
  // function.
  async _validateMigrationStructure(migration) {
    const migrationName =
      this.config.migrationSource.getMigrationName(migration);
    // maybe promise
    const migrationContent = await this.config.migrationSource.getMigration(
      migration
    );
    if (
      typeof migrationContent.up !== 'function' ||
      typeof migrationContent.down !== 'function'
    ) {
      throw new Error(
        `Invalid migration: ${migrationName} must have both an up and down function`
      );
    }

    return migration;
  }

  // Get the last batch of migrations, by name, ordered by insert id in reverse
  // order.
  async _getLastBatch([allMigrations]) {
    const { tableName, schemaName } = this.config;
    const migrationNames = await getTable(this.knex, tableName, schemaName)
      .where('batch', function (qb) {
        qb.max('batch').from(getTableName(tableName, schemaName));
      })
      .orderBy('id', 'desc');

    const lastBatchMigrations = migrationNames.map((migration) => {
      return allMigrations.find((entry) => {
        return (
          this.config.migrationSource.getMigrationName(entry) === migration.name
        );
      });
    });
    return Promise.all(lastBatchMigrations);
  }

  // Returns the latest batch number.
  _latestBatchNumber(trx = this.knex) {
    return trx
      .from(getTableName(this.config.tableName, this.config.schemaName))
      .max('batch as max_batch')
      .then((obj) => obj[0].max_batch || 0);
  }

  // If transaction config for a single migration is defined, use that.
  // Otherwise, rely on the common config. This allows enabling/disabling
  // transaction for a single migration at will, regardless of the common
  // config.
  _useTransaction(migrationContent, allTransactionsDisabled) {
    const singleTransactionValue = get(migrationContent, 'config.transaction');

    return isBoolean$1(singleTransactionValue)
      ? singleTransactionValue
      : !allTransactionsDisabled;
  }

  // Runs a batch of `migrations` in a specified `direction`, saving the
  // appropriate database information as the migrations are run.
  _waterfallBatch(batchNo, migrations, direction, trx) {
    const trxOrKnex = trx || this.knex;
    const { tableName, schemaName, disableTransactions } = this.config;
    let current = Promise.resolve();
    const log = [];
    migrations.forEach((migration) => {
      const name = this.config.migrationSource.getMigrationName(migration);
      this._activeMigration.fileName = name;
      const migrationContent =
        this.config.migrationSource.getMigration(migration);

      // We're going to run each of the migrations in the current "up".
      current = current
        .then(async () => await migrationContent) //maybe promise
        .then((migrationContent) => {
          this._activeMigration.fileName = name;
          if (
            !trx &&
            this._useTransaction(migrationContent, disableTransactions)
          ) {
            this.knex.enableProcessing();
            return this._transaction(
              this.knex,
              migrationContent,
              direction,
              name
            );
          }

          trxOrKnex.enableProcessing();
          return checkPromise(
            this.knex.client.logger,
            migrationContent[direction](trxOrKnex),
            name
          );
        })
        .then(() => {
          trxOrKnex.disableProcessing();
          this.knex.disableProcessing();
          log.push(name);
          if (direction === 'up') {
            return trxOrKnex.into(getTableName(tableName, schemaName)).insert({
              name,
              batch: batchNo,
              migration_time: new Date(),
            });
          }
          if (direction === 'down') {
            return trxOrKnex
              .from(getTableName(tableName, schemaName))
              .where({ name })
              .del();
          }
        });
    });

    return current.then(() => [batchNo, log]);
  }

  _transaction(knex, migrationContent, direction, name) {
    return knex.transaction((trx) => {
      return checkPromise(
        knex.client.logger,
        migrationContent[direction](trx),
        name,
        () => {
          trx.commit();
        }
      );
    });
  }
};

// Validates that migrations are present in the appropriate directories.
function validateMigrationList(migrationSource, migrations) {
  const [all, completed] = migrations;
  const diff = getMissingMigrations(migrationSource, completed, all);
  if (!isEmpty$4(diff)) {
    const names = diff.map((d) => d.name);
    throw new Error(
      `The migration directory is corrupt, the following files are missing: ${names.join(
        ', '
      )}`
    );
  }
}

function getMissingMigrations(migrationSource, completed, all) {
  return differenceWith(completed, all, (c, a) => {
    return c.name === migrationSource.getMigrationName(a);
  });
}

function getNewMigrations(migrationSource, all, completed) {
  return differenceWith(all, completed, (a, c) => {
    return c.name === migrationSource.getMigrationName(a);
  });
}

function checkPromise(logger, migrationPromise, name, commitFn) {
  if (!migrationPromise || typeof migrationPromise.then !== 'function') {
    logger.warn(`migration ${name} did not return a promise`);
    if (commitFn) {
      commitFn();
    }
  }
  return migrationPromise;
}

var Migrator_1 = {
  Migrator: Migrator$1,
};

var baseGetTag = _baseGetTag,
    isArray$7 = isArray_1,
    isObjectLike = isObjectLike_1;

/** `Object#toString` result references. */
var stringTag = '[object String]';

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString$8(value) {
  return typeof value == 'string' ||
    (!isArray$7(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
}

var isString_1 = isString$8;

/** Used to match a single whitespace character. */

var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex$1(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

var _trimmedEndIndex = trimmedEndIndex$1;

var trimmedEndIndex = _trimmedEndIndex;

/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim$1(string) {
  return string
    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
    : string;
}

var _baseTrim = baseTrim$1;

var baseTrim = _baseTrim,
    isObject$9 = isObject_1,
    isSymbol = isSymbol_1;

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber$3(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject$9(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject$9(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

var toNumber_1 = toNumber$3;

var toNumber$2 = toNumber_1;

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite$1(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber$2(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

var toFinite_1 = toFinite$1;

var toFinite = toFinite_1;

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger$3(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

var toInteger_1 = toInteger$3;

var baseValues = _baseValues,
    keys$1 = keys_1;

/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
function values$2(object) {
  return object == null ? [] : baseValues(object, keys$1(object));
}

var values_1 = values$2;

var baseIndexOf$1 = _baseIndexOf,
    isArrayLike$2 = isArrayLike_1,
    isString$7 = isString_1,
    toInteger$2 = toInteger_1,
    values$1 = values_1;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$2 = Math.max;

/**
 * Checks if `value` is in `collection`. If `collection` is a string, it's
 * checked for a substring of `value`, otherwise
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * is used for equality comparisons. If `fromIndex` is negative, it's used as
 * the offset from the end of `collection`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object|string} collection The collection to inspect.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
 * @returns {boolean} Returns `true` if `value` is found, else `false`.
 * @example
 *
 * _.includes([1, 2, 3], 1);
 * // => true
 *
 * _.includes([1, 2, 3], 1, 2);
 * // => false
 *
 * _.includes({ 'a': 1, 'b': 2 }, 1);
 * // => true
 *
 * _.includes('abcd', 'bc');
 * // => true
 */
function includes$1(collection, value, fromIndex, guard) {
  collection = isArrayLike$2(collection) ? collection : values$1(collection);
  fromIndex = (fromIndex && !guard) ? toInteger$2(fromIndex) : 0;

  var length = collection.length;
  if (fromIndex < 0) {
    fromIndex = nativeMax$2(length + fromIndex, 0);
  }
  return isString$7(collection)
    ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
    : (!!length && baseIndexOf$1(collection, value, fromIndex) > -1);
}

var includes_1 = includes$1;

const path$2 = require$$0$5;
const flatten$1 = flatten_1;
const includes = includes_1;
const { AbstractMigrationsLoader } = MigrationsLoader;
const { getFilepathsInFolder } = fs_1;

const filterByLoadExtensions = (extensions) => (value) => {
  const extension = path$2.extname(value);
  return includes(extensions, extension);
};

let FsSeeds$1 = class FsSeeds extends AbstractMigrationsLoader {
  _getConfigDirectories(logger) {
    const directories = this.migrationsPaths;
    return directories.map((directory) => {
      if (!directory) {
        logger.warn(
          'Empty value passed as a directory for Seeder, this is not supported.'
        );
      }
      return path$2.resolve(process.cwd(), directory);
    });
  }

  async getSeeds(config) {
    const { loadExtensions, recursive, specific } = config;

    const seeds = flatten$1(
      await Promise.all(
        this._getConfigDirectories(config.logger).map((d) =>
          getFilepathsInFolder(d, recursive)
        )
      )
    );

    // if true, each dir are already sorted
    // (getFilepathsInFolderRecursively does this)
    // if false, we need to sort all the seeds
    let files = seeds.filter(filterByLoadExtensions(loadExtensions));
    if (!this.sortDirsSeparately) {
      files.sort();
    }

    if (specific) {
      files = files.filter((file) => path$2.basename(file) === specific);
      if (files.length === 0) {
        throw new Error(
          `Invalid argument provided: the specific seed "${specific}" does not exist.`
        );
      }
    }

    return files;
  }

  async getSeed(filepath) {
    const importFile = requireImportFile(); // late import
    const seed = await importFile(filepath);
    return seed;
  }
};

var fsSeeds = {
  FsSeeds: FsSeeds$1,
};

const { FsSeeds } = fsSeeds;
const Logger$1 = logger;
const { DEFAULT_LOAD_EXTENSIONS } = MigrationsLoader;
const defaultLogger = new Logger$1();

const CONFIG_DEFAULT = Object.freeze({
  extension: 'js',
  directory: './seeds',
  loadExtensions: DEFAULT_LOAD_EXTENSIONS,
  specific: null,
  timestampFilenamePrefix: false,
  recursive: false,
  sortDirsSeparately: false,
});

function getMergedConfig$1(config, currentConfig, logger = defaultLogger) {
  // config is the user specified config, mergedConfig has defaults and current config
  // applied to it.
  const mergedConfig = Object.assign(
    {},
    CONFIG_DEFAULT,
    currentConfig || {},
    config,
    {
      logger,
    }
  );

  if (
    config &&
    // If user specifies any FS related config,
    // clear specified migrationSource to avoid ambiguity
    (config.directory ||
      config.sortDirsSeparately !== undefined ||
      config.loadExtensions)
  ) {
    if (config.seedSource) {
      logger.warn(
        'FS-related option specified for seed configuration. This resets seedSource to default FsMigrations'
      );
    }
    mergedConfig.seedSource = null;
  }

  // If the user has not specified any configs, we need to
  // default to fs migrations to maintain compatibility
  if (!mergedConfig.seedSource) {
    mergedConfig.seedSource = new FsSeeds(
      mergedConfig.directory,
      mergedConfig.sortDirsSeparately,
      mergedConfig.loadExtensions
    );
  }

  return mergedConfig;
}

var seederConfigurationMerger = {
  getMergedConfig: getMergedConfig$1,
};

// Seeder
// -------

const path$1 = require$$0$5;
const { ensureDirectoryExists } = fs_1;
const { writeJsFileUsingTemplate } = template_1;
const { yyyymmddhhmmss } = timestamp;
const { getMergedConfig } = seederConfigurationMerger;

// The new seeds we're performing, typically called from the `knex.seed`
// interface on the main `knex` object. Passes the `knex` instance performing
// the seeds.
let Seeder$1 = class Seeder {
  constructor(knex) {
    this.knex = knex;
    this.config = this.resolveConfig(knex.client.config.seeds);
  }

  // Runs seed files for the given environment.
  async run(config) {
    this.config = this.resolveConfig(config);
    const files = await this.config.seedSource.getSeeds(this.config);
    return this._runSeeds(files);
  }

  // Creates a new seed file, with a given name.
  async make(name, config) {
    this.config = this.resolveConfig(config);
    if (!name)
      throw new Error('A name must be specified for the generated seed');
    await this._ensureFolder(config);
    const seedPath = await this._writeNewSeed(name);
    return seedPath;
  }

  // Ensures a folder for the seeds exist, dependent on the
  // seed config settings.
  _ensureFolder() {
    const dirs = this.config.seedSource._getConfigDirectories(
      this.config.logger
    );
    const promises = dirs.map(ensureDirectoryExists);
    return Promise.all(promises);
  }

  // Run seed files, in sequence.
  async _runSeeds(seeds) {
    for (const seed of seeds) {
      await this._validateSeedStructure(seed);
    }
    return this._waterfallBatch(seeds);
  }

  async _validateSeedStructure(filepath) {
    const seed = await this.config.seedSource.getSeed(filepath);
    if (typeof seed.seed !== 'function') {
      throw new Error(
        `Invalid seed file: ${filepath} must have a seed function`
      );
    }
    return filepath;
  }

  _getStubPath() {
    return (
      this.config.stub ||
      path$1.join(__dirname, 'stub', this.config.extension + '.stub')
    );
  }

  _getNewStubFileName(name) {
    if (name[0] === '-') name = name.slice(1);

    if (this.config.timestampFilenamePrefix === true) {
      name = `${yyyymmddhhmmss()}_${name}`;
    }

    return `${name}.${this.config.extension}`;
  }

  _getNewStubFilePath(name) {
    const fileName = this._getNewStubFileName(name);
    const dirs = this.config.seedSource._getConfigDirectories(
      this.config.logger
    );
    const dir = dirs.slice(-1)[0]; // Get last specified directory
    return path$1.join(dir, fileName);
  }

  // Write a new seed to disk, using the config and generated filename,
  // passing any `variables` given in the config to the template.
  async _writeNewSeed(name) {
    const seedPath = this._getNewStubFilePath(name);
    await writeJsFileUsingTemplate(
      seedPath,
      this._getStubPath(),
      { variable: 'd' },
      this.config.variables || {}
    );
    return seedPath;
  }

  async _listAll(config) {
    this.config = this.resolveConfig(config);
    return this.config.seedSource.getSeeds(this.config);
  }

  // Runs a batch of seed files.
  async _waterfallBatch(seeds) {
    const { knex } = this;
    const log = [];
    for (const seedPath of seeds) {
      const seed = await this.config.seedSource.getSeed(seedPath);
      try {
        await seed.seed(knex);
        log.push(seedPath);
      } catch (originalError) {
        const error = new Error(
          `Error while executing "${seedPath}" seed: ${originalError.message}`
        );
        error.original = originalError;
        error.stack =
          error.stack.split('\n').slice(0, 2).join('\n') +
          '\n' +
          originalError.stack;
        throw error;
      }
    }
    return [log];
  }

  resolveConfig(config) {
    return getMergedConfig(config, this.config, this.knex.client.logger);
  }
};

var Seeder_1 = Seeder$1;

// FunctionHelper
// -------
// Used for adding functions from the builder
// Example usage: table.dateTime('datetime_to_date').notNull().defaultTo(knex.fn.now());
let FunctionHelper$1 = class FunctionHelper {
  constructor(client) {
    this.client = client;
  }

  now(precision) {
    if (typeof precision === 'number') {
      return this.client.raw(`CURRENT_TIMESTAMP(${precision})`);
    }
    return this.client.raw('CURRENT_TIMESTAMP');
  }

  uuidToBin(uuid, ordered = true) {
    const buf = Buffer.from(uuid.replace(/-/g, ''), 'hex');
    return ordered
      ? Buffer.concat([
          buf.slice(6, 8),
          buf.slice(4, 6),
          buf.slice(0, 4),
          buf.slice(8, 16),
        ])
      : Buffer.concat([
          buf.slice(0, 4),
          buf.slice(4, 6),
          buf.slice(6, 8),
          buf.slice(8, 16),
        ]);
  }

  binToUuid(bin, ordered = true) {
    const buf = Buffer.from(bin, 'hex');
    return ordered
      ? [
          buf.toString('hex', 4, 8),
          buf.toString('hex', 2, 4),
          buf.toString('hex', 0, 2),
          buf.toString('hex', 8, 10),
          buf.toString('hex', 10, 16),
        ].join('-')
      : [
          buf.toString('hex', 0, 4),
          buf.toString('hex', 4, 6),
          buf.toString('hex', 6, 8),
          buf.toString('hex', 8, 10),
          buf.toString('hex', 10, 16),
        ].join('-');
  }
};

var FunctionHelper_1 = FunctionHelper$1;

// All properties we can use to start a query chain
// from the `knex` object, e.g. `knex.select('*').from(...`
var methodConstants = [
  'with',
  'withRecursive',
  'withMaterialized',
  'withNotMaterialized',
  'select',
  'as',
  'columns',
  'column',
  'from',
  'fromJS',
  'fromRaw',
  'into',
  'withSchema',
  'table',
  'distinct',
  'join',
  'joinRaw',
  'innerJoin',
  'leftJoin',
  'leftOuterJoin',
  'rightJoin',
  'rightOuterJoin',
  'outerJoin',
  'fullOuterJoin',
  'crossJoin',
  'where',
  'andWhere',
  'orWhere',
  'whereNot',
  'orWhereNot',
  'whereLike',
  'andWhereLike',
  'orWhereLike',
  'whereILike',
  'andWhereILike',
  'orWhereILike',
  'whereRaw',
  'whereWrapped',
  'havingWrapped',
  'orWhereRaw',
  'whereExists',
  'orWhereExists',
  'whereNotExists',
  'orWhereNotExists',
  'whereIn',
  'orWhereIn',
  'whereNotIn',
  'orWhereNotIn',
  'whereNull',
  'orWhereNull',
  'whereNotNull',
  'orWhereNotNull',
  'whereBetween',
  'whereNotBetween',
  'andWhereBetween',
  'andWhereNotBetween',
  'orWhereBetween',
  'orWhereNotBetween',
  'groupBy',
  'groupByRaw',
  'orderBy',
  'orderByRaw',
  'union',
  'unionAll',
  'intersect',
  'having',
  'havingRaw',
  'orHaving',
  'orHavingRaw',
  'offset',
  'limit',
  'count',
  'countDistinct',
  'min',
  'max',
  'sum',
  'sumDistinct',
  'avg',
  'avgDistinct',
  'increment',
  'decrement',
  'first',
  'debug',
  'pluck',
  'clearSelect',
  'clearWhere',
  'clearGroup',
  'clearOrder',
  'clearHaving',
  'insert',
  'update',
  'returning',
  'del',
  'delete',
  'truncate',
  'transacting',
  'connection',

  // JSON methods

  // Json manipulation functions
  'jsonExtract',
  'jsonSet',
  'jsonInsert',
  'jsonRemove',

  // Wheres Json
  'whereJsonObject',
  'orWhereJsonObject',
  'andWhereJsonObject',
  'whereNotJsonObject',
  'orWhereNotJsonObject',
  'andWhereNotJsonObject',

  'whereJsonPath',
  'orWhereJsonPath',
  'andWhereJsonPath',

  'whereJsonSupersetOf',
  'orWhereJsonSupersetOf',
  'andWhereJsonSupersetOf',
  'whereJsonNotSupersetOf',
  'orWhereJsonNotSupersetOf',
  'andWhereJsonNotSupersetOf',

  'whereJsonSubsetOf',
  'orWhereJsonSubsetOf',
  'andWhereJsonSubsetOf',
  'whereJsonNotSubsetOf',
  'orWhereJsonNotSubsetOf',
  'andWhereJsonNotSubsetOf',
];

var baseAssignValue$1 = _baseAssignValue,
    eq = eq_1;

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue$2(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue$1(object, key, value);
  }
}

var _assignMergeValue = assignMergeValue$2;

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */

function safeGet$2(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

var _safeGet = safeGet$2;

var copyObject$2 = _copyObject,
    keysIn$2 = keysIn_1;

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject$1(value) {
  return copyObject$2(value, keysIn$2(value));
}

var toPlainObject_1 = toPlainObject$1;

var assignMergeValue$1 = _assignMergeValue,
    cloneBuffer = _cloneBufferExports,
    cloneTypedArray = _cloneTypedArray,
    copyArray$1 = _copyArray,
    initCloneObject = _initCloneObject,
    isArguments = isArguments_1,
    isArray$6 = isArray_1,
    isArrayLikeObject = isArrayLikeObject_1,
    isBuffer$1 = isBufferExports,
    isFunction$4 = isFunction_1,
    isObject$8 = isObject_1,
    isPlainObject$4 = isPlainObject_1,
    isTypedArray$2 = isTypedArray_1,
    safeGet$1 = _safeGet,
    toPlainObject = toPlainObject_1;

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep$1(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet$1(object, key),
      srcValue = safeGet$1(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue$1(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray$6(srcValue),
        isBuff = !isArr && isBuffer$1(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray$2(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray$6(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray$1(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject$4(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject$8(objValue) || isFunction$4(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue$1(object, key, newValue);
}

var _baseMergeDeep = baseMergeDeep$1;

var Stack = _Stack,
    assignMergeValue = _assignMergeValue,
    baseFor = _baseFor,
    baseMergeDeep = _baseMergeDeep,
    isObject$7 = isObject_1,
    keysIn$1 = keysIn_1,
    safeGet = _safeGet;

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge$1(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack || (stack = new Stack);
    if (isObject$7(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge$1, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn$1);
}

var _baseMerge = baseMerge$1;

var baseMerge = _baseMerge,
    createAssigner$2 = _createAssigner;

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge$1 = createAssigner$2(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

var merge_1 = merge$1;

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */

function baseSlice$2(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

var _baseSlice = baseSlice$2;

var baseSlice$1 = _baseSlice,
    isIterateeCall = _isIterateeCall,
    toInteger$1 = toInteger_1;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil = Math.ceil,
    nativeMax$1 = Math.max;

/**
 * Creates an array of elements split into groups the length of `size`.
 * If `array` can't be split evenly, the final chunk will be the remaining
 * elements.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to process.
 * @param {number} [size=1] The length of each chunk
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the new array of chunks.
 * @example
 *
 * _.chunk(['a', 'b', 'c', 'd'], 2);
 * // => [['a', 'b'], ['c', 'd']]
 *
 * _.chunk(['a', 'b', 'c', 'd'], 3);
 * // => [['a', 'b', 'c'], ['d']]
 */
function chunk$1(array, size, guard) {
  if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
    size = 1;
  } else {
    size = nativeMax$1(toInteger$1(size), 0);
  }
  var length = array == null ? 0 : array.length;
  if (!length || size < 1) {
    return [];
  }
  var index = 0,
      resIndex = 0,
      result = Array(nativeCeil(length / size));

  while (index < length) {
    result[resIndex++] = baseSlice$1(array, index, (index += size));
  }
  return result;
}

var chunk_1 = chunk$1;

/**
 * @param {number} delay
 * @returns {Promise<void>}
 */

var delay$2 = (delay) =>
  new Promise((resolve) => setTimeout(resolve, delay));

const chunk = chunk_1;
const flatten = flatten_1;
const delay$1 = delay$2;
const { isNumber: isNumber$2 } = is;

function batchInsert$1(client, tableName, batch, chunkSize = 1000) {
  let returning = undefined;
  let transaction = null;
  if (!isNumber$2(chunkSize) || chunkSize < 1) {
    throw new TypeError(`Invalid chunkSize: ${chunkSize}`);
  }
  if (!Array.isArray(batch)) {
    throw new TypeError(`Invalid batch: Expected array, got ${typeof batch}`);
  }
  const chunks = chunk(batch, chunkSize);

  const runInTransaction = (cb) => {
    if (transaction) {
      return cb(transaction);
    }
    return client.transaction(cb);
  };

  return Object.assign(
    Promise.resolve().then(async () => {
      //Next tick to ensure wrapper functions are called if needed
      await delay$1(1);
      return runInTransaction(async (tr) => {
        const chunksResults = [];
        for (const items of chunks) {
          chunksResults.push(await tr(tableName).insert(items, returning));
        }
        return flatten(chunksResults);
      });
    }),
    {
      returning(columns) {
        returning = columns;

        return this;
      },
      transacting(tr) {
        transaction = tr;

        return this;
      },
    }
  );
}

var batchInsert_1 = batchInsert$1;

const { EventEmitter: EventEmitter$8 } = require$$0;

const { Migrator } = Migrator_1;
const Seeder = Seeder_1;
const FunctionHelper = FunctionHelper_1;
const QueryInterface = methodConstants;
const merge = merge_1;
const batchInsert = batchInsert_1;
const { isObject: isObject$6 } = is;

// Javascript does not officially support "callable objects".  Instead,
// you must create a regular Function and inject properties/methods
// into it.  In other words: you can't leverage Prototype Inheritance
// to share the property/method definitions.
//
// To work around this, we're creating an Object Property Definition.
// This allow us to quickly inject everything into the `knex` function
// via the `Object.defineProperties(..)` function.  More importantly,
// it allows the same definitions to be shared across `knex` instances.
const KNEX_PROPERTY_DEFINITIONS = {
  client: {
    get() {
      return this.context.client;
    },
    set(client) {
      this.context.client = client;
    },
    configurable: true,
  },

  userParams: {
    get() {
      return this.context.userParams;
    },
    set(userParams) {
      this.context.userParams = userParams;
    },
    configurable: true,
  },

  schema: {
    get() {
      return this.client.schemaBuilder();
    },
    configurable: true,
  },

  migrate: {
    get() {
      return new Migrator(this);
    },
    configurable: true,
  },

  seed: {
    get() {
      return new Seeder(this);
    },
    configurable: true,
  },

  fn: {
    get() {
      return new FunctionHelper(this.client);
    },
    configurable: true,
  },
};

// `knex` instances serve as proxies around `context` objects.  So, calling
// any of these methods on the `knex` instance will forward the call to
// the `knex.context` object. This ensures that `this` will correctly refer
// to `context` within each of these methods.
const CONTEXT_METHODS = [
  'raw',
  'batchInsert',
  'transaction',
  'transactionProvider',
  'initialize',
  'destroy',
  'ref',
  'withUserParams',
  'queryBuilder',
  'disableProcessing',
  'enableProcessing',
];

for (const m of CONTEXT_METHODS) {
  KNEX_PROPERTY_DEFINITIONS[m] = {
    value: function (...args) {
      return this.context[m](...args);
    },
    configurable: true,
  };
}

function makeKnex$1(client) {
  // The object we're potentially using to kick off an initial chain.
  function knex(tableName, options) {
    return createQueryBuilder(knex.context, tableName, options);
  }

  redefineProperties(knex, client);
  return knex;
}

function initContext(knexFn) {
  const knexContext = knexFn.context || {};
  Object.assign(knexContext, {
    queryBuilder() {
      return this.client.queryBuilder();
    },

    raw() {
      return this.client.raw.apply(this.client, arguments);
    },

    batchInsert(table, batch, chunkSize = 1000) {
      return batchInsert(this, table, batch, chunkSize);
    },

    // Creates a new transaction.
    // If container is provided, returns a promise for when the transaction is resolved.
    // If container is not provided, returns a promise with a transaction that is resolved
    // when transaction is ready to be used.
    transaction(container, _config) {
      // Overload support of `transaction(config)`
      if (!_config && isObject$6(container)) {
        _config = container;
        container = null;
      }

      const config = Object.assign({}, _config);
      config.userParams = this.userParams || {};
      if (config.doNotRejectOnRollback === undefined) {
        config.doNotRejectOnRollback = true;
      }

      return this._transaction(container, config);
    },

    // Internal method that actually establishes the Transaction.  It makes no assumptions
    // about the `config` or `outerTx`, and expects the caller to handle these details.
    _transaction(container, config, outerTx = null) {
      if (container) {
        const trx = this.client.transaction(container, config, outerTx);
        return trx;
      } else {
        return new Promise((resolve, reject) => {
          this.client.transaction(resolve, config, outerTx).catch(reject);
        });
      }
    },

    transactionProvider(config) {
      let trx;
      return () => {
        if (!trx) {
          trx = this.transaction(undefined, config);
        }
        return trx;
      };
    },

    // Typically never needed, initializes the pool for a knex client.
    initialize(config) {
      return this.client.initializePool(config);
    },

    // Convenience method for tearing down the pool.
    destroy(callback) {
      return this.client.destroy(callback);
    },

    ref(ref) {
      return this.client.ref(ref);
    },

    // Do not document this as public API until naming and API is improved for general consumption
    // This method exists to disable processing of internal queries in migrations
    disableProcessing() {
      if (this.userParams.isProcessingDisabled) {
        return;
      }
      this.userParams.wrapIdentifier = this.client.config.wrapIdentifier;
      this.userParams.postProcessResponse =
        this.client.config.postProcessResponse;
      this.client.config.wrapIdentifier = null;
      this.client.config.postProcessResponse = null;
      this.userParams.isProcessingDisabled = true;
    },

    // Do not document this as public API until naming and API is improved for general consumption
    // This method exists to enable execution of non-internal queries with consistent identifier naming in migrations
    enableProcessing() {
      if (!this.userParams.isProcessingDisabled) {
        return;
      }
      this.client.config.wrapIdentifier = this.userParams.wrapIdentifier;
      this.client.config.postProcessResponse =
        this.userParams.postProcessResponse;
      this.userParams.isProcessingDisabled = false;
    },

    withUserParams(params) {
      const knexClone = shallowCloneFunction(knexFn); // We need to include getters in our clone
      if (this.client) {
        knexClone.client = Object.create(this.client.constructor.prototype); // Clone client to avoid leaking listeners that are set on it
        merge(knexClone.client, this.client);
        knexClone.client.config = Object.assign({}, this.client.config); // Clone client config to make sure they can be modified independently
      }

      redefineProperties(knexClone, knexClone.client);
      _copyEventListeners('query', knexFn, knexClone);
      _copyEventListeners('query-error', knexFn, knexClone);
      _copyEventListeners('query-response', knexFn, knexClone);
      _copyEventListeners('start', knexFn, knexClone);
      knexClone.userParams = params;
      return knexClone;
    },
  });

  if (!knexFn.context) {
    knexFn.context = knexContext;
  }
}

function _copyEventListeners(eventName, sourceKnex, targetKnex) {
  const listeners = sourceKnex.listeners(eventName);
  listeners.forEach((listener) => {
    targetKnex.on(eventName, listener);
  });
}

function redefineProperties(knex, client) {
  // Allow chaining methods from the root object, before
  // any other information is specified.
  //
  // TODO: `QueryBuilder.extend(..)` allows new QueryBuilder
  //       methods to be introduced via external components.
  //       As a side-effect, it also pushes the new method names
  //       into the `QueryInterface` array.
  //
  //       The Problem: due to the way the code is currently
  //       structured, these new methods cannot be retroactively
  //       injected into existing `knex` instances!  As a result,
  //       some `knex` instances will support the methods, and
  //       others will not.
  //
  //       We should revisit this once we figure out the desired
  //       behavior / usage.  For instance: do we really want to
  //       allow external components to directly manipulate `knex`
  //       data structures?  Or, should we come up w/ a different
  //       approach that avoids side-effects / mutation?
  //
  //      (FYI: I noticed this issue because I attempted to integrate
  //       this logic directly into the `KNEX_PROPERTY_DEFINITIONS`
  //       construction.  However, `KNEX_PROPERTY_DEFINITIONS` is
  //       constructed before any `knex` instances are created.
  //       As a result, the method extensions were missing from all
  //       `knex` instances.)
  for (let i = 0; i < QueryInterface.length; i++) {
    const method = QueryInterface[i];
    knex[method] = function () {
      const builder = this.queryBuilder();
      return builder[method].apply(builder, arguments);
    };
  }

  Object.defineProperties(knex, KNEX_PROPERTY_DEFINITIONS);

  initContext(knex);
  knex.client = client;
  knex.userParams = {};

  // Hook up the "knex" object as an EventEmitter.
  const ee = new EventEmitter$8();
  for (const key in ee) {
    knex[key] = ee[key];
  }

  // Unfortunately, something seems to be broken in Node 6 and removing events from a clone also mutates original Knex,
  // which is highly undesirable
  if (knex._internalListeners) {
    knex._internalListeners.forEach(({ eventName, listener }) => {
      knex.client.removeListener(eventName, listener); // Remove duplicates for copies
    });
  }
  knex._internalListeners = [];

  // Passthrough all "start" and "query" events to the knex object.
  _addInternalListener(knex, 'start', (obj) => {
    knex.emit('start', obj);
  });
  _addInternalListener(knex, 'query', (obj) => {
    knex.emit('query', obj);
  });
  _addInternalListener(knex, 'query-error', (err, obj) => {
    knex.emit('query-error', err, obj);
  });
  _addInternalListener(knex, 'query-response', (response, obj, builder) => {
    knex.emit('query-response', response, obj, builder);
  });
}

function _addInternalListener(knex, eventName, listener) {
  knex.client.on(eventName, listener);
  knex._internalListeners.push({
    eventName,
    listener,
  });
}

function createQueryBuilder(knexContext, tableName, options) {
  const qb = knexContext.queryBuilder();
  if (!tableName)
    knexContext.client.logger.warn(
      'calling knex without a tableName is deprecated. Use knex.queryBuilder() instead.'
    );
  return tableName ? qb.table(tableName, options) : qb;
}

function shallowCloneFunction(originalFunction) {
  const fnContext = Object.create(
    Object.getPrototypeOf(originalFunction),
    Object.getOwnPropertyDescriptors(originalFunction)
  );

  const knexContext = {};
  const knexFnWrapper = (tableName, options) => {
    return createQueryBuilder(knexContext, tableName, options);
  };

  const clonedFunction = knexFnWrapper.bind(fnContext);
  Object.assign(clonedFunction, originalFunction);
  clonedFunction.context = knexContext;
  return clonedFunction;
}

var makeKnex_1 = makeKnex$1;

var noop$2 = function () {};

const noop$1 = noop$2;

const finallyMixin$2 = (prototype) =>
  Object.assign(prototype, {
    finally(onFinally) {
      return this.then().finally(onFinally);
    },
  });

// FYI: Support for `Promise.prototype.finally` was not introduced until Node 9.
//      Therefore, Knex will need to conditionally inject support for `.finally(..)`
//      until support for Node 8 is officially dropped.
var finallyMixin_1 = Promise.prototype.finally ? finallyMixin$2 : noop$1;

// Transaction
// -------
const { EventEmitter: EventEmitter$7 } = require$$0;
const Debug = srcExports;
const uniqueId$1 = uniqueId_1;
const { callbackify: callbackify$1 } = require$$0$4;

const makeKnex = makeKnex_1;
const { timeout, KnexTimeoutError: KnexTimeoutError$1 } = timeout$3;
const finallyMixin$1 = finallyMixin_1;

const debug$3 = Debug('knex:tx');

// FYI: This is defined as a function instead of a constant so that
//      each Transactor can have its own copy of the default config.
//      This will minimize the impact of bugs that might be introduced
//      if a Transactor ever mutates its config.
function DEFAULT_CONFIG() {
  return {
    userParams: {},
    doNotRejectOnRollback: true,
  };
}
// These aren't supported in sqlite3 which is serialized already so it's as
// safe as reasonable, except for a special read_uncommitted pragma
const validIsolationLevels = [
  // Doesn't really work in postgres, it treats it as read committed
  'read uncommitted',
  'read committed',
  'snapshot',
  // snapshot and repeatable read are basically the same, most "repeatable
  // read" implementations are actually "snapshot" also known as Multi Version
  // Concurrency Control (MVCC). Mssql's repeatable read doesn't stop
  // repeated reads for inserts as it uses a pessimistic locking system so
  // you should probably use 'snapshot' to stop read skew.
  'repeatable read',
  // mysql pretends to have serializable, but it is not
  'serializable',
];

// Acts as a facade for a Promise, keeping the internal state
// and managing any child transactions.
let Transaction$1 = class Transaction extends EventEmitter$7 {
  constructor(client, container, config = DEFAULT_CONFIG(), outerTx = null) {
    super();
    this.userParams = config.userParams;
    this.doNotRejectOnRollback = config.doNotRejectOnRollback;

    const txid = (this.txid = uniqueId$1('trx'));

    this.client = client;
    this.logger = client.logger;
    this.outerTx = outerTx;
    this.trxClient = undefined;
    this._completed = false;
    this._debug = client.config && client.config.debug;

    if (config.isolationLevel) {
      this.setIsolationLevel(config.isolationLevel);
    }

    debug$3(
      '%s: Starting %s transaction',
      txid,
      outerTx ? 'nested' : 'top level'
    );

    // `this` can potentially serve as an `outerTx` for another
    // Transaction.  So, go ahead and establish `_lastChild` now.
    this._lastChild = Promise.resolve();

    const _previousSibling = outerTx ? outerTx._lastChild : Promise.resolve();

    // FYI: As you will see in a moment, this Promise will be used to construct
    //      2 separate Promise Chains.  This ensures that each Promise Chain
    //      can establish its error-handling semantics without interfering
    //      with the other Promise Chain.
    const basePromise = _previousSibling.then(() =>
      this._evaluateContainer(config, container)
    );

    // FYI: This is the Promise Chain for EXTERNAL use.  It ensures that the
    //      caller must handle any exceptions that result from `basePromise`.
    this._promise = basePromise.then((x) => x);

    if (outerTx) {
      // FYI: This is the Promise Chain for INTERNAL use.  It serves as a signal
      //      for when the next sibling should begin its execution.  Therefore,
      //      exceptions are caught and ignored.
      outerTx._lastChild = basePromise.catch(() => {});
    }
  }

  isCompleted() {
    return (
      this._completed || (this.outerTx && this.outerTx.isCompleted()) || false
    );
  }

  begin(conn) {
    const runIsolationLevelQuery = this.isolationLevel
      ? this.query(
          conn,
          `SET TRANSACTION ISOLATION LEVEL ${this.isolationLevel};`
        )
      : Promise.resolve();
    return runIsolationLevelQuery.then(() => this.query(conn, 'BEGIN;'));
  }

  savepoint(conn) {
    return this.query(conn, `SAVEPOINT ${this.txid};`);
  }

  commit(conn, value) {
    return this.query(conn, 'COMMIT;', 1, value);
  }

  release(conn, value) {
    return this.query(conn, `RELEASE SAVEPOINT ${this.txid};`, 1, value);
  }

  setIsolationLevel(isolationLevel) {
    if (!validIsolationLevels.includes(isolationLevel)) {
      throw new Error(
        `Invalid isolationLevel, supported isolation levels are: ${JSON.stringify(
          validIsolationLevels
        )}`
      );
    }
    this.isolationLevel = isolationLevel;
    return this;
  }

  rollback(conn, error) {
    return timeout(this.query(conn, 'ROLLBACK', 2, error), 5000).catch(
      (err) => {
        if (!(err instanceof KnexTimeoutError$1)) {
          return Promise.reject(err);
        }
        this._rejecter(error);
      }
    );
  }

  rollbackTo(conn, error) {
    return timeout(
      this.query(conn, `ROLLBACK TO SAVEPOINT ${this.txid}`, 2, error),
      5000
    ).catch((err) => {
      if (!(err instanceof KnexTimeoutError$1)) {
        return Promise.reject(err);
      }
      this._rejecter(error);
    });
  }

  query(conn, sql, status, value) {
    const q = this.trxClient
      .query(conn, sql)
      .catch((err) => {
        status = 2;
        value = err;
        this._completed = true;
        debug$3('%s error running transaction query', this.txid);
      })
      .then((res) => {
        if (status === 1) {
          this._resolver(value);
        }
        if (status === 2) {
          if (value === undefined) {
            if (this.doNotRejectOnRollback && /^ROLLBACK\b/i.test(sql)) {
              this._resolver();
              return;
            }

            value = new Error(`Transaction rejected with non-error: ${value}`);
          }
          this._rejecter(value);
        }
        return res;
      });
    if (status === 1 || status === 2) {
      this._completed = true;
    }
    return q;
  }

  debug(enabled) {
    this._debug = arguments.length ? enabled : true;
    return this;
  }

  async _evaluateContainer(config, container) {
    return this.acquireConnection(config, (connection) => {
      const trxClient = (this.trxClient = makeTxClient(
        this,
        this.client,
        connection
      ));
      const init = this.client.transacting
        ? this.savepoint(connection)
        : this.begin(connection);
      const executionPromise = new Promise((resolver, rejecter) => {
        this._resolver = resolver;
        this._rejecter = rejecter;
      });

      init
        .then(() => {
          return makeTransactor(this, connection, trxClient);
        })
        .then((transactor) => {
          transactor.executionPromise = executionPromise;

          // If we've returned a "thenable" from the transaction container, assume
          // the rollback and commit are chained to this object's success / failure.
          // Directly thrown errors are treated as automatic rollbacks.
          let result;
          try {
            result = container(transactor);
          } catch (err) {
            result = Promise.reject(err);
          }
          if (result && result.then && typeof result.then === 'function') {
            result
              .then((val) => {
                return transactor.commit(val);
              })
              .catch((err) => {
                return transactor.rollback(err);
              });
          }
          return null;
        })
        .catch((e) => {
          return this._rejecter(e);
        });

      return executionPromise;
    });
  }

  // Acquire a connection and create a disposer - either using the one passed
  // via config or getting one off the client. The disposer will be called once
  // the original promise is marked completed.
  async acquireConnection(config, cb) {
    const configConnection = config && config.connection;
    const connection =
      configConnection || (await this.client.acquireConnection());

    try {
      connection.__knexTxId = this.txid;
      return await cb(connection);
    } finally {
      if (!configConnection) {
        debug$3('%s: releasing connection', this.txid);
        this.client.releaseConnection(connection);
      } else {
        debug$3('%s: not releasing external connection', this.txid);
      }
    }
  }

  then(onResolve, onReject) {
    return this._promise.then(onResolve, onReject);
  }

  catch(...args) {
    return this._promise.catch(...args);
  }

  asCallback(cb) {
    callbackify$1(() => this._promise)(cb);
    return this._promise;
  }
};
finallyMixin$1(Transaction$1.prototype);

// The transactor is a full featured knex object, with a "commit", a "rollback"
// and a "savepoint" function. The "savepoint" is just sugar for creating a new
// transaction. If the rollback is run inside a savepoint, it rolls back to the
// last savepoint - otherwise it rolls back the transaction.
function makeTransactor(trx, connection, trxClient) {
  const transactor = makeKnex(trxClient);

  transactor.context.withUserParams = () => {
    throw new Error(
      'Cannot set user params on a transaction - it can only inherit params from main knex instance'
    );
  };

  transactor.isTransaction = true;
  transactor.userParams = trx.userParams || {};

  transactor.context.transaction = function (container, options) {
    if (!options) {
      options = { doNotRejectOnRollback: true };
    } else if (options.doNotRejectOnRollback === undefined) {
      options.doNotRejectOnRollback = true;
    }

    return this._transaction(container, options, trx);
  };

  transactor.savepoint = function (container, options) {
    return transactor.transaction(container, options);
  };

  if (trx.client.transacting) {
    transactor.commit = (value) => trx.release(connection, value);
    transactor.rollback = (error) => trx.rollbackTo(connection, error);
  } else {
    transactor.commit = (value) => trx.commit(connection, value);
    transactor.rollback = (error) => trx.rollback(connection, error);
  }

  transactor.isCompleted = () => trx.isCompleted();

  return transactor;
}

// We need to make a client object which always acquires the same
// connection and does not release back into the pool.
function makeTxClient(trx, client, connection) {
  const trxClient = Object.create(client.constructor.prototype);
  trxClient.version = client.version;
  trxClient.config = client.config;
  trxClient.driver = client.driver;
  trxClient.connectionSettings = client.connectionSettings;
  trxClient.transacting = true;
  trxClient.valueForUndefined = client.valueForUndefined;
  trxClient.logger = client.logger;

  trxClient.on('start', function (arg) {
    trx.emit('start', arg);
    client.emit('start', arg);
  });

  trxClient.on('query', function (arg) {
    trx.emit('query', arg);
    client.emit('query', arg);
  });

  trxClient.on('query-error', function (err, obj) {
    trx.emit('query-error', err, obj);
    client.emit('query-error', err, obj);
  });

  trxClient.on('query-response', function (response, obj, builder) {
    trx.emit('query-response', response, obj, builder);
    client.emit('query-response', response, obj, builder);
  });

  const _query = trxClient.query;
  trxClient.query = function (conn, obj) {
    const completed = trx.isCompleted();
    return new Promise(function (resolve, reject) {
      try {
        if (conn !== connection)
          throw new Error('Invalid connection for transaction query.');
        if (completed) completedError(trx, obj);
        resolve(_query.call(trxClient, conn, obj));
      } catch (e) {
        reject(e);
      }
    });
  };
  const _stream = trxClient.stream;
  trxClient.stream = function (conn, obj, stream, options) {
    const completed = trx.isCompleted();
    return new Promise(function (resolve, reject) {
      try {
        if (conn !== connection)
          throw new Error('Invalid connection for transaction query.');
        if (completed) completedError(trx, obj);
        resolve(_stream.call(trxClient, conn, obj, stream, options));
      } catch (e) {
        reject(e);
      }
    });
  };
  trxClient.acquireConnection = function () {
    return Promise.resolve(connection);
  };
  trxClient.releaseConnection = function () {
    return Promise.resolve();
  };

  return trxClient;
}

function completedError(trx, obj) {
  const sql = typeof obj === 'string' ? obj : obj && obj.sql;
  debug$3('%s: Transaction completed: %s', trx.txid, sql);
  throw new Error(
    'Transaction query already complete, run with DEBUG=knex:tx for more info'
  );
}

var transaction = Transaction$1;

const _debugQuery = srcExports('knex:query');
const debugBindings$2 = srcExports('knex:bindings');
const debugQuery = (sql, txId) => _debugQuery(sql.replace(/%/g, '%%'), txId);
const { isString: isString$6 } = is;

function formatQuery$1(sql, bindings, timeZone, client) {
  bindings = bindings == null ? [] : [].concat(bindings);
  let index = 0;
  return sql.replace(/\\?\?/g, (match) => {
    if (match === '\\?') {
      return '?';
    }
    if (index === bindings.length) {
      return match;
    }
    const value = bindings[index++];
    return client._escapeBinding(value, { timeZone });
  });
}

function enrichQueryObject$1(connection, queryParam, client) {
  const queryObject = isString$6(queryParam) ? { sql: queryParam } : queryParam;

  queryObject.bindings = client.prepBindings(queryObject.bindings);
  queryObject.sql = client.positionBindings(queryObject.sql);

  const { __knexUid, __knexTxId } = connection;

  client.emit('query', Object.assign({ __knexUid, __knexTxId }, queryObject));
  debugQuery(queryObject.sql, __knexTxId);
  debugBindings$2(queryObject.bindings, __knexTxId);

  return queryObject;
}

function executeQuery$1(connection, queryObject, client) {
  return client._query(connection, queryObject).catch((err) => {
    if (client.config && client.config.compileSqlOnError === false) {
      err.message = queryObject.sql + ' - ' + err.message;
    } else {
      err.message =
        formatQuery$1(queryObject.sql, queryObject.bindings, undefined, client) +
        ' - ' +
        err.message;
    }
    client.emit(
      'query-error',
      err,
      Object.assign(
        { __knexUid: connection.__knexUid, __knexTxId: connection.__knexUid },
        queryObject
      )
    );
    throw err;
  });
}

var queryExecutioner = {
  enrichQueryObject: enrichQueryObject$1,
  executeQuery: executeQuery$1,
  formatQuery: formatQuery$1,
};

var assignValue$1 = _assignValue,
    copyObject$1 = _copyObject,
    createAssigner$1 = _createAssigner,
    isArrayLike$1 = isArrayLike_1,
    isPrototype = _isPrototype,
    keys = keys_1;

/** Used for built-in method references. */
var objectProto$2 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

/**
 * Assigns own enumerable string keyed properties of source objects to the
 * destination object. Source objects are applied from left to right.
 * Subsequent sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object` and is loosely based on
 * [`Object.assign`](https://mdn.io/Object/assign).
 *
 * @static
 * @memberOf _
 * @since 0.10.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.assignIn
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * function Bar() {
 *   this.c = 3;
 * }
 *
 * Foo.prototype.b = 2;
 * Bar.prototype.d = 4;
 *
 * _.assign({ 'a': 0 }, new Foo, new Bar);
 * // => { 'a': 1, 'c': 3 }
 */
var assign$7 = createAssigner$1(function(object, source) {
  if (isPrototype(source) || isArrayLike$1(source)) {
    copyObject$1(source, keys(source), object);
    return;
  }
  for (var key in source) {
    if (hasOwnProperty$2.call(source, key)) {
      assignValue$1(object, key, source[key]);
    }
  }
});

var assign_1 = assign$7;

var baseClone = _baseClone;

/** Used to compose bitmasks for cloning. */
var CLONE_SYMBOLS_FLAG = 4;

/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */
function clone$2(value) {
  return baseClone(value, CLONE_SYMBOLS_FLAG);
}

var clone_1 = clone$2;

var eachExports = {};
var each$3 = {
  get exports(){ return eachExports; },
  set exports(v){ eachExports = v; },
};

var identity = identity_1;

/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */
function castFunction$1(value) {
  return typeof value == 'function' ? value : identity;
}

var _castFunction = castFunction$1;

var arrayEach$1 = _arrayEach,
    baseEach$3 = _baseEach,
    castFunction = _castFunction,
    isArray$5 = isArray_1;

/**
 * Iterates over elements of `collection` and invokes `iteratee` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length"
 * property are iterated like arrays. To avoid this behavior use `_.forIn`
 * or `_.forOwn` for object iteration.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEachRight
 * @example
 *
 * _.forEach([1, 2], function(value) {
 *   console.log(value);
 * });
 * // => Logs `1` then `2`.
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */
function forEach(collection, iteratee) {
  var func = isArray$5(collection) ? arrayEach$1 : baseEach$3;
  return func(collection, castFunction(iteratee));
}

var forEach_1 = forEach;

(function (module) {
	module.exports = forEach_1;
} (each$3));

var baseEach$2 = _baseEach;

/**
 * The base implementation of `_.filter` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function baseFilter$1(collection, predicate) {
  var result = [];
  baseEach$2(collection, function(value, index, collection) {
    if (predicate(value, index, collection)) {
      result.push(value);
    }
  });
  return result;
}

var _baseFilter = baseFilter$1;

/** Error message constants. */

var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that negates the result of the predicate `func`. The
 * `func` predicate is invoked with the `this` binding and arguments of the
 * created function.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Function
 * @param {Function} predicate The predicate to negate.
 * @returns {Function} Returns the new negated function.
 * @example
 *
 * function isEven(n) {
 *   return n % 2 == 0;
 * }
 *
 * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
 * // => [1, 3, 5]
 */
function negate$2(predicate) {
  if (typeof predicate != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0: return !predicate.call(this);
      case 1: return !predicate.call(this, args[0]);
      case 2: return !predicate.call(this, args[0], args[1]);
      case 3: return !predicate.call(this, args[0], args[1], args[2]);
    }
    return !predicate.apply(this, args);
  };
}

var negate_1 = negate$2;

var arrayFilter = _arrayFilter,
    baseFilter = _baseFilter,
    baseIteratee$6 = _baseIteratee,
    isArray$4 = isArray_1,
    negate$1 = negate_1;

/**
 * The opposite of `_.filter`; this method returns the elements of `collection`
 * that `predicate` does **not** return truthy for.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 * @see _.filter
 * @example
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': false },
 *   { 'user': 'fred',   'age': 40, 'active': true }
 * ];
 *
 * _.reject(users, function(o) { return !o.active; });
 * // => objects for ['fred']
 *
 * // The `_.matches` iteratee shorthand.
 * _.reject(users, { 'age': 40, 'active': true });
 * // => objects for ['barney']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.reject(users, ['active', false]);
 * // => objects for ['fred']
 *
 * // The `_.property` iteratee shorthand.
 * _.reject(users, 'active');
 * // => objects for ['barney']
 */
function reject$1(collection, predicate) {
  var func = isArray$4(collection) ? arrayFilter : baseFilter;
  return func(collection, negate$1(baseIteratee$6(predicate)));
}

var reject_1 = reject$1;

var baseSlice = _baseSlice;

/**
 * Gets all but the first element of `array`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * _.tail([1, 2, 3]);
 * // => [2, 3]
 */
function tail$4(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseSlice(array, 1, length) : [];
}

var tail_1 = tail$4;

/**
 * Converts `iterator` to an array.
 *
 * @private
 * @param {Object} iterator The iterator to convert.
 * @returns {Array} Returns the converted array.
 */

function iteratorToArray$3(iterator) {
  var data,
      result = [];

  while (!(data = iterator.next()).done) {
    result.push(data.value);
  }
  return result;
}

var _iteratorToArray = iteratorToArray$3;

/**
 * Converts an ASCII `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */

function asciiToArray$1(string) {
  return string.split('');
}

var _asciiToArray = asciiToArray$1;

/** Used to compose unicode character classes. */

var rsAstralRange$1 = '\\ud800-\\udfff',
    rsComboMarksRange$1 = '\\u0300-\\u036f',
    reComboHalfMarksRange$1 = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange$1 = '\\u20d0-\\u20ff',
    rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1,
    rsVarRange$1 = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsZWJ$1 = '\\u200d';

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var reHasUnicode = RegExp('[' + rsZWJ$1 + rsAstralRange$1  + rsComboRange$1 + rsVarRange$1 + ']');

/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */
function hasUnicode$1(string) {
  return reHasUnicode.test(string);
}

var _hasUnicode = hasUnicode$1;

/** Used to compose unicode character classes. */

var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/**
 * Converts a Unicode `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function unicodeToArray$1(string) {
  return string.match(reUnicode) || [];
}

var _unicodeToArray = unicodeToArray$1;

var asciiToArray = _asciiToArray,
    hasUnicode = _hasUnicode,
    unicodeToArray = _unicodeToArray;

/**
 * Converts `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function stringToArray$1(string) {
  return hasUnicode(string)
    ? unicodeToArray(string)
    : asciiToArray(string);
}

var _stringToArray = stringToArray$1;

var Symbol$1 = _Symbol,
    copyArray = _copyArray,
    getTag = _getTag,
    isArrayLike = isArrayLike_1,
    isString$5 = isString_1,
    iteratorToArray$2 = _iteratorToArray,
    mapToArray = _mapToArray,
    setToArray = _setToArray,
    stringToArray = _stringToArray,
    values = values_1;

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/** Built-in value references. */
var symIterator = Symbol$1 ? Symbol$1.iterator : undefined;

/**
 * Converts `value` to an array.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Array} Returns the converted array.
 * @example
 *
 * _.toArray({ 'a': 1, 'b': 2 });
 * // => [1, 2]
 *
 * _.toArray('abc');
 * // => ['a', 'b', 'c']
 *
 * _.toArray(1);
 * // => []
 *
 * _.toArray(null);
 * // => []
 */
function toArray$4(value) {
  if (!value) {
    return [];
  }
  if (isArrayLike(value)) {
    return isString$5(value) ? stringToArray(value) : copyArray(value);
  }
  if (symIterator && value[symIterator]) {
    return iteratorToArray$2(value[symIterator]());
  }
  var tag = getTag(value),
      func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

  return func(value);
}

var toArray_1 = toArray$4;

// The client names we'll allow in the `{name: lib}` pairing.
const CLIENT_ALIASES$1 = Object.freeze({
  pg: 'postgres',
  postgresql: 'postgres',
  sqlite: 'sqlite3',
});

const SUPPORTED_CLIENTS = Object.freeze(
  [
    'mssql',
    'mysql',
    'mysql2',
    'oracledb',
    'postgres',
    'pgnative',
    'redshift',
    'sqlite3',
    'cockroachdb',
    'better-sqlite3',
  ].concat(Object.keys(CLIENT_ALIASES$1))
);

const DRIVER_NAMES = Object.freeze({
  MsSQL: 'mssql',
  MySQL: 'mysql',
  MySQL2: 'mysql2',
  Oracle: 'oracledb',
  PostgreSQL: 'pg',
  PgNative: 'pgnative',
  Redshift: 'pg-redshift',
  SQLite: 'sqlite3',
  CockroachDB: 'cockroachdb',
  BetterSQLite3: 'better-sqlite3',
});

const POOL_CONFIG_OPTIONS$1 = Object.freeze([
  'maxWaitingClients',
  'testOnBorrow',
  'fifo',
  'priorityRange',
  'autostart',
  'evictionRunIntervalMillis',
  'numTestsPerRun',
  'softIdleTimeoutMillis',
  'Promise',
]);

/**
 * Regex that only matches comma's in strings that aren't wrapped in parentheses. Can be used to
 * safely split strings like `id int, name string, body text, primary key (id, name)` into definition
 * rows
 */
const COMMA_NO_PAREN_REGEX = /,[\s](?![^(]*\))/g;

var constants$2 = {
  CLIENT_ALIASES: CLIENT_ALIASES$1,
  SUPPORTED_CLIENTS,
  POOL_CONFIG_OPTIONS: POOL_CONFIG_OPTIONS$1,
  COMMA_NO_PAREN_REGEX,
  DRIVER_NAMES,
};

const isPlainObject$3 = isPlainObject_1;
const isTypedArray$1 = isTypedArray_1;
const { CLIENT_ALIASES } = constants$2;
const { isFunction: isFunction$3 } = is;

// Check if the first argument is an array, otherwise uses all arguments as an
// array.
function normalizeArr$2(...args) {
  if (Array.isArray(args[0])) {
    return args[0];
  }

  return args;
}

function containsUndefined(mixed) {
  let argContainsUndefined = false;

  if (isTypedArray$1(mixed)) return false;

  if (mixed && isFunction$3(mixed.toSQL)) {
    //Any QueryBuilder or Raw will automatically be validated during compile.
    return argContainsUndefined;
  }

  if (Array.isArray(mixed)) {
    for (let i = 0; i < mixed.length; i++) {
      if (argContainsUndefined) break;
      argContainsUndefined = containsUndefined(mixed[i]);
    }
  } else if (isPlainObject$3(mixed)) {
    Object.keys(mixed).forEach((key) => {
      if (!argContainsUndefined) {
        argContainsUndefined = containsUndefined(mixed[key]);
      }
    });
  } else {
    argContainsUndefined = mixed === undefined;
  }

  return argContainsUndefined;
}

function getUndefinedIndices(mixed) {
  const indices = [];

  if (Array.isArray(mixed)) {
    mixed.forEach((item, index) => {
      if (containsUndefined(item)) {
        indices.push(index);
      }
    });
  } else if (isPlainObject$3(mixed)) {
    Object.keys(mixed).forEach((key) => {
      if (containsUndefined(mixed[key])) {
        indices.push(key);
      }
    });
  } else {
    indices.push(0);
  }

  return indices;
}

function addQueryContext$3(Target) {
  // Stores or returns (if called with no arguments) context passed to
  // wrapIdentifier and postProcessResponse hooks
  Target.prototype.queryContext = function (context) {
    if (context === undefined) {
      return this._queryContext;
    }
    this._queryContext = context;
    return this;
  };
}

function resolveClientNameWithAliases(clientName) {
  return CLIENT_ALIASES[clientName] || clientName;
}

function toNumber$1(val, fallback) {
  if (val === undefined || val === null) return fallback;
  const number = parseInt(val, 10);
  return isNaN(number) ? fallback : number;
}

var helpers$7 = {
  addQueryContext: addQueryContext$3,
  containsUndefined,
  getUndefinedIndices,
  normalizeArr: normalizeArr$2,
  resolveClientNameWithAliases,
  toNumber: toNumber$1,
};

const assert$2 = require$$0$6;

// JoinClause
// -------

function getClauseFromArguments(compilerType, bool, first, operator, second) {
  if (typeof first === 'function') {
    return {
      type: 'onWrapped',
      value: first,
      bool: bool,
    };
  }

  switch (arguments.length) {
    case 3:
      return { type: 'onRaw', value: first, bool };
    case 4:
      return {
        type: compilerType,
        column: first,
        operator: '=',
        value: operator,
        bool,
      };
    default:
      return {
        type: compilerType,
        column: first,
        operator,
        value: second,
        bool,
      };
  }
}

// The "JoinClause" is an object holding any necessary info about a join,
// including the type, and any associated tables & columns being joined.
let JoinClause$2 = class JoinClause {
  constructor(table, type, schema) {
    this.schema = schema;
    this.table = table;
    this.joinType = type;
    this.and = this;
    this.clauses = [];
  }

  get or() {
    return this._bool('or');
  }

  // Adds an "on" clause to the current join object.
  on(first) {
    if (typeof first === 'object' && typeof first.toSQL !== 'function') {
      const keys = Object.keys(first);
      let i = -1;
      const method = this._bool() === 'or' ? 'orOn' : 'on';
      while (++i < keys.length) {
        this[method](keys[i], first[keys[i]]);
      }
      return this;
    }

    const data = getClauseFromArguments('onBasic', this._bool(), ...arguments);

    if (data) {
      this.clauses.push(data);
    }

    return this;
  }

  // Adds an "or on" clause to the current join object.
  orOn(first, operator, second) {
    return this._bool('or').on.apply(this, arguments);
  }

  onJsonPathEquals(columnFirst, jsonPathFirst, columnSecond, jsonPathSecond) {
    this.clauses.push({
      type: 'onJsonPathEquals',
      columnFirst: columnFirst,
      jsonPathFirst: jsonPathFirst,
      columnSecond: columnSecond,
      jsonPathSecond: jsonPathSecond,
      bool: this._bool(),
      not: this._not(),
    });
    return this;
  }

  orOnJsonPathEquals(columnFirst, jsonPathFirst, columnSecond, jsonPathSecond) {
    return this._bool('or').onJsonPathEquals.apply(this, arguments);
  }

  // Adds a "using" clause to the current join.
  using(column) {
    return this.clauses.push({ type: 'onUsing', column, bool: this._bool() });
  }

  onVal(first) {
    if (typeof first === 'object' && typeof first.toSQL !== 'function') {
      const keys = Object.keys(first);
      let i = -1;
      const method = this._bool() === 'or' ? 'orOnVal' : 'onVal';
      while (++i < keys.length) {
        this[method](keys[i], first[keys[i]]);
      }
      return this;
    }

    const data = getClauseFromArguments('onVal', this._bool(), ...arguments);

    if (data) {
      this.clauses.push(data);
    }

    return this;
  }

  andOnVal() {
    return this.onVal(...arguments);
  }

  orOnVal() {
    return this._bool('or').onVal(...arguments);
  }

  onBetween(column, values) {
    assert$2(
      Array.isArray(values),
      'The second argument to onBetween must be an array.'
    );
    assert$2(
      values.length === 2,
      'You must specify 2 values for the onBetween clause'
    );
    this.clauses.push({
      type: 'onBetween',
      column,
      value: values,
      bool: this._bool(),
      not: this._not(),
    });
    return this;
  }

  onNotBetween(column, values) {
    return this._not(true).onBetween(column, values);
  }

  orOnBetween(column, values) {
    return this._bool('or').onBetween(column, values);
  }

  orOnNotBetween(column, values) {
    return this._bool('or')._not(true).onBetween(column, values);
  }

  onIn(column, values) {
    if (Array.isArray(values) && values.length === 0) return this.on(1, '=', 0);
    this.clauses.push({
      type: 'onIn',
      column,
      value: values,
      not: this._not(),
      bool: this._bool(),
    });
    return this;
  }

  onNotIn(column, values) {
    return this._not(true).onIn(column, values);
  }

  orOnIn(column, values) {
    return this._bool('or').onIn(column, values);
  }

  orOnNotIn(column, values) {
    return this._bool('or')._not(true).onIn(column, values);
  }

  onNull(column) {
    this.clauses.push({
      type: 'onNull',
      column,
      not: this._not(),
      bool: this._bool(),
    });
    return this;
  }

  orOnNull(callback) {
    return this._bool('or').onNull(callback);
  }

  onNotNull(callback) {
    return this._not(true).onNull(callback);
  }

  orOnNotNull(callback) {
    return this._not(true)._bool('or').onNull(callback);
  }

  onExists(callback) {
    this.clauses.push({
      type: 'onExists',
      value: callback,
      not: this._not(),
      bool: this._bool(),
    });
    return this;
  }

  orOnExists(callback) {
    return this._bool('or').onExists(callback);
  }

  onNotExists(callback) {
    return this._not(true).onExists(callback);
  }

  orOnNotExists(callback) {
    return this._not(true)._bool('or').onExists(callback);
  }

  // Explicitly set the type of join, useful within a function when creating a grouped join.
  type(type) {
    this.joinType = type;
    return this;
  }

  _bool(bool) {
    if (arguments.length === 1) {
      this._boolFlag = bool;
      return this;
    }
    const ret = this._boolFlag || 'and';
    this._boolFlag = 'and';
    return ret;
  }

  _not(val) {
    if (arguments.length === 1) {
      this._notFlag = val;
      return this;
    }
    const ret = this._notFlag;
    this._notFlag = false;
    return ret;
  }
};

Object.assign(JoinClause$2.prototype, {
  grouping: 'join',
});

JoinClause$2.prototype.andOn = JoinClause$2.prototype.on;
JoinClause$2.prototype.andOnIn = JoinClause$2.prototype.onIn;
JoinClause$2.prototype.andOnNotIn = JoinClause$2.prototype.onNotIn;
JoinClause$2.prototype.andOnNull = JoinClause$2.prototype.onNull;
JoinClause$2.prototype.andOnNotNull = JoinClause$2.prototype.onNotNull;
JoinClause$2.prototype.andOnExists = JoinClause$2.prototype.onExists;
JoinClause$2.prototype.andOnNotExists = JoinClause$2.prototype.onNotExists;
JoinClause$2.prototype.andOnBetween = JoinClause$2.prototype.onBetween;
JoinClause$2.prototype.andOnNotBetween = JoinClause$2.prototype.onNotBetween;
JoinClause$2.prototype.andOnJsonPathEquals =
  JoinClause$2.prototype.onJsonPathEquals;

var joinclause = JoinClause$2;

const assert$1 = require$$0$6;

// Analytic
// -------

// The "Analytic" is an object holding any necessary info about a analytic function
// e.g row_number, rank, dense_rank,
let Analytic$1 = class Analytic {
  constructor(method, schema, alias, orderBy, partitions) {
    this.schema = schema;
    this.type = 'analytic';
    this.method = method;
    this.order = orderBy || [];
    this.partitions = partitions || [];
    this.alias = alias;
    this.and = this;

    this.grouping = 'columns';
  }

  partitionBy(column, direction) {
    assert$1(
      Array.isArray(column) || typeof column === 'string',
      `The argument to an analytic partitionBy function must be either a string
            or an array of string.`
    );

    if (Array.isArray(column)) {
      this.partitions = this.partitions.concat(column);
    } else {
      this.partitions.push({ column: column, order: direction });
    }
    return this;
  }

  orderBy(column, direction) {
    assert$1(
      Array.isArray(column) || typeof column === 'string',
      `The argument to an analytic orderBy function must be either a string
            or an array of string.`
    );

    if (Array.isArray(column)) {
      this.order = this.order.concat(column);
    } else {
      this.order.push({ column: column, order: direction });
    }
    return this;
  }
};

var analytic = Analytic$1;

var saveAsyncStack$3 = function saveAsyncStack(instance, lines) {
  if (instance.client.config.asyncStackTraces) {
    // a hack to get a callstack into the client code despite this
    // node.js bug https://github.com/nodejs/node/issues/11865

    // Save error here but not error trace
    // reading trace with '--enable-source-maps' flag on node can be very costly

    instance._asyncStack = {
      error: new Error(),
      lines,
    };
  }
};

/**
 * internal constants, do not use in application code
 */

var constants$1 = {
  lockMode: {
    forShare: 'forShare',
    forUpdate: 'forUpdate',
    forNoKeyUpdate: 'forNoKeyUpdate',
    forKeyShare: 'forKeyShare',
  },
  waitMode: {
    skipLocked: 'skipLocked',
    noWait: 'noWait',
  },
};

const clone$1 = clone_1;
const isEmpty$3 = isEmpty_1;
const { callbackify } = require$$0$4;
const finallyMixin = finallyMixin_1;
const { formatQuery } = queryExecutioner;

function augmentWithBuilderInterface$3(Target) {
  Target.prototype.toQuery = function (tz) {
    let data = this.toSQL(this._method, tz);
    if (!Array.isArray(data)) data = [data];
    if (!data.length) {
      return '';
    }

    return data
      .map((statement) => {
        return formatQuery(statement.sql, statement.bindings, tz, this.client);
      })
      .reduce((a, c) => a.concat(a.endsWith(';') ? '\n' : ';\n', c));
  };

  // Create a new instance of the `Runner`, passing in the current object.
  Target.prototype.then = function (/* onFulfilled, onRejected */) {
    let result = this.client.runner(this).run();

    if (this.client.config.asyncStackTraces) {
      result = result.catch((err) => {
        err.originalStack = err.stack;
        const firstLine = err.stack.split('\n')[0];

        // a hack to get a callstack into the client code despite this
        // node.js bug https://github.com/nodejs/node/issues/11865
        // see lib/util/save-async-stack.js for more details
        const { error, lines } = this._asyncStack;
        const stackByLines = error.stack.split('\n');
        const asyncStack = stackByLines.slice(lines);
        asyncStack.unshift(firstLine);

        // put the fake more helpful "async" stack on the thrown error
        err.stack = asyncStack.join('\n');
        throw err;
      });
    }

    return result.then.apply(result, arguments);
  };

  // Add additional "options" to the builder. Typically used for client specific
  // items, like the `mysql` and `sqlite3` drivers.
  Target.prototype.options = function (opts) {
    this._options = this._options || [];
    this._options.push(clone$1(opts) || {});
    return this;
  };

  // Sets an explicit "connection" we wish to use for this query.
  Target.prototype.connection = function (connection) {
    this._connection = connection;
    this.client.processPassedConnection(connection);
    return this;
  };

  // Set a debug flag for the current schema query stack.
  Target.prototype.debug = function (enabled) {
    this._debug = arguments.length ? enabled : true;
    return this;
  };

  // Set the transaction object for this query.
  Target.prototype.transacting = function (transaction) {
    if (transaction && transaction.client) {
      if (!transaction.client.transacting) {
        transaction.client.logger.warn(
          `Invalid transaction value: ${transaction.client}`
        );
      } else {
        this.client = transaction.client;
      }
    }
    if (isEmpty$3(transaction)) {
      this.client.logger.error(
        'Invalid value on transacting call, potential bug'
      );
      throw Error(
        'Invalid transacting value (null, undefined or empty object)'
      );
    }
    return this;
  };

  // Initializes a stream.
  Target.prototype.stream = function (options) {
    return this.client.runner(this).stream(options);
  };

  // Initialize a stream & pipe automatically.
  Target.prototype.pipe = function (writable, options) {
    return this.client.runner(this).pipe(writable, options);
  };

  Target.prototype.asCallback = function (cb) {
    const promise = this.then();
    callbackify(() => promise)(cb);
    return promise;
  };

  Target.prototype.catch = function (onReject) {
    return this.then().catch(onReject);
  };

  Object.defineProperty(Target.prototype, Symbol.toStringTag, {
    get: () => 'object',
  });

  finallyMixin(Target.prototype);
}

var builderInterfaceAugmenter = {
  augmentWithBuilderInterface: augmentWithBuilderInterface$3,
};

// Builder
// -------
const assert = require$$0$6;
const { EventEmitter: EventEmitter$6 } = require$$0;
const assign$6 = assign_1;
const clone = clone_1;
const each$2 = eachExports;
const isEmpty$2 = isEmpty_1;
const isPlainObject$2 = isPlainObject_1;
const last = last_1;
const reject = reject_1;
const tail$3 = tail_1;
const toArray$3 = toArray_1;

const { addQueryContext: addQueryContext$2, normalizeArr: normalizeArr$1 } = helpers$7;
const JoinClause$1 = joinclause;
const Analytic = analytic;
const saveAsyncStack$2 = saveAsyncStack$3;
const {
  isBoolean,
  isNumber: isNumber$1,
  isObject: isObject$5,
  isString: isString$4,
  isFunction: isFunction$2,
} = is;

const { lockMode, waitMode } = constants$1;
const {
  augmentWithBuilderInterface: augmentWithBuilderInterface$2,
} = builderInterfaceAugmenter;

const SELECT_COMMANDS = new Set(['pluck', 'first', 'select']);
const CLEARABLE_STATEMENTS = new Set([
  'with',
  'select',
  'columns',
  'hintComments',
  'where',
  'union',
  'join',
  'group',
  'order',
  'having',
  'limit',
  'offset',
  'counter',
  'counters',
]);
const LOCK_MODES = new Set([
  lockMode.forShare,
  lockMode.forUpdate,
  lockMode.forNoKeyUpdate,
  lockMode.forKeyShare,
]);

// Typically called from `knex.builder`,
// start a new query building chain.
class Builder extends EventEmitter$6 {
  constructor(client) {
    super();
    this.client = client;
    this.and = this;
    this._single = {};
    this._statements = [];
    this._method = 'select';
    if (client.config) {
      saveAsyncStack$2(this, 5);
      this._debug = client.config.debug;
    }
    // Internal flags used in the builder.
    this._joinFlag = 'inner';
    this._boolFlag = 'and';
    this._notFlag = false;
    this._asColumnFlag = false;
  }

  toString() {
    return this.toQuery();
  }

  // Convert the current query "toSQL"
  toSQL(method, tz) {
    return this.client.queryCompiler(this).toSQL(method || this._method, tz);
  }

  // Create a shallow clone of the current query builder.
  clone() {
    const cloned = new this.constructor(this.client);
    cloned._method = this._method;
    cloned._single = clone(this._single);
    cloned._statements = clone(this._statements);
    cloned._debug = this._debug;

    // `_option` is assigned by the `Interface` mixin.
    if (this._options !== undefined) {
      cloned._options = clone(this._options);
    }
    if (this._queryContext !== undefined) {
      cloned._queryContext = clone(this._queryContext);
    }
    if (this._connection !== undefined) {
      cloned._connection = this._connection;
    }

    return cloned;
  }

  timeout(ms, { cancel } = {}) {
    if (isNumber$1(ms) && ms > 0) {
      this._timeout = ms;
      if (cancel) {
        this.client.assertCanCancelQuery();
        this._cancelOnTimeout = true;
      }
    }
    return this;
  }

  // With
  // ------
  isValidStatementArg(statement) {
    return (
      typeof statement === 'function' ||
      statement instanceof Builder ||
      (statement && statement.isRawInstance)
    );
  }

  _validateWithArgs(alias, statementOrColumnList, nothingOrStatement, method) {
    const [query, columnList] =
      typeof nothingOrStatement === 'undefined'
        ? [statementOrColumnList, undefined]
        : [nothingOrStatement, statementOrColumnList];
    if (typeof alias !== 'string') {
      throw new Error(`${method}() first argument must be a string`);
    }

    if (this.isValidStatementArg(query) && typeof columnList === 'undefined') {
      // Validated as two-arg variant (alias, statement).
      return;
    }

    // Attempt to interpret as three-arg variant (alias, columnList, statement).
    const isNonEmptyNameList =
      Array.isArray(columnList) &&
      columnList.length > 0 &&
      columnList.every((it) => typeof it === 'string');
    if (!isNonEmptyNameList) {
      throw new Error(
        `${method}() second argument must be a statement or non-empty column name list.`
      );
    }

    if (this.isValidStatementArg(query)) {
      return;
    }
    throw new Error(
      `${method}() third argument must be a function / QueryBuilder or a raw when its second argument is a column name list`
    );
  }

  with(alias, statementOrColumnList, nothingOrStatement) {
    this._validateWithArgs(
      alias,
      statementOrColumnList,
      nothingOrStatement,
      'with'
    );
    return this.withWrapped(alias, statementOrColumnList, nothingOrStatement);
  }

  withMaterialized(alias, statementOrColumnList, nothingOrStatement) {
    throw new Error('With materialized is not supported by this dialect');
  }

  withNotMaterialized(alias, statementOrColumnList, nothingOrStatement) {
    throw new Error('With materialized is not supported by this dialect');
  }

  // Helper for compiling any advanced `with` queries.
  withWrapped(alias, statementOrColumnList, nothingOrStatement, materialized) {
    const [query, columnList] =
      typeof nothingOrStatement === 'undefined'
        ? [statementOrColumnList, undefined]
        : [nothingOrStatement, statementOrColumnList];
    const statement = {
      grouping: 'with',
      type: 'withWrapped',
      alias: alias,
      columnList,
      value: query,
    };
    if (materialized !== undefined) {
      statement.materialized = materialized;
    }
    this._statements.push(statement);
    return this;
  }

  // With Recursive
  // ------

  withRecursive(alias, statementOrColumnList, nothingOrStatement) {
    this._validateWithArgs(
      alias,
      statementOrColumnList,
      nothingOrStatement,
      'withRecursive'
    );
    return this.withRecursiveWrapped(
      alias,
      statementOrColumnList,
      nothingOrStatement
    );
  }

  // Helper for compiling any advanced `withRecursive` queries.
  withRecursiveWrapped(alias, statementOrColumnList, nothingOrStatement) {
    this.withWrapped(alias, statementOrColumnList, nothingOrStatement);
    this._statements[this._statements.length - 1].recursive = true;
    return this;
  }

  // Select
  // ------

  // Adds a column or columns to the list of "columns"
  // being selected on the query.
  columns(column) {
    if (!column && column !== 0) return this;
    this._statements.push({
      grouping: 'columns',
      value: normalizeArr$1(...arguments),
    });
    return this;
  }

  // Allow for a sub-select to be explicitly aliased as a column,
  // without needing to compile the query in a where.
  as(column) {
    this._single.as = column;
    return this;
  }

  // Adds a single hint or an array of hits to the list of "hintComments" on the query.
  hintComment(hints) {
    hints = Array.isArray(hints) ? hints : [hints];
    if (hints.some((hint) => !isString$4(hint))) {
      throw new Error('Hint comment must be a string');
    }
    if (hints.some((hint) => hint.includes('/*') || hint.includes('*/'))) {
      throw new Error('Hint comment cannot include "/*" or "*/"');
    }
    if (hints.some((hint) => hint.includes('?'))) {
      throw new Error('Hint comment cannot include "?"');
    }
    this._statements.push({
      grouping: 'hintComments',
      value: hints,
    });
    return this;
  }

  // Prepends the `schemaName` on `tableName` defined by `.table` and `.join`.
  withSchema(schemaName) {
    this._single.schema = schemaName;
    return this;
  }

  // Sets the `tableName` on the query.
  // Alias to "from" for select and "into" for insert statements
  // e.g. builder.insert({a: value}).into('tableName')
  // `options`: options object containing keys:
  //   - `only`: whether the query should use SQL's ONLY to not return
  //           inheriting table data. Defaults to false.
  table(tableName, options = {}) {
    this._single.table = tableName;
    this._single.only = options.only === true;
    return this;
  }

  // Adds a `distinct` clause to the query.
  distinct(...args) {
    this._statements.push({
      grouping: 'columns',
      value: normalizeArr$1(...args),
      distinct: true,
    });
    return this;
  }

  distinctOn(...args) {
    if (isEmpty$2(args)) {
      throw new Error('distinctOn requires at least on argument');
    }
    this._statements.push({
      grouping: 'columns',
      value: normalizeArr$1(...args),
      distinctOn: true,
    });
    return this;
  }

  // Adds a join clause to the query, allowing for advanced joins
  // with an anonymous function as the second argument.
  join(table, first, ...args) {
    let join;
    const schema =
      table instanceof Builder || typeof table === 'function'
        ? undefined
        : this._single.schema;
    const joinType = this._joinType();
    if (typeof first === 'function') {
      join = new JoinClause$1(table, joinType, schema);
      first.call(join, join);
    } else if (joinType === 'raw') {
      join = new JoinClause$1(this.client.raw(table, first), 'raw');
    } else {
      join = new JoinClause$1(table, joinType, schema);
      if (first) {
        join.on(first, ...args);
      }
    }
    this._statements.push(join);
    return this;
  }

  using(tables) {
    throw new Error(
      "'using' function is only available in PostgreSQL dialect with Delete statements."
    );
  }

  // JOIN blocks:
  innerJoin(...args) {
    return this._joinType('inner').join(...args);
  }

  leftJoin(...args) {
    return this._joinType('left').join(...args);
  }

  leftOuterJoin(...args) {
    return this._joinType('left outer').join(...args);
  }

  rightJoin(...args) {
    return this._joinType('right').join(...args);
  }

  rightOuterJoin(...args) {
    return this._joinType('right outer').join(...args);
  }

  outerJoin(...args) {
    return this._joinType('outer').join(...args);
  }

  fullOuterJoin(...args) {
    return this._joinType('full outer').join(...args);
  }

  crossJoin(...args) {
    return this._joinType('cross').join(...args);
  }

  joinRaw(...args) {
    return this._joinType('raw').join(...args);
  }

  // Where modifiers:
  get or() {
    return this._bool('or');
  }

  get not() {
    return this._not(true);
  }

  // The where function can be used in several ways:
  // The most basic is `where(key, value)`, which expands to
  // where key = value.
  where(column, operator, value) {
    const argsLength = arguments.length;

    // Support "where true || where false"
    if (column === false || column === true) {
      return this.where(1, '=', column ? 1 : 0);
    }

    // Check if the column is a function, in which case it's
    // a where statement wrapped in parens.
    if (typeof column === 'function') {
      return this.whereWrapped(column);
    }

    // Allows `where({id: 2})` syntax.
    if (isObject$5(column) && !column.isRawInstance)
      return this._objectWhere(column);

    // Allow a raw statement to be passed along to the query.
    if (column && column.isRawInstance && argsLength === 1)
      return this.whereRaw(column);

    // Enable the where('key', value) syntax, only when there
    // are explicitly two arguments passed, so it's not possible to
    // do where('key', '!=') and have that turn into where key != null
    if (argsLength === 2) {
      value = operator;
      operator = '=';

      // If the value is null, and it's a two argument query,
      // we assume we're going for a `whereNull`.
      if (value === null) {
        return this.whereNull(column);
      }
    }

    // lower case the operator for comparison purposes
    const checkOperator = `${operator}`.toLowerCase().trim();

    // If there are 3 arguments, check whether 'in' is one of them.
    if (argsLength === 3) {
      if (checkOperator === 'in' || checkOperator === 'not in') {
        return this._not(checkOperator === 'not in').whereIn(column, value);
      }
      if (checkOperator === 'between' || checkOperator === 'not between') {
        return this._not(checkOperator === 'not between').whereBetween(
          column,
          value
        );
      }
    }

    // If the value is still null, check whether they're meaning
    // where value is null
    if (value === null) {
      // Check for .where(key, 'is', null) or .where(key, 'is not', 'null');
      if (checkOperator === 'is' || checkOperator === 'is not') {
        return this._not(checkOperator === 'is not').whereNull(column);
      }
    }

    // Push onto the where statement stack.
    this._statements.push({
      grouping: 'where',
      type: 'whereBasic',
      column,
      operator,
      value,
      not: this._not(),
      bool: this._bool(),
      asColumn: this._asColumnFlag,
    });
    return this;
  }

  whereColumn(...args) {
    this._asColumnFlag = true;
    this.where(...args);
    this._asColumnFlag = false;
    return this;
  }

  // Adds an `or where` clause to the query.
  orWhere(column, ...args) {
    this._bool('or');
    const obj = column;
    if (isObject$5(obj) && !obj.isRawInstance) {
      return this.whereWrapped(function () {
        for (const key in obj) {
          this.andWhere(key, obj[key]);
        }
      });
    }
    return this.where(column, ...args);
  }

  orWhereColumn(column, ...args) {
    this._bool('or');
    const obj = column;
    if (isObject$5(obj) && !obj.isRawInstance) {
      return this.whereWrapped(function () {
        for (const key in obj) {
          this.andWhereColumn(key, '=', obj[key]);
        }
      });
    }
    return this.whereColumn(column, ...args);
  }

  // Adds an `not where` clause to the query.
  whereNot(column, ...args) {
    if (args.length >= 2) {
      if (args[0] === 'in' || args[0] === 'between') {
        this.client.logger.warn(
          'whereNot is not suitable for "in" and "between" type subqueries. You should use "not in" and "not between" instead.'
        );
      }
    }
    return this._not(true).where(column, ...args);
  }

  whereNotColumn(...args) {
    return this._not(true).whereColumn(...args);
  }

  // Adds an `or not where` clause to the query.
  orWhereNot(...args) {
    return this._bool('or').whereNot(...args);
  }

  orWhereNotColumn(...args) {
    return this._bool('or').whereNotColumn(...args);
  }

  // Processes an object literal provided in a "where" clause.
  _objectWhere(obj) {
    const boolVal = this._bool();
    const notVal = this._not() ? 'Not' : '';
    for (const key in obj) {
      this[boolVal + 'Where' + notVal](key, obj[key]);
    }
    return this;
  }

  // Adds a raw `where` clause to the query.
  whereRaw(sql, bindings) {
    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);

    this._statements.push({
      grouping: 'where',
      type: 'whereRaw',
      value: raw,
      not: this._not(),
      bool: this._bool(),
    });
    return this;
  }

  orWhereRaw(sql, bindings) {
    return this._bool('or').whereRaw(sql, bindings);
  }

  // Helper for compiling any advanced `where` queries.
  whereWrapped(callback) {
    this._statements.push({
      grouping: 'where',
      type: 'whereWrapped',
      value: callback,
      not: this._not(),
      bool: this._bool(),
    });
    return this;
  }

  // Adds a `where exists` clause to the query.
  whereExists(callback) {
    this._statements.push({
      grouping: 'where',
      type: 'whereExists',
      value: callback,
      not: this._not(),
      bool: this._bool(),
    });
    return this;
  }

  // Adds an `or where exists` clause to the query.
  orWhereExists(callback) {
    return this._bool('or').whereExists(callback);
  }

  // Adds a `where not exists` clause to the query.
  whereNotExists(callback) {
    return this._not(true).whereExists(callback);
  }

  // Adds a `or where not exists` clause to the query.
  orWhereNotExists(callback) {
    return this._bool('or').whereNotExists(callback);
  }

  // Adds a `where in` clause to the query.
  whereIn(column, values) {
    if (Array.isArray(values) && isEmpty$2(values))
      return this.where(this._not());
    this._statements.push({
      grouping: 'where',
      type: 'whereIn',
      column,
      value: values,
      not: this._not(),
      bool: this._bool(),
    });
    return this;
  }

  // Adds a `or where in` clause to the query.
  orWhereIn(column, values) {
    return this._bool('or').whereIn(column, values);
  }

  // Adds a `where not in` clause to the query.
  whereNotIn(column, values) {
    return this._not(true).whereIn(column, values);
  }

  // Adds a `or where not in` clause to the query.
  orWhereNotIn(column, values) {
    return this._bool('or')._not(true).whereIn(column, values);
  }

  // Adds a `where null` clause to the query.
  whereNull(column) {
    this._statements.push({
      grouping: 'where',
      type: 'whereNull',
      column,
      not: this._not(),
      bool: this._bool(),
    });
    return this;
  }

  // Adds a `or where null` clause to the query.
  orWhereNull(column) {
    return this._bool('or').whereNull(column);
  }

  // Adds a `where not null` clause to the query.
  whereNotNull(column) {
    return this._not(true).whereNull(column);
  }

  // Adds a `or where not null` clause to the query.
  orWhereNotNull(column) {
    return this._bool('or').whereNotNull(column);
  }

  // Adds a `where between` clause to the query.
  whereBetween(column, values) {
    assert(
      Array.isArray(values),
      'The second argument to whereBetween must be an array.'
    );
    assert(
      values.length === 2,
      'You must specify 2 values for the whereBetween clause'
    );
    this._statements.push({
      grouping: 'where',
      type: 'whereBetween',
      column,
      value: values,
      not: this._not(),
      bool: this._bool(),
    });
    return this;
  }

  // Adds a `where not between` clause to the query.
  whereNotBetween(column, values) {
    return this._not(true).whereBetween(column, values);
  }

  // Adds a `or where between` clause to the query.
  orWhereBetween(column, values) {
    return this._bool('or').whereBetween(column, values);
  }

  // Adds a `or where not between` clause to the query.
  orWhereNotBetween(column, values) {
    return this._bool('or').whereNotBetween(column, values);
  }

  _whereLike(type, column, value) {
    this._statements.push({
      grouping: 'where',
      type: type,
      column,
      value: value,
      not: this._not(),
      bool: this._bool(),
      asColumn: this._asColumnFlag,
    });
    return this;
  }

  // Adds a `where like` clause to the query.
  whereLike(column, value) {
    return this._whereLike('whereLike', column, value);
  }

  // Adds a `or where like` clause to the query.
  orWhereLike(column, value) {
    return this._bool('or')._whereLike('whereLike', column, value);
  }

  // Adds a `where ilike` clause to the query.
  whereILike(column, value) {
    return this._whereLike('whereILike', column, value);
  }

  // Adds a `or where ilike` clause to the query.
  orWhereILike(column, value) {
    return this._bool('or')._whereLike('whereILike', column, value);
  }

  // Adds a `group by` clause to the query.
  groupBy(item) {
    if (item && item.isRawInstance) {
      return this.groupByRaw.apply(this, arguments);
    }
    this._statements.push({
      grouping: 'group',
      type: 'groupByBasic',
      value: normalizeArr$1(...arguments),
    });
    return this;
  }

  // Adds a raw `group by` clause to the query.
  groupByRaw(sql, bindings) {
    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);
    this._statements.push({
      grouping: 'group',
      type: 'groupByRaw',
      value: raw,
    });
    return this;
  }

  // Adds a `order by` clause to the query.
  orderBy(column, direction, nulls = '') {
    if (Array.isArray(column)) {
      return this._orderByArray(column);
    }
    this._statements.push({
      grouping: 'order',
      type: 'orderByBasic',
      value: column,
      direction,
      nulls,
    });
    return this;
  }

  // Adds a `order by` with multiple columns to the query.
  _orderByArray(columnDefs) {
    for (let i = 0; i < columnDefs.length; i++) {
      const columnInfo = columnDefs[i];
      if (isObject$5(columnInfo)) {
        this._statements.push({
          grouping: 'order',
          type: 'orderByBasic',
          value: columnInfo['column'],
          direction: columnInfo['order'],
          nulls: columnInfo['nulls'],
        });
      } else if (isString$4(columnInfo)) {
        this._statements.push({
          grouping: 'order',
          type: 'orderByBasic',
          value: columnInfo,
        });
      }
    }
    return this;
  }

  // Add a raw `order by` clause to the query.
  orderByRaw(sql, bindings) {
    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);
    this._statements.push({
      grouping: 'order',
      type: 'orderByRaw',
      value: raw,
    });
    return this;
  }

  _union(clause, args) {
    let callbacks = args[0];
    let wrap = args[1];
    if (args.length === 1 || (args.length === 2 && isBoolean(wrap))) {
      if (!Array.isArray(callbacks)) {
        callbacks = [callbacks];
      }
      for (let i = 0, l = callbacks.length; i < l; i++) {
        this._statements.push({
          grouping: 'union',
          clause: clause,
          value: callbacks[i],
          wrap: wrap || false,
        });
      }
    } else {
      callbacks = toArray$3(args).slice(0, args.length - 1);
      wrap = args[args.length - 1];
      if (!isBoolean(wrap)) {
        callbacks.push(wrap);
        wrap = false;
      }
      this._union(clause, [callbacks, wrap]);
    }
    return this;
  }

  // Add a union statement to the query.
  union(...args) {
    return this._union('union', args);
  }

  // Adds a union all statement to the query.
  unionAll(...args) {
    return this._union('union all', args);
  }

  // Adds an intersect statement to the query
  intersect(callbacks, wrap) {
    if (arguments.length === 1 || (arguments.length === 2 && isBoolean(wrap))) {
      if (!Array.isArray(callbacks)) {
        callbacks = [callbacks];
      }
      for (let i = 0, l = callbacks.length; i < l; i++) {
        this._statements.push({
          grouping: 'union',
          clause: 'intersect',
          value: callbacks[i],
          wrap: wrap || false,
        });
      }
    } else {
      callbacks = toArray$3(arguments).slice(0, arguments.length - 1);
      wrap = arguments[arguments.length - 1];
      if (!isBoolean(wrap)) {
        callbacks.push(wrap);
        wrap = false;
      }
      this.intersect(callbacks, wrap);
    }
    return this;
  }

  // Adds a `having` clause to the query.
  having(column, operator, value) {
    if (column.isRawInstance && arguments.length === 1) {
      return this.havingRaw(column);
    }

    // Check if the column is a function, in which case it's
    // a having statement wrapped in parens.
    if (typeof column === 'function') {
      return this.havingWrapped(column);
    }

    this._statements.push({
      grouping: 'having',
      type: 'havingBasic',
      column,
      operator,
      value,
      bool: this._bool(),
      not: this._not(),
    });
    return this;
  }

  orHaving(column, ...args) {
    this._bool('or');
    const obj = column;
    if (isObject$5(obj) && !obj.isRawInstance) {
      return this.havingWrapped(function () {
        for (const key in obj) {
          this.andHaving(key, obj[key]);
        }
      });
    }
    return this.having(column, ...args);
  }

  // Helper for compiling any advanced `having` queries.
  havingWrapped(callback) {
    this._statements.push({
      grouping: 'having',
      type: 'havingWrapped',
      value: callback,
      bool: this._bool(),
      not: this._not(),
    });
    return this;
  }

  havingNull(column) {
    this._statements.push({
      grouping: 'having',
      type: 'havingNull',
      column,
      not: this._not(),
      bool: this._bool(),
    });
    return this;
  }

  orHavingNull(callback) {
    return this._bool('or').havingNull(callback);
  }

  havingNotNull(callback) {
    return this._not(true).havingNull(callback);
  }

  orHavingNotNull(callback) {
    return this._not(true)._bool('or').havingNull(callback);
  }

  havingExists(callback) {
    this._statements.push({
      grouping: 'having',
      type: 'havingExists',
      value: callback,
      not: this._not(),
      bool: this._bool(),
    });
    return this;
  }

  orHavingExists(callback) {
    return this._bool('or').havingExists(callback);
  }

  havingNotExists(callback) {
    return this._not(true).havingExists(callback);
  }

  orHavingNotExists(callback) {
    return this._not(true)._bool('or').havingExists(callback);
  }

  havingBetween(column, values) {
    assert(
      Array.isArray(values),
      'The second argument to havingBetween must be an array.'
    );
    assert(
      values.length === 2,
      'You must specify 2 values for the havingBetween clause'
    );
    this._statements.push({
      grouping: 'having',
      type: 'havingBetween',
      column,
      value: values,
      not: this._not(),
      bool: this._bool(),
    });
    return this;
  }

  orHavingBetween(column, values) {
    return this._bool('or').havingBetween(column, values);
  }

  havingNotBetween(column, values) {
    return this._not(true).havingBetween(column, values);
  }

  orHavingNotBetween(column, values) {
    return this._not(true)._bool('or').havingBetween(column, values);
  }

  havingIn(column, values) {
    if (Array.isArray(values) && isEmpty$2(values))
      return this.where(this._not());
    this._statements.push({
      grouping: 'having',
      type: 'havingIn',
      column,
      value: values,
      not: this._not(),
      bool: this._bool(),
    });
    return this;
  }

  // Adds a `or where in` clause to the query.
  orHavingIn(column, values) {
    return this._bool('or').havingIn(column, values);
  }

  // Adds a `where not in` clause to the query.
  havingNotIn(column, values) {
    return this._not(true).havingIn(column, values);
  }

  // Adds a `or where not in` clause to the query.
  orHavingNotIn(column, values) {
    return this._bool('or')._not(true).havingIn(column, values);
  }

  // Adds a raw `having` clause to the query.
  havingRaw(sql, bindings) {
    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);
    this._statements.push({
      grouping: 'having',
      type: 'havingRaw',
      value: raw,
      bool: this._bool(),
      not: this._not(),
    });
    return this;
  }

  orHavingRaw(sql, bindings) {
    return this._bool('or').havingRaw(sql, bindings);
  }

  // set the skip binding parameter (= insert the raw value in the query) for an attribute.
  _setSkipBinding(attribute, options) {
    let skipBinding = options;
    if (isObject$5(options)) {
      skipBinding = options.skipBinding;
    }
    this._single.skipBinding = this._single.skipBinding || {};
    this._single.skipBinding[attribute] = skipBinding;
  }

  // Only allow a single "offset" to be set for the current query.
  offset(value, options) {
    if (value == null || value.isRawInstance || value instanceof Builder) {
      // Builder for backward compatibility
      this._single.offset = value;
    } else {
      const val = parseInt(value, 10);
      if (isNaN(val)) {
        this.client.logger.warn('A valid integer must be provided to offset');
      } else if (val < 0) {
        throw new Error(`A non-negative integer must be provided to offset.`);
      } else {
        this._single.offset = val;
      }
    }
    this._setSkipBinding('offset', options);
    return this;
  }

  // Only allow a single "limit" to be set for the current query.
  limit(value, options) {
    const val = parseInt(value, 10);
    if (isNaN(val)) {
      this.client.logger.warn('A valid integer must be provided to limit');
    } else {
      this._single.limit = val;
      this._setSkipBinding('limit', options);
    }
    return this;
  }

  // Retrieve the "count" result of the query.
  count(column, options) {
    return this._aggregate('count', column || '*', options);
  }

  // Retrieve the minimum value of a given column.
  min(column, options) {
    return this._aggregate('min', column, options);
  }

  // Retrieve the maximum value of a given column.
  max(column, options) {
    return this._aggregate('max', column, options);
  }

  // Retrieve the sum of the values of a given column.
  sum(column, options) {
    return this._aggregate('sum', column, options);
  }

  // Retrieve the average of the values of a given column.
  avg(column, options) {
    return this._aggregate('avg', column, options);
  }

  // Retrieve the "count" of the distinct results of the query.
  countDistinct(...columns) {
    let options;
    if (columns.length > 1 && isPlainObject$2(last(columns))) {
      [options] = columns.splice(columns.length - 1, 1);
    }

    if (!columns.length) {
      columns = '*';
    } else if (columns.length === 1) {
      columns = columns[0];
    }

    return this._aggregate('count', columns, { ...options, distinct: true });
  }

  // Retrieve the sum of the distinct values of a given column.
  sumDistinct(column, options) {
    return this._aggregate('sum', column, { ...options, distinct: true });
  }

  // Retrieve the vg of the distinct results of the query.
  avgDistinct(column, options) {
    return this._aggregate('avg', column, { ...options, distinct: true });
  }

  // Increments a column's value by the specified amount.
  increment(column, amount = 1) {
    if (isObject$5(column)) {
      for (const key in column) {
        this._counter(key, column[key]);
      }

      return this;
    }

    return this._counter(column, amount);
  }

  // Decrements a column's value by the specified amount.
  decrement(column, amount = 1) {
    if (isObject$5(column)) {
      for (const key in column) {
        this._counter(key, -column[key]);
      }

      return this;
    }

    return this._counter(column, -amount);
  }

  // Clears increments/decrements
  clearCounters() {
    this._single.counter = {};
    return this;
  }

  // Sets the values for a `select` query, informing that only the first
  // row should be returned (limit 1).
  first(...args) {
    if (this._method && this._method !== 'select') {
      throw new Error(`Cannot chain .first() on "${this._method}" query`);
    }

    this.select(normalizeArr$1(...args));
    this._method = 'first';
    this.limit(1);
    return this;
  }

  // Use existing connection to execute the query
  // Same value that client.acquireConnection() for an according client returns should be passed
  connection(_connection) {
    this._connection = _connection;
    this.client.processPassedConnection(_connection);
    return this;
  }

  // Pluck a column from a query.
  pluck(column) {
    if (this._method && this._method !== 'select') {
      throw new Error(`Cannot chain .pluck() on "${this._method}" query`);
    }

    this._method = 'pluck';
    this._single.pluck = column;
    this._statements.push({
      grouping: 'columns',
      type: 'pluck',
      value: column,
    });
    return this;
  }

  // Deprecated. Remove everything from select clause
  clearSelect() {
    this._clearGrouping('columns');
    return this;
  }

  // Deprecated. Remove everything from where clause
  clearWhere() {
    this._clearGrouping('where');
    return this;
  }

  // Deprecated. Remove everything from group clause
  clearGroup() {
    this._clearGrouping('group');
    return this;
  }

  // Deprecated. Remove everything from order clause
  clearOrder() {
    this._clearGrouping('order');
    return this;
  }

  // Deprecated. Remove everything from having clause
  clearHaving() {
    this._clearGrouping('having');
    return this;
  }

  // Remove everything from statement clause
  clear(statement) {
    if (!CLEARABLE_STATEMENTS.has(statement))
      throw new Error(`Knex Error: unknown statement '${statement}'`);
    if (statement.startsWith('counter')) return this.clearCounters();
    if (statement === 'select') {
      statement = 'columns';
    }
    this._clearGrouping(statement);
    return this;
  }

  // Insert & Update
  // ------

  // Sets the values for an `insert` query.
  insert(values, returning, options) {
    this._method = 'insert';
    if (!isEmpty$2(returning)) this.returning(returning, options);
    this._single.insert = values;
    return this;
  }

  // Sets the values for an `update`, allowing for both
  // `.update(key, value, [returning])` and `.update(obj, [returning])` syntaxes.
  update(values, returning, options) {
    let ret;
    const obj = this._single.update || {};
    this._method = 'update';
    if (isString$4(values)) {
      if (isPlainObject$2(returning)) {
        obj[values] = JSON.stringify(returning);
      } else {
        obj[values] = returning;
      }
      if (arguments.length > 2) {
        ret = arguments[2];
      }
    } else {
      const keys = Object.keys(values);
      if (this._single.update) {
        this.client.logger.warn('Update called multiple times with objects.');
      }
      let i = -1;
      while (++i < keys.length) {
        obj[keys[i]] = values[keys[i]];
      }
      ret = arguments[1];
    }
    if (!isEmpty$2(ret)) this.returning(ret, options);
    this._single.update = obj;
    return this;
  }

  // Sets the returning value for the query.
  returning(returning, options) {
    this._single.returning = returning;
    this._single.options = options;
    return this;
  }

  onConflict(columns) {
    if (typeof columns === 'string') {
      columns = [columns];
    }
    return new OnConflictBuilder(this, columns || true);
  }

  // Delete
  // ------

  // Executes a delete statement on the query;
  delete(ret, options) {
    this._method = 'del';
    if (!isEmpty$2(ret)) this.returning(ret, options);
    return this;
  }

  // Truncates a table, ends the query chain.
  truncate(tableName) {
    this._method = 'truncate';
    if (tableName) {
      this._single.table = tableName;
    }
    return this;
  }

  // Retrieves columns for the table specified by `knex(tableName)`
  columnInfo(column) {
    this._method = 'columnInfo';
    this._single.columnInfo = column;
    return this;
  }

  // Set a lock for update constraint.
  forUpdate(...tables) {
    this._single.lock = lockMode.forUpdate;
    if (tables.length === 1 && Array.isArray(tables[0])) {
      this._single.lockTables = tables[0];
    } else {
      this._single.lockTables = tables;
    }
    return this;
  }

  // Set a lock for share constraint.
  forShare(...tables) {
    this._single.lock = lockMode.forShare;
    this._single.lockTables = tables;
    return this;
  }

  // Set a lock for no key update constraint.
  forNoKeyUpdate(...tables) {
    this._single.lock = lockMode.forNoKeyUpdate;
    this._single.lockTables = tables;
    return this;
  }

  // Set a lock for key share constraint.
  forKeyShare(...tables) {
    this._single.lock = lockMode.forKeyShare;
    this._single.lockTables = tables;
    return this;
  }

  // Skips locked rows when using a lock constraint.
  skipLocked() {
    if (!this._isSelectQuery()) {
      throw new Error(`Cannot chain .skipLocked() on "${this._method}" query!`);
    }
    if (!this._hasLockMode()) {
      throw new Error(
        '.skipLocked() can only be used after a call to .forShare() or .forUpdate()!'
      );
    }
    if (this._single.waitMode === waitMode.noWait) {
      throw new Error('.skipLocked() cannot be used together with .noWait()!');
    }
    this._single.waitMode = waitMode.skipLocked;
    return this;
  }

  // Causes error when acessing a locked row instead of waiting for it to be released.
  noWait() {
    if (!this._isSelectQuery()) {
      throw new Error(`Cannot chain .noWait() on "${this._method}" query!`);
    }
    if (!this._hasLockMode()) {
      throw new Error(
        '.noWait() can only be used after a call to .forShare() or .forUpdate()!'
      );
    }
    if (this._single.waitMode === waitMode.skipLocked) {
      throw new Error('.noWait() cannot be used together with .skipLocked()!');
    }
    this._single.waitMode = waitMode.noWait;
    return this;
  }

  // Takes a JS object of methods to call and calls them
  fromJS(obj) {
    each$2(obj, (val, key) => {
      if (typeof this[key] !== 'function') {
        this.client.logger.warn(`Knex Error: unknown key ${key}`);
      }
      if (Array.isArray(val)) {
        this[key].apply(this, val);
      } else {
        this[key](val);
      }
    });
    return this;
  }

  fromRaw(sql, bindings) {
    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);
    return this.from(raw);
  }

  // Passes query to provided callback function, useful for e.g. composing
  // domain-specific helpers
  modify(callback) {
    callback.apply(this, [this].concat(tail$3(arguments)));
    return this;
  }

  upsert(values, returning, options) {
    throw new Error(
      `Upsert is not yet supported for dialect ${this.client.dialect}`
    );
  }

  // JSON support functions
  _json(nameFunction, params) {
    this._statements.push({
      grouping: 'columns',
      type: 'json',
      method: nameFunction,
      params: params,
    });
    return this;
  }

  jsonExtract() {
    const column = arguments[0];
    let path;
    let alias;
    let singleValue = true;

    // We use arguments to have the signatures :
    // - column (string or array)
    // - column + path
    // - column + path + alias
    // - column + path + alias + singleValue
    // - column array + singleValue
    if (arguments.length >= 2) {
      path = arguments[1];
    }
    if (arguments.length >= 3) {
      alias = arguments[2];
    }
    if (arguments.length === 4) {
      singleValue = arguments[3];
    }
    if (
      arguments.length === 2 &&
      Array.isArray(arguments[0]) &&
      isBoolean(arguments[1])
    ) {
      singleValue = arguments[1];
    }
    return this._json('jsonExtract', {
      column: column,
      path: path,
      alias: alias,
      singleValue, // boolean used only in MSSQL to use function for extract value instead of object/array.
    });
  }

  jsonSet(column, path, value, alias) {
    return this._json('jsonSet', {
      column: column,
      path: path,
      value: value,
      alias: alias,
    });
  }

  jsonInsert(column, path, value, alias) {
    return this._json('jsonInsert', {
      column: column,
      path: path,
      value: value,
      alias: alias,
    });
  }

  jsonRemove(column, path, alias) {
    return this._json('jsonRemove', {
      column: column,
      path: path,
      alias: alias,
    });
  }

  // Wheres for JSON
  _isJsonObject(jsonValue) {
    return isObject$5(jsonValue) && !(jsonValue instanceof Builder);
  }

  _whereJsonWrappedValue(type, column, value) {
    const whereJsonClause = {
      grouping: 'where',
      type: type,
      column,
      value: value,
      not: this._not(),
      bool: this._bool(),
      asColumn: this._asColumnFlag,
    };
    if (arguments[3]) {
      whereJsonClause.operator = arguments[3];
    }
    if (arguments[4]) {
      whereJsonClause.jsonPath = arguments[4];
    }
    this._statements.push(whereJsonClause);
  }

  whereJsonObject(column, value) {
    this._whereJsonWrappedValue('whereJsonObject', column, value);
    return this;
  }

  orWhereJsonObject(column, value) {
    return this._bool('or').whereJsonObject(column, value);
  }

  whereNotJsonObject(column, value) {
    return this._not(true).whereJsonObject(column, value);
  }

  orWhereNotJsonObject(column, value) {
    return this._bool('or').whereNotJsonObject(column, value);
  }

  whereJsonPath(column, path, operator, value) {
    this._whereJsonWrappedValue('whereJsonPath', column, value, operator, path);
    return this;
  }

  orWhereJsonPath(column, path, operator, value) {
    return this._bool('or').whereJsonPath(column, path, operator, value);
  }

  // Json superset wheres
  whereJsonSupersetOf(column, value) {
    this._whereJsonWrappedValue('whereJsonSupersetOf', column, value);
    return this;
  }

  whereJsonNotSupersetOf(column, value) {
    return this._not(true).whereJsonSupersetOf(column, value);
  }

  orWhereJsonSupersetOf(column, value) {
    return this._bool('or').whereJsonSupersetOf(column, value);
  }

  orWhereJsonNotSupersetOf(column, value) {
    return this._bool('or').whereJsonNotSupersetOf(column, value);
  }

  // Json subset wheres
  whereJsonSubsetOf(column, value) {
    this._whereJsonWrappedValue('whereJsonSubsetOf', column, value);
    return this;
  }

  whereJsonNotSubsetOf(column, value) {
    return this._not(true).whereJsonSubsetOf(column, value);
  }

  orWhereJsonSubsetOf(column, value) {
    return this._bool('or').whereJsonSubsetOf(column, value);
  }

  orWhereJsonNotSubsetOf(column, value) {
    return this._bool('or').whereJsonNotSubsetOf(column, value);
  }

  whereJsonHasNone(column, values) {
    this._not(true).whereJsonHasAll(column, values);
    return this;
  }

  // end of wheres for JSON

  _analytic(alias, second, third) {
    let analytic;
    const { schema } = this._single;
    const method = this._analyticMethod();
    alias = typeof alias === 'string' ? alias : null;

    assert(
      typeof second === 'function' ||
        second.isRawInstance ||
        Array.isArray(second) ||
        typeof second === 'string' ||
        typeof second === 'object',
      `The second argument to an analytic function must be either a function, a raw,
       an array of string or object, an object or a single string.`
    );

    if (third) {
      assert(
        Array.isArray(third) ||
          typeof third === 'string' ||
          typeof third === 'object',
        'The third argument to an analytic function must be either a string, an array of string or object or an object.'
      );
    }

    if (isFunction$2(second)) {
      analytic = new Analytic(method, schema, alias);
      second.call(analytic, analytic);
    } else if (second.isRawInstance) {
      const raw = second;
      analytic = {
        grouping: 'columns',
        type: 'analytic',
        method: method,
        raw: raw,
        alias: alias,
      };
    } else {
      const order = !Array.isArray(second) ? [second] : second;
      let partitions = third || [];
      partitions = !Array.isArray(partitions) ? [partitions] : partitions;
      analytic = {
        grouping: 'columns',
        type: 'analytic',
        method: method,
        order: order,
        alias: alias,
        partitions: partitions,
      };
    }
    this._statements.push(analytic);
    return this;
  }

  rank(...args) {
    return this._analyticMethod('rank')._analytic(...args);
  }

  denseRank(...args) {
    return this._analyticMethod('dense_rank')._analytic(...args);
  }

  rowNumber(...args) {
    return this._analyticMethod('row_number')._analytic(...args);
  }

  // ----------------------------------------------------------------------

  // Helper for the incrementing/decrementing queries.
  _counter(column, amount) {
    amount = parseFloat(amount);

    this._method = 'update';

    this._single.counter = this._single.counter || {};

    this._single.counter[column] = amount;

    return this;
  }

  // Helper to get or set the "boolFlag" value.
  _bool(val) {
    if (arguments.length === 1) {
      this._boolFlag = val;
      return this;
    }
    const ret = this._boolFlag;
    this._boolFlag = 'and';
    return ret;
  }

  // Helper to get or set the "notFlag" value.
  _not(val) {
    if (arguments.length === 1) {
      this._notFlag = val;
      return this;
    }
    const ret = this._notFlag;
    this._notFlag = false;
    return ret;
  }

  // Helper to get or set the "joinFlag" value.
  _joinType(val) {
    if (arguments.length === 1) {
      this._joinFlag = val;
      return this;
    }
    const ret = this._joinFlag || 'inner';
    this._joinFlag = 'inner';
    return ret;
  }

  _analyticMethod(val) {
    if (arguments.length === 1) {
      this._analyticFlag = val;
      return this;
    }
    return this._analyticFlag || 'row_number';
  }

  // Helper for compiling any aggregate queries.
  _aggregate(method, column, options = {}) {
    this._statements.push({
      grouping: 'columns',
      type: column.isRawInstance ? 'aggregateRaw' : 'aggregate',
      method,
      value: column,
      aggregateDistinct: options.distinct || false,
      alias: options.as,
    });
    return this;
  }

  // Helper function for clearing or reseting a grouping type from the builder
  _clearGrouping(grouping) {
    if (grouping in this._single) {
      this._single[grouping] = undefined;
    } else {
      this._statements = reject(this._statements, { grouping });
    }
  }

  // Helper function that checks if the builder will emit a select query
  _isSelectQuery() {
    return SELECT_COMMANDS.has(this._method);
  }

  // Helper function that checks if the query has a lock mode set
  _hasLockMode() {
    return LOCK_MODES.has(this._single.lock);
  }
}

Builder.prototype.select = Builder.prototype.columns;
Builder.prototype.column = Builder.prototype.columns;
Builder.prototype.andWhereNot = Builder.prototype.whereNot;
Builder.prototype.andWhereNotColumn = Builder.prototype.whereNotColumn;
Builder.prototype.andWhere = Builder.prototype.where;
Builder.prototype.andWhereColumn = Builder.prototype.whereColumn;
Builder.prototype.andWhereRaw = Builder.prototype.whereRaw;
Builder.prototype.andWhereBetween = Builder.prototype.whereBetween;
Builder.prototype.andWhereNotBetween = Builder.prototype.whereNotBetween;
Builder.prototype.andWhereJsonObject = Builder.prototype.whereJsonObject;
Builder.prototype.andWhereNotJsonObject = Builder.prototype.whereJsonObject;
Builder.prototype.andWhereJsonPath = Builder.prototype.whereJsonPath;
Builder.prototype.andWhereLike = Builder.prototype.whereLike;
Builder.prototype.andWhereILike = Builder.prototype.whereILike;
Builder.prototype.andHaving = Builder.prototype.having;
Builder.prototype.andHavingIn = Builder.prototype.havingIn;
Builder.prototype.andHavingNotIn = Builder.prototype.havingNotIn;
Builder.prototype.andHavingNull = Builder.prototype.havingNull;
Builder.prototype.andHavingNotNull = Builder.prototype.havingNotNull;
Builder.prototype.andHavingExists = Builder.prototype.havingExists;
Builder.prototype.andHavingNotExists = Builder.prototype.havingNotExists;
Builder.prototype.andHavingBetween = Builder.prototype.havingBetween;
Builder.prototype.andHavingNotBetween = Builder.prototype.havingNotBetween;
Builder.prototype.from = Builder.prototype.table;
Builder.prototype.into = Builder.prototype.table;
Builder.prototype.del = Builder.prototype.delete;

// Attach all of the top level promise methods that should be chainable.
augmentWithBuilderInterface$2(Builder);
addQueryContext$2(Builder);

Builder.extend = (methodName, fn) => {
  if (Object.prototype.hasOwnProperty.call(Builder.prototype, methodName)) {
    throw new Error(
      `Can't extend QueryBuilder with existing method ('${methodName}').`
    );
  }

  assign$6(Builder.prototype, { [methodName]: fn });
};

// Sub-builder for onConflict clauses
class OnConflictBuilder {
  constructor(builder, columns) {
    this.builder = builder;
    this._columns = columns;
  }

  // Sets insert query to ignore conflicts
  ignore() {
    this.builder._single.onConflict = this._columns;
    this.builder._single.ignore = true;
    return this.builder;
  }

  // Sets insert query to update on conflict
  merge(updates) {
    this.builder._single.onConflict = this._columns;
    this.builder._single.merge = { updates };
    return this.builder;
  }

  // Prevent
  then() {
    throw new Error(
      'Incomplete onConflict clause. .onConflict() must be directly followed by either .merge() or .ignore()'
    );
  }
}

var querybuilder = Builder;

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */

function arrayReduce$1(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

var _arrayReduce = arrayReduce$1;

/**
 * The base implementation of `_.reduce` and `_.reduceRight`, without support
 * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} accumulator The initial value.
 * @param {boolean} initAccum Specify using the first or last element of
 *  `collection` as the initial value.
 * @param {Function} eachFunc The function to iterate over `collection`.
 * @returns {*} Returns the accumulated value.
 */

function baseReduce$1(collection, iteratee, accumulator, initAccum, eachFunc) {
  eachFunc(collection, function(value, index, collection) {
    accumulator = initAccum
      ? (initAccum = false, value)
      : iteratee(accumulator, value, index, collection);
  });
  return accumulator;
}

var _baseReduce = baseReduce$1;

var arrayReduce = _arrayReduce,
    baseEach$1 = _baseEach,
    baseIteratee$5 = _baseIteratee,
    baseReduce = _baseReduce,
    isArray$3 = isArray_1;

/**
 * Reduces `collection` to a value which is the accumulated result of running
 * each element in `collection` thru `iteratee`, where each successive
 * invocation is supplied the return value of the previous. If `accumulator`
 * is not given, the first element of `collection` is used as the initial
 * value. The iteratee is invoked with four arguments:
 * (accumulator, value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.reduce`, `_.reduceRight`, and `_.transform`.
 *
 * The guarded methods are:
 * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
 * and `sortBy`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @returns {*} Returns the accumulated value.
 * @see _.reduceRight
 * @example
 *
 * _.reduce([1, 2], function(sum, n) {
 *   return sum + n;
 * }, 0);
 * // => 3
 *
 * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
 *   (result[value] || (result[value] = [])).push(key);
 *   return result;
 * }, {});
 * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
 */
function reduce$2(collection, iteratee, accumulator) {
  var func = isArray$3(collection) ? arrayReduce : baseReduce,
      initAccum = arguments.length < 3;

  return func(collection, baseIteratee$5(iteratee), accumulator, initAccum, baseEach$1);
}

var reduce_1 = reduce$2;

var arrayEach = _arrayEach,
    baseCreate = _baseCreate,
    baseForOwn = _baseForOwn,
    baseIteratee$4 = _baseIteratee,
    getPrototype = _getPrototype,
    isArray$2 = isArray_1,
    isBuffer = isBufferExports,
    isFunction$1 = isFunction_1,
    isObject$4 = isObject_1,
    isTypedArray = isTypedArray_1;

/**
 * An alternative to `_.reduce`; this method transforms `object` to a new
 * `accumulator` object which is the result of running each of its own
 * enumerable string keyed properties thru `iteratee`, with each invocation
 * potentially mutating the `accumulator` object. If `accumulator` is not
 * provided, a new object with the same `[[Prototype]]` will be used. The
 * iteratee is invoked with four arguments: (accumulator, value, key, object).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @static
 * @memberOf _
 * @since 1.3.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [accumulator] The custom accumulator value.
 * @returns {*} Returns the accumulated value.
 * @example
 *
 * _.transform([2, 3, 4], function(result, n) {
 *   result.push(n *= n);
 *   return n % 2 == 0;
 * }, []);
 * // => [4, 9]
 *
 * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
 *   (result[value] || (result[value] = [])).push(key);
 * }, {});
 * // => { '1': ['a', 'c'], '2': ['b'] }
 */
function transform$1(object, iteratee, accumulator) {
  var isArr = isArray$2(object),
      isArrLike = isArr || isBuffer(object) || isTypedArray(object);

  iteratee = baseIteratee$4(iteratee);
  if (accumulator == null) {
    var Ctor = object && object.constructor;
    if (isArrLike) {
      accumulator = isArr ? new Ctor : [];
    }
    else if (isObject$4(object)) {
      accumulator = isFunction$1(Ctor) ? baseCreate(getPrototype(object)) : {};
    }
    else {
      accumulator = {};
    }
  }
  (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
    return iteratee(accumulator, value, index, object);
  });
  return accumulator;
}

var transform_1 = transform$1;

const { isObject: isObject$3 } = is;

// Compiles a callback using the query builder.
function compileCallback$2(callback, method, client, bindingsHolder) {
  // Build the callback
  const builder = client.queryBuilder();
  callback.call(builder, builder);

  // Compile the callback, using the current formatter (to track all bindings).
  const compiler = client.queryCompiler(builder, bindingsHolder.bindings);

  // Return the compiled & parameterized sql.
  return compiler.toSQL(method || builder._method || 'select');
}

function wrapAsIdentifier$1(value, builder, client) {
  const queryContext = builder.queryContext();
  return client.wrapIdentifier((value || '').trim(), queryContext);
}

function formatDefault$1(value, type, client) {
  if (value === void 0) {
    return '';
  } else if (value === null) {
    return 'null';
  } else if (value && value.isRawInstance) {
    return value.toQuery();
  } else if (type === 'bool') {
    if (value === 'false') value = 0;
    return `'${value ? 1 : 0}'`;
  } else if ((type === 'json' || type === 'jsonb') && isObject$3(value)) {
    return `'${JSON.stringify(value)}'`;
  } else {
    return client._escapeBinding(value.toString());
  }
}

var formatterUtils = {
  compileCallback: compileCallback$2,
  wrapAsIdentifier: wrapAsIdentifier$1,
  formatDefault: formatDefault$1,
};

const transform = transform_1;
const QueryBuilder$2 = querybuilder;
const { compileCallback: compileCallback$1, wrapAsIdentifier } = formatterUtils;

// Valid values for the `order by` clause generation.
const orderBys = ['asc', 'desc'];

// Turn this into a lookup map
const operators = transform(
  [
    '=',
    '<',
    '>',
    '<=',
    '>=',
    '<>',
    '!=',
    'like',
    'not like',
    'between',
    'not between',
    'ilike',
    'not ilike',
    'exists',
    'not exist',
    'rlike',
    'not rlike',
    'regexp',
    'not regexp',
    'match',
    '&',
    '|',
    '^',
    '<<',
    '>>',
    '~',
    '~=',
    '~*',
    '!~',
    '!~*',
    '#',
    '&&',
    '@>',
    '<@',
    '||',
    '&<',
    '&>',
    '-|-',
    '@@',
    '!!',
    ['?', '\\?'],
    ['?|', '\\?|'],
    ['?&', '\\?&'],
  ],
  (result, key) => {
    if (Array.isArray(key)) {
      result[key[0]] = key[1];
    } else {
      result[key] = key;
    }
  },
  {}
);

// Accepts a string or array of columns to wrap as appropriate. Column can be raw
function columnize$1(target, builder, client, bindingHolder) {
  const columns = Array.isArray(target) ? target : [target];
  let str = '',
    i = -1;
  while (++i < columns.length) {
    if (i > 0) str += ', ';
    str += wrap(columns[i], undefined, builder, client, bindingHolder);
  }
  return str;
}

// Puts the appropriate wrapper around a value depending on the database
// engine, unless it's a knex.raw value, in which case it's left alone.
function wrap(value, isParameter, builder, client, bindingHolder) {
  const raw = unwrapRaw$1(value, isParameter, builder, client, bindingHolder);
  if (raw) return raw;
  switch (typeof value) {
    case 'function':
      return outputQuery$1(
        compileCallback$1(value, undefined, client, bindingHolder),
        true,
        builder,
        client
      );
    case 'object':
      return parseObject(value, builder, client, bindingHolder);
    case 'number':
      return value;
    default:
      return wrapString(value + '', builder, client);
  }
}

function unwrapRaw$1(value, isParameter, builder, client, bindingsHolder) {
  let query;
  if (value instanceof QueryBuilder$2) {
    query = client.queryCompiler(value).toSQL();
    if (query.bindings) {
      bindingsHolder.bindings.push(...query.bindings);
    }
    return outputQuery$1(query, isParameter, builder, client);
  }
  if (value && value.isRawInstance) {
    value.client = client;
    if (builder._queryContext) {
      value.queryContext = () => {
        return builder._queryContext;
      };
    }

    query = value.toSQL();
    if (query.bindings) {
      bindingsHolder.bindings.push(...query.bindings);
    }
    return query.sql;
  }
  if (isParameter) {
    bindingsHolder.bindings.push(value);
  }
}

function operator(value, builder, client, bindingsHolder) {
  const raw = unwrapRaw$1(value, undefined, builder, client, bindingsHolder);
  if (raw) return raw;
  const operator = operators[(value || '').toLowerCase()];
  if (!operator) {
    throw new TypeError(`The operator "${value}" is not permitted`);
  }
  return operator;
}

// Coerce to string to prevent strange errors when it's not a string.
function wrapString(value, builder, client) {
  const asIndex = value.toLowerCase().indexOf(' as ');
  if (asIndex !== -1) {
    const first = value.slice(0, asIndex);
    const second = value.slice(asIndex + 4);
    return client.alias(
      wrapString(first, builder, client),
      wrapAsIdentifier(second, builder, client)
    );
  }
  const wrapped = [];
  let i = -1;
  const segments = value.split('.');
  while (++i < segments.length) {
    value = segments[i];
    if (i === 0 && segments.length > 1) {
      wrapped.push(wrapString((value || '').trim(), builder, client));
    } else {
      wrapped.push(wrapAsIdentifier(value, builder, client));
    }
  }
  return wrapped.join('.');
}

// Key-value notation for alias
function parseObject(obj, builder, client, formatter) {
  const ret = [];
  for (const alias in obj) {
    const queryOrIdentifier = obj[alias];
    // Avoids double aliasing for subqueries
    if (typeof queryOrIdentifier === 'function') {
      const compiled = compileCallback$1(
        queryOrIdentifier,
        undefined,
        client,
        formatter
      );
      compiled.as = alias; // enforces the object's alias
      ret.push(outputQuery$1(compiled, true, builder, client));
    } else if (queryOrIdentifier instanceof QueryBuilder$2) {
      ret.push(
        client.alias(
          `(${wrap(queryOrIdentifier, undefined, builder, client, formatter)})`,
          wrapAsIdentifier(alias, builder, client)
        )
      );
    } else {
      ret.push(
        client.alias(
          wrap(queryOrIdentifier, undefined, builder, client, formatter),
          wrapAsIdentifier(alias, builder, client)
        )
      );
    }
  }
  return ret.join(', ');
}

// Ensures the query is aliased if necessary.
function outputQuery$1(compiled, isParameter, builder, client) {
  let sql = compiled.sql || '';
  if (sql) {
    if (
      (compiled.method === 'select' || compiled.method === 'first') &&
      (isParameter || compiled.as)
    ) {
      sql = `(${sql})`;
      if (compiled.as)
        return client.alias(sql, wrapString(compiled.as, builder, client));
    }
  }
  return sql;
}

/**
 * Creates SQL for a parameter, which might be passed to where() or .with() or
 * pretty much anywhere in API.
 *
 * @param value
 * @param method Optional at least 'select' or 'update' are valid
 * @param builder
 * @param client
 * @param bindingHolder
 */
function rawOrFn(value, method, builder, client, bindingHolder) {
  if (typeof value === 'function') {
    return outputQuery$1(
      compileCallback$1(value, method, client, bindingHolder),
      undefined,
      builder,
      client
    );
  }
  return unwrapRaw$1(value, undefined, builder, client, bindingHolder) || '';
}

// Specify the direction of the ordering.
function direction$1(value, builder, client, bindingsHolder) {
  const raw = unwrapRaw$1(value, undefined, builder, client, bindingsHolder);
  if (raw) return raw;
  return orderBys.indexOf((value || '').toLowerCase()) !== -1 ? value : 'asc';
}

var wrappingFormatter = {
  columnize: columnize$1,
  direction: direction$1,
  operator,
  outputQuery: outputQuery$1,
  rawOrFn,
  unwrapRaw: unwrapRaw$1,
  wrap,
  wrapString,
};

const { columnize } = wrappingFormatter;

function replaceRawArrBindings$1(raw, client) {
  const bindingsHolder = {
    bindings: [],
  };
  const builder = raw;

  const expectedBindings = raw.bindings.length;
  const values = raw.bindings;
  let index = 0;

  const sql = raw.sql.replace(/\\?\?\??/g, function (match) {
    if (match === '\\?') {
      return match;
    }

    const value = values[index++];

    if (match === '??') {
      return columnize(value, builder, client, bindingsHolder);
    }
    return client.parameter(value, builder, bindingsHolder);
  });

  if (expectedBindings !== index) {
    throw new Error(`Expected ${expectedBindings} bindings, saw ${index}`);
  }

  return {
    method: 'raw',
    sql,
    bindings: bindingsHolder.bindings,
  };
}

function replaceKeyBindings$1(raw, client) {
  const bindingsHolder = {
    bindings: [],
  };
  const builder = raw;

  const values = raw.bindings;
  const regex = /\\?(:(\w+):(?=::)|:(\w+):(?!:)|:(\w+))/g;

  const sql = raw.sql.replace(regex, function (match, p1, p2, p3, p4) {
    if (match !== p1) {
      return p1;
    }

    const part = p2 || p3 || p4;
    const key = match.trim();
    const isIdentifier = key[key.length - 1] === ':';
    const value = values[part];

    if (value === undefined) {
      if (Object.prototype.hasOwnProperty.call(values, part)) {
        bindingsHolder.bindings.push(value);
      }

      return match;
    }

    if (isIdentifier) {
      return match.replace(
        p1,
        columnize(value, builder, client, bindingsHolder)
      );
    }

    return match.replace(p1, client.parameter(value, builder, bindingsHolder));
  });

  return {
    method: 'raw',
    sql,
    bindings: bindingsHolder.bindings,
  };
}

var rawFormatter = {
  replaceKeyBindings: replaceKeyBindings$1,
  replaceRawArrBindings: replaceRawArrBindings$1,
};

// This alphabet uses `A-Za-z0-9_-` symbols. The genetic algorithm helped
// optimize the gzip compression for this alphabet.
const urlAlphabet =
  'ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW';

const numberAlphabet = '0123456789';

/**
 * Generate URL-friendly unique ID. This method uses the non-secure
 * predictable random generator with bigger collision probability.
 * Based on https://github.com/ai/nanoid
 *
 * ```js
 * model.id = nanoid() //=> "Uakgb_J5m9g-0JDMbcJqL"
 * ```
 *
 * @param size Size of the ID. The default size is 21.
 * @returns A random string.
 */
function nanoid$2(size = 21) {
  let id = '';
  // A compact alternative for `for (var i = 0; i < step; i++)`.
  let i = size;
  while (i--) {
    // `| 0` is more compact and faster than `Math.floor()`.
    id += urlAlphabet[(Math.random() * 64) | 0];
  }
  return id;
}

function nanonum(size = 21) {
  let id = '';
  let i = size;
  while (i--) {
    id += numberAlphabet[(Math.random() * 10) | 0];
  }
  return id;
}

var nanoid_1 = { nanoid: nanoid$2, nanonum };

// Raw
// -------
const { EventEmitter: EventEmitter$5 } = require$$0;
const debug$2 = srcExports;
const assign$5 = assign_1;
const isPlainObject$1 = isPlainObject_1;
const reduce$1 = reduce_1;

const {
  replaceRawArrBindings,
  replaceKeyBindings,
} = rawFormatter;
const helpers$6 = helpers$7;
const saveAsyncStack$1 = saveAsyncStack$3;
const { nanoid: nanoid$1 } = nanoid_1;
const { isNumber, isObject: isObject$2 } = is;
const {
  augmentWithBuilderInterface: augmentWithBuilderInterface$1,
} = builderInterfaceAugmenter;

const debugBindings$1 = debug$2('knex:bindings');

let Raw$3 = class Raw extends EventEmitter$5 {
  constructor(client) {
    super();

    this.client = client;

    this.sql = '';
    this.bindings = [];

    // Todo: Deprecate
    this._wrappedBefore = undefined;
    this._wrappedAfter = undefined;
    if (client && client.config) {
      this._debug = client.config.debug;
      saveAsyncStack$1(this, 4);
    }
  }
  set(sql, bindings) {
    this.sql = sql;
    this.bindings =
      (isObject$2(bindings) && !bindings.toSQL) || bindings === undefined
        ? bindings
        : [bindings];

    return this;
  }

  timeout(ms, { cancel } = {}) {
    if (isNumber(ms) && ms > 0) {
      this._timeout = ms;
      if (cancel) {
        this.client.assertCanCancelQuery();
        this._cancelOnTimeout = true;
      }
    }
    return this;
  }

  // Wraps the current sql with `before` and `after`.
  wrap(before, after) {
    this._wrappedBefore = before;
    this._wrappedAfter = after;
    return this;
  }

  // Calls `toString` on the Knex object.
  toString() {
    return this.toQuery();
  }

  // Returns the raw sql for the query.
  toSQL(method, tz) {
    let obj;
    if (Array.isArray(this.bindings)) {
      obj = replaceRawArrBindings(this, this.client);
    } else if (this.bindings && isPlainObject$1(this.bindings)) {
      obj = replaceKeyBindings(this, this.client);
    } else {
      obj = {
        method: 'raw',
        sql: this.sql,
        bindings: this.bindings === undefined ? [] : [this.bindings],
      };
    }

    if (this._wrappedBefore) {
      obj.sql = this._wrappedBefore + obj.sql;
    }
    if (this._wrappedAfter) {
      obj.sql = obj.sql + this._wrappedAfter;
    }

    obj.options = reduce$1(this._options, assign$5, {});

    if (this._timeout) {
      obj.timeout = this._timeout;
      if (this._cancelOnTimeout) {
        obj.cancelOnTimeout = this._cancelOnTimeout;
      }
    }

    obj.bindings = obj.bindings || [];
    if (helpers$6.containsUndefined(obj.bindings)) {
      const undefinedBindingIndices = helpers$6.getUndefinedIndices(
        this.bindings
      );
      debugBindings$1(obj.bindings);
      throw new Error(
        `Undefined binding(s) detected for keys [${undefinedBindingIndices}] when compiling RAW query: ${obj.sql}`
      );
    }

    obj.__knexQueryUid = nanoid$1();

    Object.defineProperties(obj, {
      toNative: {
        value: () => ({
          sql: this.client.positionBindings(obj.sql),
          bindings: this.client.prepBindings(obj.bindings),
        }),
        enumerable: false,
      },
    });

    return obj;
  }
};

// Workaround to avoid circular dependency between wrappingFormatter.unwrapRaw and rawFormatter
Raw$3.prototype.isRawInstance = true;

// Allow the `Raw` object to be utilized with full access to the relevant
// promise API.
augmentWithBuilderInterface$1(Raw$3);
helpers$6.addQueryContext(Raw$3);

var raw = Raw$3;

/**
 * Creates an array with all falsey values removed. The values `false`, `null`,
 * `0`, `""`, `undefined`, and `NaN` are falsey.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to compact.
 * @returns {Array} Returns the new array of filtered values.
 * @example
 *
 * _.compact([0, 1, false, 2, '', 3]);
 * // => [1, 2, 3]
 */

function compact$1(array) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (value) {
      result[resIndex++] = value;
    }
  }
  return result;
}

var compact_1 = compact$1;

/**
 * A specialized version of `baseAggregator` for arrays.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} setter The function to set `accumulator` values.
 * @param {Function} iteratee The iteratee to transform keys.
 * @param {Object} accumulator The initial aggregated object.
 * @returns {Function} Returns `accumulator`.
 */

function arrayAggregator$1(array, setter, iteratee, accumulator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    var value = array[index];
    setter(accumulator, value, iteratee(value), array);
  }
  return accumulator;
}

var _arrayAggregator = arrayAggregator$1;

var baseEach = _baseEach;

/**
 * Aggregates elements of `collection` on `accumulator` with keys transformed
 * by `iteratee` and values set by `setter`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} setter The function to set `accumulator` values.
 * @param {Function} iteratee The iteratee to transform keys.
 * @param {Object} accumulator The initial aggregated object.
 * @returns {Function} Returns `accumulator`.
 */
function baseAggregator$1(collection, setter, iteratee, accumulator) {
  baseEach(collection, function(value, key, collection) {
    setter(accumulator, value, iteratee(value), collection);
  });
  return accumulator;
}

var _baseAggregator = baseAggregator$1;

var arrayAggregator = _arrayAggregator,
    baseAggregator = _baseAggregator,
    baseIteratee$3 = _baseIteratee,
    isArray$1 = isArray_1;

/**
 * Creates a function like `_.groupBy`.
 *
 * @private
 * @param {Function} setter The function to set accumulator values.
 * @param {Function} [initializer] The accumulator object initializer.
 * @returns {Function} Returns the new aggregator function.
 */
function createAggregator$1(setter, initializer) {
  return function(collection, iteratee) {
    var func = isArray$1(collection) ? arrayAggregator : baseAggregator,
        accumulator = initializer ? initializer() : {};

    return func(collection, setter, baseIteratee$3(iteratee), accumulator);
  };
}

var _createAggregator = createAggregator$1;

var baseAssignValue = _baseAssignValue,
    createAggregator = _createAggregator;

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

/**
 * Creates an object composed of keys generated from the results of running
 * each element of `collection` thru `iteratee`. The order of grouped values
 * is determined by the order they occur in `collection`. The corresponding
 * value of each key is an array of elements responsible for generating the
 * key. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
 * @returns {Object} Returns the composed aggregate object.
 * @example
 *
 * _.groupBy([6.1, 4.2, 6.3], Math.floor);
 * // => { '4': [4.2], '6': [6.1, 6.3] }
 *
 * // The `_.property` iteratee shorthand.
 * _.groupBy(['one', 'two', 'three'], 'length');
 * // => { '3': ['one', 'two'], '5': ['three'] }
 */
var groupBy$4 = createAggregator(function(result, value, key) {
  if (hasOwnProperty$1.call(result, key)) {
    result[key].push(value);
  } else {
    baseAssignValue(result, key, [value]);
  }
});

var groupBy_1 = groupBy$4;

/** Used for built-in method references. */

var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.has` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHas$1(object, key) {
  return object != null && hasOwnProperty.call(object, key);
}

var _baseHas = baseHas$1;

var baseHas = _baseHas,
    hasPath = _hasPath;

/**
 * Checks if `path` is a direct property of `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = { 'a': { 'b': 2 } };
 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.has(object, 'a');
 * // => true
 *
 * _.has(object, 'a.b');
 * // => true
 *
 * _.has(object, ['a', 'b']);
 * // => true
 *
 * _.has(other, 'a');
 * // => false
 */
function has$2(object, path) {
  return object != null && hasPath(object, path, baseHas);
}

var has_1 = has$2;

var arrayMap$1 = _arrayMap,
    baseIteratee$2 = _baseIteratee,
    baseMap = _baseMap,
    isArray = isArray_1;

/**
 * Creates an array of values by running each element in `collection` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
 *
 * The guarded methods are:
 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * _.map([4, 8], square);
 * // => [16, 64]
 *
 * _.map({ 'a': 4, 'b': 8 }, square);
 * // => [16, 64] (iteration order is not guaranteed)
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * // The `_.property` iteratee shorthand.
 * _.map(users, 'user');
 * // => ['barney', 'fred']
 */
function map$2(collection, iteratee) {
  var func = isArray(collection) ? arrayMap$1 : baseMap;
  return func(collection, baseIteratee$2(iteratee));
}

var map_1 = map$2;

var assignValue = _assignValue,
    castPath$1 = _castPath,
    isIndex = _isIndex,
    isObject$1 = isObject_1,
    toKey = _toKey;

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet$1(object, path, value, customizer) {
  if (!isObject$1(object)) {
    return object;
  }
  path = castPath$1(path, object);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
      return object;
    }

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = isObject$1(objValue)
          ? objValue
          : (isIndex(path[index + 1]) ? [] : {});
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

var _baseSet = baseSet$1;

var baseGet = _baseGet,
    baseSet = _baseSet,
    castPath = _castPath;

/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */
function basePickBy$1(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = baseGet(object, path);

    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }
  return result;
}

var _basePickBy = basePickBy$1;

var arrayMap = _arrayMap,
    baseIteratee$1 = _baseIteratee,
    basePickBy = _basePickBy,
    getAllKeysIn = _getAllKeysIn;

/**
 * Creates an object composed of the `object` properties `predicate` returns
 * truthy for. The predicate is invoked with two arguments: (value, key).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The source object.
 * @param {Function} [predicate=_.identity] The function invoked per property.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pickBy(object, _.isNumber);
 * // => { 'a': 1, 'c': 3 }
 */
function pickBy$1(object, predicate) {
  if (object == null) {
    return {};
  }
  var props = arrayMap(getAllKeysIn(object), function(prop) {
    return [prop];
  });
  predicate = baseIteratee$1(predicate);
  return basePickBy(object, props, function(value, path) {
    return predicate(value, path[0]);
  });
}

var pickBy_1 = pickBy$1;

var baseIteratee = _baseIteratee,
    negate = negate_1,
    pickBy = pickBy_1;

/**
 * The opposite of `_.pickBy`; this method creates an object composed of
 * the own and inherited enumerable string keyed properties of `object` that
 * `predicate` doesn't return truthy for. The predicate is invoked with two
 * arguments: (value, key).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The source object.
 * @param {Function} [predicate=_.identity] The function invoked per property.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.omitBy(object, _.isNumber);
 * // => { 'b': '2' }
 */
function omitBy$1(object, predicate) {
  return pickBy(object, negate(baseIteratee(predicate)));
}

var omitBy_1 = omitBy$1;

// Query Compiler
// -------
const helpers$5 = helpers$7;
const Raw$2 = raw;
const QueryBuilder$1 = querybuilder;
const JoinClause = joinclause;
const debug$1 = srcExports;

const assign$4 = assign_1;
const compact = compact_1;
const groupBy$3 = groupBy_1;
const has$1 = has_1;
const isEmpty$1 = isEmpty_1;
const map$1 = map_1;
const omitBy = omitBy_1;
const reduce = reduce_1;
const { nanoid } = nanoid_1;
const { isString: isString$3, isUndefined } = is;
const {
  columnize: columnize_$2,
  direction: direction_,
  operator: operator_$1,
  wrap: wrap_$1,
  unwrapRaw: unwrapRaw_,
  rawOrFn: rawOrFn_,
} = wrappingFormatter;

const debugBindings = debug$1('knex:bindings');

const components = [
  'columns',
  'join',
  'where',
  'union',
  'group',
  'having',
  'order',
  'limit',
  'offset',
  'lock',
  'waitMode',
];

// The "QueryCompiler" takes all of the query statements which
// have been gathered in the "QueryBuilder" and turns them into a
// properly formatted / bound query string.
let QueryCompiler$1 = class QueryCompiler {
  constructor(client, builder, bindings) {
    this.client = client;
    this.method = builder._method || 'select';
    this.options = builder._options;
    this.single = builder._single;
    this.timeout = builder._timeout || false;
    this.cancelOnTimeout = builder._cancelOnTimeout || false;
    this.grouped = groupBy$3(builder._statements, 'grouping');
    this.formatter = client.formatter(builder);
    // Used when the insert call is empty.
    this._emptyInsertValue = 'default values';
    this.first = this.select;

    this.bindings = bindings || [];
    this.formatter.bindings = this.bindings;
    this.bindingsHolder = this;
    this.builder = this.formatter.builder;
  }

  // Collapse the builder into a single object
  toSQL(method, tz) {
    this._undefinedInWhereClause = false;
    this.undefinedBindingsInfo = [];

    method = method || this.method;
    const val = this[method]() || '';

    const query = {
      method,
      options: reduce(this.options, assign$4, {}),
      timeout: this.timeout,
      cancelOnTimeout: this.cancelOnTimeout,
      bindings: this.bindingsHolder.bindings || [],
      __knexQueryUid: nanoid(),
    };

    Object.defineProperties(query, {
      toNative: {
        value: () => {
          return {
            sql: this.client.positionBindings(query.sql),
            bindings: this.client.prepBindings(query.bindings),
          };
        },
        enumerable: false,
      },
    });

    if (isString$3(val)) {
      query.sql = val;
    } else {
      assign$4(query, val);
    }

    if (method === 'select' || method === 'first') {
      if (this.single.as) {
        query.as = this.single.as;
      }
    }

    if (this._undefinedInWhereClause) {
      debugBindings(query.bindings);
      throw new Error(
        `Undefined binding(s) detected when compiling ` +
          `${method.toUpperCase()}. Undefined column(s): [${this.undefinedBindingsInfo.join(
            ', '
          )}] query: ${query.sql}`
      );
    }

    return query;
  }

  // Compiles the `select` statement, or nested sub-selects by calling each of
  // the component compilers, trimming out the empties, and returning a
  // generated query string.
  select() {
    let sql = this.with();

    let unionStatement = '';

    const firstStatements = [];
    const endStatements = [];

    components.forEach((component) => {
      const statement = this[component](this);
      // We store the 'union' statement to append it at the end.
      // We still need to call the component sequentially because of
      // order of bindings.
      switch (component) {
        case 'union':
          unionStatement = statement;
          break;
        case 'columns':
        case 'join':
        case 'where':
          firstStatements.push(statement);
          break;
        default:
          endStatements.push(statement);
          break;
      }
    });

    // Check if we need to wrap the main query.
    // We need to wrap main query if one of union have wrap options to true
    // to avoid error syntax (in PostgreSQL for example).
    const wrapMainQuery =
      this.grouped.union &&
      this.grouped.union.map((u) => u.wrap).some((u) => u);

    if (this.onlyUnions()) {
      const statements = compact(firstStatements.concat(endStatements)).join(
        ' '
      );
      sql += unionStatement + (statements ? ' ' + statements : '');
    } else {
      const allStatements =
        (wrapMainQuery ? '(' : '') +
        compact(firstStatements).join(' ') +
        (wrapMainQuery ? ')' : '');
      const endStat = compact(endStatements).join(' ');
      sql +=
        allStatements +
        (unionStatement ? ' ' + unionStatement : '') +
        (endStat ? ' ' + endStat : endStat);
    }
    return sql;
  }

  pluck() {
    let toPluck = this.single.pluck;
    if (toPluck.indexOf('.') !== -1) {
      toPluck = toPluck.split('.').slice(-1)[0];
    }
    return {
      sql: this.select(),
      pluck: toPluck,
    };
  }

  // Compiles an "insert" query, allowing for multiple
  // inserts using a single query statement.
  insert() {
    const insertValues = this.single.insert || [];
    const sql = this.with() + `insert into ${this.tableName} `;
    const body = this._insertBody(insertValues);
    return body === '' ? '' : sql + body;
  }

  _onConflictClause(columns) {
    return columns instanceof Raw$2
      ? this.formatter.wrap(columns)
      : `(${this.formatter.columnize(columns)})`;
  }

  _buildInsertValues(insertData) {
    let sql = '';
    let i = -1;
    while (++i < insertData.values.length) {
      if (i !== 0) sql += '), (';
      sql += this.client.parameterize(
        insertData.values[i],
        this.client.valueForUndefined,
        this.builder,
        this.bindingsHolder
      );
    }
    return sql;
  }

  _insertBody(insertValues) {
    let sql = '';
    if (Array.isArray(insertValues)) {
      if (insertValues.length === 0) {
        return '';
      }
    } else if (typeof insertValues === 'object' && isEmpty$1(insertValues)) {
      return sql + this._emptyInsertValue;
    }

    const insertData = this._prepInsert(insertValues);
    if (typeof insertData === 'string') {
      sql += insertData;
    } else {
      if (insertData.columns.length) {
        sql += `(${columnize_$2(
          insertData.columns,
          this.builder,
          this.client,
          this.bindingsHolder
        )}`;
        sql += ') values (' + this._buildInsertValues(insertData) + ')';
      } else if (insertValues.length === 1 && insertValues[0]) {
        sql += this._emptyInsertValue;
      } else {
        sql = '';
      }
    }
    return sql;
  }

  // Compiles the "update" query.
  update() {
    // Make sure tableName is processed by the formatter first.
    const withSQL = this.with();
    const { tableName } = this;
    const updateData = this._prepUpdate(this.single.update);
    const wheres = this.where();
    return (
      withSQL +
      `update ${this.single.only ? 'only ' : ''}${tableName}` +
      ' set ' +
      updateData.join(', ') +
      (wheres ? ` ${wheres}` : '')
    );
  }

  _hintComments() {
    let hints = this.grouped.hintComments || [];
    hints = hints.map((hint) => compact(hint.value).join(' '));
    hints = compact(hints).join(' ');
    return hints ? `/*+ ${hints} */ ` : '';
  }

  // Compiles the columns in the query, specifying if an item was distinct.
  columns() {
    let distinctClause = '';
    if (this.onlyUnions()) return '';
    const hints = this._hintComments();
    const columns = this.grouped.columns || [];
    let i = -1,
      sql = [];
    if (columns) {
      while (++i < columns.length) {
        const stmt = columns[i];
        if (stmt.distinct) distinctClause = 'distinct ';
        if (stmt.distinctOn) {
          distinctClause = this.distinctOn(stmt.value);
          continue;
        }
        if (stmt.type === 'aggregate') {
          sql.push(...this.aggregate(stmt));
        } else if (stmt.type === 'aggregateRaw') {
          sql.push(this.aggregateRaw(stmt));
        } else if (stmt.type === 'analytic') {
          sql.push(this.analytic(stmt));
        } else if (stmt.type === 'json') {
          sql.push(this.json(stmt));
        } else if (stmt.value && stmt.value.length > 0) {
          sql.push(
            columnize_$2(
              stmt.value,
              this.builder,
              this.client,
              this.bindingsHolder
            )
          );
        }
      }
    }
    if (sql.length === 0) sql = ['*'];
    const select = this.onlyJson() ? '' : 'select ';
    return (
      `${select}${hints}${distinctClause}` +
      sql.join(', ') +
      (this.tableName
        ? ` from ${this.single.only ? 'only ' : ''}${this.tableName}`
        : '')
    );
  }

  _aggregate(stmt, { aliasSeparator = ' as ', distinctParentheses } = {}) {
    const value = stmt.value;
    const method = stmt.method;
    const distinct = stmt.aggregateDistinct ? 'distinct ' : '';
    const wrap = (identifier) =>
      wrap_$1(
        identifier,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      );
    const addAlias = (value, alias) => {
      if (alias) {
        return value + aliasSeparator + wrap(alias);
      }
      return value;
    };
    const aggregateArray = (value, alias) => {
      let columns = value.map(wrap).join(', ');
      if (distinct) {
        const openParen = distinctParentheses ? '(' : ' ';
        const closeParen = distinctParentheses ? ')' : '';
        columns = distinct.trim() + openParen + columns + closeParen;
      }
      const aggregated = `${method}(${columns})`;
      return addAlias(aggregated, alias);
    };
    const aggregateString = (value, alias) => {
      const aggregated = `${method}(${distinct + wrap(value)})`;
      return addAlias(aggregated, alias);
    };

    if (Array.isArray(value)) {
      return [aggregateArray(value)];
    }

    if (typeof value === 'object') {
      if (stmt.alias) {
        throw new Error('When using an object explicit alias can not be used');
      }
      return Object.entries(value).map(([alias, column]) => {
        if (Array.isArray(column)) {
          return aggregateArray(column, alias);
        }
        return aggregateString(column, alias);
      });
    }

    // Allows us to speciy an alias for the aggregate types.
    const splitOn = value.toLowerCase().indexOf(' as ');
    let column = value;
    let { alias } = stmt;
    if (splitOn !== -1) {
      column = value.slice(0, splitOn);
      if (alias) {
        throw new Error(`Found multiple aliases for same column: ${column}`);
      }
      alias = value.slice(splitOn + 4);
    }
    return [aggregateString(column, alias)];
  }

  aggregate(stmt) {
    return this._aggregate(stmt);
  }

  aggregateRaw(stmt) {
    const distinct = stmt.aggregateDistinct ? 'distinct ' : '';
    return `${stmt.method}(${
      distinct +
      unwrapRaw_(
        stmt.value,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      )
    })`;
  }

  _joinTable(join) {
    return join.schema && !(join.table instanceof Raw$2)
      ? `${join.schema}.${join.table}`
      : join.table;
  }

  // Compiles all each of the `join` clauses on the query,
  // including any nested join queries.
  join() {
    let sql = '';
    let i = -1;
    const joins = this.grouped.join;
    if (!joins) return '';
    while (++i < joins.length) {
      const join = joins[i];
      const table = this._joinTable(join);
      if (i > 0) sql += ' ';
      if (join.joinType === 'raw') {
        sql += unwrapRaw_(
          join.table,
          undefined,
          this.builder,
          this.client,
          this.bindingsHolder
        );
      } else {
        sql +=
          join.joinType +
          ' join ' +
          wrap_$1(
            table,
            undefined,
            this.builder,
            this.client,
            this.bindingsHolder
          );
        let ii = -1;
        while (++ii < join.clauses.length) {
          const clause = join.clauses[ii];
          if (ii > 0) {
            sql += ` ${clause.bool} `;
          } else {
            sql += ` ${clause.type === 'onUsing' ? 'using' : 'on'} `;
          }
          const val = this[clause.type](clause);
          if (val) {
            sql += val;
          }
        }
      }
    }
    return sql;
  }

  onBetween(statement) {
    return (
      wrap_$1(
        statement.column,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ' ' +
      this._not(statement, 'between') +
      ' ' +
      statement.value
        .map((value) =>
          this.client.parameter(value, this.builder, this.bindingsHolder)
        )
        .join(' and ')
    );
  }

  onNull(statement) {
    return (
      wrap_$1(
        statement.column,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ' is ' +
      this._not(statement, 'null')
    );
  }

  onExists(statement) {
    return (
      this._not(statement, 'exists') +
      ' (' +
      rawOrFn_(
        statement.value,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ')'
    );
  }

  onIn(statement) {
    if (Array.isArray(statement.column)) return this.multiOnIn(statement);

    let values;
    if (statement.value instanceof Raw$2) {
      values = this.client.parameter(
        statement.value,
        this.builder,
        this.formatter
      );
    } else {
      values = this.client.parameterize(
        statement.value,
        undefined,
        this.builder,
        this.bindingsHolder
      );
    }

    return (
      wrap_$1(
        statement.column,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ' ' +
      this._not(statement, 'in ') +
      this.wrap(values)
    );
  }

  multiOnIn(statement) {
    let i = -1,
      sql = `(${columnize_$2(
        statement.column,
        this.builder,
        this.client,
        this.bindingsHolder
      )}) `;
    sql += this._not(statement, 'in ') + '((';
    while (++i < statement.value.length) {
      if (i !== 0) sql += '),(';
      sql += this.client.parameterize(
        statement.value[i],
        undefined,
        this.builder,
        this.bindingsHolder
      );
    }
    return sql + '))';
  }

  // Compiles all `where` statements on the query.
  where() {
    const wheres = this.grouped.where;
    if (!wheres) return;
    const sql = [];
    let i = -1;
    while (++i < wheres.length) {
      const stmt = wheres[i];
      if (
        Object.prototype.hasOwnProperty.call(stmt, 'value') &&
        helpers$5.containsUndefined(stmt.value)
      ) {
        this.undefinedBindingsInfo.push(stmt.column);
        this._undefinedInWhereClause = true;
      }
      const val = this[stmt.type](stmt);
      if (val) {
        if (sql.length === 0) {
          sql[0] = 'where';
        } else {
          sql.push(stmt.bool);
        }
        sql.push(val);
      }
    }
    return sql.length > 1 ? sql.join(' ') : '';
  }

  group() {
    return this._groupsOrders('group');
  }

  order() {
    return this._groupsOrders('order');
  }

  // Compiles the `having` statements.
  having() {
    const havings = this.grouped.having;
    if (!havings) return '';
    const sql = ['having'];
    for (let i = 0, l = havings.length; i < l; i++) {
      const s = havings[i];
      const val = this[s.type](s);
      if (val) {
        if (sql.length === 0) {
          sql[0] = 'where';
        }
        if (sql.length > 1 || (sql.length === 1 && sql[0] !== 'having')) {
          sql.push(s.bool);
        }
        sql.push(val);
      }
    }
    return sql.length > 1 ? sql.join(' ') : '';
  }

  havingRaw(statement) {
    return (
      this._not(statement, '') +
      unwrapRaw_(
        statement.value,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      )
    );
  }

  havingWrapped(statement) {
    const val = rawOrFn_(
      statement.value,
      'where',
      this.builder,
      this.client,
      this.bindingsHolder
    );
    return (val && this._not(statement, '') + '(' + val.slice(6) + ')') || '';
  }

  havingBasic(statement) {
    return (
      this._not(statement, '') +
      wrap_$1(
        statement.column,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ' ' +
      operator_$1(
        statement.operator,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ' ' +
      this.client.parameter(statement.value, this.builder, this.bindingsHolder)
    );
  }

  havingNull(statement) {
    return (
      wrap_$1(
        statement.column,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ' is ' +
      this._not(statement, 'null')
    );
  }

  havingExists(statement) {
    return (
      this._not(statement, 'exists') +
      ' (' +
      rawOrFn_(
        statement.value,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ')'
    );
  }

  havingBetween(statement) {
    return (
      wrap_$1(
        statement.column,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ' ' +
      this._not(statement, 'between') +
      ' ' +
      statement.value
        .map((value) =>
          this.client.parameter(value, this.builder, this.bindingsHolder)
        )
        .join(' and ')
    );
  }

  havingIn(statement) {
    if (Array.isArray(statement.column)) return this.multiHavingIn(statement);
    return (
      wrap_$1(
        statement.column,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ' ' +
      this._not(statement, 'in ') +
      this.wrap(
        this.client.parameterize(
          statement.value,
          undefined,
          this.builder,
          this.bindingsHolder
        )
      )
    );
  }

  multiHavingIn(statement) {
    return this.multiOnIn(statement);
  }

  // Compile the "union" queries attached to the main query.
  union() {
    const onlyUnions = this.onlyUnions();
    const unions = this.grouped.union;
    if (!unions) return '';
    let sql = '';
    for (let i = 0, l = unions.length; i < l; i++) {
      const union = unions[i];
      if (i > 0) sql += ' ';
      if (i > 0 || !onlyUnions) sql += union.clause + ' ';
      const statement = rawOrFn_(
        union.value,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      );
      if (statement) {
        const wrap = union.wrap;
        if (wrap) sql += '(';
        sql += statement;
        if (wrap) sql += ')';
      }
    }
    return sql;
  }

  // If we haven't specified any columns or a `tableName`, we're assuming this
  // is only being used for unions.
  onlyUnions() {
    return (
      (!this.grouped.columns || !!this.grouped.columns[0].value) &&
      this.grouped.union &&
      !this.tableName
    );
  }

  _getValueOrParameterFromAttribute(attribute, rawValue) {
    if (this.single.skipBinding[attribute] === true) {
      return rawValue !== undefined && rawValue !== null
        ? rawValue
        : this.single[attribute];
    }
    return this.client.parameter(
      this.single[attribute],
      this.builder,
      this.bindingsHolder
    );
  }

  onlyJson() {
    return (
      !this.tableName &&
      this.grouped.columns &&
      this.grouped.columns.length === 1 &&
      this.grouped.columns[0].type === 'json'
    );
  }

  limit() {
    const noLimit = !this.single.limit && this.single.limit !== 0;
    if (noLimit) return '';
    return `limit ${this._getValueOrParameterFromAttribute('limit')}`;
  }

  offset() {
    if (!this.single.offset) return '';
    return `offset ${this._getValueOrParameterFromAttribute('offset')}`;
  }

  // Compiles a `delete` query.
  del() {
    // Make sure tableName is processed by the formatter first.
    const { tableName } = this;
    const withSQL = this.with();
    const wheres = this.where();
    const joins = this.join();
    // When using joins, delete the "from" table values as a default
    const deleteSelector = joins ? tableName + ' ' : '';
    return (
      withSQL +
      `delete ${deleteSelector}from ${
        this.single.only ? 'only ' : ''
      }${tableName}` +
      (joins ? ` ${joins}` : '') +
      (wheres ? ` ${wheres}` : '')
    );
  }

  // Compiles a `truncate` query.
  truncate() {
    return `truncate ${this.tableName}`;
  }

  // Compiles the "locks".
  lock() {
    if (this.single.lock) {
      return this[this.single.lock]();
    }
  }

  // Compiles the wait mode on the locks.
  waitMode() {
    if (this.single.waitMode) {
      return this[this.single.waitMode]();
    }
  }

  // Fail on unsupported databases
  skipLocked() {
    throw new Error(
      '.skipLocked() is currently only supported on MySQL 8.0+ and PostgreSQL 9.5+'
    );
  }

  // Fail on unsupported databases
  noWait() {
    throw new Error(
      '.noWait() is currently only supported on MySQL 8.0+, MariaDB 10.3.0+ and PostgreSQL 9.5+'
    );
  }

  distinctOn(value) {
    throw new Error('.distinctOn() is currently only supported on PostgreSQL');
  }

  // On Clause
  // ------

  onWrapped(clause) {
    const self = this;

    const wrapJoin = new JoinClause();
    clause.value.call(wrapJoin, wrapJoin);

    let sql = '';

    for (let ii = 0; ii < wrapJoin.clauses.length; ii++) {
      const wrapClause = wrapJoin.clauses[ii];
      if (ii > 0) {
        sql += ` ${wrapClause.bool} `;
      }
      const val = self[wrapClause.type](wrapClause);
      if (val) {
        sql += val;
      }
    }

    if (sql.length) {
      return `(${sql})`;
    }
    return '';
  }

  onBasic(clause) {
    const toWrap = clause.value instanceof QueryBuilder$1;
    return (
      wrap_$1(
        clause.column,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ' ' +
      operator_$1(
        clause.operator,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ' ' +
      (toWrap ? '(' : '') +
      wrap_$1(
        clause.value,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      (toWrap ? ')' : '')
    );
  }

  onVal(clause) {
    return (
      wrap_$1(
        clause.column,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ' ' +
      operator_$1(
        clause.operator,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ' ' +
      this.client.parameter(clause.value, this.builder, this.bindingsHolder)
    );
  }

  onRaw(clause) {
    return unwrapRaw_(
      clause.value,
      undefined,
      this.builder,
      this.client,
      this.bindingsHolder
    );
  }

  onUsing(clause) {
    return (
      '(' +
      columnize_$2(
        clause.column,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ')'
    );
  }

  // Where Clause
  // ------

  _valueClause(statement) {
    return statement.asColumn
      ? wrap_$1(
          statement.value,
          undefined,
          this.builder,
          this.client,
          this.bindingsHolder
        )
      : this.client.parameter(
          statement.value,
          this.builder,
          this.bindingsHolder
        );
  }

  _columnClause(statement) {
    let columns;
    if (Array.isArray(statement.column)) {
      columns = `(${columnize_$2(
        statement.column,
        this.builder,
        this.client,
        this.bindingsHolder
      )})`;
    } else {
      columns = wrap_$1(
        statement.column,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      );
    }
    return columns;
  }

  whereIn(statement) {
    const values = this.client.values(
      statement.value,
      this.builder,
      this.bindingsHolder
    );
    return `${this._columnClause(statement)} ${this._not(
      statement,
      'in '
    )}${values}`;
  }

  whereLike(statement) {
    return `${this._columnClause(statement)} ${this._not(
      statement,
      'like '
    )}${this._valueClause(statement)}`;
  }

  whereILike(statement) {
    return `${this._columnClause(statement)} ${this._not(
      statement,
      'ilike '
    )}${this._valueClause(statement)}`;
  }

  whereNull(statement) {
    return (
      wrap_$1(
        statement.column,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ' is ' +
      this._not(statement, 'null')
    );
  }

  // Compiles a basic "where" clause.
  whereBasic(statement) {
    return (
      this._not(statement, '') +
      wrap_$1(
        statement.column,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ' ' +
      operator_$1(
        statement.operator,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ' ' +
      this._valueClause(statement)
    );
  }

  whereExists(statement) {
    return (
      this._not(statement, 'exists') +
      ' (' +
      rawOrFn_(
        statement.value,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ')'
    );
  }

  whereWrapped(statement) {
    const val = rawOrFn_(
      statement.value,
      'where',
      this.builder,
      this.client,
      this.bindingsHolder
    );
    return (val && this._not(statement, '') + '(' + val.slice(6) + ')') || '';
  }

  whereBetween(statement) {
    return (
      wrap_$1(
        statement.column,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ' ' +
      this._not(statement, 'between') +
      ' ' +
      statement.value
        .map((value) =>
          this.client.parameter(value, this.builder, this.bindingsHolder)
        )
        .join(' and ')
    );
  }

  // Compiles a "whereRaw" query.
  whereRaw(statement) {
    return (
      this._not(statement, '') +
      unwrapRaw_(
        statement.value,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      )
    );
  }

  _jsonWrapValue(jsonValue) {
    if (!this.builder._isJsonObject(jsonValue)) {
      try {
        return JSON.stringify(JSON.parse(jsonValue.replace(/\n|\t/g, '')));
      } catch (e) {
        return jsonValue;
      }
    }
    return JSON.stringify(jsonValue);
  }

  _jsonValueClause(statement) {
    statement.value = this._jsonWrapValue(statement.value);
    return this._valueClause(statement);
  }

  whereJsonObject(statement) {
    return `${this._columnClause(statement)} ${
      statement.not ? '!=' : '='
    } ${this._jsonValueClause(statement)}`;
  }

  wrap(str) {
    if (str.charAt(0) !== '(') return `(${str})`;
    return str;
  }

  json(stmt) {
    return this[stmt.method](stmt.params);
  }

  analytic(stmt) {
    let sql = '';
    const self = this;
    sql += stmt.method + '() over (';

    if (stmt.raw) {
      sql += stmt.raw;
    } else {
      if (stmt.partitions.length) {
        sql += 'partition by ';
        sql +=
          map$1(stmt.partitions, function (partition) {
            if (isString$3(partition)) {
              return self.formatter.columnize(partition);
            } else return self.formatter.columnize(partition.column) + (partition.order ? ' ' + partition.order : '');
          }).join(', ') + ' ';
      }

      sql += 'order by ';
      sql += map$1(stmt.order, function (order) {
        if (isString$3(order)) {
          return self.formatter.columnize(order);
        } else return self.formatter.columnize(order.column) + (order.order ? ' ' + order.order : '');
      }).join(', ');
    }

    sql += ')';

    if (stmt.alias) {
      sql += ' as ' + stmt.alias;
    }

    return sql;
  }

  // Compiles all `with` statements on the query.
  with() {
    if (!this.grouped.with || !this.grouped.with.length) {
      return '';
    }
    const withs = this.grouped.with;
    if (!withs) return;
    const sql = [];
    let i = -1;
    let isRecursive = false;
    while (++i < withs.length) {
      const stmt = withs[i];
      if (stmt.recursive) {
        isRecursive = true;
      }
      const val = this[stmt.type](stmt);
      sql.push(val);
    }
    return `with ${isRecursive ? 'recursive ' : ''}${sql.join(', ')} `;
  }

  withWrapped(statement) {
    const val = rawOrFn_(
      statement.value,
      undefined,
      this.builder,
      this.client,
      this.bindingsHolder
    );
    const columnList = statement.columnList
      ? '(' +
        columnize_$2(
          statement.columnList,
          this.builder,
          this.client,
          this.bindingsHolder
        ) +
        ')'
      : '';
    const materialized =
      statement.materialized === undefined
        ? ''
        : statement.materialized
        ? 'materialized '
        : 'not materialized ';
    return (
      (val &&
        columnize_$2(
          statement.alias,
          this.builder,
          this.client,
          this.bindingsHolder
        ) +
          columnList +
          ' as ' +
          materialized +
          '(' +
          val +
          ')') ||
      ''
    );
  }

  // Determines whether to add a "not" prefix to the where clause.
  _not(statement, str) {
    if (statement.not) return `not ${str}`;
    return str;
  }

  _prepInsert(data) {
    const isRaw = rawOrFn_(
      data,
      undefined,
      this.builder,
      this.client,
      this.bindingsHolder
    );
    if (isRaw) return isRaw;
    let columns = [];
    const values = [];
    if (!Array.isArray(data)) data = data ? [data] : [];
    let i = -1;
    while (++i < data.length) {
      if (data[i] == null) break;
      if (i === 0) columns = Object.keys(data[i]).sort();
      const row = new Array(columns.length);
      const keys = Object.keys(data[i]);
      let j = -1;
      while (++j < keys.length) {
        const key = keys[j];
        let idx = columns.indexOf(key);
        if (idx === -1) {
          columns = columns.concat(key).sort();
          idx = columns.indexOf(key);
          let k = -1;
          while (++k < values.length) {
            values[k].splice(idx, 0, undefined);
          }
          row.splice(idx, 0, undefined);
        }
        row[idx] = data[i][key];
      }
      values.push(row);
    }
    return {
      columns,
      values,
    };
  }

  // "Preps" the update.
  _prepUpdate(data = {}) {
    const { counter = {} } = this.single;

    for (const column of Object.keys(counter)) {
      //Skip?
      if (has$1(data, column)) {
        //Needed?
        this.client.logger.warn(
          `increment/decrement called for a column that has already been specified in main .update() call. Ignoring increment/decrement and using value from .update() call.`
        );
        continue;
      }

      let value = counter[column];

      const symbol = value < 0 ? '-' : '+';

      if (symbol === '-') {
        value = -value;
      }

      data[column] = this.client.raw(`?? ${symbol} ?`, [column, value]);
    }

    data = omitBy(data, isUndefined);

    const vals = [];
    const columns = Object.keys(data);
    let i = -1;

    while (++i < columns.length) {
      vals.push(
        wrap_$1(
          columns[i],
          undefined,
          this.builder,
          this.client,
          this.bindingsHolder
        ) +
          ' = ' +
          this.client.parameter(
            data[columns[i]],
            this.builder,
            this.bindingsHolder
          )
      );
    }

    if (isEmpty$1(vals)) {
      throw new Error(
        [
          'Empty .update() call detected!',
          'Update data does not contain any values to update.',
          'This will result in a faulty query.',
          this.single.table ? `Table: ${this.single.table}.` : '',
          this.single.update
            ? `Columns: ${Object.keys(this.single.update)}.`
            : '',
        ].join(' ')
      );
    }

    return vals;
  }

  _formatGroupsItemValue(value, nulls) {
    const { formatter } = this;
    let nullOrder = '';
    if (nulls === 'last') {
      nullOrder = ' is null';
    } else if (nulls === 'first') {
      nullOrder = ' is not null';
    }

    let groupOrder;
    if (value instanceof Raw$2) {
      groupOrder = unwrapRaw_(
        value,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      );
    } else if (value instanceof QueryBuilder$1 || nulls) {
      groupOrder = '(' + formatter.columnize(value) + nullOrder + ')';
    } else {
      groupOrder = formatter.columnize(value);
    }
    return groupOrder;
  }

  _basicGroupOrder(item, type) {
    const column = this._formatGroupsItemValue(item.value, item.nulls);
    const direction =
      type === 'order' && item.type !== 'orderByRaw'
        ? ` ${direction_(
            item.direction,
            this.builder,
            this.client,
            this.bindingsHolder
          )}`
        : '';
    return column + direction;
  }

  _groupOrder(item, type) {
    return this._basicGroupOrder(item, type);
  }

  _groupOrderNulls(item, type) {
    const column = this._formatGroupsItemValue(item.value);
    const direction =
      type === 'order' && item.type !== 'orderByRaw'
        ? ` ${direction_(
            item.direction,
            this.builder,
            this.client,
            this.bindingsHolder
          )}`
        : '';
    if (item.nulls && !(item.value instanceof Raw$2)) {
      return `${column}${direction ? direction : ''} nulls ${item.nulls}`;
    }
    return column + direction;
  }

  // Compiles the `order by` statements.
  _groupsOrders(type) {
    const items = this.grouped[type];
    if (!items) return '';
    const sql = items.map((item) => {
      return this._groupOrder(item, type);
    });
    return sql.length ? type + ' by ' + sql.join(', ') : '';
  }

  // Get the table name, wrapping it if necessary.
  // Implemented as a property to prevent ordering issues as described in #704.
  get tableName() {
    if (!this._tableName) {
      // Only call this.formatter.wrap() the first time this property is accessed.
      let tableName = this.single.table;
      const schemaName = this.single.schema;

      if (tableName && schemaName) {
        const isQueryBuilder = tableName instanceof QueryBuilder$1;
        const isRawQuery = tableName instanceof Raw$2;
        const isFunction = typeof tableName === 'function';

        if (!isQueryBuilder && !isRawQuery && !isFunction) {
          tableName = `${schemaName}.${tableName}`;
        }
      }

      this._tableName = tableName
        ? // Wrap subQuery with parenthesis, #3485
          wrap_$1(
            tableName,
            tableName instanceof QueryBuilder$1,
            this.builder,
            this.client,
            this.bindingsHolder
          )
        : '';
    }
    return this._tableName;
  }

  _jsonPathWrap(extraction) {
    return this.client.parameter(
      extraction.path || extraction[1],
      this.builder,
      this.bindingsHolder
    );
  }

  // Json common functions
  _jsonExtract(nameFunction, params) {
    let extractions;
    if (Array.isArray(params.column)) {
      extractions = params.column;
    } else {
      extractions = [params];
    }
    if (!Array.isArray(nameFunction)) {
      nameFunction = [nameFunction];
    }
    return extractions
      .map((extraction) => {
        let jsonCol = `${columnize_$2(
          extraction.column || extraction[0],
          this.builder,
          this.client,
          this.bindingsHolder
        )}, ${this._jsonPathWrap(extraction)}`;
        nameFunction.forEach((f) => {
          jsonCol = f + '(' + jsonCol + ')';
        });
        const alias = extraction.alias || extraction[2];
        return alias
          ? this.client.alias(jsonCol, this.formatter.wrap(alias))
          : jsonCol;
      })
      .join(', ');
  }

  _jsonSet(nameFunction, params) {
    const jsonSet = `${nameFunction}(${columnize_$2(
      params.column,
      this.builder,
      this.client,
      this.bindingsHolder
    )}, ${this.client.parameter(
      params.path,
      this.builder,
      this.bindingsHolder
    )}, ${this.client.parameter(
      params.value,
      this.builder,
      this.bindingsHolder
    )})`;
    return params.alias
      ? this.client.alias(jsonSet, this.formatter.wrap(params.alias))
      : jsonSet;
  }

  _whereJsonPath(nameFunction, statement) {
    return `${nameFunction}(${this._columnClause(
      statement
    )}, ${this._jsonPathWrap({ path: statement.jsonPath })}) ${operator_$1(
      statement.operator,
      this.builder,
      this.client,
      this.bindingsHolder
    )} ${this._jsonValueClause(statement)}`;
  }

  _onJsonPathEquals(nameJoinFunction, clause) {
    return (
      nameJoinFunction +
      '(' +
      wrap_$1(
        clause.columnFirst,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ', ' +
      this.client.parameter(
        clause.jsonPathFirst,
        this.builder,
        this.bindingsHolder
      ) +
      ') = ' +
      nameJoinFunction +
      '(' +
      wrap_$1(
        clause.columnSecond,
        undefined,
        this.builder,
        this.client,
        this.bindingsHolder
      ) +
      ', ' +
      this.client.parameter(
        clause.jsonPathSecond,
        this.builder,
        this.bindingsHolder
      ) +
      ')'
    );
  }
};

var querycompiler = QueryCompiler$1;

const { EventEmitter: EventEmitter$4 } = require$$0;
const toArray$2 = toArray_1;
const assign$3 = assign_1;
const { addQueryContext: addQueryContext$1 } = helpers$7;
const saveAsyncStack = saveAsyncStack$3;
const {
  augmentWithBuilderInterface,
} = builderInterfaceAugmenter;

// Constructor for the builder instance, typically called from
// `knex.builder`, accepting the current `knex` instance,
// and pulling out the `client` and `grammar` from the current
// knex instance.
let SchemaBuilder$1 = class SchemaBuilder extends EventEmitter$4 {
  constructor(client) {
    super();
    this.client = client;
    this._sequence = [];

    if (client.config) {
      this._debug = client.config.debug;
      saveAsyncStack(this, 4);
    }
  }

  withSchema(schemaName) {
    this._schema = schemaName;
    return this;
  }

  toString() {
    return this.toQuery();
  }

  toSQL() {
    return this.client.schemaCompiler(this).toSQL();
  }

  async generateDdlCommands() {
    return await this.client.schemaCompiler(this).generateDdlCommands();
  }
};

// Each of the schema builder methods just add to the
// "_sequence" array for consistency.
[
  'createTable',
  'createTableIfNotExists',
  'createTableLike',
  'createView',
  'createViewOrReplace',
  'createMaterializedView',
  'refreshMaterializedView',
  'dropView',
  'dropViewIfExists',
  'dropMaterializedView',
  'dropMaterializedViewIfExists',
  'createSchema',
  'createSchemaIfNotExists',
  'dropSchema',
  'dropSchemaIfExists',
  'createExtension',
  'createExtensionIfNotExists',
  'dropExtension',
  'dropExtensionIfExists',
  'table',
  'alterTable',
  'view',
  'alterView',
  'hasTable',
  'hasColumn',
  'dropTable',
  'renameTable',
  'renameView',
  'dropTableIfExists',
  'raw',
].forEach(function (method) {
  SchemaBuilder$1.prototype[method] = function () {
    if (method === 'createTableIfNotExists') {
      this.client.logger.warn(
        [
          'Use async .hasTable to check if table exists and then use plain .createTable. Since ',
          '.createTableIfNotExists actually just generates plain "CREATE TABLE IF NOT EXIST..." ',
          'query it will not work correctly if there are any alter table queries generated for ',
          'columns afterwards. To not break old migrations this function is left untouched for now',
          ', but it should not be used when writing new code and it is removed from documentation.',
        ].join('')
      );
    }
    if (method === 'table') method = 'alterTable';
    if (method === 'view') method = 'alterView';
    this._sequence.push({
      method,
      args: toArray$2(arguments),
    });
    return this;
  };
});

SchemaBuilder$1.extend = (methodName, fn) => {
  if (
    Object.prototype.hasOwnProperty.call(SchemaBuilder$1.prototype, methodName)
  ) {
    throw new Error(
      `Can't extend SchemaBuilder with existing method ('${methodName}').`
    );
  }

  assign$3(SchemaBuilder$1.prototype, { [methodName]: fn });
};

augmentWithBuilderInterface(SchemaBuilder$1);
addQueryContext$1(SchemaBuilder$1);

var builder = SchemaBuilder$1;

const tail$2 = tail_1;
const { isString: isString$2 } = is;

// Push a new query onto the compiled "sequence" stack,
// creating a new formatter, returning the compiler.
function pushQuery$3(query) {
  if (!query) return;
  if (isString$2(query)) {
    query = { sql: query };
  }
  if (!query.bindings) {
    query.bindings = this.bindingsHolder.bindings;
  }
  this.sequence.push(query);

  this.formatter = this.client.formatter(this._commonBuilder);
  this.bindings = [];
  this.formatter.bindings = this.bindings;
}

// Used in cases where we need to push some additional column specific statements.
function pushAdditional$2(fn) {
  const child = new this.constructor(
    this.client,
    this.tableCompiler,
    this.columnBuilder
  );
  fn.call(child, tail$2(arguments));
  this.sequence.additional = (this.sequence.additional || []).concat(
    child.sequence
  );
}

// Unshift a new query onto the compiled "sequence" stack,
// creating a new formatter, returning the compiler.
function unshiftQuery$2(query) {
  if (!query) return;
  if (isString$2(query)) {
    query = { sql: query };
  }
  if (!query.bindings) {
    query.bindings = this.bindingsHolder.bindings;
  }
  this.sequence.unshift(query);

  this.formatter = this.client.formatter(this._commonBuilder);
  this.bindings = [];
  this.formatter.bindings = this.bindings;
}

var helpers$4 = {
  pushAdditional: pushAdditional$2,
  pushQuery: pushQuery$3,
  unshiftQuery: unshiftQuery$2,
};

const {
  pushQuery: pushQuery$2,
  pushAdditional: pushAdditional$1,
  unshiftQuery: unshiftQuery$1,
} = helpers$4;

// The "SchemaCompiler" takes all of the query statements which have been
// gathered in the "SchemaBuilder" and turns them into an array of
// properly formatted / bound query strings.
let SchemaCompiler$1 = class SchemaCompiler {
  constructor(client, builder) {
    this.builder = builder;
    this._commonBuilder = this.builder;
    this.client = client;
    this.schema = builder._schema;

    this.bindings = [];
    this.bindingsHolder = this;
    this.formatter = client.formatter(builder);
    this.formatter.bindings = this.bindings;
    this.sequence = [];
  }

  createSchema() {
    throwOnlyPGError('createSchema');
  }

  createSchemaIfNotExists() {
    throwOnlyPGError('createSchemaIfNotExists');
  }

  dropSchema() {
    throwOnlyPGError('dropSchema');
  }

  dropSchemaIfExists() {
    throwOnlyPGError('dropSchemaIfExists');
  }

  dropTable(tableName) {
    this.pushQuery(
      this.dropTablePrefix +
        this.formatter.wrap(prefixedTableName(this.schema, tableName))
    );
  }

  dropTableIfExists(tableName) {
    this.pushQuery(
      this.dropTablePrefix +
        'if exists ' +
        this.formatter.wrap(prefixedTableName(this.schema, tableName))
    );
  }

  dropView(viewName) {
    this._dropView(viewName, false, false);
  }

  dropViewIfExists(viewName) {
    this._dropView(viewName, true, false);
  }

  dropMaterializedView(viewName) {
    throw new Error('materialized views are not supported by this dialect.');
  }

  dropMaterializedViewIfExists(viewName) {
    throw new Error('materialized views are not supported by this dialect.');
  }

  renameView(from, to) {
    throw new Error(
      'rename view is not supported by this dialect (instead drop then create another view).'
    );
  }

  refreshMaterializedView() {
    throw new Error('materialized views are not supported by this dialect.');
  }

  _dropView(viewName, ifExists, materialized) {
    this.pushQuery(
      (materialized ? this.dropMaterializedViewPrefix : this.dropViewPrefix) +
        (ifExists ? 'if exists ' : '') +
        this.formatter.wrap(prefixedTableName(this.schema, viewName))
    );
  }

  raw(sql, bindings) {
    this.sequence.push(this.client.raw(sql, bindings).toSQL());
  }

  toSQL() {
    const sequence = this.builder._sequence;
    for (let i = 0, l = sequence.length; i < l; i++) {
      const query = sequence[i];
      this[query.method].apply(this, query.args);
    }
    return this.sequence;
  }

  async generateDdlCommands() {
    const generatedCommands = this.toSQL();
    return {
      pre: [],
      sql: Array.isArray(generatedCommands)
        ? generatedCommands
        : [generatedCommands],
      check: null,
      post: [],
    };
  }
};

SchemaCompiler$1.prototype.dropTablePrefix = 'drop table ';
SchemaCompiler$1.prototype.dropViewPrefix = 'drop view ';
SchemaCompiler$1.prototype.dropMaterializedViewPrefix = 'drop materialized view ';
SchemaCompiler$1.prototype.alterViewPrefix = 'alter view ';

SchemaCompiler$1.prototype.alterTable = buildTable('alter');
SchemaCompiler$1.prototype.createTable = buildTable('create');
SchemaCompiler$1.prototype.createTableIfNotExists = buildTable('createIfNot');
SchemaCompiler$1.prototype.createTableLike = buildTable('createLike');

SchemaCompiler$1.prototype.createView = buildView('create');
SchemaCompiler$1.prototype.createViewOrReplace = buildView('createOrReplace');
SchemaCompiler$1.prototype.createMaterializedView = buildView(
  'createMaterializedView'
);
SchemaCompiler$1.prototype.alterView = buildView('alter');

SchemaCompiler$1.prototype.pushQuery = pushQuery$2;
SchemaCompiler$1.prototype.pushAdditional = pushAdditional$1;
SchemaCompiler$1.prototype.unshiftQuery = unshiftQuery$1;

function build(builder) {
  // pass queryContext down to tableBuilder but do not overwrite it if already set
  const queryContext = this.builder.queryContext();
  if (queryContext !== undefined && builder.queryContext() === undefined) {
    builder.queryContext(queryContext);
  }

  builder.setSchema(this.schema);
  const sql = builder.toSQL();

  for (let i = 0, l = sql.length; i < l; i++) {
    this.sequence.push(sql[i]);
  }
}

function buildTable(type) {
  if (type === 'createLike') {
    return function (tableName, tableNameLike, fn) {
      const builder = this.client.tableBuilder(
        type,
        tableName,
        tableNameLike,
        fn
      );
      build.call(this, builder);
    };
  } else {
    return function (tableName, fn) {
      const builder = this.client.tableBuilder(type, tableName, null, fn);
      build.call(this, builder);
    };
  }
}

function buildView(type) {
  return function (viewName, fn) {
    const builder = this.client.viewBuilder(type, viewName, fn);
    build.call(this, builder);
  };
}

function prefixedTableName(prefix, table) {
  return prefix ? `${prefix}.${table}` : table;
}

function throwOnlyPGError(operationName) {
  throw new Error(
    `${operationName} is not supported for this dialect (only PostgreSQL supports it currently).`
  );
}

var compiler = SchemaCompiler$1;

var extendExports = {};
var extend$4 = {
  get exports(){ return extendExports; },
  set exports(v){ extendExports = v; },
};

var copyObject = _copyObject,
    createAssigner = _createAssigner,
    keysIn = keysIn_1;

/**
 * This method is like `_.assign` except that it iterates over own and
 * inherited source properties.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extend
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.assign
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * function Bar() {
 *   this.c = 3;
 * }
 *
 * Foo.prototype.b = 2;
 * Bar.prototype.d = 4;
 *
 * _.assignIn({ 'a': 0 }, new Foo, new Bar);
 * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
 */
var assignIn = createAssigner(function(object, source) {
  copyObject(source, keysIn(source), object);
});

var assignIn_1 = assignIn;

(function (module) {
	module.exports = assignIn_1;
} (extend$4));

// TableBuilder

// Takes the function passed to the "createTable" or "table/editTable"
// functions and calls it with the "TableBuilder" as both the context and
// the first argument. Inside this function we can specify what happens to the
// method, pushing everything we want to do onto the "allStatements" array,
// which is then compiled into sql.
// ------
const each$1 = eachExports;
const extend$3 = extendExports;
const assign$2 = assign_1;
const toArray$1 = toArray_1;
const helpers$3 = helpers$7;
const { isString: isString$1, isFunction, isObject } = is;

let TableBuilder$1 = class TableBuilder {
  constructor(client, method, tableName, tableNameLike, fn) {
    this.client = client;
    this._fn = fn;
    this._method = method;
    this._schemaName = undefined;
    this._tableName = tableName;
    this._tableNameLike = tableNameLike;
    this._statements = [];
    this._single = {};

    if (!tableNameLike && !isFunction(this._fn)) {
      throw new TypeError(
        'A callback function must be supplied to calls against `.createTable` ' +
          'and `.table`'
      );
    }
  }

  setSchema(schemaName) {
    this._schemaName = schemaName;
  }

  // Convert the current tableBuilder object "toSQL"
  // giving us additional methods if we're altering
  // rather than creating the table.
  toSQL() {
    if (this._method === 'alter') {
      extend$3(this, AlterMethods$2);
    }
    // With 'create table ... like' callback function is useless.
    if (this._fn) {
      this._fn.call(this, this);
    }
    return this.client.tableCompiler(this).toSQL();
  }

  // The "timestamps" call is really just sets the `created_at` and `updated_at` columns.

  timestamps(useTimestamps, defaultToNow, useCamelCase) {
    if (isObject(useTimestamps)) {
      ({ useTimestamps, defaultToNow, useCamelCase } = useTimestamps);
    }
    const method = useTimestamps === true ? 'timestamp' : 'datetime';
    const createdAt = this[method](useCamelCase ? 'createdAt' : 'created_at');
    const updatedAt = this[method](useCamelCase ? 'updatedAt' : 'updated_at');

    if (defaultToNow === true) {
      const now = this.client.raw('CURRENT_TIMESTAMP');
      createdAt.notNullable().defaultTo(now);
      updatedAt.notNullable().defaultTo(now);
    }
  }

  // Set the comment value for a table, they're only allowed to be called
  // once per table.
  comment(value) {
    if (typeof value !== 'string') {
      throw new TypeError('Table comment must be string');
    }
    this._single.comment = value;
  }

  // Set a foreign key on the table, calling
  // `table.foreign('column_name').references('column').on('table').onDelete()...
  // Also called from the ColumnBuilder context when chaining.
  foreign(column, keyName) {
    const foreignData = { column: column, keyName: keyName };
    this._statements.push({
      grouping: 'alterTable',
      method: 'foreign',
      args: [foreignData],
    });
    let returnObj = {
      references(tableColumn) {
        let pieces;
        if (isString$1(tableColumn)) {
          pieces = tableColumn.split('.');
        }
        if (!pieces || pieces.length === 1) {
          foreignData.references = pieces ? pieces[0] : tableColumn;
          return {
            on(tableName) {
              if (typeof tableName !== 'string') {
                throw new TypeError(
                  `Expected tableName to be a string, got: ${typeof tableName}`
                );
              }
              foreignData.inTable = tableName;
              return returnObj;
            },
            inTable() {
              return this.on.apply(this, arguments);
            },
          };
        }
        foreignData.inTable = pieces[0];
        foreignData.references = pieces[1];
        return returnObj;
      },
      withKeyName(keyName) {
        foreignData.keyName = keyName;
        return returnObj;
      },
      onUpdate(statement) {
        foreignData.onUpdate = statement;
        return returnObj;
      },
      onDelete(statement) {
        foreignData.onDelete = statement;
        return returnObj;
      },
      deferrable: (type) => {
        const unSupported = [
          'mysql',
          'mssql',
          'redshift',
          'mysql2',
          'oracledb',
        ];
        if (unSupported.indexOf(this.client.dialect) !== -1) {
          throw new Error(`${this.client.dialect} does not support deferrable`);
        }
        foreignData.deferrable = type;
        return returnObj;
      },
      _columnBuilder(builder) {
        extend$3(builder, returnObj);
        returnObj = builder;
        return builder;
      },
    };
    return returnObj;
  }

  check(checkPredicate, bindings, constraintName) {
    this._statements.push({
      grouping: 'checks',
      args: [checkPredicate, bindings, constraintName],
    });
    return this;
  }
};

[
  // Each of the index methods can be called individually, with the
  // column name to be used, e.g. table.unique('column').
  'index',
  'primary',
  'unique',

  // Key specific
  'dropPrimary',
  'dropUnique',
  'dropIndex',
  'dropForeign',
].forEach((method) => {
  TableBuilder$1.prototype[method] = function () {
    this._statements.push({
      grouping: 'alterTable',
      method,
      args: toArray$1(arguments),
    });
    return this;
  };
});

// Warn for dialect-specific table methods, since that's the
// only time these are supported.
const specialMethods = {
  mysql: ['engine', 'charset', 'collate'],
  postgresql: ['inherits'],
};
each$1(specialMethods, function (methods, dialect) {
  methods.forEach(function (method) {
    TableBuilder$1.prototype[method] = function (value) {
      if (this.client.dialect !== dialect) {
        throw new Error(
          `Knex only supports ${method} statement with ${dialect}.`
        );
      }
      if (this._method === 'alter') {
        throw new Error(
          `Knex does not support altering the ${method} outside of create ` +
            `table, please use knex.raw statement.`
        );
      }
      this._single[method] = value;
    };
  });
});

helpers$3.addQueryContext(TableBuilder$1);

// Each of the column types that we can add, we create a new ColumnBuilder
// instance and push it onto the statements array.
const columnTypes = [
  // Numeric
  'tinyint',
  'smallint',
  'mediumint',
  'int',
  'bigint',
  'decimal',
  'float',
  'double',
  'real',
  'bit',
  'boolean',
  'serial',

  // Date / Time
  'date',
  'datetime',
  'timestamp',
  'time',
  'year',

  // Geometry
  'geometry',
  'geography',
  'point',

  // String
  'char',
  'varchar',
  'tinytext',
  'tinyText',
  'text',
  'mediumtext',
  'mediumText',
  'longtext',
  'longText',
  'binary',
  'varbinary',
  'tinyblob',
  'tinyBlob',
  'mediumblob',
  'mediumBlob',
  'blob',
  'longblob',
  'longBlob',
  'enum',
  'set',

  // Increments, Aliases, and Additional
  'bool',
  'dateTime',
  'increments',
  'bigincrements',
  'bigIncrements',
  'integer',
  'biginteger',
  'bigInteger',
  'string',
  'json',
  'jsonb',
  'uuid',
  'enu',
  'specificType',
];

// For each of the column methods, create a new "ColumnBuilder" interface,
// push it onto the "allStatements" stack, and then return the interface,
// with which we can add indexes, etc.
columnTypes.forEach((type) => {
  TableBuilder$1.prototype[type] = function () {
    const args = toArray$1(arguments);
    const builder = this.client.columnBuilder(this, type, args);
    this._statements.push({
      grouping: 'columns',
      builder,
    });
    return builder;
  };
});

const AlterMethods$2 = {
  // Renames the current column `from` the current
  // TODO: this.column(from).rename(to)
  renameColumn(from, to) {
    this._statements.push({
      grouping: 'alterTable',
      method: 'renameColumn',
      args: [from, to],
    });
    return this;
  },

  dropTimestamps() {
    // arguments[0] = useCamelCase
    return this.dropColumns(
      arguments[0] === true
        ? ['createdAt', 'updatedAt']
        : ['created_at', 'updated_at']
    );
  },

  setNullable(column) {
    this._statements.push({
      grouping: 'alterTable',
      method: 'setNullable',
      args: [column],
    });

    return this;
  },

  check(checkPredicate, bindings, constraintName) {
    this._statements.push({
      grouping: 'alterTable',
      method: 'check',
      args: [checkPredicate, bindings, constraintName],
    });
  },

  dropChecks() {
    this._statements.push({
      grouping: 'alterTable',
      method: 'dropChecks',
      args: toArray$1(arguments),
    });
  },

  dropNullable(column) {
    this._statements.push({
      grouping: 'alterTable',
      method: 'dropNullable',
      args: [column],
    });

    return this;
  },

  // TODO: changeType
};

// Drop a column from the current table.
// TODO: Enable this.column(columnName).drop();
AlterMethods$2.dropColumn = AlterMethods$2.dropColumns = function () {
  this._statements.push({
    grouping: 'alterTable',
    method: 'dropColumn',
    args: toArray$1(arguments),
  });
  return this;
};

TableBuilder$1.extend = (methodName, fn) => {
  if (
    Object.prototype.hasOwnProperty.call(TableBuilder$1.prototype, methodName)
  ) {
    throw new Error(
      `Can't extend TableBuilder with existing method ('${methodName}').`
    );
  }

  assign$2(TableBuilder$1.prototype, { [methodName]: fn });
};

var tablebuilder = TableBuilder$1;

var baseIndexOf = _baseIndexOf,
    toInteger = toInteger_1;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Gets the index at which the first occurrence of `value` is found in `array`
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. If `fromIndex` is negative, it's used as the
 * offset from the end of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 * @example
 *
 * _.indexOf([1, 2, 1, 2], 2);
 * // => 1
 *
 * // Search from the `fromIndex`.
 * _.indexOf([1, 2, 1, 2], 2, 2);
 * // => 3
 */
function indexOf$1(array, value, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index < 0) {
    index = nativeMax(length + index, 0);
  }
  return baseIndexOf(array, value, index);
}

var indexOf_1 = indexOf$1;

/* eslint max-len:0 */

// Table Compiler
// -------
const {
  pushAdditional,
  pushQuery: pushQuery$1,
  unshiftQuery,
} = helpers$4;
const helpers$2 = helpers$7;
const groupBy$2 = groupBy_1;
const indexOf = indexOf_1;
const isEmpty = isEmpty_1;
const tail$1 = tail_1;
const { normalizeArr } = helpers$7;

let TableCompiler$1 = class TableCompiler {
  constructor(client, tableBuilder) {
    this.client = client;
    this.tableBuilder = tableBuilder;
    this._commonBuilder = this.tableBuilder;
    this.method = tableBuilder._method;
    this.schemaNameRaw = tableBuilder._schemaName;
    this.tableNameRaw = tableBuilder._tableName;
    this.tableNameLikeRaw = tableBuilder._tableNameLike;
    this.single = tableBuilder._single;
    this.grouped = groupBy$2(tableBuilder._statements, 'grouping');

    this.formatter = client.formatter(tableBuilder);
    this.bindings = [];
    this.formatter.bindings = this.bindings;
    this.bindingsHolder = this;

    this.sequence = [];
    this._formatting = client.config && client.config.formatting;

    this.checksCount = 0;
  }

  // Convert the tableCompiler toSQL
  toSQL() {
    this[this.method]();
    return this.sequence;
  }

  // Column Compilation
  // -------

  // If this is a table "creation", we need to first run through all
  // of the columns to build them into a single string,
  // and then run through anything else and push it to the query sequence.
  create(ifNot, like) {
    const columnBuilders = this.getColumns();
    const columns = columnBuilders.map((col) => col.toSQL());
    const columnTypes = this.getColumnTypes(columns);
    if (this.createAlterTableMethods) {
      this.alterTableForCreate(columnTypes);
    }
    this.createQuery(columnTypes, ifNot, like);
    this.columnQueries(columns);
    delete this.single.comment;
    this.alterTable();
  }

  // Only create the table if it doesn't exist.
  createIfNot() {
    this.create(true);
  }

  createLike() {
    this.create(false, true);
  }

  createLikeIfNot() {
    this.create(true, true);
  }

  // If we're altering the table, we need to one-by-one
  // go through and handle each of the queries associated
  // with altering the table's schema.
  alter() {
    const addColBuilders = this.getColumns();
    const addColumns = addColBuilders.map((col) => col.toSQL());
    const alterColBuilders = this.getColumns('alter');
    const alterColumns = alterColBuilders.map((col) => col.toSQL());
    const addColumnTypes = this.getColumnTypes(addColumns);
    const alterColumnTypes = this.getColumnTypes(alterColumns);

    this.addColumns(addColumnTypes);
    this.alterColumns(alterColumnTypes, alterColBuilders);
    this.columnQueries(addColumns);
    this.columnQueries(alterColumns);
    this.alterTable();
  }

  foreign(foreignData) {
    if (foreignData.inTable && foreignData.references) {
      const keyName = foreignData.keyName
        ? this.formatter.wrap(foreignData.keyName)
        : this._indexCommand('foreign', this.tableNameRaw, foreignData.column);
      const column = this.formatter.columnize(foreignData.column);
      const references = this.formatter.columnize(foreignData.references);
      const inTable = this.formatter.wrap(foreignData.inTable);
      const onUpdate = foreignData.onUpdate
        ? (this.lowerCase ? ' on update ' : ' ON UPDATE ') +
          foreignData.onUpdate
        : '';
      const onDelete = foreignData.onDelete
        ? (this.lowerCase ? ' on delete ' : ' ON DELETE ') +
          foreignData.onDelete
        : '';
      const deferrable = foreignData.deferrable
        ? this.lowerCase
          ? ` deferrable initially ${foreignData.deferrable.toLowerCase()} `
          : ` DEFERRABLE INITIALLY ${foreignData.deferrable.toUpperCase()} `
        : '';
      if (this.lowerCase) {
        this.pushQuery(
          (!this.forCreate ? `alter table ${this.tableName()} add ` : '') +
            'constraint ' +
            keyName +
            ' ' +
            'foreign key (' +
            column +
            ') references ' +
            inTable +
            ' (' +
            references +
            ')' +
            onUpdate +
            onDelete +
            deferrable
        );
      } else {
        this.pushQuery(
          (!this.forCreate ? `ALTER TABLE ${this.tableName()} ADD ` : '') +
            'CONSTRAINT ' +
            keyName +
            ' ' +
            'FOREIGN KEY (' +
            column +
            ') REFERENCES ' +
            inTable +
            ' (' +
            references +
            ')' +
            onUpdate +
            onDelete +
            deferrable
        );
      }
    }
  }

  // Get all of the column sql & bindings individually for building the table queries.
  getColumnTypes(columns) {
    return columns.reduce(
      function (memo, columnSQL) {
        const column = columnSQL[0];
        memo.sql.push(column.sql);
        memo.bindings.concat(column.bindings);
        return memo;
      },
      { sql: [], bindings: [] }
    );
  }

  // Adds all of the additional queries from the "column"
  columnQueries(columns) {
    const queries = columns.reduce(function (memo, columnSQL) {
      const column = tail$1(columnSQL);
      if (!isEmpty(column)) return memo.concat(column);
      return memo;
    }, []);
    for (const q of queries) {
      this.pushQuery(q);
    }
  }

  // All of the columns to "add" for the query
  addColumns(columns, prefix) {
    prefix = prefix || this.addColumnsPrefix;

    if (columns.sql.length > 0) {
      const columnSql = columns.sql.map((column) => {
        return prefix + column;
      });
      this.pushQuery({
        sql:
          (this.lowerCase ? 'alter table ' : 'ALTER TABLE ') +
          this.tableName() +
          ' ' +
          columnSql.join(', '),
        bindings: columns.bindings,
      });
    }
  }

  alterColumns(columns, colBuilders) {
    if (columns.sql.length > 0) {
      this.addColumns(columns, this.alterColumnsPrefix, colBuilders);
    }
  }

  // Compile the columns as needed for the current create or alter table
  getColumns(method) {
    const columns = this.grouped.columns || [];
    method = method || 'add';

    const queryContext = this.tableBuilder.queryContext();

    return columns
      .filter((column) => column.builder._method === method)
      .map((column) => {
        // pass queryContext down to columnBuilder but do not overwrite it if already set
        if (
          queryContext !== undefined &&
          column.builder.queryContext() === undefined
        ) {
          column.builder.queryContext(queryContext);
        }
        return this.client.columnCompiler(this, column.builder);
      });
  }

  tableName() {
    const name = this.schemaNameRaw
      ? `${this.schemaNameRaw}.${this.tableNameRaw}`
      : this.tableNameRaw;

    return this.formatter.wrap(name);
  }

  tableNameLike() {
    const name = this.schemaNameRaw
      ? `${this.schemaNameRaw}.${this.tableNameLikeRaw}`
      : this.tableNameLikeRaw;

    return this.formatter.wrap(name);
  }

  // Generate all of the alter column statements necessary for the query.
  alterTable() {
    const alterTable = this.grouped.alterTable || [];
    for (let i = 0, l = alterTable.length; i < l; i++) {
      const statement = alterTable[i];
      if (this[statement.method]) {
        this[statement.method].apply(this, statement.args);
      } else {
        this.client.logger.error(`Debug: ${statement.method} does not exist`);
      }
    }
    for (const item in this.single) {
      if (typeof this[item] === 'function') this[item](this.single[item]);
    }
  }

  alterTableForCreate(columnTypes) {
    this.forCreate = true;
    const savedSequence = this.sequence;
    const alterTable = this.grouped.alterTable || [];
    this.grouped.alterTable = [];
    for (let i = 0, l = alterTable.length; i < l; i++) {
      const statement = alterTable[i];
      if (indexOf(this.createAlterTableMethods, statement.method) < 0) {
        this.grouped.alterTable.push(statement);
        continue;
      }
      if (this[statement.method]) {
        this.sequence = [];
        this[statement.method].apply(this, statement.args);
        columnTypes.sql.push(this.sequence[0].sql);
      } else {
        this.client.logger.error(`Debug: ${statement.method} does not exist`);
      }
    }
    this.sequence = savedSequence;
    this.forCreate = false;
  }

  // Drop the index on the current table.
  dropIndex(value) {
    this.pushQuery(`drop index${value}`);
  }

  dropUnique() {
    throw new Error('Method implemented in the dialect driver');
  }

  dropForeign() {
    throw new Error('Method implemented in the dialect driver');
  }

  dropColumn() {
    const columns = helpers$2.normalizeArr.apply(null, arguments);
    const drops = (Array.isArray(columns) ? columns : [columns]).map(
      (column) => {
        return this.dropColumnPrefix + this.formatter.wrap(column);
      }
    );
    this.pushQuery(
      (this.lowerCase ? 'alter table ' : 'ALTER TABLE ') +
        this.tableName() +
        ' ' +
        drops.join(', ')
    );
  }

  //Default implementation of setNullable. Overwrite on dialect-specific tablecompiler when needed
  //(See postgres/mssql for reference)
  _setNullableState(column, nullable) {
    const tableName = this.tableName();
    const columnName = this.formatter.columnize(column);
    const alterColumnPrefix = this.alterColumnsPrefix;
    return this.pushQuery({
      sql: 'SELECT 1',
      output: () => {
        return this.client
          .queryBuilder()
          .from(this.tableNameRaw)
          .columnInfo(column)
          .then((columnInfo) => {
            if (isEmpty(columnInfo)) {
              throw new Error(
                `.setNullable: Column ${columnName} does not exist in table ${tableName}.`
              );
            }
            const nullableType = nullable ? 'null' : 'not null';
            const columnType =
              columnInfo.type +
              (columnInfo.maxLength ? `(${columnInfo.maxLength})` : '');
            const defaultValue =
              columnInfo.defaultValue !== null &&
              columnInfo.defaultValue !== void 0
                ? `default '${columnInfo.defaultValue}'`
                : '';
            const sql = `alter table ${tableName} ${alterColumnPrefix} ${columnName} ${columnType} ${nullableType} ${defaultValue}`;
            return this.client.raw(sql);
          });
      },
    });
  }

  setNullable(column) {
    return this._setNullableState(column, true);
  }

  dropNullable(column) {
    return this._setNullableState(column, false);
  }

  dropChecks(checkConstraintNames) {
    if (checkConstraintNames === undefined) return '';
    checkConstraintNames = normalizeArr(checkConstraintNames);
    const tableName = this.tableName();
    const sql = `alter table ${tableName} ${checkConstraintNames
      .map((constraint) => `drop constraint ${constraint}`)
      .join(', ')}`;
    this.pushQuery(sql);
  }

  check(checkPredicate, bindings, constraintName) {
    const tableName = this.tableName();
    let checkConstraint = constraintName;
    if (!checkConstraint) {
      this.checksCount++;
      checkConstraint = tableName + '_' + this.checksCount;
    }
    const sql = `alter table ${tableName} add constraint ${checkConstraint} check(${checkPredicate})`;
    this.pushQuery(sql);
  }

  _addChecks() {
    if (this.grouped.checks) {
      return (
        ', ' +
        this.grouped.checks
          .map((c) => {
            return `${
              c.args[2] ? 'constraint ' + c.args[2] + ' ' : ''
            }check (${this.client.raw(c.args[0], c.args[1])})`;
          })
          .join(', ')
      );
    }
    return '';
  }

  // If no name was specified for this index, we will create one using a basic
  // convention of the table name, followed by the columns, followed by an
  // index type, such as primary or index, which makes the index unique.
  _indexCommand(type, tableName, columns) {
    if (!Array.isArray(columns)) columns = columns ? [columns] : [];
    const table = tableName.replace(/\.|-/g, '_');
    const indexName = (
      table +
      '_' +
      columns.join('_') +
      '_' +
      type
    ).toLowerCase();
    return this.formatter.wrap(indexName);
  }

  _getPrimaryKeys() {
    return (this.grouped.alterTable || [])
      .filter((a) => a.method === 'primary')
      .flatMap((a) => a.args)
      .flat();
  }

  _canBeAddPrimaryKey(options) {
    return options.primaryKey && this._getPrimaryKeys().length === 0;
  }

  _getIncrementsColumnNames() {
    return this.grouped.columns
      .filter((c) => c.builder._type === 'increments')
      .map((c) => c.builder._args[0]);
  }
};

TableCompiler$1.prototype.pushQuery = pushQuery$1;
TableCompiler$1.prototype.pushAdditional = pushAdditional;
TableCompiler$1.prototype.unshiftQuery = unshiftQuery;
TableCompiler$1.prototype.lowerCase = true;
TableCompiler$1.prototype.createAlterTableMethods = null;
TableCompiler$1.prototype.addColumnsPrefix = 'add column ';
TableCompiler$1.prototype.alterColumnsPrefix = 'alter column ';
TableCompiler$1.prototype.modifyColumnPrefix = 'modify column ';
TableCompiler$1.prototype.dropColumnPrefix = 'drop column ';

var tablecompiler = TableCompiler$1;

const extend$2 = extendExports;
const assign$1 = assign_1;
const toArray = toArray_1;
const { addQueryContext } = helpers$7;

// The chainable interface off the original "column" method.
let ColumnBuilder$1 = class ColumnBuilder {
  constructor(client, tableBuilder, type, args) {
    this.client = client;
    this._method = 'add';
    this._single = {};
    this._modifiers = {};
    this._statements = [];
    this._type = columnAlias[type] || type;
    this._args = args;
    this._tableBuilder = tableBuilder;

    // If we're altering the table, extend the object
    // with the available "alter" methods.
    if (tableBuilder._method === 'alter') {
      extend$2(this, AlterMethods$1);
    }
  }

  // Specify that the current column "references" a column,
  // which may be tableName.column or just "column"
  references(value) {
    return this._tableBuilder.foreign
      .call(this._tableBuilder, this._args[0], undefined, this)
      ._columnBuilder(this)
      .references(value);
  }
};

// All of the modifier methods that can be used to modify the current query.
const modifiers = [
  'default',
  'defaultsTo',
  'defaultTo',
  'unsigned',
  'nullable',
  'first',
  'after',
  'comment',
  'collate',
  'check',
  'checkPositive',
  'checkNegative',
  'checkIn',
  'checkNotIn',
  'checkBetween',
  'checkLength',
  'checkRegex',
];

// Aliases for convenience.
const aliasMethod = {
  default: 'defaultTo',
  defaultsTo: 'defaultTo',
};

// If we call any of the modifiers (index or otherwise) on the chainable, we pretend
// as though we're calling `table.method(column)` directly.
modifiers.forEach(function (method) {
  const key = aliasMethod[method] || method;
  ColumnBuilder$1.prototype[method] = function () {
    this._modifiers[key] = toArray(arguments);
    return this;
  };
});

addQueryContext(ColumnBuilder$1);

ColumnBuilder$1.prototype.notNull = ColumnBuilder$1.prototype.notNullable =
  function notNullable() {
    return this.nullable(false);
  };

['index', 'primary', 'unique'].forEach(function (method) {
  ColumnBuilder$1.prototype[method] = function () {
    if (this._type.toLowerCase().indexOf('increments') === -1) {
      this._tableBuilder[method].apply(
        this._tableBuilder,
        [this._args[0]].concat(toArray(arguments))
      );
    }
    return this;
  };
});

ColumnBuilder$1.extend = (methodName, fn) => {
  if (
    Object.prototype.hasOwnProperty.call(ColumnBuilder$1.prototype, methodName)
  ) {
    throw new Error(
      `Can't extend ColumnBuilder with existing method ('${methodName}').`
    );
  }

  assign$1(ColumnBuilder$1.prototype, { [methodName]: fn });
};

const AlterMethods$1 = {};

// Specify that the column is to be dropped. This takes precedence
// over all other rules for the column.
AlterMethods$1.drop = function () {
  this._single.drop = true;

  return this;
};

// Specify the "type" that we're looking to set the
// Knex takes no responsibility for any data-loss that may
// occur when changing data types.
AlterMethods$1.alterType = function (type) {
  this._statements.push({
    grouping: 'alterType',
    value: type,
  });

  return this;
};

// Set column method to alter (default is add).
AlterMethods$1.alter = function ({
  alterNullable = true,
  alterType = true,
} = {}) {
  this._method = 'alter';
  this.alterNullable = alterNullable;
  this.alterType = alterType;

  return this;
};

// Alias a few methods for clarity when processing.
const columnAlias = {
  float: 'floating',
  enum: 'enu',
  boolean: 'bool',
  string: 'varchar',
  bigint: 'bigInteger',
};

var columnbuilder = ColumnBuilder$1;

var firstExports = {};
var first$1 = {
  get exports(){ return firstExports; },
  set exports(v){ firstExports = v; },
};

/**
 * Gets the first element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias first
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the first element of `array`.
 * @example
 *
 * _.head([1, 2, 3]);
 * // => 1
 *
 * _.head([]);
 * // => undefined
 */

function head(array) {
  return (array && array.length) ? array[0] : undefined;
}

var head_1 = head;

(function (module) {
	module.exports = head_1;
} (first$1));

// Column Compiler
// Used for designating column definitions
// during the table "create" / "alter" statements.
// -------
const helpers$1 = helpers$4;
const groupBy$1 = groupBy_1;
const first = firstExports;
const has = has_1;
const tail = tail_1;
const { toNumber } = helpers$7;
const { formatDefault } = formatterUtils;
const { operator: operator_ } = wrappingFormatter;

let ColumnCompiler$1 = class ColumnCompiler {
  constructor(client, tableCompiler, columnBuilder) {
    this.client = client;
    this.tableCompiler = tableCompiler;
    this.columnBuilder = columnBuilder;
    this._commonBuilder = this.columnBuilder;
    this.args = columnBuilder._args;
    this.type = columnBuilder._type.toLowerCase();
    this.grouped = groupBy$1(columnBuilder._statements, 'grouping');
    this.modified = columnBuilder._modifiers;
    this.isIncrements = this.type.indexOf('increments') !== -1;

    this.formatter = client.formatter(columnBuilder);
    this.bindings = [];
    this.formatter.bindings = this.bindings;
    this.bindingsHolder = this;

    this.sequence = [];
    this.modifiers = [];

    this.checksCount = 0;
  }

  _addCheckModifiers() {
    this.modifiers.push(
      'check',
      'checkPositive',
      'checkNegative',
      'checkIn',
      'checkNotIn',
      'checkBetween',
      'checkLength',
      'checkRegex'
    );
  }

  defaults(label) {
    if (Object.prototype.hasOwnProperty.call(this._defaultMap, label)) {
      return this._defaultMap[label].bind(this)();
    } else {
      throw new Error(
        `There is no default for the specified identifier ${label}`
      );
    }
  }

  // To convert to sql, we first go through and build the
  // column as it would be in the insert statement
  toSQL() {
    this.pushQuery(this.compileColumn());
    if (this.sequence.additional) {
      this.sequence = this.sequence.concat(this.sequence.additional);
    }
    return this.sequence;
  }

  // Compiles a column.
  compileColumn() {
    return (
      this.formatter.wrap(this.getColumnName()) +
      ' ' +
      this.getColumnType() +
      this.getModifiers()
    );
  }

  // Assumes the autoincrementing key is named `id` if not otherwise specified.
  getColumnName() {
    const value = first(this.args);
    return value || this.defaults('columnName');
  }

  getColumnType() {
    // Column type is cached so side effects (such as in pg native enums) are only run once
    if (!this._columnType) {
      const type = this[this.type];
      this._columnType =
        typeof type === 'function' ? type.apply(this, tail(this.args)) : type;
    }

    return this._columnType;
  }

  getModifiers() {
    const modifiers = [];

    for (let i = 0, l = this.modifiers.length; i < l; i++) {
      const modifier = this.modifiers[i];

      //Cannot allow 'nullable' modifiers on increments types
      if (!this.isIncrements || (this.isIncrements && modifier === 'comment')) {
        if (has(this.modified, modifier)) {
          const val = this[modifier].apply(this, this.modified[modifier]);
          if (val) modifiers.push(val);
        }
      }
    }

    return modifiers.length > 0 ? ` ${modifiers.join(' ')}` : '';
  }

  // Types
  // ------
  varchar(length) {
    return `varchar(${toNumber(length, 255)})`;
  }

  floating(precision, scale) {
    return `float(${toNumber(precision, 8)}, ${toNumber(scale, 2)})`;
  }

  decimal(precision, scale) {
    if (precision === null) {
      throw new Error(
        'Specifying no precision on decimal columns is not supported for that SQL dialect.'
      );
    }
    return `decimal(${toNumber(precision, 8)}, ${toNumber(scale, 2)})`;
  }

  // Used to support custom types
  specifictype(type) {
    return type;
  }

  // Modifiers
  // -------

  nullable(nullable) {
    return nullable === false ? 'not null' : 'null';
  }

  notNullable() {
    return this.nullable(false);
  }

  defaultTo(value) {
    return `default ${formatDefault(value, this.type, this.client)}`;
  }

  increments(options = { primaryKey: true }) {
    return (
      'integer not null' +
      (this.tableCompiler._canBeAddPrimaryKey(options) ? ' primary key' : '') +
      ' autoincrement'
    );
  }

  bigincrements(options = { primaryKey: true }) {
    return this.increments(options);
  }

  _pushAlterCheckQuery(checkPredicate, constraintName) {
    let checkName = constraintName;
    if (!checkName) {
      this.checksCount++;
      checkName =
        this.tableCompiler.tableNameRaw +
        '_' +
        this.getColumnName() +
        '_' +
        this.checksCount;
    }
    this.pushAdditional(function () {
      this.pushQuery(
        `alter table ${this.tableCompiler.tableName()} add constraint ${checkName} check(${checkPredicate})`
      );
    });
  }

  _checkConstraintName(constraintName) {
    return constraintName ? `constraint ${constraintName} ` : '';
  }

  _check(checkPredicate, constraintName) {
    if (this.columnBuilder._method === 'alter') {
      this._pushAlterCheckQuery(checkPredicate, constraintName);
      return '';
    }
    return `${this._checkConstraintName(
      constraintName
    )}check (${checkPredicate})`;
  }

  checkPositive(constraintName) {
    return this._check(
      `${this.formatter.wrap(this.getColumnName())} ${operator_(
        '>',
        this.columnBuilder,
        this.bindingsHolder
      )} 0`,
      constraintName
    );
  }

  checkNegative(constraintName) {
    return this._check(
      `${this.formatter.wrap(this.getColumnName())} ${operator_(
        '<',
        this.columnBuilder,
        this.bindingsHolder
      )} 0`,
      constraintName
    );
  }

  _checkIn(values, constraintName, not) {
    return this._check(
      `${this.formatter.wrap(this.getColumnName())} ${
        not ? 'not ' : ''
      }in (${values.map((v) => this.client._escapeBinding(v)).join(',')})`,
      constraintName
    );
  }

  checkIn(values, constraintName) {
    return this._checkIn(values, constraintName);
  }

  checkNotIn(values, constraintName) {
    return this._checkIn(values, constraintName, true);
  }

  checkBetween(intervals, constraintName) {
    if (
      intervals.length === 2 &&
      !Array.isArray(intervals[0]) &&
      !Array.isArray(intervals[1])
    ) {
      intervals = [intervals];
    }
    const intervalChecks = intervals
      .map((interval) => {
        return `${this.formatter.wrap(
          this.getColumnName()
        )} between ${this.client._escapeBinding(
          interval[0]
        )} and ${this.client._escapeBinding(interval[1])}`;
      })
      .join(' or ');
    return this._check(intervalChecks, constraintName);
  }

  checkLength(operator, length, constraintName) {
    return this._check(
      `length(${this.formatter.wrap(this.getColumnName())}) ${operator_(
        operator,
        this.columnBuilder,
        this.bindingsHolder
      )} ${toNumber(length)}`,
      constraintName
    );
  }
};

ColumnCompiler$1.prototype.binary = 'blob';
ColumnCompiler$1.prototype.bool = 'boolean';
ColumnCompiler$1.prototype.date = 'date';
ColumnCompiler$1.prototype.datetime = 'datetime';
ColumnCompiler$1.prototype.time = 'time';
ColumnCompiler$1.prototype.timestamp = 'timestamp';
ColumnCompiler$1.prototype.geometry = 'geometry';
ColumnCompiler$1.prototype.geography = 'geography';
ColumnCompiler$1.prototype.point = 'point';
ColumnCompiler$1.prototype.enu = 'varchar';
ColumnCompiler$1.prototype.bit = ColumnCompiler$1.prototype.json = 'text';
ColumnCompiler$1.prototype.uuid = ({
  useBinaryUuid = false,
  primaryKey = false,
} = {}) => (useBinaryUuid ? 'binary(16)' : 'char(36)');
ColumnCompiler$1.prototype.integer =
  ColumnCompiler$1.prototype.smallint =
  ColumnCompiler$1.prototype.mediumint =
    'integer';
ColumnCompiler$1.prototype.biginteger = 'bigint';
ColumnCompiler$1.prototype.text = 'text';
ColumnCompiler$1.prototype.tinyint = 'tinyint';

ColumnCompiler$1.prototype.pushQuery = helpers$1.pushQuery;
ColumnCompiler$1.prototype.pushAdditional = helpers$1.pushAdditional;
ColumnCompiler$1.prototype.unshiftQuery = helpers$1.unshiftQuery;

ColumnCompiler$1.prototype._defaultMap = {
  columnName: function () {
    if (!this.isIncrements) {
      throw new Error(
        `You did not specify a column name for the ${this.type} column.`
      );
    }
    return 'id';
  },
};

var columncompiler = ColumnCompiler$1;

const Raw$1 = raw;

let Ref$1 = class Ref extends Raw$1 {
  constructor(client, ref) {
    super(client);

    this.ref = ref;
    this._schema = null;
    this._alias = null;
  }

  withSchema(schema) {
    this._schema = schema;

    return this;
  }

  as(alias) {
    this._alias = alias;

    return this;
  }

  toSQL() {
    const string = this._schema ? `${this._schema}.${this.ref}` : this.ref;

    const formatter = this.client.formatter(this);

    const ref = formatter.columnize(string);

    const sql = this._alias ? `${ref} as ${formatter.wrap(this._alias)}` : ref;

    this.set(sql, []);

    return super.toSQL(...arguments);
  }
};

var ref = Ref$1;

const {
  columnize: columnize_$1,
  wrap: wrap_,
} = wrappingFormatter;

let Formatter$1 = class Formatter {
  constructor(client, builder) {
    this.client = client;
    this.builder = builder;
    this.bindings = [];
  }

  // Accepts a string or array of columns to wrap as appropriate.
  columnize(target) {
    return columnize_$1(target, this.builder, this.client, this);
  }

  // Puts the appropriate wrapper around a value depending on the database
  // engine, unless it's a knex.raw value, in which case it's left alone.
  wrap(value, isParameter) {
    return wrap_(value, isParameter, this.builder, this.client, this);
  }
};

var formatter = Formatter$1;

const helpers = helpers$7;
const extend$1 = extendExports;
const assign = assign_1;

let ViewBuilder$1 = class ViewBuilder {
  constructor(client, method, viewName, fn) {
    this.client = client;
    this._method = method;
    this._schemaName = undefined;
    this._columns = undefined;
    this._fn = fn;
    this._viewName = viewName;
    this._statements = [];
    this._single = {};
  }

  setSchema(schemaName) {
    this._schemaName = schemaName;
  }

  columns(columns) {
    this._columns = columns;
  }

  as(selectQuery) {
    this._selectQuery = selectQuery;
  }

  checkOption() {
    throw new Error(
      'check option definition is not supported by this dialect.'
    );
  }

  localCheckOption() {
    throw new Error(
      'check option definition is not supported by this dialect.'
    );
  }

  cascadedCheckOption() {
    throw new Error(
      'check option definition is not supported by this dialect.'
    );
  }

  toSQL() {
    if (this._method === 'alter') {
      extend$1(this, AlterMethods);
    }
    this._fn.call(this, this);
    return this.client.viewCompiler(this).toSQL();
  }
};

const AlterMethods = {
  column(column) {
    const self = this;
    return {
      rename: function (newName) {
        self._statements.push({
          grouping: 'alterView',
          method: 'renameColumn',
          args: [column, newName],
        });
        return this;
      },
      defaultTo: function (defaultValue) {
        self._statements.push({
          grouping: 'alterView',
          method: 'defaultTo',
          args: [column, defaultValue],
        });
        return this;
      },
    };
  },
};

helpers.addQueryContext(ViewBuilder$1);

ViewBuilder$1.extend = (methodName, fn) => {
  if (Object.prototype.hasOwnProperty.call(ViewBuilder$1.prototype, methodName)) {
    throw new Error(
      `Can't extend ViewBuilder with existing method ('${methodName}').`
    );
  }

  assign(ViewBuilder$1.prototype, { [methodName]: fn });
};

var viewbuilder = ViewBuilder$1;

/* eslint max-len:0 */

// View Compiler
// -------
const { pushQuery } = helpers$4;
const groupBy = groupBy_1;
const { columnize: columnize_ } = wrappingFormatter;

let ViewCompiler$1 = class ViewCompiler {
  constructor(client, viewBuilder) {
    this.client = client;
    this.viewBuilder = viewBuilder;
    this._commonBuilder = this.viewBuilder;
    this.method = viewBuilder._method;
    this.schemaNameRaw = viewBuilder._schemaName;
    this.viewNameRaw = viewBuilder._viewName;
    this.single = viewBuilder._single;
    this.selectQuery = viewBuilder._selectQuery;
    this.columns = viewBuilder._columns;
    this.grouped = groupBy(viewBuilder._statements, 'grouping');

    this.formatter = client.formatter(viewBuilder);
    this.bindings = [];
    this.formatter.bindings = this.bindings;
    this.bindingsHolder = this;

    this.sequence = [];
  }

  // Convert the tableCompiler toSQL
  toSQL() {
    this[this.method]();
    return this.sequence;
  }

  // Column Compilation
  // -------

  create() {
    this.createQuery(this.columns, this.selectQuery);
  }

  createOrReplace() {
    throw new Error('replace views is not supported by this dialect.');
  }

  createMaterializedView() {
    throw new Error('materialized views are not supported by this dialect.');
  }

  createQuery(columns, selectQuery, materialized, replace) {
    const createStatement =
      'create ' +
      (materialized ? 'materialized ' : '') +
      (replace ? 'or replace ' : '') +
      'view ';
    const columnList = columns
      ? ' (' +
        columnize_(
          columns,
          this.viewBuilder,
          this.client,
          this.bindingsHolder
        ) +
        ')'
      : '';
    let sql = createStatement + this.viewName() + columnList;
    sql += ' as ';
    sql += selectQuery.toString();
    switch (this.single.checkOption) {
      case 'default_option':
        sql += ' with check option';
        break;
      case 'local':
        sql += ' with local check option';
        break;
      case 'cascaded':
        sql += ' with cascaded check option';
        break;
    }
    this.pushQuery({
      sql,
    });
  }

  renameView(from, to) {
    throw new Error(
      'rename view is not supported by this dialect (instead drop, then create another view).'
    );
  }

  refreshMaterializedView() {
    throw new Error('materialized views are not supported by this dialect.');
  }

  alter() {
    this.alterView();
  }

  alterView() {
    const alterView = this.grouped.alterView || [];
    for (let i = 0, l = alterView.length; i < l; i++) {
      const statement = alterView[i];
      if (this[statement.method]) {
        this[statement.method].apply(this, statement.args);
      } else {
        this.client.logger.error(`Debug: ${statement.method} does not exist`);
      }
    }
    for (const item in this.single) {
      if (typeof this[item] === 'function') this[item](this.single[item]);
    }
  }

  renameColumn(from, to) {
    throw new Error('rename column of views is not supported by this dialect.');
  }

  defaultTo(column, defaultValue) {
    throw new Error(
      'change default values of views is not supported by this dialect.'
    );
  }

  viewName() {
    const name = this.schemaNameRaw
      ? `${this.schemaNameRaw}.${this.viewNameRaw}`
      : this.viewNameRaw;

    return this.formatter.wrap(name);
  }
};

ViewCompiler$1.prototype.pushQuery = pushQuery;

var viewcompiler = ViewCompiler$1;

const { Pool, TimeoutError } = tarnExports;
const { EventEmitter: EventEmitter$3 } = require$$0;
const { promisify } = require$$0$4;
const { makeEscape } = string;
const cloneDeep = cloneDeep_1;
const defaults = defaults_1;
const uniqueId = uniqueId_1;

const Runner = runner;
const Transaction = transaction;
const {
  executeQuery,
  enrichQueryObject,
} = queryExecutioner;
const QueryBuilder = querybuilder;
const QueryCompiler = querycompiler;
const SchemaBuilder = builder;
const SchemaCompiler = compiler;
const TableBuilder = tablebuilder;
const TableCompiler = tablecompiler;
const ColumnBuilder = columnbuilder;
const ColumnCompiler = columncompiler;
const { KnexTimeoutError } = timeout$3;
const { outputQuery, unwrapRaw } = wrappingFormatter;
const { compileCallback } = formatterUtils;
const Raw = raw;
const Ref = ref;
const Formatter = formatter;
const Logger = logger;
const { POOL_CONFIG_OPTIONS } = constants$2;
const ViewBuilder = viewbuilder;
const ViewCompiler = viewcompiler;
const isPlainObject = isPlainObject_1;

const debug = srcExports('knex:client');

// The base client provides the general structure
// for a dialect specific client object.

let Client$1 = class Client extends EventEmitter$3 {
  constructor(config = {}) {
    super();
    this.config = config;
    this.logger = new Logger(config);

    //Client is a required field, so throw error if it's not supplied.
    //If 'this.dialect' is set, then this is a 'super()' call, in which case
    //'client' does not have to be set as it's already assigned on the client prototype.

    if (this.dialect && !this.config.client) {
      this.logger.warn(
        `Using 'this.dialect' to identify the client is deprecated and support for it will be removed in the future. Please use configuration option 'client' instead.`
      );
    }

    const dbClient = this.config.client || this.dialect;
    if (!dbClient) {
      throw new Error(
        `knex: Required configuration option 'client' is missing.`
      );
    }

    if (config.version) {
      this.version = config.version;
    }

    if (config.connection && config.connection instanceof Function) {
      this.connectionConfigProvider = config.connection;
      this.connectionConfigExpirationChecker = () => true; // causes the provider to be called on first use
    } else {
      this.connectionSettings = cloneDeep(config.connection || {});
      this.connectionConfigExpirationChecker = null;
    }
    if (this.driverName && config.connection) {
      this.initializeDriver();
      if (!config.pool || (config.pool && config.pool.max !== 0)) {
        this.initializePool(config);
      }
    }
    this.valueForUndefined = this.raw('DEFAULT');
    if (config.useNullAsDefault) {
      this.valueForUndefined = null;
    }
  }
  formatter(builder) {
    return new Formatter(this, builder);
  }

  queryBuilder() {
    return new QueryBuilder(this);
  }

  queryCompiler(builder, formatter) {
    return new QueryCompiler(this, builder, formatter);
  }

  schemaBuilder() {
    return new SchemaBuilder(this);
  }

  schemaCompiler(builder) {
    return new SchemaCompiler(this, builder);
  }

  tableBuilder(type, tableName, tableNameLike, fn) {
    return new TableBuilder(this, type, tableName, tableNameLike, fn);
  }

  viewBuilder(type, viewBuilder, fn) {
    return new ViewBuilder(this, type, viewBuilder, fn);
  }

  tableCompiler(tableBuilder) {
    return new TableCompiler(this, tableBuilder);
  }

  viewCompiler(viewCompiler) {
    return new ViewCompiler(this, viewCompiler);
  }

  columnBuilder(tableBuilder, type, args) {
    return new ColumnBuilder(this, tableBuilder, type, args);
  }

  columnCompiler(tableBuilder, columnBuilder) {
    return new ColumnCompiler(this, tableBuilder, columnBuilder);
  }

  runner(builder) {
    return new Runner(this, builder);
  }

  transaction(container, config, outerTx) {
    return new Transaction(this, container, config, outerTx);
  }

  raw() {
    return new Raw(this).set(...arguments);
  }

  ref() {
    return new Ref(this, ...arguments);
  }
  query(connection, queryParam) {
    const queryObject = enrichQueryObject(connection, queryParam, this);
    return executeQuery(connection, queryObject, this);
  }

  stream(connection, queryParam, stream, options) {
    const queryObject = enrichQueryObject(connection, queryParam, this);
    return this._stream(connection, queryObject, stream, options);
  }

  prepBindings(bindings) {
    return bindings;
  }

  positionBindings(sql) {
    return sql;
  }

  postProcessResponse(resp, queryContext) {
    if (this.config.postProcessResponse) {
      return this.config.postProcessResponse(resp, queryContext);
    }
    return resp;
  }

  wrapIdentifier(value, queryContext) {
    return this.customWrapIdentifier(
      value,
      this.wrapIdentifierImpl,
      queryContext
    );
  }

  customWrapIdentifier(value, origImpl, queryContext) {
    if (this.config.wrapIdentifier) {
      return this.config.wrapIdentifier(value, origImpl, queryContext);
    }
    return origImpl(value);
  }

  wrapIdentifierImpl(value) {
    return value !== '*' ? `"${value.replace(/"/g, '""')}"` : '*';
  }

  initializeDriver() {
    try {
      this.driver = this._driver();
    } catch (e) {
      const message = `Knex: run\n$ npm install ${this.driverName} --save`;
      this.logger.error(`${message}\n${e.message}\n${e.stack}`);
      throw new Error(`${message}\n${e.message}`);
    }
  }

  poolDefaults() {
    return { min: 2, max: 10, propagateCreateError: true };
  }

  getPoolSettings(poolConfig) {
    poolConfig = defaults({}, poolConfig, this.poolDefaults());

    POOL_CONFIG_OPTIONS.forEach((option) => {
      if (option in poolConfig) {
        this.logger.warn(
          [
            `Pool config option "${option}" is no longer supported.`,
            `See https://github.com/Vincit/tarn.js for possible pool config options.`,
          ].join(' ')
        );
      }
    });

    const DEFAULT_ACQUIRE_TIMEOUT = 60000;
    const timeouts = [
      this.config.acquireConnectionTimeout,
      poolConfig.acquireTimeoutMillis,
    ].filter((timeout) => timeout !== undefined);

    if (!timeouts.length) {
      timeouts.push(DEFAULT_ACQUIRE_TIMEOUT);
    }

    // acquire connection timeout can be set on config or config.pool
    // choose the smallest, positive timeout setting and set on poolConfig
    poolConfig.acquireTimeoutMillis = Math.min(...timeouts);

    const updatePoolConnectionSettingsFromProvider = async () => {
      if (!this.connectionConfigProvider) {
        return; // static configuration, nothing to update
      }
      if (
        !this.connectionConfigExpirationChecker ||
        !this.connectionConfigExpirationChecker()
      ) {
        return; // not expired, reuse existing connection
      }
      const providerResult = await this.connectionConfigProvider();
      if (providerResult.expirationChecker) {
        this.connectionConfigExpirationChecker =
          providerResult.expirationChecker;
        delete providerResult.expirationChecker; // MySQL2 driver warns on receiving extra properties
      } else {
        this.connectionConfigExpirationChecker = null;
      }
      this.connectionSettings = providerResult;
    };

    return Object.assign(poolConfig, {
      create: async () => {
        await updatePoolConnectionSettingsFromProvider();
        const connection = await this.acquireRawConnection();
        connection.__knexUid = uniqueId('__knexUid');
        if (poolConfig.afterCreate) {
          await promisify(poolConfig.afterCreate)(connection);
        }
        return connection;
      },

      destroy: (connection) => {
        if (connection !== void 0) {
          return this.destroyRawConnection(connection);
        }
      },

      validate: (connection) => {
        if (connection.__knex__disposed) {
          this.logger.warn(`Connection Error: ${connection.__knex__disposed}`);
          return false;
        }

        return this.validateConnection(connection);
      },
    });
  }

  initializePool(config = this.config) {
    if (this.pool) {
      this.logger.warn('The pool has already been initialized');
      return;
    }

    const tarnPoolConfig = {
      ...this.getPoolSettings(config.pool),
    };
    // afterCreate is an internal knex param, tarn.js does not support it
    if (tarnPoolConfig.afterCreate) {
      delete tarnPoolConfig.afterCreate;
    }

    this.pool = new Pool(tarnPoolConfig);
  }

  validateConnection(connection) {
    return true;
  }

  // Acquire a connection from the pool.
  async acquireConnection() {
    if (!this.pool) {
      throw new Error('Unable to acquire a connection');
    }
    try {
      const connection = await this.pool.acquire().promise;
      debug('acquired connection from pool: %s', connection.__knexUid);
      return connection;
    } catch (error) {
      let convertedError = error;
      if (error instanceof TimeoutError) {
        convertedError = new KnexTimeoutError(
          'Knex: Timeout acquiring a connection. The pool is probably full. ' +
            'Are you missing a .transacting(trx) call?'
        );
      }
      throw convertedError;
    }
  }

  // Releases a connection back to the connection pool,
  // returning a promise resolved when the connection is released.
  releaseConnection(connection) {
    debug('releasing connection to pool: %s', connection.__knexUid);
    const didRelease = this.pool.release(connection);

    if (!didRelease) {
      debug('pool refused connection: %s', connection.__knexUid);
    }

    return Promise.resolve();
  }

  // Destroy the current connection pool for the client.
  async destroy(callback) {
    try {
      if (this.pool && this.pool.destroy) {
        await this.pool.destroy();
      }
      this.pool = undefined;

      if (typeof callback === 'function') {
        callback();
      }
    } catch (err) {
      if (typeof callback === 'function') {
        return callback(err);
      }
      throw err;
    }
  }

  // Return the database being used by this client.
  database() {
    return this.connectionSettings.database;
  }

  toString() {
    return '[object KnexClient]';
  }

  assertCanCancelQuery() {
    if (!this.canCancelQuery) {
      throw new Error('Query cancelling not supported for this dialect');
    }
  }

  cancelQuery() {
    throw new Error('Query cancelling not supported for this dialect');
  }

  // Formatter part

  alias(first, second) {
    return first + ' as ' + second;
  }

  // Checks whether a value is a function... if it is, we compile it
  // otherwise we check whether it's a raw
  parameter(value, builder, bindingsHolder) {
    if (typeof value === 'function') {
      return outputQuery(
        compileCallback(value, undefined, this, bindingsHolder),
        true,
        builder,
        this
      );
    }
    return unwrapRaw(value, true, builder, this, bindingsHolder) || '?';
  }

  // Turns a list of values into a list of ?'s, joining them with commas unless
  // a "joining" value is specified (e.g. ' and ')
  parameterize(values, notSetValue, builder, bindingsHolder) {
    if (typeof values === 'function')
      return this.parameter(values, builder, bindingsHolder);
    values = Array.isArray(values) ? values : [values];
    let str = '',
      i = -1;
    while (++i < values.length) {
      if (i > 0) str += ', ';
      let value = values[i];
      // json columns can have object in values.
      if (isPlainObject(value)) {
        value = JSON.stringify(value);
      }
      str += this.parameter(
        value === undefined ? notSetValue : value,
        builder,
        bindingsHolder
      );
    }
    return str;
  }

  // Formats `values` into a parenthesized list of parameters for a `VALUES`
  // clause.
  //
  // [1, 2]                  -> '(?, ?)'
  // [[1, 2], [3, 4]]        -> '((?, ?), (?, ?))'
  // knex('table')           -> '(select * from "table")'
  // knex.raw('select ?', 1) -> '(select ?)'
  //
  values(values, builder, bindingsHolder) {
    if (Array.isArray(values)) {
      if (Array.isArray(values[0])) {
        return `(${values
          .map(
            (value) =>
              `(${this.parameterize(
                value,
                undefined,
                builder,
                bindingsHolder
              )})`
          )
          .join(', ')})`;
      }
      return `(${this.parameterize(
        values,
        undefined,
        builder,
        bindingsHolder
      )})`;
    }

    if (values && values.isRawInstance) {
      return `(${this.parameter(values, builder, bindingsHolder)})`;
    }

    return this.parameter(values, builder, bindingsHolder);
  }

  processPassedConnection(connection) {
    // Default implementation is noop
  }

  toPathForJson(jsonPath) {
    // By default, we want a json path, so if this function is not overriden,
    // we return the path.
    return jsonPath;
  }
};

Object.assign(Client$1.prototype, {
  _escapeBinding: makeEscape({
    escapeString(str) {
      return `'${str.replace(/'/g, "''")}'`;
    },
  }),

  canCancelQuery: false,
});

var client$1 = Client$1;

var lodashExports = {};
var lodash = {
  get exports(){ return lodashExports; },
  set exports(v){ lodashExports = v; },
};

/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

(function (module, exports) {
(function() {

	  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
	  var undefined$1;

	  /** Used as the semantic version number. */
	  var VERSION = '4.17.21';

	  /** Used as the size to enable large array optimizations. */
	  var LARGE_ARRAY_SIZE = 200;

	  /** Error message constants. */
	  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
	      FUNC_ERROR_TEXT = 'Expected a function',
	      INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';

	  /** Used to stand-in for `undefined` hash values. */
	  var HASH_UNDEFINED = '__lodash_hash_undefined__';

	  /** Used as the maximum memoize cache size. */
	  var MAX_MEMOIZE_SIZE = 500;

	  /** Used as the internal argument placeholder. */
	  var PLACEHOLDER = '__lodash_placeholder__';

	  /** Used to compose bitmasks for cloning. */
	  var CLONE_DEEP_FLAG = 1,
	      CLONE_FLAT_FLAG = 2,
	      CLONE_SYMBOLS_FLAG = 4;

	  /** Used to compose bitmasks for value comparisons. */
	  var COMPARE_PARTIAL_FLAG = 1,
	      COMPARE_UNORDERED_FLAG = 2;

	  /** Used to compose bitmasks for function metadata. */
	  var WRAP_BIND_FLAG = 1,
	      WRAP_BIND_KEY_FLAG = 2,
	      WRAP_CURRY_BOUND_FLAG = 4,
	      WRAP_CURRY_FLAG = 8,
	      WRAP_CURRY_RIGHT_FLAG = 16,
	      WRAP_PARTIAL_FLAG = 32,
	      WRAP_PARTIAL_RIGHT_FLAG = 64,
	      WRAP_ARY_FLAG = 128,
	      WRAP_REARG_FLAG = 256,
	      WRAP_FLIP_FLAG = 512;

	  /** Used as default options for `_.truncate`. */
	  var DEFAULT_TRUNC_LENGTH = 30,
	      DEFAULT_TRUNC_OMISSION = '...';

	  /** Used to detect hot functions by number of calls within a span of milliseconds. */
	  var HOT_COUNT = 800,
	      HOT_SPAN = 16;

	  /** Used to indicate the type of lazy iteratees. */
	  var LAZY_FILTER_FLAG = 1,
	      LAZY_MAP_FLAG = 2,
	      LAZY_WHILE_FLAG = 3;

	  /** Used as references for various `Number` constants. */
	  var INFINITY = 1 / 0,
	      MAX_SAFE_INTEGER = 9007199254740991,
	      MAX_INTEGER = 1.7976931348623157e+308,
	      NAN = 0 / 0;

	  /** Used as references for the maximum length and index of an array. */
	  var MAX_ARRAY_LENGTH = 4294967295,
	      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
	      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

	  /** Used to associate wrap methods with their bit flags. */
	  var wrapFlags = [
	    ['ary', WRAP_ARY_FLAG],
	    ['bind', WRAP_BIND_FLAG],
	    ['bindKey', WRAP_BIND_KEY_FLAG],
	    ['curry', WRAP_CURRY_FLAG],
	    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
	    ['flip', WRAP_FLIP_FLAG],
	    ['partial', WRAP_PARTIAL_FLAG],
	    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
	    ['rearg', WRAP_REARG_FLAG]
	  ];

	  /** `Object#toString` result references. */
	  var argsTag = '[object Arguments]',
	      arrayTag = '[object Array]',
	      asyncTag = '[object AsyncFunction]',
	      boolTag = '[object Boolean]',
	      dateTag = '[object Date]',
	      domExcTag = '[object DOMException]',
	      errorTag = '[object Error]',
	      funcTag = '[object Function]',
	      genTag = '[object GeneratorFunction]',
	      mapTag = '[object Map]',
	      numberTag = '[object Number]',
	      nullTag = '[object Null]',
	      objectTag = '[object Object]',
	      promiseTag = '[object Promise]',
	      proxyTag = '[object Proxy]',
	      regexpTag = '[object RegExp]',
	      setTag = '[object Set]',
	      stringTag = '[object String]',
	      symbolTag = '[object Symbol]',
	      undefinedTag = '[object Undefined]',
	      weakMapTag = '[object WeakMap]',
	      weakSetTag = '[object WeakSet]';

	  var arrayBufferTag = '[object ArrayBuffer]',
	      dataViewTag = '[object DataView]',
	      float32Tag = '[object Float32Array]',
	      float64Tag = '[object Float64Array]',
	      int8Tag = '[object Int8Array]',
	      int16Tag = '[object Int16Array]',
	      int32Tag = '[object Int32Array]',
	      uint8Tag = '[object Uint8Array]',
	      uint8ClampedTag = '[object Uint8ClampedArray]',
	      uint16Tag = '[object Uint16Array]',
	      uint32Tag = '[object Uint32Array]';

	  /** Used to match empty string literals in compiled template source. */
	  var reEmptyStringLeading = /\b__p \+= '';/g,
	      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
	      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

	  /** Used to match HTML entities and HTML characters. */
	  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
	      reUnescapedHtml = /[&<>"']/g,
	      reHasEscapedHtml = RegExp(reEscapedHtml.source),
	      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

	  /** Used to match template delimiters. */
	  var reEscape = /<%-([\s\S]+?)%>/g,
	      reEvaluate = /<%([\s\S]+?)%>/g,
	      reInterpolate = /<%=([\s\S]+?)%>/g;

	  /** Used to match property names within property paths. */
	  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	      reIsPlainProp = /^\w*$/,
	      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

	  /**
	   * Used to match `RegExp`
	   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	   */
	  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
	      reHasRegExpChar = RegExp(reRegExpChar.source);

	  /** Used to match leading whitespace. */
	  var reTrimStart = /^\s+/;

	  /** Used to match a single whitespace character. */
	  var reWhitespace = /\s/;

	  /** Used to match wrap detail comments. */
	  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
	      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
	      reSplitDetails = /,? & /;

	  /** Used to match words composed of alphanumeric characters. */
	  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

	  /**
	   * Used to validate the `validate` option in `_.template` variable.
	   *
	   * Forbids characters which could potentially change the meaning of the function argument definition:
	   * - "()," (modification of function parameters)
	   * - "=" (default value)
	   * - "[]{}" (destructuring of function parameters)
	   * - "/" (beginning of a comment)
	   * - whitespace
	   */
	  var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;

	  /** Used to match backslashes in property paths. */
	  var reEscapeChar = /\\(\\)?/g;

	  /**
	   * Used to match
	   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
	   */
	  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

	  /** Used to match `RegExp` flags from their coerced string values. */
	  var reFlags = /\w*$/;

	  /** Used to detect bad signed hexadecimal string values. */
	  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

	  /** Used to detect binary string values. */
	  var reIsBinary = /^0b[01]+$/i;

	  /** Used to detect host constructors (Safari). */
	  var reIsHostCtor = /^\[object .+?Constructor\]$/;

	  /** Used to detect octal string values. */
	  var reIsOctal = /^0o[0-7]+$/i;

	  /** Used to detect unsigned integer values. */
	  var reIsUint = /^(?:0|[1-9]\d*)$/;

	  /** Used to match Latin Unicode letters (excluding mathematical operators). */
	  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

	  /** Used to ensure capturing order of template delimiters. */
	  var reNoMatch = /($^)/;

	  /** Used to match unescaped characters in compiled string literals. */
	  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

	  /** Used to compose unicode character classes. */
	  var rsAstralRange = '\\ud800-\\udfff',
	      rsComboMarksRange = '\\u0300-\\u036f',
	      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
	      rsComboSymbolsRange = '\\u20d0-\\u20ff',
	      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
	      rsDingbatRange = '\\u2700-\\u27bf',
	      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
	      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
	      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
	      rsPunctuationRange = '\\u2000-\\u206f',
	      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
	      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
	      rsVarRange = '\\ufe0e\\ufe0f',
	      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

	  /** Used to compose unicode capture groups. */
	  var rsApos = "['\u2019]",
	      rsAstral = '[' + rsAstralRange + ']',
	      rsBreak = '[' + rsBreakRange + ']',
	      rsCombo = '[' + rsComboRange + ']',
	      rsDigits = '\\d+',
	      rsDingbat = '[' + rsDingbatRange + ']',
	      rsLower = '[' + rsLowerRange + ']',
	      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
	      rsFitz = '\\ud83c[\\udffb-\\udfff]',
	      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
	      rsNonAstral = '[^' + rsAstralRange + ']',
	      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
	      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
	      rsUpper = '[' + rsUpperRange + ']',
	      rsZWJ = '\\u200d';

	  /** Used to compose unicode regexes. */
	  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
	      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
	      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
	      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
	      reOptMod = rsModifier + '?',
	      rsOptVar = '[' + rsVarRange + ']?',
	      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
	      rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
	      rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
	      rsSeq = rsOptVar + reOptMod + rsOptJoin,
	      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
	      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

	  /** Used to match apostrophes. */
	  var reApos = RegExp(rsApos, 'g');

	  /**
	   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
	   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
	   */
	  var reComboMark = RegExp(rsCombo, 'g');

	  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
	  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

	  /** Used to match complex or compound words. */
	  var reUnicodeWord = RegExp([
	    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
	    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
	    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
	    rsUpper + '+' + rsOptContrUpper,
	    rsOrdUpper,
	    rsOrdLower,
	    rsDigits,
	    rsEmoji
	  ].join('|'), 'g');

	  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
	  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

	  /** Used to detect strings that need a more robust regexp to match words. */
	  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

	  /** Used to assign default `context` object properties. */
	  var contextProps = [
	    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
	    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
	    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
	    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
	    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
	  ];

	  /** Used to make template sourceURLs easier to identify. */
	  var templateCounter = -1;

	  /** Used to identify `toStringTag` values of typed arrays. */
	  var typedArrayTags = {};
	  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	  typedArrayTags[uint32Tag] = true;
	  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	  typedArrayTags[setTag] = typedArrayTags[stringTag] =
	  typedArrayTags[weakMapTag] = false;

	  /** Used to identify `toStringTag` values supported by `_.clone`. */
	  var cloneableTags = {};
	  cloneableTags[argsTag] = cloneableTags[arrayTag] =
	  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
	  cloneableTags[boolTag] = cloneableTags[dateTag] =
	  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
	  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
	  cloneableTags[int32Tag] = cloneableTags[mapTag] =
	  cloneableTags[numberTag] = cloneableTags[objectTag] =
	  cloneableTags[regexpTag] = cloneableTags[setTag] =
	  cloneableTags[stringTag] = cloneableTags[symbolTag] =
	  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
	  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
	  cloneableTags[errorTag] = cloneableTags[funcTag] =
	  cloneableTags[weakMapTag] = false;

	  /** Used to map Latin Unicode letters to basic Latin letters. */
	  var deburredLetters = {
	    // Latin-1 Supplement block.
	    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
	    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
	    '\xc7': 'C',  '\xe7': 'c',
	    '\xd0': 'D',  '\xf0': 'd',
	    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
	    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
	    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
	    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
	    '\xd1': 'N',  '\xf1': 'n',
	    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
	    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
	    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
	    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
	    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
	    '\xc6': 'Ae', '\xe6': 'ae',
	    '\xde': 'Th', '\xfe': 'th',
	    '\xdf': 'ss',
	    // Latin Extended-A block.
	    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
	    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
	    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
	    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
	    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
	    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
	    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
	    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
	    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
	    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
	    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
	    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
	    '\u0134': 'J',  '\u0135': 'j',
	    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
	    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
	    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
	    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
	    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
	    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
	    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
	    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
	    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
	    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
	    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
	    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
	    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
	    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
	    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
	    '\u0174': 'W',  '\u0175': 'w',
	    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
	    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
	    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
	    '\u0132': 'IJ', '\u0133': 'ij',
	    '\u0152': 'Oe', '\u0153': 'oe',
	    '\u0149': "'n", '\u017f': 's'
	  };

	  /** Used to map characters to HTML entities. */
	  var htmlEscapes = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#39;'
	  };

	  /** Used to map HTML entities to characters. */
	  var htmlUnescapes = {
	    '&amp;': '&',
	    '&lt;': '<',
	    '&gt;': '>',
	    '&quot;': '"',
	    '&#39;': "'"
	  };

	  /** Used to escape characters for inclusion in compiled string literals. */
	  var stringEscapes = {
	    '\\': '\\',
	    "'": "'",
	    '\n': 'n',
	    '\r': 'r',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };

	  /** Built-in method references without a dependency on `root`. */
	  var freeParseFloat = parseFloat,
	      freeParseInt = parseInt;

	  /** Detect free variable `global` from Node.js. */
	  var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	  /** Detect free variable `self`. */
	  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	  /** Used as a reference to the global object. */
	  var root = freeGlobal || freeSelf || Function('return this')();

	  /** Detect free variable `exports`. */
	  var freeExports = exports && !exports.nodeType && exports;

	  /** Detect free variable `module`. */
	  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	  /** Detect the popular CommonJS extension `module.exports`. */
	  var moduleExports = freeModule && freeModule.exports === freeExports;

	  /** Detect free variable `process` from Node.js. */
	  var freeProcess = moduleExports && freeGlobal.process;

	  /** Used to access faster Node.js helpers. */
	  var nodeUtil = (function() {
	    try {
	      // Use `util.types` for Node.js 10+.
	      var types = freeModule && freeModule.require && freeModule.require('util').types;

	      if (types) {
	        return types;
	      }

	      // Legacy `process.binding('util')` for Node.js < 10.
	      return freeProcess && freeProcess.binding && freeProcess.binding('util');
	    } catch (e) {}
	  }());

	  /* Node.js helper references. */
	  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
	      nodeIsDate = nodeUtil && nodeUtil.isDate,
	      nodeIsMap = nodeUtil && nodeUtil.isMap,
	      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
	      nodeIsSet = nodeUtil && nodeUtil.isSet,
	      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

	  /*--------------------------------------------------------------------------*/

	  /**
	   * A faster alternative to `Function#apply`, this function invokes `func`
	   * with the `this` binding of `thisArg` and the arguments of `args`.
	   *
	   * @private
	   * @param {Function} func The function to invoke.
	   * @param {*} thisArg The `this` binding of `func`.
	   * @param {Array} args The arguments to invoke `func` with.
	   * @returns {*} Returns the result of `func`.
	   */
	  function apply(func, thisArg, args) {
	    switch (args.length) {
	      case 0: return func.call(thisArg);
	      case 1: return func.call(thisArg, args[0]);
	      case 2: return func.call(thisArg, args[0], args[1]);
	      case 3: return func.call(thisArg, args[0], args[1], args[2]);
	    }
	    return func.apply(thisArg, args);
	  }

	  /**
	   * A specialized version of `baseAggregator` for arrays.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} setter The function to set `accumulator` values.
	   * @param {Function} iteratee The iteratee to transform keys.
	   * @param {Object} accumulator The initial aggregated object.
	   * @returns {Function} Returns `accumulator`.
	   */
	  function arrayAggregator(array, setter, iteratee, accumulator) {
	    var index = -1,
	        length = array == null ? 0 : array.length;

	    while (++index < length) {
	      var value = array[index];
	      setter(accumulator, value, iteratee(value), array);
	    }
	    return accumulator;
	  }

	  /**
	   * A specialized version of `_.forEach` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns `array`.
	   */
	  function arrayEach(array, iteratee) {
	    var index = -1,
	        length = array == null ? 0 : array.length;

	    while (++index < length) {
	      if (iteratee(array[index], index, array) === false) {
	        break;
	      }
	    }
	    return array;
	  }

	  /**
	   * A specialized version of `_.forEachRight` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns `array`.
	   */
	  function arrayEachRight(array, iteratee) {
	    var length = array == null ? 0 : array.length;

	    while (length--) {
	      if (iteratee(array[length], length, array) === false) {
	        break;
	      }
	    }
	    return array;
	  }

	  /**
	   * A specialized version of `_.every` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} predicate The function invoked per iteration.
	   * @returns {boolean} Returns `true` if all elements pass the predicate check,
	   *  else `false`.
	   */
	  function arrayEvery(array, predicate) {
	    var index = -1,
	        length = array == null ? 0 : array.length;

	    while (++index < length) {
	      if (!predicate(array[index], index, array)) {
	        return false;
	      }
	    }
	    return true;
	  }

	  /**
	   * A specialized version of `_.filter` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} predicate The function invoked per iteration.
	   * @returns {Array} Returns the new filtered array.
	   */
	  function arrayFilter(array, predicate) {
	    var index = -1,
	        length = array == null ? 0 : array.length,
	        resIndex = 0,
	        result = [];

	    while (++index < length) {
	      var value = array[index];
	      if (predicate(value, index, array)) {
	        result[resIndex++] = value;
	      }
	    }
	    return result;
	  }

	  /**
	   * A specialized version of `_.includes` for arrays without support for
	   * specifying an index to search from.
	   *
	   * @private
	   * @param {Array} [array] The array to inspect.
	   * @param {*} target The value to search for.
	   * @returns {boolean} Returns `true` if `target` is found, else `false`.
	   */
	  function arrayIncludes(array, value) {
	    var length = array == null ? 0 : array.length;
	    return !!length && baseIndexOf(array, value, 0) > -1;
	  }

	  /**
	   * This function is like `arrayIncludes` except that it accepts a comparator.
	   *
	   * @private
	   * @param {Array} [array] The array to inspect.
	   * @param {*} target The value to search for.
	   * @param {Function} comparator The comparator invoked per element.
	   * @returns {boolean} Returns `true` if `target` is found, else `false`.
	   */
	  function arrayIncludesWith(array, value, comparator) {
	    var index = -1,
	        length = array == null ? 0 : array.length;

	    while (++index < length) {
	      if (comparator(value, array[index])) {
	        return true;
	      }
	    }
	    return false;
	  }

	  /**
	   * A specialized version of `_.map` for arrays without support for iteratee
	   * shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns the new mapped array.
	   */
	  function arrayMap(array, iteratee) {
	    var index = -1,
	        length = array == null ? 0 : array.length,
	        result = Array(length);

	    while (++index < length) {
	      result[index] = iteratee(array[index], index, array);
	    }
	    return result;
	  }

	  /**
	   * Appends the elements of `values` to `array`.
	   *
	   * @private
	   * @param {Array} array The array to modify.
	   * @param {Array} values The values to append.
	   * @returns {Array} Returns `array`.
	   */
	  function arrayPush(array, values) {
	    var index = -1,
	        length = values.length,
	        offset = array.length;

	    while (++index < length) {
	      array[offset + index] = values[index];
	    }
	    return array;
	  }

	  /**
	   * A specialized version of `_.reduce` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @param {*} [accumulator] The initial value.
	   * @param {boolean} [initAccum] Specify using the first element of `array` as
	   *  the initial value.
	   * @returns {*} Returns the accumulated value.
	   */
	  function arrayReduce(array, iteratee, accumulator, initAccum) {
	    var index = -1,
	        length = array == null ? 0 : array.length;

	    if (initAccum && length) {
	      accumulator = array[++index];
	    }
	    while (++index < length) {
	      accumulator = iteratee(accumulator, array[index], index, array);
	    }
	    return accumulator;
	  }

	  /**
	   * A specialized version of `_.reduceRight` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @param {*} [accumulator] The initial value.
	   * @param {boolean} [initAccum] Specify using the last element of `array` as
	   *  the initial value.
	   * @returns {*} Returns the accumulated value.
	   */
	  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
	    var length = array == null ? 0 : array.length;
	    if (initAccum && length) {
	      accumulator = array[--length];
	    }
	    while (length--) {
	      accumulator = iteratee(accumulator, array[length], length, array);
	    }
	    return accumulator;
	  }

	  /**
	   * A specialized version of `_.some` for arrays without support for iteratee
	   * shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} predicate The function invoked per iteration.
	   * @returns {boolean} Returns `true` if any element passes the predicate check,
	   *  else `false`.
	   */
	  function arraySome(array, predicate) {
	    var index = -1,
	        length = array == null ? 0 : array.length;

	    while (++index < length) {
	      if (predicate(array[index], index, array)) {
	        return true;
	      }
	    }
	    return false;
	  }

	  /**
	   * Gets the size of an ASCII `string`.
	   *
	   * @private
	   * @param {string} string The string inspect.
	   * @returns {number} Returns the string size.
	   */
	  var asciiSize = baseProperty('length');

	  /**
	   * Converts an ASCII `string` to an array.
	   *
	   * @private
	   * @param {string} string The string to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function asciiToArray(string) {
	    return string.split('');
	  }

	  /**
	   * Splits an ASCII `string` into an array of its words.
	   *
	   * @private
	   * @param {string} The string to inspect.
	   * @returns {Array} Returns the words of `string`.
	   */
	  function asciiWords(string) {
	    return string.match(reAsciiWord) || [];
	  }

	  /**
	   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
	   * without support for iteratee shorthands, which iterates over `collection`
	   * using `eachFunc`.
	   *
	   * @private
	   * @param {Array|Object} collection The collection to inspect.
	   * @param {Function} predicate The function invoked per iteration.
	   * @param {Function} eachFunc The function to iterate over `collection`.
	   * @returns {*} Returns the found element or its key, else `undefined`.
	   */
	  function baseFindKey(collection, predicate, eachFunc) {
	    var result;
	    eachFunc(collection, function(value, key, collection) {
	      if (predicate(value, key, collection)) {
	        result = key;
	        return false;
	      }
	    });
	    return result;
	  }

	  /**
	   * The base implementation of `_.findIndex` and `_.findLastIndex` without
	   * support for iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {Function} predicate The function invoked per iteration.
	   * @param {number} fromIndex The index to search from.
	   * @param {boolean} [fromRight] Specify iterating from right to left.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseFindIndex(array, predicate, fromIndex, fromRight) {
	    var length = array.length,
	        index = fromIndex + (fromRight ? 1 : -1);

	    while ((fromRight ? index-- : ++index < length)) {
	      if (predicate(array[index], index, array)) {
	        return index;
	      }
	    }
	    return -1;
	  }

	  /**
	   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseIndexOf(array, value, fromIndex) {
	    return value === value
	      ? strictIndexOf(array, value, fromIndex)
	      : baseFindIndex(array, baseIsNaN, fromIndex);
	  }

	  /**
	   * This function is like `baseIndexOf` except that it accepts a comparator.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @param {Function} comparator The comparator invoked per element.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseIndexOfWith(array, value, fromIndex, comparator) {
	    var index = fromIndex - 1,
	        length = array.length;

	    while (++index < length) {
	      if (comparator(array[index], value)) {
	        return index;
	      }
	    }
	    return -1;
	  }

	  /**
	   * The base implementation of `_.isNaN` without support for number objects.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	   */
	  function baseIsNaN(value) {
	    return value !== value;
	  }

	  /**
	   * The base implementation of `_.mean` and `_.meanBy` without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {number} Returns the mean.
	   */
	  function baseMean(array, iteratee) {
	    var length = array == null ? 0 : array.length;
	    return length ? (baseSum(array, iteratee) / length) : NAN;
	  }

	  /**
	   * The base implementation of `_.property` without support for deep paths.
	   *
	   * @private
	   * @param {string} key The key of the property to get.
	   * @returns {Function} Returns the new accessor function.
	   */
	  function baseProperty(key) {
	    return function(object) {
	      return object == null ? undefined$1 : object[key];
	    };
	  }

	  /**
	   * The base implementation of `_.propertyOf` without support for deep paths.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @returns {Function} Returns the new accessor function.
	   */
	  function basePropertyOf(object) {
	    return function(key) {
	      return object == null ? undefined$1 : object[key];
	    };
	  }

	  /**
	   * The base implementation of `_.reduce` and `_.reduceRight`, without support
	   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
	   *
	   * @private
	   * @param {Array|Object} collection The collection to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @param {*} accumulator The initial value.
	   * @param {boolean} initAccum Specify using the first or last element of
	   *  `collection` as the initial value.
	   * @param {Function} eachFunc The function to iterate over `collection`.
	   * @returns {*} Returns the accumulated value.
	   */
	  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
	    eachFunc(collection, function(value, index, collection) {
	      accumulator = initAccum
	        ? (initAccum = false, value)
	        : iteratee(accumulator, value, index, collection);
	    });
	    return accumulator;
	  }

	  /**
	   * The base implementation of `_.sortBy` which uses `comparer` to define the
	   * sort order of `array` and replaces criteria objects with their corresponding
	   * values.
	   *
	   * @private
	   * @param {Array} array The array to sort.
	   * @param {Function} comparer The function to define sort order.
	   * @returns {Array} Returns `array`.
	   */
	  function baseSortBy(array, comparer) {
	    var length = array.length;

	    array.sort(comparer);
	    while (length--) {
	      array[length] = array[length].value;
	    }
	    return array;
	  }

	  /**
	   * The base implementation of `_.sum` and `_.sumBy` without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {number} Returns the sum.
	   */
	  function baseSum(array, iteratee) {
	    var result,
	        index = -1,
	        length = array.length;

	    while (++index < length) {
	      var current = iteratee(array[index]);
	      if (current !== undefined$1) {
	        result = result === undefined$1 ? current : (result + current);
	      }
	    }
	    return result;
	  }

	  /**
	   * The base implementation of `_.times` without support for iteratee shorthands
	   * or max array length checks.
	   *
	   * @private
	   * @param {number} n The number of times to invoke `iteratee`.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns the array of results.
	   */
	  function baseTimes(n, iteratee) {
	    var index = -1,
	        result = Array(n);

	    while (++index < n) {
	      result[index] = iteratee(index);
	    }
	    return result;
	  }

	  /**
	   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
	   * of key-value pairs for `object` corresponding to the property names of `props`.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @param {Array} props The property names to get values for.
	   * @returns {Object} Returns the key-value pairs.
	   */
	  function baseToPairs(object, props) {
	    return arrayMap(props, function(key) {
	      return [key, object[key]];
	    });
	  }

	  /**
	   * The base implementation of `_.trim`.
	   *
	   * @private
	   * @param {string} string The string to trim.
	   * @returns {string} Returns the trimmed string.
	   */
	  function baseTrim(string) {
	    return string
	      ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
	      : string;
	  }

	  /**
	   * The base implementation of `_.unary` without support for storing metadata.
	   *
	   * @private
	   * @param {Function} func The function to cap arguments for.
	   * @returns {Function} Returns the new capped function.
	   */
	  function baseUnary(func) {
	    return function(value) {
	      return func(value);
	    };
	  }

	  /**
	   * The base implementation of `_.values` and `_.valuesIn` which creates an
	   * array of `object` property values corresponding to the property names
	   * of `props`.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @param {Array} props The property names to get values for.
	   * @returns {Object} Returns the array of property values.
	   */
	  function baseValues(object, props) {
	    return arrayMap(props, function(key) {
	      return object[key];
	    });
	  }

	  /**
	   * Checks if a `cache` value for `key` exists.
	   *
	   * @private
	   * @param {Object} cache The cache to query.
	   * @param {string} key The key of the entry to check.
	   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	   */
	  function cacheHas(cache, key) {
	    return cache.has(key);
	  }

	  /**
	   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
	   * that is not found in the character symbols.
	   *
	   * @private
	   * @param {Array} strSymbols The string symbols to inspect.
	   * @param {Array} chrSymbols The character symbols to find.
	   * @returns {number} Returns the index of the first unmatched string symbol.
	   */
	  function charsStartIndex(strSymbols, chrSymbols) {
	    var index = -1,
	        length = strSymbols.length;

	    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
	    return index;
	  }

	  /**
	   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
	   * that is not found in the character symbols.
	   *
	   * @private
	   * @param {Array} strSymbols The string symbols to inspect.
	   * @param {Array} chrSymbols The character symbols to find.
	   * @returns {number} Returns the index of the last unmatched string symbol.
	   */
	  function charsEndIndex(strSymbols, chrSymbols) {
	    var index = strSymbols.length;

	    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
	    return index;
	  }

	  /**
	   * Gets the number of `placeholder` occurrences in `array`.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} placeholder The placeholder to search for.
	   * @returns {number} Returns the placeholder count.
	   */
	  function countHolders(array, placeholder) {
	    var length = array.length,
	        result = 0;

	    while (length--) {
	      if (array[length] === placeholder) {
	        ++result;
	      }
	    }
	    return result;
	  }

	  /**
	   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
	   * letters to basic Latin letters.
	   *
	   * @private
	   * @param {string} letter The matched letter to deburr.
	   * @returns {string} Returns the deburred letter.
	   */
	  var deburrLetter = basePropertyOf(deburredLetters);

	  /**
	   * Used by `_.escape` to convert characters to HTML entities.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */
	  var escapeHtmlChar = basePropertyOf(htmlEscapes);

	  /**
	   * Used by `_.template` to escape characters for inclusion in compiled string literals.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */
	  function escapeStringChar(chr) {
	    return '\\' + stringEscapes[chr];
	  }

	  /**
	   * Gets the value at `key` of `object`.
	   *
	   * @private
	   * @param {Object} [object] The object to query.
	   * @param {string} key The key of the property to get.
	   * @returns {*} Returns the property value.
	   */
	  function getValue(object, key) {
	    return object == null ? undefined$1 : object[key];
	  }

	  /**
	   * Checks if `string` contains Unicode symbols.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
	   */
	  function hasUnicode(string) {
	    return reHasUnicode.test(string);
	  }

	  /**
	   * Checks if `string` contains a word composed of Unicode symbols.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {boolean} Returns `true` if a word is found, else `false`.
	   */
	  function hasUnicodeWord(string) {
	    return reHasUnicodeWord.test(string);
	  }

	  /**
	   * Converts `iterator` to an array.
	   *
	   * @private
	   * @param {Object} iterator The iterator to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function iteratorToArray(iterator) {
	    var data,
	        result = [];

	    while (!(data = iterator.next()).done) {
	      result.push(data.value);
	    }
	    return result;
	  }

	  /**
	   * Converts `map` to its key-value pairs.
	   *
	   * @private
	   * @param {Object} map The map to convert.
	   * @returns {Array} Returns the key-value pairs.
	   */
	  function mapToArray(map) {
	    var index = -1,
	        result = Array(map.size);

	    map.forEach(function(value, key) {
	      result[++index] = [key, value];
	    });
	    return result;
	  }

	  /**
	   * Creates a unary function that invokes `func` with its argument transformed.
	   *
	   * @private
	   * @param {Function} func The function to wrap.
	   * @param {Function} transform The argument transform.
	   * @returns {Function} Returns the new function.
	   */
	  function overArg(func, transform) {
	    return function(arg) {
	      return func(transform(arg));
	    };
	  }

	  /**
	   * Replaces all `placeholder` elements in `array` with an internal placeholder
	   * and returns an array of their indexes.
	   *
	   * @private
	   * @param {Array} array The array to modify.
	   * @param {*} placeholder The placeholder to replace.
	   * @returns {Array} Returns the new array of placeholder indexes.
	   */
	  function replaceHolders(array, placeholder) {
	    var index = -1,
	        length = array.length,
	        resIndex = 0,
	        result = [];

	    while (++index < length) {
	      var value = array[index];
	      if (value === placeholder || value === PLACEHOLDER) {
	        array[index] = PLACEHOLDER;
	        result[resIndex++] = index;
	      }
	    }
	    return result;
	  }

	  /**
	   * Converts `set` to an array of its values.
	   *
	   * @private
	   * @param {Object} set The set to convert.
	   * @returns {Array} Returns the values.
	   */
	  function setToArray(set) {
	    var index = -1,
	        result = Array(set.size);

	    set.forEach(function(value) {
	      result[++index] = value;
	    });
	    return result;
	  }

	  /**
	   * Converts `set` to its value-value pairs.
	   *
	   * @private
	   * @param {Object} set The set to convert.
	   * @returns {Array} Returns the value-value pairs.
	   */
	  function setToPairs(set) {
	    var index = -1,
	        result = Array(set.size);

	    set.forEach(function(value) {
	      result[++index] = [value, value];
	    });
	    return result;
	  }

	  /**
	   * A specialized version of `_.indexOf` which performs strict equality
	   * comparisons of values, i.e. `===`.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function strictIndexOf(array, value, fromIndex) {
	    var index = fromIndex - 1,
	        length = array.length;

	    while (++index < length) {
	      if (array[index] === value) {
	        return index;
	      }
	    }
	    return -1;
	  }

	  /**
	   * A specialized version of `_.lastIndexOf` which performs strict equality
	   * comparisons of values, i.e. `===`.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function strictLastIndexOf(array, value, fromIndex) {
	    var index = fromIndex + 1;
	    while (index--) {
	      if (array[index] === value) {
	        return index;
	      }
	    }
	    return index;
	  }

	  /**
	   * Gets the number of symbols in `string`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {number} Returns the string size.
	   */
	  function stringSize(string) {
	    return hasUnicode(string)
	      ? unicodeSize(string)
	      : asciiSize(string);
	  }

	  /**
	   * Converts `string` to an array.
	   *
	   * @private
	   * @param {string} string The string to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function stringToArray(string) {
	    return hasUnicode(string)
	      ? unicodeToArray(string)
	      : asciiToArray(string);
	  }

	  /**
	   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
	   * character of `string`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {number} Returns the index of the last non-whitespace character.
	   */
	  function trimmedEndIndex(string) {
	    var index = string.length;

	    while (index-- && reWhitespace.test(string.charAt(index))) {}
	    return index;
	  }

	  /**
	   * Used by `_.unescape` to convert HTML entities to characters.
	   *
	   * @private
	   * @param {string} chr The matched character to unescape.
	   * @returns {string} Returns the unescaped character.
	   */
	  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

	  /**
	   * Gets the size of a Unicode `string`.
	   *
	   * @private
	   * @param {string} string The string inspect.
	   * @returns {number} Returns the string size.
	   */
	  function unicodeSize(string) {
	    var result = reUnicode.lastIndex = 0;
	    while (reUnicode.test(string)) {
	      ++result;
	    }
	    return result;
	  }

	  /**
	   * Converts a Unicode `string` to an array.
	   *
	   * @private
	   * @param {string} string The string to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function unicodeToArray(string) {
	    return string.match(reUnicode) || [];
	  }

	  /**
	   * Splits a Unicode `string` into an array of its words.
	   *
	   * @private
	   * @param {string} The string to inspect.
	   * @returns {Array} Returns the words of `string`.
	   */
	  function unicodeWords(string) {
	    return string.match(reUnicodeWord) || [];
	  }

	  /*--------------------------------------------------------------------------*/

	  /**
	   * Create a new pristine `lodash` function using the `context` object.
	   *
	   * @static
	   * @memberOf _
	   * @since 1.1.0
	   * @category Util
	   * @param {Object} [context=root] The context object.
	   * @returns {Function} Returns a new `lodash` function.
	   * @example
	   *
	   * _.mixin({ 'foo': _.constant('foo') });
	   *
	   * var lodash = _.runInContext();
	   * lodash.mixin({ 'bar': lodash.constant('bar') });
	   *
	   * _.isFunction(_.foo);
	   * // => true
	   * _.isFunction(_.bar);
	   * // => false
	   *
	   * lodash.isFunction(lodash.foo);
	   * // => false
	   * lodash.isFunction(lodash.bar);
	   * // => true
	   *
	   * // Create a suped-up `defer` in Node.js.
	   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
	   */
	  var runInContext = (function runInContext(context) {
	    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

	    /** Built-in constructor references. */
	    var Array = context.Array,
	        Date = context.Date,
	        Error = context.Error,
	        Function = context.Function,
	        Math = context.Math,
	        Object = context.Object,
	        RegExp = context.RegExp,
	        String = context.String,
	        TypeError = context.TypeError;

	    /** Used for built-in method references. */
	    var arrayProto = Array.prototype,
	        funcProto = Function.prototype,
	        objectProto = Object.prototype;

	    /** Used to detect overreaching core-js shims. */
	    var coreJsData = context['__core-js_shared__'];

	    /** Used to resolve the decompiled source of functions. */
	    var funcToString = funcProto.toString;

	    /** Used to check objects for own properties. */
	    var hasOwnProperty = objectProto.hasOwnProperty;

	    /** Used to generate unique IDs. */
	    var idCounter = 0;

	    /** Used to detect methods masquerading as native. */
	    var maskSrcKey = (function() {
	      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	      return uid ? ('Symbol(src)_1.' + uid) : '';
	    }());

	    /**
	     * Used to resolve the
	     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	     * of values.
	     */
	    var nativeObjectToString = objectProto.toString;

	    /** Used to infer the `Object` constructor. */
	    var objectCtorString = funcToString.call(Object);

	    /** Used to restore the original `_` reference in `_.noConflict`. */
	    var oldDash = root._;

	    /** Used to detect if a method is native. */
	    var reIsNative = RegExp('^' +
	      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	    );

	    /** Built-in value references. */
	    var Buffer = moduleExports ? context.Buffer : undefined$1,
	        Symbol = context.Symbol,
	        Uint8Array = context.Uint8Array,
	        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined$1,
	        getPrototype = overArg(Object.getPrototypeOf, Object),
	        objectCreate = Object.create,
	        propertyIsEnumerable = objectProto.propertyIsEnumerable,
	        splice = arrayProto.splice,
	        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined$1,
	        symIterator = Symbol ? Symbol.iterator : undefined$1,
	        symToStringTag = Symbol ? Symbol.toStringTag : undefined$1;

	    var defineProperty = (function() {
	      try {
	        var func = getNative(Object, 'defineProperty');
	        func({}, '', {});
	        return func;
	      } catch (e) {}
	    }());

	    /** Mocked built-ins. */
	    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
	        ctxNow = Date && Date.now !== root.Date.now && Date.now,
	        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

	    /* Built-in method references for those with the same name as other `lodash` methods. */
	    var nativeCeil = Math.ceil,
	        nativeFloor = Math.floor,
	        nativeGetSymbols = Object.getOwnPropertySymbols,
	        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined$1,
	        nativeIsFinite = context.isFinite,
	        nativeJoin = arrayProto.join,
	        nativeKeys = overArg(Object.keys, Object),
	        nativeMax = Math.max,
	        nativeMin = Math.min,
	        nativeNow = Date.now,
	        nativeParseInt = context.parseInt,
	        nativeRandom = Math.random,
	        nativeReverse = arrayProto.reverse;

	    /* Built-in method references that are verified to be native. */
	    var DataView = getNative(context, 'DataView'),
	        Map = getNative(context, 'Map'),
	        Promise = getNative(context, 'Promise'),
	        Set = getNative(context, 'Set'),
	        WeakMap = getNative(context, 'WeakMap'),
	        nativeCreate = getNative(Object, 'create');

	    /** Used to store function metadata. */
	    var metaMap = WeakMap && new WeakMap;

	    /** Used to lookup unminified function names. */
	    var realNames = {};

	    /** Used to detect maps, sets, and weakmaps. */
	    var dataViewCtorString = toSource(DataView),
	        mapCtorString = toSource(Map),
	        promiseCtorString = toSource(Promise),
	        setCtorString = toSource(Set),
	        weakMapCtorString = toSource(WeakMap);

	    /** Used to convert symbols to primitives and strings. */
	    var symbolProto = Symbol ? Symbol.prototype : undefined$1,
	        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1,
	        symbolToString = symbolProto ? symbolProto.toString : undefined$1;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a `lodash` object which wraps `value` to enable implicit method
	     * chain sequences. Methods that operate on and return arrays, collections,
	     * and functions can be chained together. Methods that retrieve a single value
	     * or may return a primitive value will automatically end the chain sequence
	     * and return the unwrapped value. Otherwise, the value must be unwrapped
	     * with `_#value`.
	     *
	     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
	     * enabled using `_.chain`.
	     *
	     * The execution of chained methods is lazy, that is, it's deferred until
	     * `_#value` is implicitly or explicitly called.
	     *
	     * Lazy evaluation allows several methods to support shortcut fusion.
	     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
	     * the creation of intermediate arrays and can greatly reduce the number of
	     * iteratee executions. Sections of a chain sequence qualify for shortcut
	     * fusion if the section is applied to an array and iteratees accept only
	     * one argument. The heuristic for whether a section qualifies for shortcut
	     * fusion is subject to change.
	     *
	     * Chaining is supported in custom builds as long as the `_#value` method is
	     * directly or indirectly included in the build.
	     *
	     * In addition to lodash methods, wrappers have `Array` and `String` methods.
	     *
	     * The wrapper `Array` methods are:
	     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
	     *
	     * The wrapper `String` methods are:
	     * `replace` and `split`
	     *
	     * The wrapper methods that support shortcut fusion are:
	     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
	     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
	     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
	     *
	     * The chainable wrapper methods are:
	     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
	     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
	     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
	     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
	     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
	     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
	     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
	     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
	     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
	     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
	     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
	     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
	     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
	     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
	     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
	     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
	     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
	     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
	     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
	     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
	     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
	     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
	     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
	     * `zipObject`, `zipObjectDeep`, and `zipWith`
	     *
	     * The wrapper methods that are **not** chainable by default are:
	     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
	     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
	     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
	     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
	     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
	     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
	     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
	     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
	     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
	     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
	     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
	     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
	     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
	     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
	     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
	     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
	     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
	     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
	     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
	     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
	     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
	     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
	     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
	     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
	     * `upperFirst`, `value`, and `words`
	     *
	     * @name _
	     * @constructor
	     * @category Seq
	     * @param {*} value The value to wrap in a `lodash` instance.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var wrapped = _([1, 2, 3]);
	     *
	     * // Returns an unwrapped value.
	     * wrapped.reduce(_.add);
	     * // => 6
	     *
	     * // Returns a wrapped value.
	     * var squares = wrapped.map(square);
	     *
	     * _.isArray(squares);
	     * // => false
	     *
	     * _.isArray(squares.value());
	     * // => true
	     */
	    function lodash(value) {
	      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
	        if (value instanceof LodashWrapper) {
	          return value;
	        }
	        if (hasOwnProperty.call(value, '__wrapped__')) {
	          return wrapperClone(value);
	        }
	      }
	      return new LodashWrapper(value);
	    }

	    /**
	     * The base implementation of `_.create` without support for assigning
	     * properties to the created object.
	     *
	     * @private
	     * @param {Object} proto The object to inherit from.
	     * @returns {Object} Returns the new object.
	     */
	    var baseCreate = (function() {
	      function object() {}
	      return function(proto) {
	        if (!isObject(proto)) {
	          return {};
	        }
	        if (objectCreate) {
	          return objectCreate(proto);
	        }
	        object.prototype = proto;
	        var result = new object;
	        object.prototype = undefined$1;
	        return result;
	      };
	    }());

	    /**
	     * The function whose prototype chain sequence wrappers inherit from.
	     *
	     * @private
	     */
	    function baseLodash() {
	      // No operation performed.
	    }

	    /**
	     * The base constructor for creating `lodash` wrapper objects.
	     *
	     * @private
	     * @param {*} value The value to wrap.
	     * @param {boolean} [chainAll] Enable explicit method chain sequences.
	     */
	    function LodashWrapper(value, chainAll) {
	      this.__wrapped__ = value;
	      this.__actions__ = [];
	      this.__chain__ = !!chainAll;
	      this.__index__ = 0;
	      this.__values__ = undefined$1;
	    }

	    /**
	     * By default, the template delimiters used by lodash are like those in
	     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
	     * following template settings to use alternative delimiters.
	     *
	     * @static
	     * @memberOf _
	     * @type {Object}
	     */
	    lodash.templateSettings = {

	      /**
	       * Used to detect `data` property values to be HTML-escaped.
	       *
	       * @memberOf _.templateSettings
	       * @type {RegExp}
	       */
	      'escape': reEscape,

	      /**
	       * Used to detect code to be evaluated.
	       *
	       * @memberOf _.templateSettings
	       * @type {RegExp}
	       */
	      'evaluate': reEvaluate,

	      /**
	       * Used to detect `data` property values to inject.
	       *
	       * @memberOf _.templateSettings
	       * @type {RegExp}
	       */
	      'interpolate': reInterpolate,

	      /**
	       * Used to reference the data object in the template text.
	       *
	       * @memberOf _.templateSettings
	       * @type {string}
	       */
	      'variable': '',

	      /**
	       * Used to import variables into the compiled template.
	       *
	       * @memberOf _.templateSettings
	       * @type {Object}
	       */
	      'imports': {

	        /**
	         * A reference to the `lodash` function.
	         *
	         * @memberOf _.templateSettings.imports
	         * @type {Function}
	         */
	        '_': lodash
	      }
	    };

	    // Ensure wrappers are instances of `baseLodash`.
	    lodash.prototype = baseLodash.prototype;
	    lodash.prototype.constructor = lodash;

	    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
	    LodashWrapper.prototype.constructor = LodashWrapper;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
	     *
	     * @private
	     * @constructor
	     * @param {*} value The value to wrap.
	     */
	    function LazyWrapper(value) {
	      this.__wrapped__ = value;
	      this.__actions__ = [];
	      this.__dir__ = 1;
	      this.__filtered__ = false;
	      this.__iteratees__ = [];
	      this.__takeCount__ = MAX_ARRAY_LENGTH;
	      this.__views__ = [];
	    }

	    /**
	     * Creates a clone of the lazy wrapper object.
	     *
	     * @private
	     * @name clone
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the cloned `LazyWrapper` object.
	     */
	    function lazyClone() {
	      var result = new LazyWrapper(this.__wrapped__);
	      result.__actions__ = copyArray(this.__actions__);
	      result.__dir__ = this.__dir__;
	      result.__filtered__ = this.__filtered__;
	      result.__iteratees__ = copyArray(this.__iteratees__);
	      result.__takeCount__ = this.__takeCount__;
	      result.__views__ = copyArray(this.__views__);
	      return result;
	    }

	    /**
	     * Reverses the direction of lazy iteration.
	     *
	     * @private
	     * @name reverse
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the new reversed `LazyWrapper` object.
	     */
	    function lazyReverse() {
	      if (this.__filtered__) {
	        var result = new LazyWrapper(this);
	        result.__dir__ = -1;
	        result.__filtered__ = true;
	      } else {
	        result = this.clone();
	        result.__dir__ *= -1;
	      }
	      return result;
	    }

	    /**
	     * Extracts the unwrapped value from its lazy wrapper.
	     *
	     * @private
	     * @name value
	     * @memberOf LazyWrapper
	     * @returns {*} Returns the unwrapped value.
	     */
	    function lazyValue() {
	      var array = this.__wrapped__.value(),
	          dir = this.__dir__,
	          isArr = isArray(array),
	          isRight = dir < 0,
	          arrLength = isArr ? array.length : 0,
	          view = getView(0, arrLength, this.__views__),
	          start = view.start,
	          end = view.end,
	          length = end - start,
	          index = isRight ? end : (start - 1),
	          iteratees = this.__iteratees__,
	          iterLength = iteratees.length,
	          resIndex = 0,
	          takeCount = nativeMin(length, this.__takeCount__);

	      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
	        return baseWrapperValue(array, this.__actions__);
	      }
	      var result = [];

	      outer:
	      while (length-- && resIndex < takeCount) {
	        index += dir;

	        var iterIndex = -1,
	            value = array[index];

	        while (++iterIndex < iterLength) {
	          var data = iteratees[iterIndex],
	              iteratee = data.iteratee,
	              type = data.type,
	              computed = iteratee(value);

	          if (type == LAZY_MAP_FLAG) {
	            value = computed;
	          } else if (!computed) {
	            if (type == LAZY_FILTER_FLAG) {
	              continue outer;
	            } else {
	              break outer;
	            }
	          }
	        }
	        result[resIndex++] = value;
	      }
	      return result;
	    }

	    // Ensure `LazyWrapper` is an instance of `baseLodash`.
	    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
	    LazyWrapper.prototype.constructor = LazyWrapper;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a hash object.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */
	    function Hash(entries) {
	      var index = -1,
	          length = entries == null ? 0 : entries.length;

	      this.clear();
	      while (++index < length) {
	        var entry = entries[index];
	        this.set(entry[0], entry[1]);
	      }
	    }

	    /**
	     * Removes all key-value entries from the hash.
	     *
	     * @private
	     * @name clear
	     * @memberOf Hash
	     */
	    function hashClear() {
	      this.__data__ = nativeCreate ? nativeCreate(null) : {};
	      this.size = 0;
	    }

	    /**
	     * Removes `key` and its value from the hash.
	     *
	     * @private
	     * @name delete
	     * @memberOf Hash
	     * @param {Object} hash The hash to modify.
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function hashDelete(key) {
	      var result = this.has(key) && delete this.__data__[key];
	      this.size -= result ? 1 : 0;
	      return result;
	    }

	    /**
	     * Gets the hash value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf Hash
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function hashGet(key) {
	      var data = this.__data__;
	      if (nativeCreate) {
	        var result = data[key];
	        return result === HASH_UNDEFINED ? undefined$1 : result;
	      }
	      return hasOwnProperty.call(data, key) ? data[key] : undefined$1;
	    }

	    /**
	     * Checks if a hash value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf Hash
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function hashHas(key) {
	      var data = this.__data__;
	      return nativeCreate ? (data[key] !== undefined$1) : hasOwnProperty.call(data, key);
	    }

	    /**
	     * Sets the hash `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf Hash
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the hash instance.
	     */
	    function hashSet(key, value) {
	      var data = this.__data__;
	      this.size += this.has(key) ? 0 : 1;
	      data[key] = (nativeCreate && value === undefined$1) ? HASH_UNDEFINED : value;
	      return this;
	    }

	    // Add methods to `Hash`.
	    Hash.prototype.clear = hashClear;
	    Hash.prototype['delete'] = hashDelete;
	    Hash.prototype.get = hashGet;
	    Hash.prototype.has = hashHas;
	    Hash.prototype.set = hashSet;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates an list cache object.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */
	    function ListCache(entries) {
	      var index = -1,
	          length = entries == null ? 0 : entries.length;

	      this.clear();
	      while (++index < length) {
	        var entry = entries[index];
	        this.set(entry[0], entry[1]);
	      }
	    }

	    /**
	     * Removes all key-value entries from the list cache.
	     *
	     * @private
	     * @name clear
	     * @memberOf ListCache
	     */
	    function listCacheClear() {
	      this.__data__ = [];
	      this.size = 0;
	    }

	    /**
	     * Removes `key` and its value from the list cache.
	     *
	     * @private
	     * @name delete
	     * @memberOf ListCache
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function listCacheDelete(key) {
	      var data = this.__data__,
	          index = assocIndexOf(data, key);

	      if (index < 0) {
	        return false;
	      }
	      var lastIndex = data.length - 1;
	      if (index == lastIndex) {
	        data.pop();
	      } else {
	        splice.call(data, index, 1);
	      }
	      --this.size;
	      return true;
	    }

	    /**
	     * Gets the list cache value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf ListCache
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function listCacheGet(key) {
	      var data = this.__data__,
	          index = assocIndexOf(data, key);

	      return index < 0 ? undefined$1 : data[index][1];
	    }

	    /**
	     * Checks if a list cache value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf ListCache
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function listCacheHas(key) {
	      return assocIndexOf(this.__data__, key) > -1;
	    }

	    /**
	     * Sets the list cache `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf ListCache
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the list cache instance.
	     */
	    function listCacheSet(key, value) {
	      var data = this.__data__,
	          index = assocIndexOf(data, key);

	      if (index < 0) {
	        ++this.size;
	        data.push([key, value]);
	      } else {
	        data[index][1] = value;
	      }
	      return this;
	    }

	    // Add methods to `ListCache`.
	    ListCache.prototype.clear = listCacheClear;
	    ListCache.prototype['delete'] = listCacheDelete;
	    ListCache.prototype.get = listCacheGet;
	    ListCache.prototype.has = listCacheHas;
	    ListCache.prototype.set = listCacheSet;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a map cache object to store key-value pairs.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */
	    function MapCache(entries) {
	      var index = -1,
	          length = entries == null ? 0 : entries.length;

	      this.clear();
	      while (++index < length) {
	        var entry = entries[index];
	        this.set(entry[0], entry[1]);
	      }
	    }

	    /**
	     * Removes all key-value entries from the map.
	     *
	     * @private
	     * @name clear
	     * @memberOf MapCache
	     */
	    function mapCacheClear() {
	      this.size = 0;
	      this.__data__ = {
	        'hash': new Hash,
	        'map': new (Map || ListCache),
	        'string': new Hash
	      };
	    }

	    /**
	     * Removes `key` and its value from the map.
	     *
	     * @private
	     * @name delete
	     * @memberOf MapCache
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function mapCacheDelete(key) {
	      var result = getMapData(this, key)['delete'](key);
	      this.size -= result ? 1 : 0;
	      return result;
	    }

	    /**
	     * Gets the map value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf MapCache
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function mapCacheGet(key) {
	      return getMapData(this, key).get(key);
	    }

	    /**
	     * Checks if a map value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf MapCache
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function mapCacheHas(key) {
	      return getMapData(this, key).has(key);
	    }

	    /**
	     * Sets the map `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf MapCache
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the map cache instance.
	     */
	    function mapCacheSet(key, value) {
	      var data = getMapData(this, key),
	          size = data.size;

	      data.set(key, value);
	      this.size += data.size == size ? 0 : 1;
	      return this;
	    }

	    // Add methods to `MapCache`.
	    MapCache.prototype.clear = mapCacheClear;
	    MapCache.prototype['delete'] = mapCacheDelete;
	    MapCache.prototype.get = mapCacheGet;
	    MapCache.prototype.has = mapCacheHas;
	    MapCache.prototype.set = mapCacheSet;

	    /*------------------------------------------------------------------------*/

	    /**
	     *
	     * Creates an array cache object to store unique values.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [values] The values to cache.
	     */
	    function SetCache(values) {
	      var index = -1,
	          length = values == null ? 0 : values.length;

	      this.__data__ = new MapCache;
	      while (++index < length) {
	        this.add(values[index]);
	      }
	    }

	    /**
	     * Adds `value` to the array cache.
	     *
	     * @private
	     * @name add
	     * @memberOf SetCache
	     * @alias push
	     * @param {*} value The value to cache.
	     * @returns {Object} Returns the cache instance.
	     */
	    function setCacheAdd(value) {
	      this.__data__.set(value, HASH_UNDEFINED);
	      return this;
	    }

	    /**
	     * Checks if `value` is in the array cache.
	     *
	     * @private
	     * @name has
	     * @memberOf SetCache
	     * @param {*} value The value to search for.
	     * @returns {number} Returns `true` if `value` is found, else `false`.
	     */
	    function setCacheHas(value) {
	      return this.__data__.has(value);
	    }

	    // Add methods to `SetCache`.
	    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	    SetCache.prototype.has = setCacheHas;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a stack cache object to store key-value pairs.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */
	    function Stack(entries) {
	      var data = this.__data__ = new ListCache(entries);
	      this.size = data.size;
	    }

	    /**
	     * Removes all key-value entries from the stack.
	     *
	     * @private
	     * @name clear
	     * @memberOf Stack
	     */
	    function stackClear() {
	      this.__data__ = new ListCache;
	      this.size = 0;
	    }

	    /**
	     * Removes `key` and its value from the stack.
	     *
	     * @private
	     * @name delete
	     * @memberOf Stack
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function stackDelete(key) {
	      var data = this.__data__,
	          result = data['delete'](key);

	      this.size = data.size;
	      return result;
	    }

	    /**
	     * Gets the stack value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf Stack
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function stackGet(key) {
	      return this.__data__.get(key);
	    }

	    /**
	     * Checks if a stack value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf Stack
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function stackHas(key) {
	      return this.__data__.has(key);
	    }

	    /**
	     * Sets the stack `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf Stack
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the stack cache instance.
	     */
	    function stackSet(key, value) {
	      var data = this.__data__;
	      if (data instanceof ListCache) {
	        var pairs = data.__data__;
	        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	          pairs.push([key, value]);
	          this.size = ++data.size;
	          return this;
	        }
	        data = this.__data__ = new MapCache(pairs);
	      }
	      data.set(key, value);
	      this.size = data.size;
	      return this;
	    }

	    // Add methods to `Stack`.
	    Stack.prototype.clear = stackClear;
	    Stack.prototype['delete'] = stackDelete;
	    Stack.prototype.get = stackGet;
	    Stack.prototype.has = stackHas;
	    Stack.prototype.set = stackSet;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates an array of the enumerable property names of the array-like `value`.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @param {boolean} inherited Specify returning inherited property names.
	     * @returns {Array} Returns the array of property names.
	     */
	    function arrayLikeKeys(value, inherited) {
	      var isArr = isArray(value),
	          isArg = !isArr && isArguments(value),
	          isBuff = !isArr && !isArg && isBuffer(value),
	          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	          skipIndexes = isArr || isArg || isBuff || isType,
	          result = skipIndexes ? baseTimes(value.length, String) : [],
	          length = result.length;

	      for (var key in value) {
	        if ((inherited || hasOwnProperty.call(value, key)) &&
	            !(skipIndexes && (
	               // Safari 9 has enumerable `arguments.length` in strict mode.
	               key == 'length' ||
	               // Node.js 0.10 has enumerable non-index properties on buffers.
	               (isBuff && (key == 'offset' || key == 'parent')) ||
	               // PhantomJS 2 has enumerable non-index properties on typed arrays.
	               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	               // Skip index properties.
	               isIndex(key, length)
	            ))) {
	          result.push(key);
	        }
	      }
	      return result;
	    }

	    /**
	     * A specialized version of `_.sample` for arrays.
	     *
	     * @private
	     * @param {Array} array The array to sample.
	     * @returns {*} Returns the random element.
	     */
	    function arraySample(array) {
	      var length = array.length;
	      return length ? array[baseRandom(0, length - 1)] : undefined$1;
	    }

	    /**
	     * A specialized version of `_.sampleSize` for arrays.
	     *
	     * @private
	     * @param {Array} array The array to sample.
	     * @param {number} n The number of elements to sample.
	     * @returns {Array} Returns the random elements.
	     */
	    function arraySampleSize(array, n) {
	      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
	    }

	    /**
	     * A specialized version of `_.shuffle` for arrays.
	     *
	     * @private
	     * @param {Array} array The array to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     */
	    function arrayShuffle(array) {
	      return shuffleSelf(copyArray(array));
	    }

	    /**
	     * This function is like `assignValue` except that it doesn't assign
	     * `undefined` values.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {string} key The key of the property to assign.
	     * @param {*} value The value to assign.
	     */
	    function assignMergeValue(object, key, value) {
	      if ((value !== undefined$1 && !eq(object[key], value)) ||
	          (value === undefined$1 && !(key in object))) {
	        baseAssignValue(object, key, value);
	      }
	    }

	    /**
	     * Assigns `value` to `key` of `object` if the existing value is not equivalent
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {string} key The key of the property to assign.
	     * @param {*} value The value to assign.
	     */
	    function assignValue(object, key, value) {
	      var objValue = object[key];
	      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
	          (value === undefined$1 && !(key in object))) {
	        baseAssignValue(object, key, value);
	      }
	    }

	    /**
	     * Gets the index at which the `key` is found in `array` of key-value pairs.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {*} key The key to search for.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     */
	    function assocIndexOf(array, key) {
	      var length = array.length;
	      while (length--) {
	        if (eq(array[length][0], key)) {
	          return length;
	        }
	      }
	      return -1;
	    }

	    /**
	     * Aggregates elements of `collection` on `accumulator` with keys transformed
	     * by `iteratee` and values set by `setter`.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} setter The function to set `accumulator` values.
	     * @param {Function} iteratee The iteratee to transform keys.
	     * @param {Object} accumulator The initial aggregated object.
	     * @returns {Function} Returns `accumulator`.
	     */
	    function baseAggregator(collection, setter, iteratee, accumulator) {
	      baseEach(collection, function(value, key, collection) {
	        setter(accumulator, value, iteratee(value), collection);
	      });
	      return accumulator;
	    }

	    /**
	     * The base implementation of `_.assign` without support for multiple sources
	     * or `customizer` functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @returns {Object} Returns `object`.
	     */
	    function baseAssign(object, source) {
	      return object && copyObject(source, keys(source), object);
	    }

	    /**
	     * The base implementation of `_.assignIn` without support for multiple sources
	     * or `customizer` functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @returns {Object} Returns `object`.
	     */
	    function baseAssignIn(object, source) {
	      return object && copyObject(source, keysIn(source), object);
	    }

	    /**
	     * The base implementation of `assignValue` and `assignMergeValue` without
	     * value checks.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {string} key The key of the property to assign.
	     * @param {*} value The value to assign.
	     */
	    function baseAssignValue(object, key, value) {
	      if (key == '__proto__' && defineProperty) {
	        defineProperty(object, key, {
	          'configurable': true,
	          'enumerable': true,
	          'value': value,
	          'writable': true
	        });
	      } else {
	        object[key] = value;
	      }
	    }

	    /**
	     * The base implementation of `_.at` without support for individual paths.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {string[]} paths The property paths to pick.
	     * @returns {Array} Returns the picked elements.
	     */
	    function baseAt(object, paths) {
	      var index = -1,
	          length = paths.length,
	          result = Array(length),
	          skip = object == null;

	      while (++index < length) {
	        result[index] = skip ? undefined$1 : get(object, paths[index]);
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.clamp` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {number} number The number to clamp.
	     * @param {number} [lower] The lower bound.
	     * @param {number} upper The upper bound.
	     * @returns {number} Returns the clamped number.
	     */
	    function baseClamp(number, lower, upper) {
	      if (number === number) {
	        if (upper !== undefined$1) {
	          number = number <= upper ? number : upper;
	        }
	        if (lower !== undefined$1) {
	          number = number >= lower ? number : lower;
	        }
	      }
	      return number;
	    }

	    /**
	     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
	     * traversed objects.
	     *
	     * @private
	     * @param {*} value The value to clone.
	     * @param {boolean} bitmask The bitmask flags.
	     *  1 - Deep clone
	     *  2 - Flatten inherited properties
	     *  4 - Clone symbols
	     * @param {Function} [customizer] The function to customize cloning.
	     * @param {string} [key] The key of `value`.
	     * @param {Object} [object] The parent object of `value`.
	     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
	     * @returns {*} Returns the cloned value.
	     */
	    function baseClone(value, bitmask, customizer, key, object, stack) {
	      var result,
	          isDeep = bitmask & CLONE_DEEP_FLAG,
	          isFlat = bitmask & CLONE_FLAT_FLAG,
	          isFull = bitmask & CLONE_SYMBOLS_FLAG;

	      if (customizer) {
	        result = object ? customizer(value, key, object, stack) : customizer(value);
	      }
	      if (result !== undefined$1) {
	        return result;
	      }
	      if (!isObject(value)) {
	        return value;
	      }
	      var isArr = isArray(value);
	      if (isArr) {
	        result = initCloneArray(value);
	        if (!isDeep) {
	          return copyArray(value, result);
	        }
	      } else {
	        var tag = getTag(value),
	            isFunc = tag == funcTag || tag == genTag;

	        if (isBuffer(value)) {
	          return cloneBuffer(value, isDeep);
	        }
	        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
	          result = (isFlat || isFunc) ? {} : initCloneObject(value);
	          if (!isDeep) {
	            return isFlat
	              ? copySymbolsIn(value, baseAssignIn(result, value))
	              : copySymbols(value, baseAssign(result, value));
	          }
	        } else {
	          if (!cloneableTags[tag]) {
	            return object ? value : {};
	          }
	          result = initCloneByTag(value, tag, isDeep);
	        }
	      }
	      // Check for circular references and return its corresponding clone.
	      stack || (stack = new Stack);
	      var stacked = stack.get(value);
	      if (stacked) {
	        return stacked;
	      }
	      stack.set(value, result);

	      if (isSet(value)) {
	        value.forEach(function(subValue) {
	          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
	        });
	      } else if (isMap(value)) {
	        value.forEach(function(subValue, key) {
	          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
	        });
	      }

	      var keysFunc = isFull
	        ? (isFlat ? getAllKeysIn : getAllKeys)
	        : (isFlat ? keysIn : keys);

	      var props = isArr ? undefined$1 : keysFunc(value);
	      arrayEach(props || value, function(subValue, key) {
	        if (props) {
	          key = subValue;
	          subValue = value[key];
	        }
	        // Recursively populate clone (susceptible to call stack limits).
	        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.conforms` which doesn't clone `source`.
	     *
	     * @private
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {Function} Returns the new spec function.
	     */
	    function baseConforms(source) {
	      var props = keys(source);
	      return function(object) {
	        return baseConformsTo(object, source, props);
	      };
	    }

	    /**
	     * The base implementation of `_.conformsTo` which accepts `props` to check.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
	     */
	    function baseConformsTo(object, source, props) {
	      var length = props.length;
	      if (object == null) {
	        return !length;
	      }
	      object = Object(object);
	      while (length--) {
	        var key = props[length],
	            predicate = source[key],
	            value = object[key];

	        if ((value === undefined$1 && !(key in object)) || !predicate(value)) {
	          return false;
	        }
	      }
	      return true;
	    }

	    /**
	     * The base implementation of `_.delay` and `_.defer` which accepts `args`
	     * to provide to `func`.
	     *
	     * @private
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {Array} args The arguments to provide to `func`.
	     * @returns {number|Object} Returns the timer id or timeout object.
	     */
	    function baseDelay(func, wait, args) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return setTimeout(function() { func.apply(undefined$1, args); }, wait);
	    }

	    /**
	     * The base implementation of methods like `_.difference` without support
	     * for excluding multiple arrays or iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Array} values The values to exclude.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     */
	    function baseDifference(array, values, iteratee, comparator) {
	      var index = -1,
	          includes = arrayIncludes,
	          isCommon = true,
	          length = array.length,
	          result = [],
	          valuesLength = values.length;

	      if (!length) {
	        return result;
	      }
	      if (iteratee) {
	        values = arrayMap(values, baseUnary(iteratee));
	      }
	      if (comparator) {
	        includes = arrayIncludesWith;
	        isCommon = false;
	      }
	      else if (values.length >= LARGE_ARRAY_SIZE) {
	        includes = cacheHas;
	        isCommon = false;
	        values = new SetCache(values);
	      }
	      outer:
	      while (++index < length) {
	        var value = array[index],
	            computed = iteratee == null ? value : iteratee(value);

	        value = (comparator || value !== 0) ? value : 0;
	        if (isCommon && computed === computed) {
	          var valuesIndex = valuesLength;
	          while (valuesIndex--) {
	            if (values[valuesIndex] === computed) {
	              continue outer;
	            }
	          }
	          result.push(value);
	        }
	        else if (!includes(values, computed, comparator)) {
	          result.push(value);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.forEach` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     */
	    var baseEach = createBaseEach(baseForOwn);

	    /**
	     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     */
	    var baseEachRight = createBaseEach(baseForOwnRight, true);

	    /**
	     * The base implementation of `_.every` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`
	     */
	    function baseEvery(collection, predicate) {
	      var result = true;
	      baseEach(collection, function(value, index, collection) {
	        result = !!predicate(value, index, collection);
	        return result;
	      });
	      return result;
	    }

	    /**
	     * The base implementation of methods like `_.max` and `_.min` which accepts a
	     * `comparator` to determine the extremum value.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The iteratee invoked per iteration.
	     * @param {Function} comparator The comparator used to compare values.
	     * @returns {*} Returns the extremum value.
	     */
	    function baseExtremum(array, iteratee, comparator) {
	      var index = -1,
	          length = array.length;

	      while (++index < length) {
	        var value = array[index],
	            current = iteratee(value);

	        if (current != null && (computed === undefined$1
	              ? (current === current && !isSymbol(current))
	              : comparator(current, computed)
	            )) {
	          var computed = current,
	              result = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.fill` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     */
	    function baseFill(array, value, start, end) {
	      var length = array.length;

	      start = toInteger(start);
	      if (start < 0) {
	        start = -start > length ? 0 : (length + start);
	      }
	      end = (end === undefined$1 || end > length) ? length : toInteger(end);
	      if (end < 0) {
	        end += length;
	      }
	      end = start > end ? 0 : toLength(end);
	      while (start < end) {
	        array[start++] = value;
	      }
	      return array;
	    }

	    /**
	     * The base implementation of `_.filter` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     */
	    function baseFilter(collection, predicate) {
	      var result = [];
	      baseEach(collection, function(value, index, collection) {
	        if (predicate(value, index, collection)) {
	          result.push(value);
	        }
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.flatten` with support for restricting flattening.
	     *
	     * @private
	     * @param {Array} array The array to flatten.
	     * @param {number} depth The maximum recursion depth.
	     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
	     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
	     * @param {Array} [result=[]] The initial result value.
	     * @returns {Array} Returns the new flattened array.
	     */
	    function baseFlatten(array, depth, predicate, isStrict, result) {
	      var index = -1,
	          length = array.length;

	      predicate || (predicate = isFlattenable);
	      result || (result = []);

	      while (++index < length) {
	        var value = array[index];
	        if (depth > 0 && predicate(value)) {
	          if (depth > 1) {
	            // Recursively flatten arrays (susceptible to call stack limits).
	            baseFlatten(value, depth - 1, predicate, isStrict, result);
	          } else {
	            arrayPush(result, value);
	          }
	        } else if (!isStrict) {
	          result[result.length] = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `baseForOwn` which iterates over `object`
	     * properties returned by `keysFunc` and invokes `iteratee` for each property.
	     * Iteratee functions may exit iteration early by explicitly returning `false`.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */
	    var baseFor = createBaseFor();

	    /**
	     * This function is like `baseFor` except that it iterates over properties
	     * in the opposite order.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */
	    var baseForRight = createBaseFor(true);

	    /**
	     * The base implementation of `_.forOwn` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForOwn(object, iteratee) {
	      return object && baseFor(object, iteratee, keys);
	    }

	    /**
	     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForOwnRight(object, iteratee) {
	      return object && baseForRight(object, iteratee, keys);
	    }

	    /**
	     * The base implementation of `_.functions` which creates an array of
	     * `object` function property names filtered from `props`.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Array} props The property names to filter.
	     * @returns {Array} Returns the function names.
	     */
	    function baseFunctions(object, props) {
	      return arrayFilter(props, function(key) {
	        return isFunction(object[key]);
	      });
	    }

	    /**
	     * The base implementation of `_.get` without support for default values.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to get.
	     * @returns {*} Returns the resolved value.
	     */
	    function baseGet(object, path) {
	      path = castPath(path, object);

	      var index = 0,
	          length = path.length;

	      while (object != null && index < length) {
	        object = object[toKey(path[index++])];
	      }
	      return (index && index == length) ? object : undefined$1;
	    }

	    /**
	     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	     * symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @param {Function} symbolsFunc The function to get the symbols of `object`.
	     * @returns {Array} Returns the array of property names and symbols.
	     */
	    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	      var result = keysFunc(object);
	      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
	    }

	    /**
	     * The base implementation of `getTag` without fallbacks for buggy environments.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @returns {string} Returns the `toStringTag`.
	     */
	    function baseGetTag(value) {
	      if (value == null) {
	        return value === undefined$1 ? undefinedTag : nullTag;
	      }
	      return (symToStringTag && symToStringTag in Object(value))
	        ? getRawTag(value)
	        : objectToString(value);
	    }

	    /**
	     * The base implementation of `_.gt` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than `other`,
	     *  else `false`.
	     */
	    function baseGt(value, other) {
	      return value > other;
	    }

	    /**
	     * The base implementation of `_.has` without support for deep paths.
	     *
	     * @private
	     * @param {Object} [object] The object to query.
	     * @param {Array|string} key The key to check.
	     * @returns {boolean} Returns `true` if `key` exists, else `false`.
	     */
	    function baseHas(object, key) {
	      return object != null && hasOwnProperty.call(object, key);
	    }

	    /**
	     * The base implementation of `_.hasIn` without support for deep paths.
	     *
	     * @private
	     * @param {Object} [object] The object to query.
	     * @param {Array|string} key The key to check.
	     * @returns {boolean} Returns `true` if `key` exists, else `false`.
	     */
	    function baseHasIn(object, key) {
	      return object != null && key in Object(object);
	    }

	    /**
	     * The base implementation of `_.inRange` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {number} number The number to check.
	     * @param {number} start The start of the range.
	     * @param {number} end The end of the range.
	     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
	     */
	    function baseInRange(number, start, end) {
	      return number >= nativeMin(start, end) && number < nativeMax(start, end);
	    }

	    /**
	     * The base implementation of methods like `_.intersection`, without support
	     * for iteratee shorthands, that accepts an array of arrays to inspect.
	     *
	     * @private
	     * @param {Array} arrays The arrays to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of shared values.
	     */
	    function baseIntersection(arrays, iteratee, comparator) {
	      var includes = comparator ? arrayIncludesWith : arrayIncludes,
	          length = arrays[0].length,
	          othLength = arrays.length,
	          othIndex = othLength,
	          caches = Array(othLength),
	          maxLength = Infinity,
	          result = [];

	      while (othIndex--) {
	        var array = arrays[othIndex];
	        if (othIndex && iteratee) {
	          array = arrayMap(array, baseUnary(iteratee));
	        }
	        maxLength = nativeMin(array.length, maxLength);
	        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
	          ? new SetCache(othIndex && array)
	          : undefined$1;
	      }
	      array = arrays[0];

	      var index = -1,
	          seen = caches[0];

	      outer:
	      while (++index < length && result.length < maxLength) {
	        var value = array[index],
	            computed = iteratee ? iteratee(value) : value;

	        value = (comparator || value !== 0) ? value : 0;
	        if (!(seen
	              ? cacheHas(seen, computed)
	              : includes(result, computed, comparator)
	            )) {
	          othIndex = othLength;
	          while (--othIndex) {
	            var cache = caches[othIndex];
	            if (!(cache
	                  ? cacheHas(cache, computed)
	                  : includes(arrays[othIndex], computed, comparator))
	                ) {
	              continue outer;
	            }
	          }
	          if (seen) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.invert` and `_.invertBy` which inverts
	     * `object` with values transformed by `iteratee` and set by `setter`.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} setter The function to set `accumulator` values.
	     * @param {Function} iteratee The iteratee to transform values.
	     * @param {Object} accumulator The initial inverted object.
	     * @returns {Function} Returns `accumulator`.
	     */
	    function baseInverter(object, setter, iteratee, accumulator) {
	      baseForOwn(object, function(value, key, object) {
	        setter(accumulator, iteratee(value), key, object);
	      });
	      return accumulator;
	    }

	    /**
	     * The base implementation of `_.invoke` without support for individual
	     * method arguments.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {Array} args The arguments to invoke the method with.
	     * @returns {*} Returns the result of the invoked method.
	     */
	    function baseInvoke(object, path, args) {
	      path = castPath(path, object);
	      object = parent(object, path);
	      var func = object == null ? object : object[toKey(last(path))];
	      return func == null ? undefined$1 : apply(func, object, args);
	    }

	    /**
	     * The base implementation of `_.isArguments`.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	     */
	    function baseIsArguments(value) {
	      return isObjectLike(value) && baseGetTag(value) == argsTag;
	    }

	    /**
	     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
	     */
	    function baseIsArrayBuffer(value) {
	      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
	    }

	    /**
	     * The base implementation of `_.isDate` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
	     */
	    function baseIsDate(value) {
	      return isObjectLike(value) && baseGetTag(value) == dateTag;
	    }

	    /**
	     * The base implementation of `_.isEqual` which supports partial comparisons
	     * and tracks traversed objects.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {boolean} bitmask The bitmask flags.
	     *  1 - Unordered comparison
	     *  2 - Partial comparison
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     */
	    function baseIsEqual(value, other, bitmask, customizer, stack) {
	      if (value === other) {
	        return true;
	      }
	      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
	        return value !== value && other !== other;
	      }
	      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
	    }

	    /**
	     * A specialized version of `baseIsEqual` for arrays and objects which performs
	     * deep comparisons and tracks traversed objects enabling objects with circular
	     * references to be compared.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
	      var objIsArr = isArray(object),
	          othIsArr = isArray(other),
	          objTag = objIsArr ? arrayTag : getTag(object),
	          othTag = othIsArr ? arrayTag : getTag(other);

	      objTag = objTag == argsTag ? objectTag : objTag;
	      othTag = othTag == argsTag ? objectTag : othTag;

	      var objIsObj = objTag == objectTag,
	          othIsObj = othTag == objectTag,
	          isSameTag = objTag == othTag;

	      if (isSameTag && isBuffer(object)) {
	        if (!isBuffer(other)) {
	          return false;
	        }
	        objIsArr = true;
	        objIsObj = false;
	      }
	      if (isSameTag && !objIsObj) {
	        stack || (stack = new Stack);
	        return (objIsArr || isTypedArray(object))
	          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
	          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
	      }
	      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
	        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	        if (objIsWrapped || othIsWrapped) {
	          var objUnwrapped = objIsWrapped ? object.value() : object,
	              othUnwrapped = othIsWrapped ? other.value() : other;

	          stack || (stack = new Stack);
	          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	        }
	      }
	      if (!isSameTag) {
	        return false;
	      }
	      stack || (stack = new Stack);
	      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	    }

	    /**
	     * The base implementation of `_.isMap` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	     */
	    function baseIsMap(value) {
	      return isObjectLike(value) && getTag(value) == mapTag;
	    }

	    /**
	     * The base implementation of `_.isMatch` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @param {Array} matchData The property names, values, and compare flags to match.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     */
	    function baseIsMatch(object, source, matchData, customizer) {
	      var index = matchData.length,
	          length = index,
	          noCustomizer = !customizer;

	      if (object == null) {
	        return !length;
	      }
	      object = Object(object);
	      while (index--) {
	        var data = matchData[index];
	        if ((noCustomizer && data[2])
	              ? data[1] !== object[data[0]]
	              : !(data[0] in object)
	            ) {
	          return false;
	        }
	      }
	      while (++index < length) {
	        data = matchData[index];
	        var key = data[0],
	            objValue = object[key],
	            srcValue = data[1];

	        if (noCustomizer && data[2]) {
	          if (objValue === undefined$1 && !(key in object)) {
	            return false;
	          }
	        } else {
	          var stack = new Stack;
	          if (customizer) {
	            var result = customizer(objValue, srcValue, key, object, source, stack);
	          }
	          if (!(result === undefined$1
	                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
	                : result
	              )) {
	            return false;
	          }
	        }
	      }
	      return true;
	    }

	    /**
	     * The base implementation of `_.isNative` without bad shim checks.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a native function,
	     *  else `false`.
	     */
	    function baseIsNative(value) {
	      if (!isObject(value) || isMasked(value)) {
	        return false;
	      }
	      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	      return pattern.test(toSource(value));
	    }

	    /**
	     * The base implementation of `_.isRegExp` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
	     */
	    function baseIsRegExp(value) {
	      return isObjectLike(value) && baseGetTag(value) == regexpTag;
	    }

	    /**
	     * The base implementation of `_.isSet` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	     */
	    function baseIsSet(value) {
	      return isObjectLike(value) && getTag(value) == setTag;
	    }

	    /**
	     * The base implementation of `_.isTypedArray` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	     */
	    function baseIsTypedArray(value) {
	      return isObjectLike(value) &&
	        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	    }

	    /**
	     * The base implementation of `_.iteratee`.
	     *
	     * @private
	     * @param {*} [value=_.identity] The value to convert to an iteratee.
	     * @returns {Function} Returns the iteratee.
	     */
	    function baseIteratee(value) {
	      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
	      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
	      if (typeof value == 'function') {
	        return value;
	      }
	      if (value == null) {
	        return identity;
	      }
	      if (typeof value == 'object') {
	        return isArray(value)
	          ? baseMatchesProperty(value[0], value[1])
	          : baseMatches(value);
	      }
	      return property(value);
	    }

	    /**
	     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */
	    function baseKeys(object) {
	      if (!isPrototype(object)) {
	        return nativeKeys(object);
	      }
	      var result = [];
	      for (var key in Object(object)) {
	        if (hasOwnProperty.call(object, key) && key != 'constructor') {
	          result.push(key);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */
	    function baseKeysIn(object) {
	      if (!isObject(object)) {
	        return nativeKeysIn(object);
	      }
	      var isProto = isPrototype(object),
	          result = [];

	      for (var key in object) {
	        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	          result.push(key);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.lt` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than `other`,
	     *  else `false`.
	     */
	    function baseLt(value, other) {
	      return value < other;
	    }

	    /**
	     * The base implementation of `_.map` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     */
	    function baseMap(collection, iteratee) {
	      var index = -1,
	          result = isArrayLike(collection) ? Array(collection.length) : [];

	      baseEach(collection, function(value, key, collection) {
	        result[++index] = iteratee(value, key, collection);
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.matches` which doesn't clone `source`.
	     *
	     * @private
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new spec function.
	     */
	    function baseMatches(source) {
	      var matchData = getMatchData(source);
	      if (matchData.length == 1 && matchData[0][2]) {
	        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
	      }
	      return function(object) {
	        return object === source || baseIsMatch(object, source, matchData);
	      };
	    }

	    /**
	     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
	     *
	     * @private
	     * @param {string} path The path of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new spec function.
	     */
	    function baseMatchesProperty(path, srcValue) {
	      if (isKey(path) && isStrictComparable(srcValue)) {
	        return matchesStrictComparable(toKey(path), srcValue);
	      }
	      return function(object) {
	        var objValue = get(object, path);
	        return (objValue === undefined$1 && objValue === srcValue)
	          ? hasIn(object, path)
	          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
	      };
	    }

	    /**
	     * The base implementation of `_.merge` without support for multiple sources.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {number} srcIndex The index of `source`.
	     * @param {Function} [customizer] The function to customize merged values.
	     * @param {Object} [stack] Tracks traversed source values and their merged
	     *  counterparts.
	     */
	    function baseMerge(object, source, srcIndex, customizer, stack) {
	      if (object === source) {
	        return;
	      }
	      baseFor(source, function(srcValue, key) {
	        stack || (stack = new Stack);
	        if (isObject(srcValue)) {
	          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
	        }
	        else {
	          var newValue = customizer
	            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
	            : undefined$1;

	          if (newValue === undefined$1) {
	            newValue = srcValue;
	          }
	          assignMergeValue(object, key, newValue);
	        }
	      }, keysIn);
	    }

	    /**
	     * A specialized version of `baseMerge` for arrays and objects which performs
	     * deep merges and tracks traversed objects enabling objects with circular
	     * references to be merged.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {string} key The key of the value to merge.
	     * @param {number} srcIndex The index of `source`.
	     * @param {Function} mergeFunc The function to merge values.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @param {Object} [stack] Tracks traversed source values and their merged
	     *  counterparts.
	     */
	    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
	      var objValue = safeGet(object, key),
	          srcValue = safeGet(source, key),
	          stacked = stack.get(srcValue);

	      if (stacked) {
	        assignMergeValue(object, key, stacked);
	        return;
	      }
	      var newValue = customizer
	        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
	        : undefined$1;

	      var isCommon = newValue === undefined$1;

	      if (isCommon) {
	        var isArr = isArray(srcValue),
	            isBuff = !isArr && isBuffer(srcValue),
	            isTyped = !isArr && !isBuff && isTypedArray(srcValue);

	        newValue = srcValue;
	        if (isArr || isBuff || isTyped) {
	          if (isArray(objValue)) {
	            newValue = objValue;
	          }
	          else if (isArrayLikeObject(objValue)) {
	            newValue = copyArray(objValue);
	          }
	          else if (isBuff) {
	            isCommon = false;
	            newValue = cloneBuffer(srcValue, true);
	          }
	          else if (isTyped) {
	            isCommon = false;
	            newValue = cloneTypedArray(srcValue, true);
	          }
	          else {
	            newValue = [];
	          }
	        }
	        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
	          newValue = objValue;
	          if (isArguments(objValue)) {
	            newValue = toPlainObject(objValue);
	          }
	          else if (!isObject(objValue) || isFunction(objValue)) {
	            newValue = initCloneObject(srcValue);
	          }
	        }
	        else {
	          isCommon = false;
	        }
	      }
	      if (isCommon) {
	        // Recursively merge objects and arrays (susceptible to call stack limits).
	        stack.set(srcValue, newValue);
	        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
	        stack['delete'](srcValue);
	      }
	      assignMergeValue(object, key, newValue);
	    }

	    /**
	     * The base implementation of `_.nth` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {Array} array The array to query.
	     * @param {number} n The index of the element to return.
	     * @returns {*} Returns the nth element of `array`.
	     */
	    function baseNth(array, n) {
	      var length = array.length;
	      if (!length) {
	        return;
	      }
	      n += n < 0 ? length : 0;
	      return isIndex(n, length) ? array[n] : undefined$1;
	    }

	    /**
	     * The base implementation of `_.orderBy` without param guards.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
	     * @param {string[]} orders The sort orders of `iteratees`.
	     * @returns {Array} Returns the new sorted array.
	     */
	    function baseOrderBy(collection, iteratees, orders) {
	      if (iteratees.length) {
	        iteratees = arrayMap(iteratees, function(iteratee) {
	          if (isArray(iteratee)) {
	            return function(value) {
	              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
	            }
	          }
	          return iteratee;
	        });
	      } else {
	        iteratees = [identity];
	      }

	      var index = -1;
	      iteratees = arrayMap(iteratees, baseUnary(getIteratee()));

	      var result = baseMap(collection, function(value, key, collection) {
	        var criteria = arrayMap(iteratees, function(iteratee) {
	          return iteratee(value);
	        });
	        return { 'criteria': criteria, 'index': ++index, 'value': value };
	      });

	      return baseSortBy(result, function(object, other) {
	        return compareMultiple(object, other, orders);
	      });
	    }

	    /**
	     * The base implementation of `_.pick` without support for individual
	     * property identifiers.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {string[]} paths The property paths to pick.
	     * @returns {Object} Returns the new object.
	     */
	    function basePick(object, paths) {
	      return basePickBy(object, paths, function(value, path) {
	        return hasIn(object, path);
	      });
	    }

	    /**
	     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {string[]} paths The property paths to pick.
	     * @param {Function} predicate The function invoked per property.
	     * @returns {Object} Returns the new object.
	     */
	    function basePickBy(object, paths, predicate) {
	      var index = -1,
	          length = paths.length,
	          result = {};

	      while (++index < length) {
	        var path = paths[index],
	            value = baseGet(object, path);

	        if (predicate(value, path)) {
	          baseSet(result, castPath(path, object), value);
	        }
	      }
	      return result;
	    }

	    /**
	     * A specialized version of `baseProperty` which supports deep paths.
	     *
	     * @private
	     * @param {Array|string} path The path of the property to get.
	     * @returns {Function} Returns the new accessor function.
	     */
	    function basePropertyDeep(path) {
	      return function(object) {
	        return baseGet(object, path);
	      };
	    }

	    /**
	     * The base implementation of `_.pullAllBy` without support for iteratee
	     * shorthands.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns `array`.
	     */
	    function basePullAll(array, values, iteratee, comparator) {
	      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
	          index = -1,
	          length = values.length,
	          seen = array;

	      if (array === values) {
	        values = copyArray(values);
	      }
	      if (iteratee) {
	        seen = arrayMap(array, baseUnary(iteratee));
	      }
	      while (++index < length) {
	        var fromIndex = 0,
	            value = values[index],
	            computed = iteratee ? iteratee(value) : value;

	        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
	          if (seen !== array) {
	            splice.call(seen, fromIndex, 1);
	          }
	          splice.call(array, fromIndex, 1);
	        }
	      }
	      return array;
	    }

	    /**
	     * The base implementation of `_.pullAt` without support for individual
	     * indexes or capturing the removed elements.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {number[]} indexes The indexes of elements to remove.
	     * @returns {Array} Returns `array`.
	     */
	    function basePullAt(array, indexes) {
	      var length = array ? indexes.length : 0,
	          lastIndex = length - 1;

	      while (length--) {
	        var index = indexes[length];
	        if (length == lastIndex || index !== previous) {
	          var previous = index;
	          if (isIndex(index)) {
	            splice.call(array, index, 1);
	          } else {
	            baseUnset(array, index);
	          }
	        }
	      }
	      return array;
	    }

	    /**
	     * The base implementation of `_.random` without support for returning
	     * floating-point numbers.
	     *
	     * @private
	     * @param {number} lower The lower bound.
	     * @param {number} upper The upper bound.
	     * @returns {number} Returns the random number.
	     */
	    function baseRandom(lower, upper) {
	      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
	    }

	    /**
	     * The base implementation of `_.range` and `_.rangeRight` which doesn't
	     * coerce arguments.
	     *
	     * @private
	     * @param {number} start The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} step The value to increment or decrement by.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Array} Returns the range of numbers.
	     */
	    function baseRange(start, end, step, fromRight) {
	      var index = -1,
	          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
	          result = Array(length);

	      while (length--) {
	        result[fromRight ? length : ++index] = start;
	        start += step;
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.repeat` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {string} string The string to repeat.
	     * @param {number} n The number of times to repeat the string.
	     * @returns {string} Returns the repeated string.
	     */
	    function baseRepeat(string, n) {
	      var result = '';
	      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
	        return result;
	      }
	      // Leverage the exponentiation by squaring algorithm for a faster repeat.
	      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
	      do {
	        if (n % 2) {
	          result += string;
	        }
	        n = nativeFloor(n / 2);
	        if (n) {
	          string += string;
	        }
	      } while (n);

	      return result;
	    }

	    /**
	     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	     *
	     * @private
	     * @param {Function} func The function to apply a rest parameter to.
	     * @param {number} [start=func.length-1] The start position of the rest parameter.
	     * @returns {Function} Returns the new function.
	     */
	    function baseRest(func, start) {
	      return setToString(overRest(func, start, identity), func + '');
	    }

	    /**
	     * The base implementation of `_.sample`.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to sample.
	     * @returns {*} Returns the random element.
	     */
	    function baseSample(collection) {
	      return arraySample(values(collection));
	    }

	    /**
	     * The base implementation of `_.sampleSize` without param guards.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to sample.
	     * @param {number} n The number of elements to sample.
	     * @returns {Array} Returns the random elements.
	     */
	    function baseSampleSize(collection, n) {
	      var array = values(collection);
	      return shuffleSelf(array, baseClamp(n, 0, array.length));
	    }

	    /**
	     * The base implementation of `_.set`.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @param {Function} [customizer] The function to customize path creation.
	     * @returns {Object} Returns `object`.
	     */
	    function baseSet(object, path, value, customizer) {
	      if (!isObject(object)) {
	        return object;
	      }
	      path = castPath(path, object);

	      var index = -1,
	          length = path.length,
	          lastIndex = length - 1,
	          nested = object;

	      while (nested != null && ++index < length) {
	        var key = toKey(path[index]),
	            newValue = value;

	        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
	          return object;
	        }

	        if (index != lastIndex) {
	          var objValue = nested[key];
	          newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
	          if (newValue === undefined$1) {
	            newValue = isObject(objValue)
	              ? objValue
	              : (isIndex(path[index + 1]) ? [] : {});
	          }
	        }
	        assignValue(nested, key, newValue);
	        nested = nested[key];
	      }
	      return object;
	    }

	    /**
	     * The base implementation of `setData` without support for hot loop shorting.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */
	    var baseSetData = !metaMap ? identity : function(func, data) {
	      metaMap.set(func, data);
	      return func;
	    };

	    /**
	     * The base implementation of `setToString` without support for hot loop shorting.
	     *
	     * @private
	     * @param {Function} func The function to modify.
	     * @param {Function} string The `toString` result.
	     * @returns {Function} Returns `func`.
	     */
	    var baseSetToString = !defineProperty ? identity : function(func, string) {
	      return defineProperty(func, 'toString', {
	        'configurable': true,
	        'enumerable': false,
	        'value': constant(string),
	        'writable': true
	      });
	    };

	    /**
	     * The base implementation of `_.shuffle`.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     */
	    function baseShuffle(collection) {
	      return shuffleSelf(values(collection));
	    }

	    /**
	     * The base implementation of `_.slice` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function baseSlice(array, start, end) {
	      var index = -1,
	          length = array.length;

	      if (start < 0) {
	        start = -start > length ? 0 : (length + start);
	      }
	      end = end > length ? length : end;
	      if (end < 0) {
	        end += length;
	      }
	      length = start > end ? 0 : ((end - start) >>> 0);
	      start >>>= 0;

	      var result = Array(length);
	      while (++index < length) {
	        result[index] = array[index + start];
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.some` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     */
	    function baseSome(collection, predicate) {
	      var result;

	      baseEach(collection, function(value, index, collection) {
	        result = predicate(value, index, collection);
	        return !result;
	      });
	      return !!result;
	    }

	    /**
	     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
	     * performs a binary search of `array` to determine the index at which `value`
	     * should be inserted into `array` in order to maintain its sort order.
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     */
	    function baseSortedIndex(array, value, retHighest) {
	      var low = 0,
	          high = array == null ? low : array.length;

	      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
	        while (low < high) {
	          var mid = (low + high) >>> 1,
	              computed = array[mid];

	          if (computed !== null && !isSymbol(computed) &&
	              (retHighest ? (computed <= value) : (computed < value))) {
	            low = mid + 1;
	          } else {
	            high = mid;
	          }
	        }
	        return high;
	      }
	      return baseSortedIndexBy(array, value, identity, retHighest);
	    }

	    /**
	     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
	     * which invokes `iteratee` for `value` and each element of `array` to compute
	     * their sort ranking. The iteratee is invoked with one argument; (value).
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} iteratee The iteratee invoked per element.
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     */
	    function baseSortedIndexBy(array, value, iteratee, retHighest) {
	      var low = 0,
	          high = array == null ? 0 : array.length;
	      if (high === 0) {
	        return 0;
	      }

	      value = iteratee(value);
	      var valIsNaN = value !== value,
	          valIsNull = value === null,
	          valIsSymbol = isSymbol(value),
	          valIsUndefined = value === undefined$1;

	      while (low < high) {
	        var mid = nativeFloor((low + high) / 2),
	            computed = iteratee(array[mid]),
	            othIsDefined = computed !== undefined$1,
	            othIsNull = computed === null,
	            othIsReflexive = computed === computed,
	            othIsSymbol = isSymbol(computed);

	        if (valIsNaN) {
	          var setLow = retHighest || othIsReflexive;
	        } else if (valIsUndefined) {
	          setLow = othIsReflexive && (retHighest || othIsDefined);
	        } else if (valIsNull) {
	          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
	        } else if (valIsSymbol) {
	          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
	        } else if (othIsNull || othIsSymbol) {
	          setLow = false;
	        } else {
	          setLow = retHighest ? (computed <= value) : (computed < value);
	        }
	        if (setLow) {
	          low = mid + 1;
	        } else {
	          high = mid;
	        }
	      }
	      return nativeMin(high, MAX_ARRAY_INDEX);
	    }

	    /**
	     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
	     * support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     */
	    function baseSortedUniq(array, iteratee) {
	      var index = -1,
	          length = array.length,
	          resIndex = 0,
	          result = [];

	      while (++index < length) {
	        var value = array[index],
	            computed = iteratee ? iteratee(value) : value;

	        if (!index || !eq(computed, seen)) {
	          var seen = computed;
	          result[resIndex++] = value === 0 ? 0 : value;
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.toNumber` which doesn't ensure correct
	     * conversions of binary, hexadecimal, or octal string values.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {number} Returns the number.
	     */
	    function baseToNumber(value) {
	      if (typeof value == 'number') {
	        return value;
	      }
	      if (isSymbol(value)) {
	        return NAN;
	      }
	      return +value;
	    }

	    /**
	     * The base implementation of `_.toString` which doesn't convert nullish
	     * values to empty strings.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {string} Returns the string.
	     */
	    function baseToString(value) {
	      // Exit early for strings to avoid a performance hit in some environments.
	      if (typeof value == 'string') {
	        return value;
	      }
	      if (isArray(value)) {
	        // Recursively convert values (susceptible to call stack limits).
	        return arrayMap(value, baseToString) + '';
	      }
	      if (isSymbol(value)) {
	        return symbolToString ? symbolToString.call(value) : '';
	      }
	      var result = (value + '');
	      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	    }

	    /**
	     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     */
	    function baseUniq(array, iteratee, comparator) {
	      var index = -1,
	          includes = arrayIncludes,
	          length = array.length,
	          isCommon = true,
	          result = [],
	          seen = result;

	      if (comparator) {
	        isCommon = false;
	        includes = arrayIncludesWith;
	      }
	      else if (length >= LARGE_ARRAY_SIZE) {
	        var set = iteratee ? null : createSet(array);
	        if (set) {
	          return setToArray(set);
	        }
	        isCommon = false;
	        includes = cacheHas;
	        seen = new SetCache;
	      }
	      else {
	        seen = iteratee ? [] : result;
	      }
	      outer:
	      while (++index < length) {
	        var value = array[index],
	            computed = iteratee ? iteratee(value) : value;

	        value = (comparator || value !== 0) ? value : 0;
	        if (isCommon && computed === computed) {
	          var seenIndex = seen.length;
	          while (seenIndex--) {
	            if (seen[seenIndex] === computed) {
	              continue outer;
	            }
	          }
	          if (iteratee) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	        else if (!includes(seen, computed, comparator)) {
	          if (seen !== result) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.unset`.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The property path to unset.
	     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
	     */
	    function baseUnset(object, path) {
	      path = castPath(path, object);
	      object = parent(object, path);
	      return object == null || delete object[toKey(last(path))];
	    }

	    /**
	     * The base implementation of `_.update`.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to update.
	     * @param {Function} updater The function to produce the updated value.
	     * @param {Function} [customizer] The function to customize path creation.
	     * @returns {Object} Returns `object`.
	     */
	    function baseUpdate(object, path, updater, customizer) {
	      return baseSet(object, path, updater(baseGet(object, path)), customizer);
	    }

	    /**
	     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
	     * without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to query.
	     * @param {Function} predicate The function invoked per iteration.
	     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function baseWhile(array, predicate, isDrop, fromRight) {
	      var length = array.length,
	          index = fromRight ? length : -1;

	      while ((fromRight ? index-- : ++index < length) &&
	        predicate(array[index], index, array)) {}

	      return isDrop
	        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
	        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
	    }

	    /**
	     * The base implementation of `wrapperValue` which returns the result of
	     * performing a sequence of actions on the unwrapped `value`, where each
	     * successive action is supplied the return value of the previous.
	     *
	     * @private
	     * @param {*} value The unwrapped value.
	     * @param {Array} actions Actions to perform to resolve the unwrapped value.
	     * @returns {*} Returns the resolved value.
	     */
	    function baseWrapperValue(value, actions) {
	      var result = value;
	      if (result instanceof LazyWrapper) {
	        result = result.value();
	      }
	      return arrayReduce(actions, function(result, action) {
	        return action.func.apply(action.thisArg, arrayPush([result], action.args));
	      }, result);
	    }

	    /**
	     * The base implementation of methods like `_.xor`, without support for
	     * iteratee shorthands, that accepts an array of arrays to inspect.
	     *
	     * @private
	     * @param {Array} arrays The arrays to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of values.
	     */
	    function baseXor(arrays, iteratee, comparator) {
	      var length = arrays.length;
	      if (length < 2) {
	        return length ? baseUniq(arrays[0]) : [];
	      }
	      var index = -1,
	          result = Array(length);

	      while (++index < length) {
	        var array = arrays[index],
	            othIndex = -1;

	        while (++othIndex < length) {
	          if (othIndex != index) {
	            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
	          }
	        }
	      }
	      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
	    }

	    /**
	     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
	     *
	     * @private
	     * @param {Array} props The property identifiers.
	     * @param {Array} values The property values.
	     * @param {Function} assignFunc The function to assign values.
	     * @returns {Object} Returns the new object.
	     */
	    function baseZipObject(props, values, assignFunc) {
	      var index = -1,
	          length = props.length,
	          valsLength = values.length,
	          result = {};

	      while (++index < length) {
	        var value = index < valsLength ? values[index] : undefined$1;
	        assignFunc(result, props[index], value);
	      }
	      return result;
	    }

	    /**
	     * Casts `value` to an empty array if it's not an array like object.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @returns {Array|Object} Returns the cast array-like object.
	     */
	    function castArrayLikeObject(value) {
	      return isArrayLikeObject(value) ? value : [];
	    }

	    /**
	     * Casts `value` to `identity` if it's not a function.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @returns {Function} Returns cast function.
	     */
	    function castFunction(value) {
	      return typeof value == 'function' ? value : identity;
	    }

	    /**
	     * Casts `value` to a path array if it's not one.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @param {Object} [object] The object to query keys on.
	     * @returns {Array} Returns the cast property path array.
	     */
	    function castPath(value, object) {
	      if (isArray(value)) {
	        return value;
	      }
	      return isKey(value, object) ? [value] : stringToPath(toString(value));
	    }

	    /**
	     * A `baseRest` alias which can be replaced with `identity` by module
	     * replacement plugins.
	     *
	     * @private
	     * @type {Function}
	     * @param {Function} func The function to apply a rest parameter to.
	     * @returns {Function} Returns the new function.
	     */
	    var castRest = baseRest;

	    /**
	     * Casts `array` to a slice if it's needed.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {number} start The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the cast slice.
	     */
	    function castSlice(array, start, end) {
	      var length = array.length;
	      end = end === undefined$1 ? length : end;
	      return (!start && end >= length) ? array : baseSlice(array, start, end);
	    }

	    /**
	     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
	     *
	     * @private
	     * @param {number|Object} id The timer id or timeout object of the timer to clear.
	     */
	    var clearTimeout = ctxClearTimeout || function(id) {
	      return root.clearTimeout(id);
	    };

	    /**
	     * Creates a clone of  `buffer`.
	     *
	     * @private
	     * @param {Buffer} buffer The buffer to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Buffer} Returns the cloned buffer.
	     */
	    function cloneBuffer(buffer, isDeep) {
	      if (isDeep) {
	        return buffer.slice();
	      }
	      var length = buffer.length,
	          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

	      buffer.copy(result);
	      return result;
	    }

	    /**
	     * Creates a clone of `arrayBuffer`.
	     *
	     * @private
	     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	     * @returns {ArrayBuffer} Returns the cloned array buffer.
	     */
	    function cloneArrayBuffer(arrayBuffer) {
	      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
	      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
	      return result;
	    }

	    /**
	     * Creates a clone of `dataView`.
	     *
	     * @private
	     * @param {Object} dataView The data view to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the cloned data view.
	     */
	    function cloneDataView(dataView, isDeep) {
	      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
	      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
	    }

	    /**
	     * Creates a clone of `regexp`.
	     *
	     * @private
	     * @param {Object} regexp The regexp to clone.
	     * @returns {Object} Returns the cloned regexp.
	     */
	    function cloneRegExp(regexp) {
	      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
	      result.lastIndex = regexp.lastIndex;
	      return result;
	    }

	    /**
	     * Creates a clone of the `symbol` object.
	     *
	     * @private
	     * @param {Object} symbol The symbol object to clone.
	     * @returns {Object} Returns the cloned symbol object.
	     */
	    function cloneSymbol(symbol) {
	      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
	    }

	    /**
	     * Creates a clone of `typedArray`.
	     *
	     * @private
	     * @param {Object} typedArray The typed array to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the cloned typed array.
	     */
	    function cloneTypedArray(typedArray, isDeep) {
	      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
	      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	    }

	    /**
	     * Compares values to sort them in ascending order.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {number} Returns the sort order indicator for `value`.
	     */
	    function compareAscending(value, other) {
	      if (value !== other) {
	        var valIsDefined = value !== undefined$1,
	            valIsNull = value === null,
	            valIsReflexive = value === value,
	            valIsSymbol = isSymbol(value);

	        var othIsDefined = other !== undefined$1,
	            othIsNull = other === null,
	            othIsReflexive = other === other,
	            othIsSymbol = isSymbol(other);

	        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
	            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
	            (valIsNull && othIsDefined && othIsReflexive) ||
	            (!valIsDefined && othIsReflexive) ||
	            !valIsReflexive) {
	          return 1;
	        }
	        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
	            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
	            (othIsNull && valIsDefined && valIsReflexive) ||
	            (!othIsDefined && valIsReflexive) ||
	            !othIsReflexive) {
	          return -1;
	        }
	      }
	      return 0;
	    }

	    /**
	     * Used by `_.orderBy` to compare multiple properties of a value to another
	     * and stable sort them.
	     *
	     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
	     * specify an order of "desc" for descending or "asc" for ascending sort order
	     * of corresponding values.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {boolean[]|string[]} orders The order to sort by for each property.
	     * @returns {number} Returns the sort order indicator for `object`.
	     */
	    function compareMultiple(object, other, orders) {
	      var index = -1,
	          objCriteria = object.criteria,
	          othCriteria = other.criteria,
	          length = objCriteria.length,
	          ordersLength = orders.length;

	      while (++index < length) {
	        var result = compareAscending(objCriteria[index], othCriteria[index]);
	        if (result) {
	          if (index >= ordersLength) {
	            return result;
	          }
	          var order = orders[index];
	          return result * (order == 'desc' ? -1 : 1);
	        }
	      }
	      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
	      // that causes it, under certain circumstances, to provide the same value for
	      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
	      // for more details.
	      //
	      // This also ensures a stable sort in V8 and other engines.
	      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
	      return object.index - other.index;
	    }

	    /**
	     * Creates an array that is the composition of partially applied arguments,
	     * placeholders, and provided arguments into a single array of arguments.
	     *
	     * @private
	     * @param {Array} args The provided arguments.
	     * @param {Array} partials The arguments to prepend to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @params {boolean} [isCurried] Specify composing for a curried function.
	     * @returns {Array} Returns the new array of composed arguments.
	     */
	    function composeArgs(args, partials, holders, isCurried) {
	      var argsIndex = -1,
	          argsLength = args.length,
	          holdersLength = holders.length,
	          leftIndex = -1,
	          leftLength = partials.length,
	          rangeLength = nativeMax(argsLength - holdersLength, 0),
	          result = Array(leftLength + rangeLength),
	          isUncurried = !isCurried;

	      while (++leftIndex < leftLength) {
	        result[leftIndex] = partials[leftIndex];
	      }
	      while (++argsIndex < holdersLength) {
	        if (isUncurried || argsIndex < argsLength) {
	          result[holders[argsIndex]] = args[argsIndex];
	        }
	      }
	      while (rangeLength--) {
	        result[leftIndex++] = args[argsIndex++];
	      }
	      return result;
	    }

	    /**
	     * This function is like `composeArgs` except that the arguments composition
	     * is tailored for `_.partialRight`.
	     *
	     * @private
	     * @param {Array} args The provided arguments.
	     * @param {Array} partials The arguments to append to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @params {boolean} [isCurried] Specify composing for a curried function.
	     * @returns {Array} Returns the new array of composed arguments.
	     */
	    function composeArgsRight(args, partials, holders, isCurried) {
	      var argsIndex = -1,
	          argsLength = args.length,
	          holdersIndex = -1,
	          holdersLength = holders.length,
	          rightIndex = -1,
	          rightLength = partials.length,
	          rangeLength = nativeMax(argsLength - holdersLength, 0),
	          result = Array(rangeLength + rightLength),
	          isUncurried = !isCurried;

	      while (++argsIndex < rangeLength) {
	        result[argsIndex] = args[argsIndex];
	      }
	      var offset = argsIndex;
	      while (++rightIndex < rightLength) {
	        result[offset + rightIndex] = partials[rightIndex];
	      }
	      while (++holdersIndex < holdersLength) {
	        if (isUncurried || argsIndex < argsLength) {
	          result[offset + holders[holdersIndex]] = args[argsIndex++];
	        }
	      }
	      return result;
	    }

	    /**
	     * Copies the values of `source` to `array`.
	     *
	     * @private
	     * @param {Array} source The array to copy values from.
	     * @param {Array} [array=[]] The array to copy values to.
	     * @returns {Array} Returns `array`.
	     */
	    function copyArray(source, array) {
	      var index = -1,
	          length = source.length;

	      array || (array = Array(length));
	      while (++index < length) {
	        array[index] = source[index];
	      }
	      return array;
	    }

	    /**
	     * Copies properties of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy properties from.
	     * @param {Array} props The property identifiers to copy.
	     * @param {Object} [object={}] The object to copy properties to.
	     * @param {Function} [customizer] The function to customize copied values.
	     * @returns {Object} Returns `object`.
	     */
	    function copyObject(source, props, object, customizer) {
	      var isNew = !object;
	      object || (object = {});

	      var index = -1,
	          length = props.length;

	      while (++index < length) {
	        var key = props[index];

	        var newValue = customizer
	          ? customizer(object[key], source[key], key, object, source)
	          : undefined$1;

	        if (newValue === undefined$1) {
	          newValue = source[key];
	        }
	        if (isNew) {
	          baseAssignValue(object, key, newValue);
	        } else {
	          assignValue(object, key, newValue);
	        }
	      }
	      return object;
	    }

	    /**
	     * Copies own symbols of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy symbols from.
	     * @param {Object} [object={}] The object to copy symbols to.
	     * @returns {Object} Returns `object`.
	     */
	    function copySymbols(source, object) {
	      return copyObject(source, getSymbols(source), object);
	    }

	    /**
	     * Copies own and inherited symbols of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy symbols from.
	     * @param {Object} [object={}] The object to copy symbols to.
	     * @returns {Object} Returns `object`.
	     */
	    function copySymbolsIn(source, object) {
	      return copyObject(source, getSymbolsIn(source), object);
	    }

	    /**
	     * Creates a function like `_.groupBy`.
	     *
	     * @private
	     * @param {Function} setter The function to set accumulator values.
	     * @param {Function} [initializer] The accumulator object initializer.
	     * @returns {Function} Returns the new aggregator function.
	     */
	    function createAggregator(setter, initializer) {
	      return function(collection, iteratee) {
	        var func = isArray(collection) ? arrayAggregator : baseAggregator,
	            accumulator = initializer ? initializer() : {};

	        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
	      };
	    }

	    /**
	     * Creates a function like `_.assign`.
	     *
	     * @private
	     * @param {Function} assigner The function to assign values.
	     * @returns {Function} Returns the new assigner function.
	     */
	    function createAssigner(assigner) {
	      return baseRest(function(object, sources) {
	        var index = -1,
	            length = sources.length,
	            customizer = length > 1 ? sources[length - 1] : undefined$1,
	            guard = length > 2 ? sources[2] : undefined$1;

	        customizer = (assigner.length > 3 && typeof customizer == 'function')
	          ? (length--, customizer)
	          : undefined$1;

	        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	          customizer = length < 3 ? undefined$1 : customizer;
	          length = 1;
	        }
	        object = Object(object);
	        while (++index < length) {
	          var source = sources[index];
	          if (source) {
	            assigner(object, source, index, customizer);
	          }
	        }
	        return object;
	      });
	    }

	    /**
	     * Creates a `baseEach` or `baseEachRight` function.
	     *
	     * @private
	     * @param {Function} eachFunc The function to iterate over a collection.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new base function.
	     */
	    function createBaseEach(eachFunc, fromRight) {
	      return function(collection, iteratee) {
	        if (collection == null) {
	          return collection;
	        }
	        if (!isArrayLike(collection)) {
	          return eachFunc(collection, iteratee);
	        }
	        var length = collection.length,
	            index = fromRight ? length : -1,
	            iterable = Object(collection);

	        while ((fromRight ? index-- : ++index < length)) {
	          if (iteratee(iterable[index], index, iterable) === false) {
	            break;
	          }
	        }
	        return collection;
	      };
	    }

	    /**
	     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new base function.
	     */
	    function createBaseFor(fromRight) {
	      return function(object, iteratee, keysFunc) {
	        var index = -1,
	            iterable = Object(object),
	            props = keysFunc(object),
	            length = props.length;

	        while (length--) {
	          var key = props[fromRight ? length : ++index];
	          if (iteratee(iterable[key], key, iterable) === false) {
	            break;
	          }
	        }
	        return object;
	      };
	    }

	    /**
	     * Creates a function that wraps `func` to invoke it with the optional `this`
	     * binding of `thisArg`.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createBind(func, bitmask, thisArg) {
	      var isBind = bitmask & WRAP_BIND_FLAG,
	          Ctor = createCtor(func);

	      function wrapper() {
	        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	        return fn.apply(isBind ? thisArg : this, arguments);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates a function like `_.lowerFirst`.
	     *
	     * @private
	     * @param {string} methodName The name of the `String` case method to use.
	     * @returns {Function} Returns the new case function.
	     */
	    function createCaseFirst(methodName) {
	      return function(string) {
	        string = toString(string);

	        var strSymbols = hasUnicode(string)
	          ? stringToArray(string)
	          : undefined$1;

	        var chr = strSymbols
	          ? strSymbols[0]
	          : string.charAt(0);

	        var trailing = strSymbols
	          ? castSlice(strSymbols, 1).join('')
	          : string.slice(1);

	        return chr[methodName]() + trailing;
	      };
	    }

	    /**
	     * Creates a function like `_.camelCase`.
	     *
	     * @private
	     * @param {Function} callback The function to combine each word.
	     * @returns {Function} Returns the new compounder function.
	     */
	    function createCompounder(callback) {
	      return function(string) {
	        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
	      };
	    }

	    /**
	     * Creates a function that produces an instance of `Ctor` regardless of
	     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
	     *
	     * @private
	     * @param {Function} Ctor The constructor to wrap.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createCtor(Ctor) {
	      return function() {
	        // Use a `switch` statement to work with class constructors. See
	        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
	        // for more details.
	        var args = arguments;
	        switch (args.length) {
	          case 0: return new Ctor;
	          case 1: return new Ctor(args[0]);
	          case 2: return new Ctor(args[0], args[1]);
	          case 3: return new Ctor(args[0], args[1], args[2]);
	          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
	          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
	          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
	          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
	        }
	        var thisBinding = baseCreate(Ctor.prototype),
	            result = Ctor.apply(thisBinding, args);

	        // Mimic the constructor's `return` behavior.
	        // See https://es5.github.io/#x13.2.2 for more details.
	        return isObject(result) ? result : thisBinding;
	      };
	    }

	    /**
	     * Creates a function that wraps `func` to enable currying.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {number} arity The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createCurry(func, bitmask, arity) {
	      var Ctor = createCtor(func);

	      function wrapper() {
	        var length = arguments.length,
	            args = Array(length),
	            index = length,
	            placeholder = getHolder(wrapper);

	        while (index--) {
	          args[index] = arguments[index];
	        }
	        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
	          ? []
	          : replaceHolders(args, placeholder);

	        length -= holders.length;
	        if (length < arity) {
	          return createRecurry(
	            func, bitmask, createHybrid, wrapper.placeholder, undefined$1,
	            args, holders, undefined$1, undefined$1, arity - length);
	        }
	        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	        return apply(fn, this, args);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates a `_.find` or `_.findLast` function.
	     *
	     * @private
	     * @param {Function} findIndexFunc The function to find the collection index.
	     * @returns {Function} Returns the new find function.
	     */
	    function createFind(findIndexFunc) {
	      return function(collection, predicate, fromIndex) {
	        var iterable = Object(collection);
	        if (!isArrayLike(collection)) {
	          var iteratee = getIteratee(predicate, 3);
	          collection = keys(collection);
	          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
	        }
	        var index = findIndexFunc(collection, predicate, fromIndex);
	        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined$1;
	      };
	    }

	    /**
	     * Creates a `_.flow` or `_.flowRight` function.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new flow function.
	     */
	    function createFlow(fromRight) {
	      return flatRest(function(funcs) {
	        var length = funcs.length,
	            index = length,
	            prereq = LodashWrapper.prototype.thru;

	        if (fromRight) {
	          funcs.reverse();
	        }
	        while (index--) {
	          var func = funcs[index];
	          if (typeof func != 'function') {
	            throw new TypeError(FUNC_ERROR_TEXT);
	          }
	          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
	            var wrapper = new LodashWrapper([], true);
	          }
	        }
	        index = wrapper ? index : length;
	        while (++index < length) {
	          func = funcs[index];

	          var funcName = getFuncName(func),
	              data = funcName == 'wrapper' ? getData(func) : undefined$1;

	          if (data && isLaziable(data[0]) &&
	                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
	                !data[4].length && data[9] == 1
	              ) {
	            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
	          } else {
	            wrapper = (func.length == 1 && isLaziable(func))
	              ? wrapper[funcName]()
	              : wrapper.thru(func);
	          }
	        }
	        return function() {
	          var args = arguments,
	              value = args[0];

	          if (wrapper && args.length == 1 && isArray(value)) {
	            return wrapper.plant(value).value();
	          }
	          var index = 0,
	              result = length ? funcs[index].apply(this, args) : value;

	          while (++index < length) {
	            result = funcs[index].call(this, result);
	          }
	          return result;
	        };
	      });
	    }

	    /**
	     * Creates a function that wraps `func` to invoke it with optional `this`
	     * binding of `thisArg`, partial application, and currying.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to prepend to those provided to
	     *  the new function.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [partialsRight] The arguments to append to those provided
	     *  to the new function.
	     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
	      var isAry = bitmask & WRAP_ARY_FLAG,
	          isBind = bitmask & WRAP_BIND_FLAG,
	          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
	          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
	          isFlip = bitmask & WRAP_FLIP_FLAG,
	          Ctor = isBindKey ? undefined$1 : createCtor(func);

	      function wrapper() {
	        var length = arguments.length,
	            args = Array(length),
	            index = length;

	        while (index--) {
	          args[index] = arguments[index];
	        }
	        if (isCurried) {
	          var placeholder = getHolder(wrapper),
	              holdersCount = countHolders(args, placeholder);
	        }
	        if (partials) {
	          args = composeArgs(args, partials, holders, isCurried);
	        }
	        if (partialsRight) {
	          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
	        }
	        length -= holdersCount;
	        if (isCurried && length < arity) {
	          var newHolders = replaceHolders(args, placeholder);
	          return createRecurry(
	            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
	            args, newHolders, argPos, ary, arity - length
	          );
	        }
	        var thisBinding = isBind ? thisArg : this,
	            fn = isBindKey ? thisBinding[func] : func;

	        length = args.length;
	        if (argPos) {
	          args = reorder(args, argPos);
	        } else if (isFlip && length > 1) {
	          args.reverse();
	        }
	        if (isAry && ary < length) {
	          args.length = ary;
	        }
	        if (this && this !== root && this instanceof wrapper) {
	          fn = Ctor || createCtor(fn);
	        }
	        return fn.apply(thisBinding, args);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates a function like `_.invertBy`.
	     *
	     * @private
	     * @param {Function} setter The function to set accumulator values.
	     * @param {Function} toIteratee The function to resolve iteratees.
	     * @returns {Function} Returns the new inverter function.
	     */
	    function createInverter(setter, toIteratee) {
	      return function(object, iteratee) {
	        return baseInverter(object, setter, toIteratee(iteratee), {});
	      };
	    }

	    /**
	     * Creates a function that performs a mathematical operation on two values.
	     *
	     * @private
	     * @param {Function} operator The function to perform the operation.
	     * @param {number} [defaultValue] The value used for `undefined` arguments.
	     * @returns {Function} Returns the new mathematical operation function.
	     */
	    function createMathOperation(operator, defaultValue) {
	      return function(value, other) {
	        var result;
	        if (value === undefined$1 && other === undefined$1) {
	          return defaultValue;
	        }
	        if (value !== undefined$1) {
	          result = value;
	        }
	        if (other !== undefined$1) {
	          if (result === undefined$1) {
	            return other;
	          }
	          if (typeof value == 'string' || typeof other == 'string') {
	            value = baseToString(value);
	            other = baseToString(other);
	          } else {
	            value = baseToNumber(value);
	            other = baseToNumber(other);
	          }
	          result = operator(value, other);
	        }
	        return result;
	      };
	    }

	    /**
	     * Creates a function like `_.over`.
	     *
	     * @private
	     * @param {Function} arrayFunc The function to iterate over iteratees.
	     * @returns {Function} Returns the new over function.
	     */
	    function createOver(arrayFunc) {
	      return flatRest(function(iteratees) {
	        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
	        return baseRest(function(args) {
	          var thisArg = this;
	          return arrayFunc(iteratees, function(iteratee) {
	            return apply(iteratee, thisArg, args);
	          });
	        });
	      });
	    }

	    /**
	     * Creates the padding for `string` based on `length`. The `chars` string
	     * is truncated if the number of characters exceeds `length`.
	     *
	     * @private
	     * @param {number} length The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padding for `string`.
	     */
	    function createPadding(length, chars) {
	      chars = chars === undefined$1 ? ' ' : baseToString(chars);

	      var charsLength = chars.length;
	      if (charsLength < 2) {
	        return charsLength ? baseRepeat(chars, length) : chars;
	      }
	      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
	      return hasUnicode(chars)
	        ? castSlice(stringToArray(result), 0, length).join('')
	        : result.slice(0, length);
	    }

	    /**
	     * Creates a function that wraps `func` to invoke it with the `this` binding
	     * of `thisArg` and `partials` prepended to the arguments it receives.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {Array} partials The arguments to prepend to those provided to
	     *  the new function.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createPartial(func, bitmask, thisArg, partials) {
	      var isBind = bitmask & WRAP_BIND_FLAG,
	          Ctor = createCtor(func);

	      function wrapper() {
	        var argsIndex = -1,
	            argsLength = arguments.length,
	            leftIndex = -1,
	            leftLength = partials.length,
	            args = Array(leftLength + argsLength),
	            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

	        while (++leftIndex < leftLength) {
	          args[leftIndex] = partials[leftIndex];
	        }
	        while (argsLength--) {
	          args[leftIndex++] = arguments[++argsIndex];
	        }
	        return apply(fn, isBind ? thisArg : this, args);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates a `_.range` or `_.rangeRight` function.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new range function.
	     */
	    function createRange(fromRight) {
	      return function(start, end, step) {
	        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
	          end = step = undefined$1;
	        }
	        // Ensure the sign of `-0` is preserved.
	        start = toFinite(start);
	        if (end === undefined$1) {
	          end = start;
	          start = 0;
	        } else {
	          end = toFinite(end);
	        }
	        step = step === undefined$1 ? (start < end ? 1 : -1) : toFinite(step);
	        return baseRange(start, end, step, fromRight);
	      };
	    }

	    /**
	     * Creates a function that performs a relational operation on two values.
	     *
	     * @private
	     * @param {Function} operator The function to perform the operation.
	     * @returns {Function} Returns the new relational operation function.
	     */
	    function createRelationalOperation(operator) {
	      return function(value, other) {
	        if (!(typeof value == 'string' && typeof other == 'string')) {
	          value = toNumber(value);
	          other = toNumber(other);
	        }
	        return operator(value, other);
	      };
	    }

	    /**
	     * Creates a function that wraps `func` to continue currying.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {Function} wrapFunc The function to create the `func` wrapper.
	     * @param {*} placeholder The placeholder value.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to prepend to those provided to
	     *  the new function.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
	      var isCurry = bitmask & WRAP_CURRY_FLAG,
	          newHolders = isCurry ? holders : undefined$1,
	          newHoldersRight = isCurry ? undefined$1 : holders,
	          newPartials = isCurry ? partials : undefined$1,
	          newPartialsRight = isCurry ? undefined$1 : partials;

	      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
	      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

	      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
	        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
	      }
	      var newData = [
	        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
	        newHoldersRight, argPos, ary, arity
	      ];

	      var result = wrapFunc.apply(undefined$1, newData);
	      if (isLaziable(func)) {
	        setData(result, newData);
	      }
	      result.placeholder = placeholder;
	      return setWrapToString(result, func, bitmask);
	    }

	    /**
	     * Creates a function like `_.round`.
	     *
	     * @private
	     * @param {string} methodName The name of the `Math` method to use when rounding.
	     * @returns {Function} Returns the new round function.
	     */
	    function createRound(methodName) {
	      var func = Math[methodName];
	      return function(number, precision) {
	        number = toNumber(number);
	        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
	        if (precision && nativeIsFinite(number)) {
	          // Shift with exponential notation to avoid floating-point issues.
	          // See [MDN](https://mdn.io/round#Examples) for more details.
	          var pair = (toString(number) + 'e').split('e'),
	              value = func(pair[0] + 'e' + (+pair[1] + precision));

	          pair = (toString(value) + 'e').split('e');
	          return +(pair[0] + 'e' + (+pair[1] - precision));
	        }
	        return func(number);
	      };
	    }

	    /**
	     * Creates a set object of `values`.
	     *
	     * @private
	     * @param {Array} values The values to add to the set.
	     * @returns {Object} Returns the new set.
	     */
	    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
	      return new Set(values);
	    };

	    /**
	     * Creates a `_.toPairs` or `_.toPairsIn` function.
	     *
	     * @private
	     * @param {Function} keysFunc The function to get the keys of a given object.
	     * @returns {Function} Returns the new pairs function.
	     */
	    function createToPairs(keysFunc) {
	      return function(object) {
	        var tag = getTag(object);
	        if (tag == mapTag) {
	          return mapToArray(object);
	        }
	        if (tag == setTag) {
	          return setToPairs(object);
	        }
	        return baseToPairs(object, keysFunc(object));
	      };
	    }

	    /**
	     * Creates a function that either curries or invokes `func` with optional
	     * `this` binding and partially applied arguments.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to wrap.
	     * @param {number} bitmask The bitmask flags.
	     *    1 - `_.bind`
	     *    2 - `_.bindKey`
	     *    4 - `_.curry` or `_.curryRight` of a bound function
	     *    8 - `_.curry`
	     *   16 - `_.curryRight`
	     *   32 - `_.partial`
	     *   64 - `_.partialRight`
	     *  128 - `_.rearg`
	     *  256 - `_.ary`
	     *  512 - `_.flip`
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to be partially applied.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
	      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
	      if (!isBindKey && typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var length = partials ? partials.length : 0;
	      if (!length) {
	        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
	        partials = holders = undefined$1;
	      }
	      ary = ary === undefined$1 ? ary : nativeMax(toInteger(ary), 0);
	      arity = arity === undefined$1 ? arity : toInteger(arity);
	      length -= holders ? holders.length : 0;

	      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
	        var partialsRight = partials,
	            holdersRight = holders;

	        partials = holders = undefined$1;
	      }
	      var data = isBindKey ? undefined$1 : getData(func);

	      var newData = [
	        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
	        argPos, ary, arity
	      ];

	      if (data) {
	        mergeData(newData, data);
	      }
	      func = newData[0];
	      bitmask = newData[1];
	      thisArg = newData[2];
	      partials = newData[3];
	      holders = newData[4];
	      arity = newData[9] = newData[9] === undefined$1
	        ? (isBindKey ? 0 : func.length)
	        : nativeMax(newData[9] - length, 0);

	      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
	        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
	      }
	      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
	        var result = createBind(func, bitmask, thisArg);
	      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
	        result = createCurry(func, bitmask, arity);
	      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
	        result = createPartial(func, bitmask, thisArg, partials);
	      } else {
	        result = createHybrid.apply(undefined$1, newData);
	      }
	      var setter = data ? baseSetData : setData;
	      return setWrapToString(setter(result, newData), func, bitmask);
	    }

	    /**
	     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
	     * of source objects to the destination object for all destination properties
	     * that resolve to `undefined`.
	     *
	     * @private
	     * @param {*} objValue The destination value.
	     * @param {*} srcValue The source value.
	     * @param {string} key The key of the property to assign.
	     * @param {Object} object The parent object of `objValue`.
	     * @returns {*} Returns the value to assign.
	     */
	    function customDefaultsAssignIn(objValue, srcValue, key, object) {
	      if (objValue === undefined$1 ||
	          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
	        return srcValue;
	      }
	      return objValue;
	    }

	    /**
	     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
	     * objects into destination objects that are passed thru.
	     *
	     * @private
	     * @param {*} objValue The destination value.
	     * @param {*} srcValue The source value.
	     * @param {string} key The key of the property to merge.
	     * @param {Object} object The parent object of `objValue`.
	     * @param {Object} source The parent object of `srcValue`.
	     * @param {Object} [stack] Tracks traversed source values and their merged
	     *  counterparts.
	     * @returns {*} Returns the value to assign.
	     */
	    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
	      if (isObject(objValue) && isObject(srcValue)) {
	        // Recursively merge objects and arrays (susceptible to call stack limits).
	        stack.set(srcValue, objValue);
	        baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
	        stack['delete'](srcValue);
	      }
	      return objValue;
	    }

	    /**
	     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
	     * objects.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @param {string} key The key of the property to inspect.
	     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
	     */
	    function customOmitClone(value) {
	      return isPlainObject(value) ? undefined$1 : value;
	    }

	    /**
	     * A specialized version of `baseIsEqualDeep` for arrays with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Array} array The array to compare.
	     * @param {Array} other The other array to compare.
	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Object} stack Tracks traversed `array` and `other` objects.
	     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	     */
	    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	          arrLength = array.length,
	          othLength = other.length;

	      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	        return false;
	      }
	      // Check that cyclic values are equal.
	      var arrStacked = stack.get(array);
	      var othStacked = stack.get(other);
	      if (arrStacked && othStacked) {
	        return arrStacked == other && othStacked == array;
	      }
	      var index = -1,
	          result = true,
	          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined$1;

	      stack.set(array, other);
	      stack.set(other, array);

	      // Ignore non-index properties.
	      while (++index < arrLength) {
	        var arrValue = array[index],
	            othValue = other[index];

	        if (customizer) {
	          var compared = isPartial
	            ? customizer(othValue, arrValue, index, other, array, stack)
	            : customizer(arrValue, othValue, index, array, other, stack);
	        }
	        if (compared !== undefined$1) {
	          if (compared) {
	            continue;
	          }
	          result = false;
	          break;
	        }
	        // Recursively compare arrays (susceptible to call stack limits).
	        if (seen) {
	          if (!arraySome(other, function(othValue, othIndex) {
	                if (!cacheHas(seen, othIndex) &&
	                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	                  return seen.push(othIndex);
	                }
	              })) {
	            result = false;
	            break;
	          }
	        } else if (!(
	              arrValue === othValue ||
	                equalFunc(arrValue, othValue, bitmask, customizer, stack)
	            )) {
	          result = false;
	          break;
	        }
	      }
	      stack['delete'](array);
	      stack['delete'](other);
	      return result;
	    }

	    /**
	     * A specialized version of `baseIsEqualDeep` for comparing objects of
	     * the same `toStringTag`.
	     *
	     * **Note:** This function only supports comparing values with tags of
	     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {string} tag The `toStringTag` of the objects to compare.
	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Object} stack Tracks traversed `object` and `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
	      switch (tag) {
	        case dataViewTag:
	          if ((object.byteLength != other.byteLength) ||
	              (object.byteOffset != other.byteOffset)) {
	            return false;
	          }
	          object = object.buffer;
	          other = other.buffer;

	        case arrayBufferTag:
	          if ((object.byteLength != other.byteLength) ||
	              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	            return false;
	          }
	          return true;

	        case boolTag:
	        case dateTag:
	        case numberTag:
	          // Coerce booleans to `1` or `0` and dates to milliseconds.
	          // Invalid dates are coerced to `NaN`.
	          return eq(+object, +other);

	        case errorTag:
	          return object.name == other.name && object.message == other.message;

	        case regexpTag:
	        case stringTag:
	          // Coerce regexes to strings and treat strings, primitives and objects,
	          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	          // for more details.
	          return object == (other + '');

	        case mapTag:
	          var convert = mapToArray;

	        case setTag:
	          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
	          convert || (convert = setToArray);

	          if (object.size != other.size && !isPartial) {
	            return false;
	          }
	          // Assume cyclic values are equal.
	          var stacked = stack.get(object);
	          if (stacked) {
	            return stacked == other;
	          }
	          bitmask |= COMPARE_UNORDERED_FLAG;

	          // Recursively compare objects (susceptible to call stack limits).
	          stack.set(object, other);
	          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	          stack['delete'](object);
	          return result;

	        case symbolTag:
	          if (symbolValueOf) {
	            return symbolValueOf.call(object) == symbolValueOf.call(other);
	          }
	      }
	      return false;
	    }

	    /**
	     * A specialized version of `baseIsEqualDeep` for objects with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Object} stack Tracks traversed `object` and `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	          objProps = getAllKeys(object),
	          objLength = objProps.length,
	          othProps = getAllKeys(other),
	          othLength = othProps.length;

	      if (objLength != othLength && !isPartial) {
	        return false;
	      }
	      var index = objLength;
	      while (index--) {
	        var key = objProps[index];
	        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
	          return false;
	        }
	      }
	      // Check that cyclic values are equal.
	      var objStacked = stack.get(object);
	      var othStacked = stack.get(other);
	      if (objStacked && othStacked) {
	        return objStacked == other && othStacked == object;
	      }
	      var result = true;
	      stack.set(object, other);
	      stack.set(other, object);

	      var skipCtor = isPartial;
	      while (++index < objLength) {
	        key = objProps[index];
	        var objValue = object[key],
	            othValue = other[key];

	        if (customizer) {
	          var compared = isPartial
	            ? customizer(othValue, objValue, key, other, object, stack)
	            : customizer(objValue, othValue, key, object, other, stack);
	        }
	        // Recursively compare objects (susceptible to call stack limits).
	        if (!(compared === undefined$1
	              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
	              : compared
	            )) {
	          result = false;
	          break;
	        }
	        skipCtor || (skipCtor = key == 'constructor');
	      }
	      if (result && !skipCtor) {
	        var objCtor = object.constructor,
	            othCtor = other.constructor;

	        // Non `Object` object instances with different constructors are not equal.
	        if (objCtor != othCtor &&
	            ('constructor' in object && 'constructor' in other) &&
	            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	          result = false;
	        }
	      }
	      stack['delete'](object);
	      stack['delete'](other);
	      return result;
	    }

	    /**
	     * A specialized version of `baseRest` which flattens the rest array.
	     *
	     * @private
	     * @param {Function} func The function to apply a rest parameter to.
	     * @returns {Function} Returns the new function.
	     */
	    function flatRest(func) {
	      return setToString(overRest(func, undefined$1, flatten), func + '');
	    }

	    /**
	     * Creates an array of own enumerable property names and symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names and symbols.
	     */
	    function getAllKeys(object) {
	      return baseGetAllKeys(object, keys, getSymbols);
	    }

	    /**
	     * Creates an array of own and inherited enumerable property names and
	     * symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names and symbols.
	     */
	    function getAllKeysIn(object) {
	      return baseGetAllKeys(object, keysIn, getSymbolsIn);
	    }

	    /**
	     * Gets metadata for `func`.
	     *
	     * @private
	     * @param {Function} func The function to query.
	     * @returns {*} Returns the metadata for `func`.
	     */
	    var getData = !metaMap ? noop : function(func) {
	      return metaMap.get(func);
	    };

	    /**
	     * Gets the name of `func`.
	     *
	     * @private
	     * @param {Function} func The function to query.
	     * @returns {string} Returns the function name.
	     */
	    function getFuncName(func) {
	      var result = (func.name + ''),
	          array = realNames[result],
	          length = hasOwnProperty.call(realNames, result) ? array.length : 0;

	      while (length--) {
	        var data = array[length],
	            otherFunc = data.func;
	        if (otherFunc == null || otherFunc == func) {
	          return data.name;
	        }
	      }
	      return result;
	    }

	    /**
	     * Gets the argument placeholder value for `func`.
	     *
	     * @private
	     * @param {Function} func The function to inspect.
	     * @returns {*} Returns the placeholder value.
	     */
	    function getHolder(func) {
	      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
	      return object.placeholder;
	    }

	    /**
	     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
	     * this function returns the custom method, otherwise it returns `baseIteratee`.
	     * If arguments are provided, the chosen function is invoked with them and
	     * its result is returned.
	     *
	     * @private
	     * @param {*} [value] The value to convert to an iteratee.
	     * @param {number} [arity] The arity of the created iteratee.
	     * @returns {Function} Returns the chosen function or its result.
	     */
	    function getIteratee() {
	      var result = lodash.iteratee || iteratee;
	      result = result === iteratee ? baseIteratee : result;
	      return arguments.length ? result(arguments[0], arguments[1]) : result;
	    }

	    /**
	     * Gets the data for `map`.
	     *
	     * @private
	     * @param {Object} map The map to query.
	     * @param {string} key The reference key.
	     * @returns {*} Returns the map data.
	     */
	    function getMapData(map, key) {
	      var data = map.__data__;
	      return isKeyable(key)
	        ? data[typeof key == 'string' ? 'string' : 'hash']
	        : data.map;
	    }

	    /**
	     * Gets the property names, values, and compare flags of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the match data of `object`.
	     */
	    function getMatchData(object) {
	      var result = keys(object),
	          length = result.length;

	      while (length--) {
	        var key = result[length],
	            value = object[key];

	        result[length] = [key, value, isStrictComparable(value)];
	      }
	      return result;
	    }

	    /**
	     * Gets the native function at `key` of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {string} key The key of the method to get.
	     * @returns {*} Returns the function if it's native, else `undefined`.
	     */
	    function getNative(object, key) {
	      var value = getValue(object, key);
	      return baseIsNative(value) ? value : undefined$1;
	    }

	    /**
	     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @returns {string} Returns the raw `toStringTag`.
	     */
	    function getRawTag(value) {
	      var isOwn = hasOwnProperty.call(value, symToStringTag),
	          tag = value[symToStringTag];

	      try {
	        value[symToStringTag] = undefined$1;
	        var unmasked = true;
	      } catch (e) {}

	      var result = nativeObjectToString.call(value);
	      if (unmasked) {
	        if (isOwn) {
	          value[symToStringTag] = tag;
	        } else {
	          delete value[symToStringTag];
	        }
	      }
	      return result;
	    }

	    /**
	     * Creates an array of the own enumerable symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of symbols.
	     */
	    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
	      if (object == null) {
	        return [];
	      }
	      object = Object(object);
	      return arrayFilter(nativeGetSymbols(object), function(symbol) {
	        return propertyIsEnumerable.call(object, symbol);
	      });
	    };

	    /**
	     * Creates an array of the own and inherited enumerable symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of symbols.
	     */
	    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
	      var result = [];
	      while (object) {
	        arrayPush(result, getSymbols(object));
	        object = getPrototype(object);
	      }
	      return result;
	    };

	    /**
	     * Gets the `toStringTag` of `value`.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @returns {string} Returns the `toStringTag`.
	     */
	    var getTag = baseGetTag;

	    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	        (Map && getTag(new Map) != mapTag) ||
	        (Promise && getTag(Promise.resolve()) != promiseTag) ||
	        (Set && getTag(new Set) != setTag) ||
	        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	      getTag = function(value) {
	        var result = baseGetTag(value),
	            Ctor = result == objectTag ? value.constructor : undefined$1,
	            ctorString = Ctor ? toSource(Ctor) : '';

	        if (ctorString) {
	          switch (ctorString) {
	            case dataViewCtorString: return dataViewTag;
	            case mapCtorString: return mapTag;
	            case promiseCtorString: return promiseTag;
	            case setCtorString: return setTag;
	            case weakMapCtorString: return weakMapTag;
	          }
	        }
	        return result;
	      };
	    }

	    /**
	     * Gets the view, applying any `transforms` to the `start` and `end` positions.
	     *
	     * @private
	     * @param {number} start The start of the view.
	     * @param {number} end The end of the view.
	     * @param {Array} transforms The transformations to apply to the view.
	     * @returns {Object} Returns an object containing the `start` and `end`
	     *  positions of the view.
	     */
	    function getView(start, end, transforms) {
	      var index = -1,
	          length = transforms.length;

	      while (++index < length) {
	        var data = transforms[index],
	            size = data.size;

	        switch (data.type) {
	          case 'drop':      start += size; break;
	          case 'dropRight': end -= size; break;
	          case 'take':      end = nativeMin(end, start + size); break;
	          case 'takeRight': start = nativeMax(start, end - size); break;
	        }
	      }
	      return { 'start': start, 'end': end };
	    }

	    /**
	     * Extracts wrapper details from the `source` body comment.
	     *
	     * @private
	     * @param {string} source The source to inspect.
	     * @returns {Array} Returns the wrapper details.
	     */
	    function getWrapDetails(source) {
	      var match = source.match(reWrapDetails);
	      return match ? match[1].split(reSplitDetails) : [];
	    }

	    /**
	     * Checks if `path` exists on `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @param {Function} hasFunc The function to check properties.
	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
	     */
	    function hasPath(object, path, hasFunc) {
	      path = castPath(path, object);

	      var index = -1,
	          length = path.length,
	          result = false;

	      while (++index < length) {
	        var key = toKey(path[index]);
	        if (!(result = object != null && hasFunc(object, key))) {
	          break;
	        }
	        object = object[key];
	      }
	      if (result || ++index != length) {
	        return result;
	      }
	      length = object == null ? 0 : object.length;
	      return !!length && isLength(length) && isIndex(key, length) &&
	        (isArray(object) || isArguments(object));
	    }

	    /**
	     * Initializes an array clone.
	     *
	     * @private
	     * @param {Array} array The array to clone.
	     * @returns {Array} Returns the initialized clone.
	     */
	    function initCloneArray(array) {
	      var length = array.length,
	          result = new array.constructor(length);

	      // Add properties assigned by `RegExp#exec`.
	      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
	        result.index = array.index;
	        result.input = array.input;
	      }
	      return result;
	    }

	    /**
	     * Initializes an object clone.
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @returns {Object} Returns the initialized clone.
	     */
	    function initCloneObject(object) {
	      return (typeof object.constructor == 'function' && !isPrototype(object))
	        ? baseCreate(getPrototype(object))
	        : {};
	    }

	    /**
	     * Initializes an object clone based on its `toStringTag`.
	     *
	     * **Note:** This function only supports cloning values with tags of
	     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @param {string} tag The `toStringTag` of the object to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the initialized clone.
	     */
	    function initCloneByTag(object, tag, isDeep) {
	      var Ctor = object.constructor;
	      switch (tag) {
	        case arrayBufferTag:
	          return cloneArrayBuffer(object);

	        case boolTag:
	        case dateTag:
	          return new Ctor(+object);

	        case dataViewTag:
	          return cloneDataView(object, isDeep);

	        case float32Tag: case float64Tag:
	        case int8Tag: case int16Tag: case int32Tag:
	        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
	          return cloneTypedArray(object, isDeep);

	        case mapTag:
	          return new Ctor;

	        case numberTag:
	        case stringTag:
	          return new Ctor(object);

	        case regexpTag:
	          return cloneRegExp(object);

	        case setTag:
	          return new Ctor;

	        case symbolTag:
	          return cloneSymbol(object);
	      }
	    }

	    /**
	     * Inserts wrapper `details` in a comment at the top of the `source` body.
	     *
	     * @private
	     * @param {string} source The source to modify.
	     * @returns {Array} details The details to insert.
	     * @returns {string} Returns the modified source.
	     */
	    function insertWrapDetails(source, details) {
	      var length = details.length;
	      if (!length) {
	        return source;
	      }
	      var lastIndex = length - 1;
	      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
	      details = details.join(length > 2 ? ', ' : ' ');
	      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
	    }

	    /**
	     * Checks if `value` is a flattenable `arguments` object or array.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
	     */
	    function isFlattenable(value) {
	      return isArray(value) || isArguments(value) ||
	        !!(spreadableSymbol && value && value[spreadableSymbol]);
	    }

	    /**
	     * Checks if `value` is a valid array-like index.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	     */
	    function isIndex(value, length) {
	      var type = typeof value;
	      length = length == null ? MAX_SAFE_INTEGER : length;

	      return !!length &&
	        (type == 'number' ||
	          (type != 'symbol' && reIsUint.test(value))) &&
	            (value > -1 && value % 1 == 0 && value < length);
	    }

	    /**
	     * Checks if the given arguments are from an iteratee call.
	     *
	     * @private
	     * @param {*} value The potential iteratee value argument.
	     * @param {*} index The potential iteratee index or key argument.
	     * @param {*} object The potential iteratee object argument.
	     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	     *  else `false`.
	     */
	    function isIterateeCall(value, index, object) {
	      if (!isObject(object)) {
	        return false;
	      }
	      var type = typeof index;
	      if (type == 'number'
	            ? (isArrayLike(object) && isIndex(index, object.length))
	            : (type == 'string' && index in object)
	          ) {
	        return eq(object[index], value);
	      }
	      return false;
	    }

	    /**
	     * Checks if `value` is a property name and not a property path.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @param {Object} [object] The object to query keys on.
	     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	     */
	    function isKey(value, object) {
	      if (isArray(value)) {
	        return false;
	      }
	      var type = typeof value;
	      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	          value == null || isSymbol(value)) {
	        return true;
	      }
	      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	        (object != null && value in Object(object));
	    }

	    /**
	     * Checks if `value` is suitable for use as unique object key.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	     */
	    function isKeyable(value) {
	      var type = typeof value;
	      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	        ? (value !== '__proto__')
	        : (value === null);
	    }

	    /**
	     * Checks if `func` has a lazy counterpart.
	     *
	     * @private
	     * @param {Function} func The function to check.
	     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
	     *  else `false`.
	     */
	    function isLaziable(func) {
	      var funcName = getFuncName(func),
	          other = lodash[funcName];

	      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
	        return false;
	      }
	      if (func === other) {
	        return true;
	      }
	      var data = getData(other);
	      return !!data && func === data[0];
	    }

	    /**
	     * Checks if `func` has its source masked.
	     *
	     * @private
	     * @param {Function} func The function to check.
	     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	     */
	    function isMasked(func) {
	      return !!maskSrcKey && (maskSrcKey in func);
	    }

	    /**
	     * Checks if `func` is capable of being masked.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
	     */
	    var isMaskable = coreJsData ? isFunction : stubFalse;

	    /**
	     * Checks if `value` is likely a prototype object.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	     */
	    function isPrototype(value) {
	      var Ctor = value && value.constructor,
	          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

	      return value === proto;
	    }

	    /**
	     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` if suitable for strict
	     *  equality comparisons, else `false`.
	     */
	    function isStrictComparable(value) {
	      return value === value && !isObject(value);
	    }

	    /**
	     * A specialized version of `matchesProperty` for source values suitable
	     * for strict equality comparisons, i.e. `===`.
	     *
	     * @private
	     * @param {string} key The key of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new spec function.
	     */
	    function matchesStrictComparable(key, srcValue) {
	      return function(object) {
	        if (object == null) {
	          return false;
	        }
	        return object[key] === srcValue &&
	          (srcValue !== undefined$1 || (key in Object(object)));
	      };
	    }

	    /**
	     * A specialized version of `_.memoize` which clears the memoized function's
	     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
	     *
	     * @private
	     * @param {Function} func The function to have its output memoized.
	     * @returns {Function} Returns the new memoized function.
	     */
	    function memoizeCapped(func) {
	      var result = memoize(func, function(key) {
	        if (cache.size === MAX_MEMOIZE_SIZE) {
	          cache.clear();
	        }
	        return key;
	      });

	      var cache = result.cache;
	      return result;
	    }

	    /**
	     * Merges the function metadata of `source` into `data`.
	     *
	     * Merging metadata reduces the number of wrappers used to invoke a function.
	     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
	     * may be applied regardless of execution order. Methods like `_.ary` and
	     * `_.rearg` modify function arguments, making the order in which they are
	     * executed important, preventing the merging of metadata. However, we make
	     * an exception for a safe combined case where curried functions have `_.ary`
	     * and or `_.rearg` applied.
	     *
	     * @private
	     * @param {Array} data The destination metadata.
	     * @param {Array} source The source metadata.
	     * @returns {Array} Returns `data`.
	     */
	    function mergeData(data, source) {
	      var bitmask = data[1],
	          srcBitmask = source[1],
	          newBitmask = bitmask | srcBitmask,
	          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

	      var isCombo =
	        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
	        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
	        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

	      // Exit early if metadata can't be merged.
	      if (!(isCommon || isCombo)) {
	        return data;
	      }
	      // Use source `thisArg` if available.
	      if (srcBitmask & WRAP_BIND_FLAG) {
	        data[2] = source[2];
	        // Set when currying a bound function.
	        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
	      }
	      // Compose partial arguments.
	      var value = source[3];
	      if (value) {
	        var partials = data[3];
	        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
	        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
	      }
	      // Compose partial right arguments.
	      value = source[5];
	      if (value) {
	        partials = data[5];
	        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
	        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
	      }
	      // Use source `argPos` if available.
	      value = source[7];
	      if (value) {
	        data[7] = value;
	      }
	      // Use source `ary` if it's smaller.
	      if (srcBitmask & WRAP_ARY_FLAG) {
	        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
	      }
	      // Use source `arity` if one is not provided.
	      if (data[9] == null) {
	        data[9] = source[9];
	      }
	      // Use source `func` and merge bitmasks.
	      data[0] = source[0];
	      data[1] = newBitmask;

	      return data;
	    }

	    /**
	     * This function is like
	     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	     * except that it includes inherited enumerable properties.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */
	    function nativeKeysIn(object) {
	      var result = [];
	      if (object != null) {
	        for (var key in Object(object)) {
	          result.push(key);
	        }
	      }
	      return result;
	    }

	    /**
	     * Converts `value` to a string using `Object.prototype.toString`.
	     *
	     * @private
	     * @param {*} value The value to convert.
	     * @returns {string} Returns the converted string.
	     */
	    function objectToString(value) {
	      return nativeObjectToString.call(value);
	    }

	    /**
	     * A specialized version of `baseRest` which transforms the rest array.
	     *
	     * @private
	     * @param {Function} func The function to apply a rest parameter to.
	     * @param {number} [start=func.length-1] The start position of the rest parameter.
	     * @param {Function} transform The rest array transform.
	     * @returns {Function} Returns the new function.
	     */
	    function overRest(func, start, transform) {
	      start = nativeMax(start === undefined$1 ? (func.length - 1) : start, 0);
	      return function() {
	        var args = arguments,
	            index = -1,
	            length = nativeMax(args.length - start, 0),
	            array = Array(length);

	        while (++index < length) {
	          array[index] = args[start + index];
	        }
	        index = -1;
	        var otherArgs = Array(start + 1);
	        while (++index < start) {
	          otherArgs[index] = args[index];
	        }
	        otherArgs[start] = transform(array);
	        return apply(func, this, otherArgs);
	      };
	    }

	    /**
	     * Gets the parent value at `path` of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array} path The path to get the parent value of.
	     * @returns {*} Returns the parent value.
	     */
	    function parent(object, path) {
	      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
	    }

	    /**
	     * Reorder `array` according to the specified indexes where the element at
	     * the first index is assigned as the first element, the element at
	     * the second index is assigned as the second element, and so on.
	     *
	     * @private
	     * @param {Array} array The array to reorder.
	     * @param {Array} indexes The arranged array indexes.
	     * @returns {Array} Returns `array`.
	     */
	    function reorder(array, indexes) {
	      var arrLength = array.length,
	          length = nativeMin(indexes.length, arrLength),
	          oldArray = copyArray(array);

	      while (length--) {
	        var index = indexes[length];
	        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined$1;
	      }
	      return array;
	    }

	    /**
	     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {string} key The key of the property to get.
	     * @returns {*} Returns the property value.
	     */
	    function safeGet(object, key) {
	      if (key === 'constructor' && typeof object[key] === 'function') {
	        return;
	      }

	      if (key == '__proto__') {
	        return;
	      }

	      return object[key];
	    }

	    /**
	     * Sets metadata for `func`.
	     *
	     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
	     * period of time, it will trip its breaker and transition to an identity
	     * function to avoid garbage collection pauses in V8. See
	     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
	     * for more details.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */
	    var setData = shortOut(baseSetData);

	    /**
	     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
	     *
	     * @private
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @returns {number|Object} Returns the timer id or timeout object.
	     */
	    var setTimeout = ctxSetTimeout || function(func, wait) {
	      return root.setTimeout(func, wait);
	    };

	    /**
	     * Sets the `toString` method of `func` to return `string`.
	     *
	     * @private
	     * @param {Function} func The function to modify.
	     * @param {Function} string The `toString` result.
	     * @returns {Function} Returns `func`.
	     */
	    var setToString = shortOut(baseSetToString);

	    /**
	     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
	     * with wrapper details in a comment at the top of the source body.
	     *
	     * @private
	     * @param {Function} wrapper The function to modify.
	     * @param {Function} reference The reference function.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @returns {Function} Returns `wrapper`.
	     */
	    function setWrapToString(wrapper, reference, bitmask) {
	      var source = (reference + '');
	      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
	    }

	    /**
	     * Creates a function that'll short out and invoke `identity` instead
	     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	     * milliseconds.
	     *
	     * @private
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new shortable function.
	     */
	    function shortOut(func) {
	      var count = 0,
	          lastCalled = 0;

	      return function() {
	        var stamp = nativeNow(),
	            remaining = HOT_SPAN - (stamp - lastCalled);

	        lastCalled = stamp;
	        if (remaining > 0) {
	          if (++count >= HOT_COUNT) {
	            return arguments[0];
	          }
	        } else {
	          count = 0;
	        }
	        return func.apply(undefined$1, arguments);
	      };
	    }

	    /**
	     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
	     *
	     * @private
	     * @param {Array} array The array to shuffle.
	     * @param {number} [size=array.length] The size of `array`.
	     * @returns {Array} Returns `array`.
	     */
	    function shuffleSelf(array, size) {
	      var index = -1,
	          length = array.length,
	          lastIndex = length - 1;

	      size = size === undefined$1 ? length : size;
	      while (++index < size) {
	        var rand = baseRandom(index, lastIndex),
	            value = array[rand];

	        array[rand] = array[index];
	        array[index] = value;
	      }
	      array.length = size;
	      return array;
	    }

	    /**
	     * Converts `string` to a property path array.
	     *
	     * @private
	     * @param {string} string The string to convert.
	     * @returns {Array} Returns the property path array.
	     */
	    var stringToPath = memoizeCapped(function(string) {
	      var result = [];
	      if (string.charCodeAt(0) === 46 /* . */) {
	        result.push('');
	      }
	      string.replace(rePropName, function(match, number, quote, subString) {
	        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
	      });
	      return result;
	    });

	    /**
	     * Converts `value` to a string key if it's not a string or symbol.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @returns {string|symbol} Returns the key.
	     */
	    function toKey(value) {
	      if (typeof value == 'string' || isSymbol(value)) {
	        return value;
	      }
	      var result = (value + '');
	      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	    }

	    /**
	     * Converts `func` to its source code.
	     *
	     * @private
	     * @param {Function} func The function to convert.
	     * @returns {string} Returns the source code.
	     */
	    function toSource(func) {
	      if (func != null) {
	        try {
	          return funcToString.call(func);
	        } catch (e) {}
	        try {
	          return (func + '');
	        } catch (e) {}
	      }
	      return '';
	    }

	    /**
	     * Updates wrapper `details` based on `bitmask` flags.
	     *
	     * @private
	     * @returns {Array} details The details to modify.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @returns {Array} Returns `details`.
	     */
	    function updateWrapDetails(details, bitmask) {
	      arrayEach(wrapFlags, function(pair) {
	        var value = '_.' + pair[0];
	        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
	          details.push(value);
	        }
	      });
	      return details.sort();
	    }

	    /**
	     * Creates a clone of `wrapper`.
	     *
	     * @private
	     * @param {Object} wrapper The wrapper to clone.
	     * @returns {Object} Returns the cloned wrapper.
	     */
	    function wrapperClone(wrapper) {
	      if (wrapper instanceof LazyWrapper) {
	        return wrapper.clone();
	      }
	      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
	      result.__actions__ = copyArray(wrapper.__actions__);
	      result.__index__  = wrapper.__index__;
	      result.__values__ = wrapper.__values__;
	      return result;
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates an array of elements split into groups the length of `size`.
	     * If `array` can't be split evenly, the final chunk will be the remaining
	     * elements.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to process.
	     * @param {number} [size=1] The length of each chunk
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the new array of chunks.
	     * @example
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 2);
	     * // => [['a', 'b'], ['c', 'd']]
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 3);
	     * // => [['a', 'b', 'c'], ['d']]
	     */
	    function chunk(array, size, guard) {
	      if ((guard ? isIterateeCall(array, size, guard) : size === undefined$1)) {
	        size = 1;
	      } else {
	        size = nativeMax(toInteger(size), 0);
	      }
	      var length = array == null ? 0 : array.length;
	      if (!length || size < 1) {
	        return [];
	      }
	      var index = 0,
	          resIndex = 0,
	          result = Array(nativeCeil(length / size));

	      while (index < length) {
	        result[resIndex++] = baseSlice(array, index, (index += size));
	      }
	      return result;
	    }

	    /**
	     * Creates an array with all falsey values removed. The values `false`, `null`,
	     * `0`, `""`, `undefined`, and `NaN` are falsey.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to compact.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.compact([0, 1, false, 2, '', 3]);
	     * // => [1, 2, 3]
	     */
	    function compact(array) {
	      var index = -1,
	          length = array == null ? 0 : array.length,
	          resIndex = 0,
	          result = [];

	      while (++index < length) {
	        var value = array[index];
	        if (value) {
	          result[resIndex++] = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * Creates a new array concatenating `array` with any additional arrays
	     * and/or values.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to concatenate.
	     * @param {...*} [values] The values to concatenate.
	     * @returns {Array} Returns the new concatenated array.
	     * @example
	     *
	     * var array = [1];
	     * var other = _.concat(array, 2, [3], [[4]]);
	     *
	     * console.log(other);
	     * // => [1, 2, 3, [4]]
	     *
	     * console.log(array);
	     * // => [1]
	     */
	    function concat() {
	      var length = arguments.length;
	      if (!length) {
	        return [];
	      }
	      var args = Array(length - 1),
	          array = arguments[0],
	          index = length;

	      while (index--) {
	        args[index - 1] = arguments[index];
	      }
	      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
	    }

	    /**
	     * Creates an array of `array` values not included in the other given arrays
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons. The order and references of result values are
	     * determined by the first array.
	     *
	     * **Note:** Unlike `_.pullAll`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @see _.without, _.xor
	     * @example
	     *
	     * _.difference([2, 1], [2, 3]);
	     * // => [1]
	     */
	    var difference = baseRest(function(array, values) {
	      return isArrayLikeObject(array)
	        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
	        : [];
	    });

	    /**
	     * This method is like `_.difference` except that it accepts `iteratee` which
	     * is invoked for each element of `array` and `values` to generate the criterion
	     * by which they're compared. The order and references of result values are
	     * determined by the first array. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The values to exclude.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
	     * // => [1.2]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
	     * // => [{ 'x': 2 }]
	     */
	    var differenceBy = baseRest(function(array, values) {
	      var iteratee = last(values);
	      if (isArrayLikeObject(iteratee)) {
	        iteratee = undefined$1;
	      }
	      return isArrayLikeObject(array)
	        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
	        : [];
	    });

	    /**
	     * This method is like `_.difference` except that it accepts `comparator`
	     * which is invoked to compare elements of `array` to `values`. The order and
	     * references of result values are determined by the first array. The comparator
	     * is invoked with two arguments: (arrVal, othVal).
	     *
	     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The values to exclude.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     *
	     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
	     * // => [{ 'x': 2, 'y': 1 }]
	     */
	    var differenceWith = baseRest(function(array, values) {
	      var comparator = last(values);
	      if (isArrayLikeObject(comparator)) {
	        comparator = undefined$1;
	      }
	      return isArrayLikeObject(array)
	        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined$1, comparator)
	        : [];
	    });

	    /**
	     * Creates a slice of `array` with `n` elements dropped from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.5.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.drop([1, 2, 3]);
	     * // => [2, 3]
	     *
	     * _.drop([1, 2, 3], 2);
	     * // => [3]
	     *
	     * _.drop([1, 2, 3], 5);
	     * // => []
	     *
	     * _.drop([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */
	    function drop(array, n, guard) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      n = (guard || n === undefined$1) ? 1 : toInteger(n);
	      return baseSlice(array, n < 0 ? 0 : n, length);
	    }

	    /**
	     * Creates a slice of `array` with `n` elements dropped from the end.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.dropRight([1, 2, 3]);
	     * // => [1, 2]
	     *
	     * _.dropRight([1, 2, 3], 2);
	     * // => [1]
	     *
	     * _.dropRight([1, 2, 3], 5);
	     * // => []
	     *
	     * _.dropRight([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */
	    function dropRight(array, n, guard) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      n = (guard || n === undefined$1) ? 1 : toInteger(n);
	      n = length - n;
	      return baseSlice(array, 0, n < 0 ? 0 : n);
	    }

	    /**
	     * Creates a slice of `array` excluding elements dropped from the end.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * invoked with three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.dropRightWhile(users, function(o) { return !o.active; });
	     * // => objects for ['barney']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
	     * // => objects for ['barney', 'fred']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.dropRightWhile(users, ['active', false]);
	     * // => objects for ['barney']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.dropRightWhile(users, 'active');
	     * // => objects for ['barney', 'fred', 'pebbles']
	     */
	    function dropRightWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3), true, true)
	        : [];
	    }

	    /**
	     * Creates a slice of `array` excluding elements dropped from the beginning.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * invoked with three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.dropWhile(users, function(o) { return !o.active; });
	     * // => objects for ['pebbles']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.dropWhile(users, { 'user': 'barney', 'active': false });
	     * // => objects for ['fred', 'pebbles']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.dropWhile(users, ['active', false]);
	     * // => objects for ['pebbles']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.dropWhile(users, 'active');
	     * // => objects for ['barney', 'fred', 'pebbles']
	     */
	    function dropWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3), true)
	        : [];
	    }

	    /**
	     * Fills elements of `array` with `value` from `start` up to, but not
	     * including, `end`.
	     *
	     * **Note:** This method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.2.0
	     * @category Array
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _.fill(array, 'a');
	     * console.log(array);
	     * // => ['a', 'a', 'a']
	     *
	     * _.fill(Array(3), 2);
	     * // => [2, 2, 2]
	     *
	     * _.fill([4, 6, 8, 10], '*', 1, 3);
	     * // => [4, '*', '*', 10]
	     */
	    function fill(array, value, start, end) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
	        start = 0;
	        end = length;
	      }
	      return baseFill(array, value, start, end);
	    }

	    /**
	     * This method is like `_.find` except that it returns the index of the first
	     * element `predicate` returns truthy for instead of the element itself.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.findIndex(users, function(o) { return o.user == 'barney'; });
	     * // => 0
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findIndex(users, { 'user': 'fred', 'active': false });
	     * // => 1
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findIndex(users, ['active', false]);
	     * // => 0
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findIndex(users, 'active');
	     * // => 2
	     */
	    function findIndex(array, predicate, fromIndex) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return -1;
	      }
	      var index = fromIndex == null ? 0 : toInteger(fromIndex);
	      if (index < 0) {
	        index = nativeMax(length + index, 0);
	      }
	      return baseFindIndex(array, getIteratee(predicate, 3), index);
	    }

	    /**
	     * This method is like `_.findIndex` except that it iterates over elements
	     * of `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=array.length-1] The index to search from.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
	     * // => 2
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
	     * // => 0
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findLastIndex(users, ['active', false]);
	     * // => 2
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findLastIndex(users, 'active');
	     * // => 0
	     */
	    function findLastIndex(array, predicate, fromIndex) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return -1;
	      }
	      var index = length - 1;
	      if (fromIndex !== undefined$1) {
	        index = toInteger(fromIndex);
	        index = fromIndex < 0
	          ? nativeMax(length + index, 0)
	          : nativeMin(index, length - 1);
	      }
	      return baseFindIndex(array, getIteratee(predicate, 3), index, true);
	    }

	    /**
	     * Flattens `array` a single level deep.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flatten([1, [2, [3, [4]], 5]]);
	     * // => [1, 2, [3, [4]], 5]
	     */
	    function flatten(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? baseFlatten(array, 1) : [];
	    }

	    /**
	     * Recursively flattens `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flattenDeep([1, [2, [3, [4]], 5]]);
	     * // => [1, 2, 3, 4, 5]
	     */
	    function flattenDeep(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? baseFlatten(array, INFINITY) : [];
	    }

	    /**
	     * Recursively flatten `array` up to `depth` times.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.4.0
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @param {number} [depth=1] The maximum recursion depth.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * var array = [1, [2, [3, [4]], 5]];
	     *
	     * _.flattenDepth(array, 1);
	     * // => [1, 2, [3, [4]], 5]
	     *
	     * _.flattenDepth(array, 2);
	     * // => [1, 2, 3, [4], 5]
	     */
	    function flattenDepth(array, depth) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      depth = depth === undefined$1 ? 1 : toInteger(depth);
	      return baseFlatten(array, depth);
	    }

	    /**
	     * The inverse of `_.toPairs`; this method returns an object composed
	     * from key-value `pairs`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} pairs The key-value pairs.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.fromPairs([['a', 1], ['b', 2]]);
	     * // => { 'a': 1, 'b': 2 }
	     */
	    function fromPairs(pairs) {
	      var index = -1,
	          length = pairs == null ? 0 : pairs.length,
	          result = {};

	      while (++index < length) {
	        var pair = pairs[index];
	        result[pair[0]] = pair[1];
	      }
	      return result;
	    }

	    /**
	     * Gets the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @alias first
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the first element of `array`.
	     * @example
	     *
	     * _.head([1, 2, 3]);
	     * // => 1
	     *
	     * _.head([]);
	     * // => undefined
	     */
	    function head(array) {
	      return (array && array.length) ? array[0] : undefined$1;
	    }

	    /**
	     * Gets the index at which the first occurrence of `value` is found in `array`
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons. If `fromIndex` is negative, it's used as the
	     * offset from the end of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.indexOf([1, 2, 1, 2], 2);
	     * // => 1
	     *
	     * // Search from the `fromIndex`.
	     * _.indexOf([1, 2, 1, 2], 2, 2);
	     * // => 3
	     */
	    function indexOf(array, value, fromIndex) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return -1;
	      }
	      var index = fromIndex == null ? 0 : toInteger(fromIndex);
	      if (index < 0) {
	        index = nativeMax(length + index, 0);
	      }
	      return baseIndexOf(array, value, index);
	    }

	    /**
	     * Gets all but the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.initial([1, 2, 3]);
	     * // => [1, 2]
	     */
	    function initial(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? baseSlice(array, 0, -1) : [];
	    }

	    /**
	     * Creates an array of unique values that are included in all given arrays
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons. The order and references of result values are
	     * determined by the first array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of intersecting values.
	     * @example
	     *
	     * _.intersection([2, 1], [2, 3]);
	     * // => [2]
	     */
	    var intersection = baseRest(function(arrays) {
	      var mapped = arrayMap(arrays, castArrayLikeObject);
	      return (mapped.length && mapped[0] === arrays[0])
	        ? baseIntersection(mapped)
	        : [];
	    });

	    /**
	     * This method is like `_.intersection` except that it accepts `iteratee`
	     * which is invoked for each element of each `arrays` to generate the criterion
	     * by which they're compared. The order and references of result values are
	     * determined by the first array. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of intersecting values.
	     * @example
	     *
	     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
	     * // => [2.1]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }]
	     */
	    var intersectionBy = baseRest(function(arrays) {
	      var iteratee = last(arrays),
	          mapped = arrayMap(arrays, castArrayLikeObject);

	      if (iteratee === last(mapped)) {
	        iteratee = undefined$1;
	      } else {
	        mapped.pop();
	      }
	      return (mapped.length && mapped[0] === arrays[0])
	        ? baseIntersection(mapped, getIteratee(iteratee, 2))
	        : [];
	    });

	    /**
	     * This method is like `_.intersection` except that it accepts `comparator`
	     * which is invoked to compare elements of `arrays`. The order and references
	     * of result values are determined by the first array. The comparator is
	     * invoked with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of intersecting values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.intersectionWith(objects, others, _.isEqual);
	     * // => [{ 'x': 1, 'y': 2 }]
	     */
	    var intersectionWith = baseRest(function(arrays) {
	      var comparator = last(arrays),
	          mapped = arrayMap(arrays, castArrayLikeObject);

	      comparator = typeof comparator == 'function' ? comparator : undefined$1;
	      if (comparator) {
	        mapped.pop();
	      }
	      return (mapped.length && mapped[0] === arrays[0])
	        ? baseIntersection(mapped, undefined$1, comparator)
	        : [];
	    });

	    /**
	     * Converts all elements in `array` into a string separated by `separator`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to convert.
	     * @param {string} [separator=','] The element separator.
	     * @returns {string} Returns the joined string.
	     * @example
	     *
	     * _.join(['a', 'b', 'c'], '~');
	     * // => 'a~b~c'
	     */
	    function join(array, separator) {
	      return array == null ? '' : nativeJoin.call(array, separator);
	    }

	    /**
	     * Gets the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the last element of `array`.
	     * @example
	     *
	     * _.last([1, 2, 3]);
	     * // => 3
	     */
	    function last(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? array[length - 1] : undefined$1;
	    }

	    /**
	     * This method is like `_.indexOf` except that it iterates over elements of
	     * `array` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=array.length-1] The index to search from.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.lastIndexOf([1, 2, 1, 2], 2);
	     * // => 3
	     *
	     * // Search from the `fromIndex`.
	     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
	     * // => 1
	     */
	    function lastIndexOf(array, value, fromIndex) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return -1;
	      }
	      var index = length;
	      if (fromIndex !== undefined$1) {
	        index = toInteger(fromIndex);
	        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
	      }
	      return value === value
	        ? strictLastIndexOf(array, value, index)
	        : baseFindIndex(array, baseIsNaN, index, true);
	    }

	    /**
	     * Gets the element at index `n` of `array`. If `n` is negative, the nth
	     * element from the end is returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.11.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=0] The index of the element to return.
	     * @returns {*} Returns the nth element of `array`.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'd'];
	     *
	     * _.nth(array, 1);
	     * // => 'b'
	     *
	     * _.nth(array, -2);
	     * // => 'c';
	     */
	    function nth(array, n) {
	      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined$1;
	    }

	    /**
	     * Removes all given values from `array` using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
	     * to remove elements from an array by predicate.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...*} [values] The values to remove.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
	     *
	     * _.pull(array, 'a', 'c');
	     * console.log(array);
	     * // => ['b', 'b']
	     */
	    var pull = baseRest(pullAll);

	    /**
	     * This method is like `_.pull` except that it accepts an array of values to remove.
	     *
	     * **Note:** Unlike `_.difference`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
	     *
	     * _.pullAll(array, ['a', 'c']);
	     * console.log(array);
	     * // => ['b', 'b']
	     */
	    function pullAll(array, values) {
	      return (array && array.length && values && values.length)
	        ? basePullAll(array, values)
	        : array;
	    }

	    /**
	     * This method is like `_.pullAll` except that it accepts `iteratee` which is
	     * invoked for each element of `array` and `values` to generate the criterion
	     * by which they're compared. The iteratee is invoked with one argument: (value).
	     *
	     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
	     *
	     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
	     * console.log(array);
	     * // => [{ 'x': 2 }]
	     */
	    function pullAllBy(array, values, iteratee) {
	      return (array && array.length && values && values.length)
	        ? basePullAll(array, values, getIteratee(iteratee, 2))
	        : array;
	    }

	    /**
	     * This method is like `_.pullAll` except that it accepts `comparator` which
	     * is invoked to compare elements of `array` to `values`. The comparator is
	     * invoked with two arguments: (arrVal, othVal).
	     *
	     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.6.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
	     *
	     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
	     * console.log(array);
	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
	     */
	    function pullAllWith(array, values, comparator) {
	      return (array && array.length && values && values.length)
	        ? basePullAll(array, values, undefined$1, comparator)
	        : array;
	    }

	    /**
	     * Removes elements from `array` corresponding to `indexes` and returns an
	     * array of removed elements.
	     *
	     * **Note:** Unlike `_.at`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'd'];
	     * var pulled = _.pullAt(array, [1, 3]);
	     *
	     * console.log(array);
	     * // => ['a', 'c']
	     *
	     * console.log(pulled);
	     * // => ['b', 'd']
	     */
	    var pullAt = flatRest(function(array, indexes) {
	      var length = array == null ? 0 : array.length,
	          result = baseAt(array, indexes);

	      basePullAt(array, arrayMap(indexes, function(index) {
	        return isIndex(index, length) ? +index : index;
	      }).sort(compareAscending));

	      return result;
	    });

	    /**
	     * Removes all elements from `array` that `predicate` returns truthy for
	     * and returns an array of the removed elements. The predicate is invoked
	     * with three arguments: (value, index, array).
	     *
	     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
	     * to pull elements from an array by value.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = [1, 2, 3, 4];
	     * var evens = _.remove(array, function(n) {
	     *   return n % 2 == 0;
	     * });
	     *
	     * console.log(array);
	     * // => [1, 3]
	     *
	     * console.log(evens);
	     * // => [2, 4]
	     */
	    function remove(array, predicate) {
	      var result = [];
	      if (!(array && array.length)) {
	        return result;
	      }
	      var index = -1,
	          indexes = [],
	          length = array.length;

	      predicate = getIteratee(predicate, 3);
	      while (++index < length) {
	        var value = array[index];
	        if (predicate(value, index, array)) {
	          result.push(value);
	          indexes.push(index);
	        }
	      }
	      basePullAt(array, indexes);
	      return result;
	    }

	    /**
	     * Reverses `array` so that the first element becomes the last, the second
	     * element becomes the second to last, and so on.
	     *
	     * **Note:** This method mutates `array` and is based on
	     * [`Array#reverse`](https://mdn.io/Array/reverse).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _.reverse(array);
	     * // => [3, 2, 1]
	     *
	     * console.log(array);
	     * // => [3, 2, 1]
	     */
	    function reverse(array) {
	      return array == null ? array : nativeReverse.call(array);
	    }

	    /**
	     * Creates a slice of `array` from `start` up to, but not including, `end`.
	     *
	     * **Note:** This method is used instead of
	     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
	     * returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function slice(array, start, end) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
	        start = 0;
	        end = length;
	      }
	      else {
	        start = start == null ? 0 : toInteger(start);
	        end = end === undefined$1 ? length : toInteger(end);
	      }
	      return baseSlice(array, start, end);
	    }

	    /**
	     * Uses a binary search to determine the lowest index at which `value`
	     * should be inserted into `array` in order to maintain its sort order.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedIndex([30, 50], 40);
	     * // => 1
	     */
	    function sortedIndex(array, value) {
	      return baseSortedIndex(array, value);
	    }

	    /**
	     * This method is like `_.sortedIndex` except that it accepts `iteratee`
	     * which is invoked for `value` and each element of `array` to compute their
	     * sort ranking. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * var objects = [{ 'x': 4 }, { 'x': 5 }];
	     *
	     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
	     * // => 0
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
	     * // => 0
	     */
	    function sortedIndexBy(array, value, iteratee) {
	      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
	    }

	    /**
	     * This method is like `_.indexOf` except that it performs a binary
	     * search on a sorted `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
	     * // => 1
	     */
	    function sortedIndexOf(array, value) {
	      var length = array == null ? 0 : array.length;
	      if (length) {
	        var index = baseSortedIndex(array, value);
	        if (index < length && eq(array[index], value)) {
	          return index;
	        }
	      }
	      return -1;
	    }

	    /**
	     * This method is like `_.sortedIndex` except that it returns the highest
	     * index at which `value` should be inserted into `array` in order to
	     * maintain its sort order.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
	     * // => 4
	     */
	    function sortedLastIndex(array, value) {
	      return baseSortedIndex(array, value, true);
	    }

	    /**
	     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
	     * which is invoked for `value` and each element of `array` to compute their
	     * sort ranking. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * var objects = [{ 'x': 4 }, { 'x': 5 }];
	     *
	     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
	     * // => 1
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
	     * // => 1
	     */
	    function sortedLastIndexBy(array, value, iteratee) {
	      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
	    }

	    /**
	     * This method is like `_.lastIndexOf` except that it performs a binary
	     * search on a sorted `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
	     * // => 3
	     */
	    function sortedLastIndexOf(array, value) {
	      var length = array == null ? 0 : array.length;
	      if (length) {
	        var index = baseSortedIndex(array, value, true) - 1;
	        if (eq(array[index], value)) {
	          return index;
	        }
	      }
	      return -1;
	    }

	    /**
	     * This method is like `_.uniq` except that it's designed and optimized
	     * for sorted arrays.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.sortedUniq([1, 1, 2]);
	     * // => [1, 2]
	     */
	    function sortedUniq(array) {
	      return (array && array.length)
	        ? baseSortedUniq(array)
	        : [];
	    }

	    /**
	     * This method is like `_.uniqBy` except that it's designed and optimized
	     * for sorted arrays.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
	     * // => [1.1, 2.3]
	     */
	    function sortedUniqBy(array, iteratee) {
	      return (array && array.length)
	        ? baseSortedUniq(array, getIteratee(iteratee, 2))
	        : [];
	    }

	    /**
	     * Gets all but the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.tail([1, 2, 3]);
	     * // => [2, 3]
	     */
	    function tail(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? baseSlice(array, 1, length) : [];
	    }

	    /**
	     * Creates a slice of `array` with `n` elements taken from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.take([1, 2, 3]);
	     * // => [1]
	     *
	     * _.take([1, 2, 3], 2);
	     * // => [1, 2]
	     *
	     * _.take([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.take([1, 2, 3], 0);
	     * // => []
	     */
	    function take(array, n, guard) {
	      if (!(array && array.length)) {
	        return [];
	      }
	      n = (guard || n === undefined$1) ? 1 : toInteger(n);
	      return baseSlice(array, 0, n < 0 ? 0 : n);
	    }

	    /**
	     * Creates a slice of `array` with `n` elements taken from the end.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.takeRight([1, 2, 3]);
	     * // => [3]
	     *
	     * _.takeRight([1, 2, 3], 2);
	     * // => [2, 3]
	     *
	     * _.takeRight([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.takeRight([1, 2, 3], 0);
	     * // => []
	     */
	    function takeRight(array, n, guard) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      n = (guard || n === undefined$1) ? 1 : toInteger(n);
	      n = length - n;
	      return baseSlice(array, n < 0 ? 0 : n, length);
	    }

	    /**
	     * Creates a slice of `array` with elements taken from the end. Elements are
	     * taken until `predicate` returns falsey. The predicate is invoked with
	     * three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.takeRightWhile(users, function(o) { return !o.active; });
	     * // => objects for ['fred', 'pebbles']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
	     * // => objects for ['pebbles']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.takeRightWhile(users, ['active', false]);
	     * // => objects for ['fred', 'pebbles']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.takeRightWhile(users, 'active');
	     * // => []
	     */
	    function takeRightWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3), false, true)
	        : [];
	    }

	    /**
	     * Creates a slice of `array` with elements taken from the beginning. Elements
	     * are taken until `predicate` returns falsey. The predicate is invoked with
	     * three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.takeWhile(users, function(o) { return !o.active; });
	     * // => objects for ['barney', 'fred']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.takeWhile(users, { 'user': 'barney', 'active': false });
	     * // => objects for ['barney']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.takeWhile(users, ['active', false]);
	     * // => objects for ['barney', 'fred']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.takeWhile(users, 'active');
	     * // => []
	     */
	    function takeWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3))
	        : [];
	    }

	    /**
	     * Creates an array of unique values, in order, from all given arrays using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * _.union([2], [1, 2]);
	     * // => [2, 1]
	     */
	    var union = baseRest(function(arrays) {
	      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
	    });

	    /**
	     * This method is like `_.union` except that it accepts `iteratee` which is
	     * invoked for each element of each `arrays` to generate the criterion by
	     * which uniqueness is computed. Result values are chosen from the first
	     * array in which the value occurs. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
	     * // => [2.1, 1.2]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }, { 'x': 2 }]
	     */
	    var unionBy = baseRest(function(arrays) {
	      var iteratee = last(arrays);
	      if (isArrayLikeObject(iteratee)) {
	        iteratee = undefined$1;
	      }
	      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
	    });

	    /**
	     * This method is like `_.union` except that it accepts `comparator` which
	     * is invoked to compare elements of `arrays`. Result values are chosen from
	     * the first array in which the value occurs. The comparator is invoked
	     * with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.unionWith(objects, others, _.isEqual);
	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
	     */
	    var unionWith = baseRest(function(arrays) {
	      var comparator = last(arrays);
	      comparator = typeof comparator == 'function' ? comparator : undefined$1;
	      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
	    });

	    /**
	     * Creates a duplicate-free version of an array, using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons, in which only the first occurrence of each element
	     * is kept. The order of result values is determined by the order they occur
	     * in the array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.uniq([2, 1, 2]);
	     * // => [2, 1]
	     */
	    function uniq(array) {
	      return (array && array.length) ? baseUniq(array) : [];
	    }

	    /**
	     * This method is like `_.uniq` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the criterion by which
	     * uniqueness is computed. The order of result values is determined by the
	     * order they occur in the array. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
	     * // => [2.1, 1.2]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }, { 'x': 2 }]
	     */
	    function uniqBy(array, iteratee) {
	      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
	    }

	    /**
	     * This method is like `_.uniq` except that it accepts `comparator` which
	     * is invoked to compare elements of `array`. The order of result values is
	     * determined by the order they occur in the array.The comparator is invoked
	     * with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.uniqWith(objects, _.isEqual);
	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
	     */
	    function uniqWith(array, comparator) {
	      comparator = typeof comparator == 'function' ? comparator : undefined$1;
	      return (array && array.length) ? baseUniq(array, undefined$1, comparator) : [];
	    }

	    /**
	     * This method is like `_.zip` except that it accepts an array of grouped
	     * elements and creates an array regrouping the elements to their pre-zip
	     * configuration.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.2.0
	     * @category Array
	     * @param {Array} array The array of grouped elements to process.
	     * @returns {Array} Returns the new array of regrouped elements.
	     * @example
	     *
	     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
	     * // => [['a', 1, true], ['b', 2, false]]
	     *
	     * _.unzip(zipped);
	     * // => [['a', 'b'], [1, 2], [true, false]]
	     */
	    function unzip(array) {
	      if (!(array && array.length)) {
	        return [];
	      }
	      var length = 0;
	      array = arrayFilter(array, function(group) {
	        if (isArrayLikeObject(group)) {
	          length = nativeMax(group.length, length);
	          return true;
	        }
	      });
	      return baseTimes(length, function(index) {
	        return arrayMap(array, baseProperty(index));
	      });
	    }

	    /**
	     * This method is like `_.unzip` except that it accepts `iteratee` to specify
	     * how regrouped values should be combined. The iteratee is invoked with the
	     * elements of each group: (...group).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.8.0
	     * @category Array
	     * @param {Array} array The array of grouped elements to process.
	     * @param {Function} [iteratee=_.identity] The function to combine
	     *  regrouped values.
	     * @returns {Array} Returns the new array of regrouped elements.
	     * @example
	     *
	     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
	     * // => [[1, 10, 100], [2, 20, 200]]
	     *
	     * _.unzipWith(zipped, _.add);
	     * // => [3, 30, 300]
	     */
	    function unzipWith(array, iteratee) {
	      if (!(array && array.length)) {
	        return [];
	      }
	      var result = unzip(array);
	      if (iteratee == null) {
	        return result;
	      }
	      return arrayMap(result, function(group) {
	        return apply(iteratee, undefined$1, group);
	      });
	    }

	    /**
	     * Creates an array excluding all given values using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * **Note:** Unlike `_.pull`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...*} [values] The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @see _.difference, _.xor
	     * @example
	     *
	     * _.without([2, 1, 2, 3], 1, 2);
	     * // => [3]
	     */
	    var without = baseRest(function(array, values) {
	      return isArrayLikeObject(array)
	        ? baseDifference(array, values)
	        : [];
	    });

	    /**
	     * Creates an array of unique values that is the
	     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
	     * of the given arrays. The order of result values is determined by the order
	     * they occur in the arrays.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of filtered values.
	     * @see _.difference, _.without
	     * @example
	     *
	     * _.xor([2, 1], [2, 3]);
	     * // => [1, 3]
	     */
	    var xor = baseRest(function(arrays) {
	      return baseXor(arrayFilter(arrays, isArrayLikeObject));
	    });

	    /**
	     * This method is like `_.xor` except that it accepts `iteratee` which is
	     * invoked for each element of each `arrays` to generate the criterion by
	     * which by which they're compared. The order of result values is determined
	     * by the order they occur in the arrays. The iteratee is invoked with one
	     * argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
	     * // => [1.2, 3.4]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 2 }]
	     */
	    var xorBy = baseRest(function(arrays) {
	      var iteratee = last(arrays);
	      if (isArrayLikeObject(iteratee)) {
	        iteratee = undefined$1;
	      }
	      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
	    });

	    /**
	     * This method is like `_.xor` except that it accepts `comparator` which is
	     * invoked to compare elements of `arrays`. The order of result values is
	     * determined by the order they occur in the arrays. The comparator is invoked
	     * with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.xorWith(objects, others, _.isEqual);
	     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
	     */
	    var xorWith = baseRest(function(arrays) {
	      var comparator = last(arrays);
	      comparator = typeof comparator == 'function' ? comparator : undefined$1;
	      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
	    });

	    /**
	     * Creates an array of grouped elements, the first of which contains the
	     * first elements of the given arrays, the second of which contains the
	     * second elements of the given arrays, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to process.
	     * @returns {Array} Returns the new array of grouped elements.
	     * @example
	     *
	     * _.zip(['a', 'b'], [1, 2], [true, false]);
	     * // => [['a', 1, true], ['b', 2, false]]
	     */
	    var zip = baseRest(unzip);

	    /**
	     * This method is like `_.fromPairs` except that it accepts two arrays,
	     * one of property identifiers and one of corresponding values.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.4.0
	     * @category Array
	     * @param {Array} [props=[]] The property identifiers.
	     * @param {Array} [values=[]] The property values.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.zipObject(['a', 'b'], [1, 2]);
	     * // => { 'a': 1, 'b': 2 }
	     */
	    function zipObject(props, values) {
	      return baseZipObject(props || [], values || [], assignValue);
	    }

	    /**
	     * This method is like `_.zipObject` except that it supports property paths.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.1.0
	     * @category Array
	     * @param {Array} [props=[]] The property identifiers.
	     * @param {Array} [values=[]] The property values.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
	     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
	     */
	    function zipObjectDeep(props, values) {
	      return baseZipObject(props || [], values || [], baseSet);
	    }

	    /**
	     * This method is like `_.zip` except that it accepts `iteratee` to specify
	     * how grouped values should be combined. The iteratee is invoked with the
	     * elements of each group: (...group).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.8.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to process.
	     * @param {Function} [iteratee=_.identity] The function to combine
	     *  grouped values.
	     * @returns {Array} Returns the new array of grouped elements.
	     * @example
	     *
	     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
	     *   return a + b + c;
	     * });
	     * // => [111, 222]
	     */
	    var zipWith = baseRest(function(arrays) {
	      var length = arrays.length,
	          iteratee = length > 1 ? arrays[length - 1] : undefined$1;

	      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined$1;
	      return unzipWith(arrays, iteratee);
	    });

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
	     * chain sequences enabled. The result of such sequences must be unwrapped
	     * with `_#value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.3.0
	     * @category Seq
	     * @param {*} value The value to wrap.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36 },
	     *   { 'user': 'fred',    'age': 40 },
	     *   { 'user': 'pebbles', 'age': 1 }
	     * ];
	     *
	     * var youngest = _
	     *   .chain(users)
	     *   .sortBy('age')
	     *   .map(function(o) {
	     *     return o.user + ' is ' + o.age;
	     *   })
	     *   .head()
	     *   .value();
	     * // => 'pebbles is 1'
	     */
	    function chain(value) {
	      var result = lodash(value);
	      result.__chain__ = true;
	      return result;
	    }

	    /**
	     * This method invokes `interceptor` and returns `value`. The interceptor
	     * is invoked with one argument; (value). The purpose of this method is to
	     * "tap into" a method chain sequence in order to modify intermediate results.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Seq
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * _([1, 2, 3])
	     *  .tap(function(array) {
	     *    // Mutate input array.
	     *    array.pop();
	     *  })
	     *  .reverse()
	     *  .value();
	     * // => [2, 1]
	     */
	    function tap(value, interceptor) {
	      interceptor(value);
	      return value;
	    }

	    /**
	     * This method is like `_.tap` except that it returns the result of `interceptor`.
	     * The purpose of this method is to "pass thru" values replacing intermediate
	     * results in a method chain sequence.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Seq
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @returns {*} Returns the result of `interceptor`.
	     * @example
	     *
	     * _('  abc  ')
	     *  .chain()
	     *  .trim()
	     *  .thru(function(value) {
	     *    return [value];
	     *  })
	     *  .value();
	     * // => ['abc']
	     */
	    function thru(value, interceptor) {
	      return interceptor(value);
	    }

	    /**
	     * This method is the wrapper version of `_.at`.
	     *
	     * @name at
	     * @memberOf _
	     * @since 1.0.0
	     * @category Seq
	     * @param {...(string|string[])} [paths] The property paths to pick.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
	     *
	     * _(object).at(['a[0].b.c', 'a[1]']).value();
	     * // => [3, 4]
	     */
	    var wrapperAt = flatRest(function(paths) {
	      var length = paths.length,
	          start = length ? paths[0] : 0,
	          value = this.__wrapped__,
	          interceptor = function(object) { return baseAt(object, paths); };

	      if (length > 1 || this.__actions__.length ||
	          !(value instanceof LazyWrapper) || !isIndex(start)) {
	        return this.thru(interceptor);
	      }
	      value = value.slice(start, +start + (length ? 1 : 0));
	      value.__actions__.push({
	        'func': thru,
	        'args': [interceptor],
	        'thisArg': undefined$1
	      });
	      return new LodashWrapper(value, this.__chain__).thru(function(array) {
	        if (length && !array.length) {
	          array.push(undefined$1);
	        }
	        return array;
	      });
	    });

	    /**
	     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
	     *
	     * @name chain
	     * @memberOf _
	     * @since 0.1.0
	     * @category Seq
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * // A sequence without explicit chaining.
	     * _(users).head();
	     * // => { 'user': 'barney', 'age': 36 }
	     *
	     * // A sequence with explicit chaining.
	     * _(users)
	     *   .chain()
	     *   .head()
	     *   .pick('user')
	     *   .value();
	     * // => { 'user': 'barney' }
	     */
	    function wrapperChain() {
	      return chain(this);
	    }

	    /**
	     * Executes the chain sequence and returns the wrapped result.
	     *
	     * @name commit
	     * @memberOf _
	     * @since 3.2.0
	     * @category Seq
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2];
	     * var wrapped = _(array).push(3);
	     *
	     * console.log(array);
	     * // => [1, 2]
	     *
	     * wrapped = wrapped.commit();
	     * console.log(array);
	     * // => [1, 2, 3]
	     *
	     * wrapped.last();
	     * // => 3
	     *
	     * console.log(array);
	     * // => [1, 2, 3]
	     */
	    function wrapperCommit() {
	      return new LodashWrapper(this.value(), this.__chain__);
	    }

	    /**
	     * Gets the next value on a wrapped object following the
	     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
	     *
	     * @name next
	     * @memberOf _
	     * @since 4.0.0
	     * @category Seq
	     * @returns {Object} Returns the next iterator value.
	     * @example
	     *
	     * var wrapped = _([1, 2]);
	     *
	     * wrapped.next();
	     * // => { 'done': false, 'value': 1 }
	     *
	     * wrapped.next();
	     * // => { 'done': false, 'value': 2 }
	     *
	     * wrapped.next();
	     * // => { 'done': true, 'value': undefined }
	     */
	    function wrapperNext() {
	      if (this.__values__ === undefined$1) {
	        this.__values__ = toArray(this.value());
	      }
	      var done = this.__index__ >= this.__values__.length,
	          value = done ? undefined$1 : this.__values__[this.__index__++];

	      return { 'done': done, 'value': value };
	    }

	    /**
	     * Enables the wrapper to be iterable.
	     *
	     * @name Symbol.iterator
	     * @memberOf _
	     * @since 4.0.0
	     * @category Seq
	     * @returns {Object} Returns the wrapper object.
	     * @example
	     *
	     * var wrapped = _([1, 2]);
	     *
	     * wrapped[Symbol.iterator]() === wrapped;
	     * // => true
	     *
	     * Array.from(wrapped);
	     * // => [1, 2]
	     */
	    function wrapperToIterator() {
	      return this;
	    }

	    /**
	     * Creates a clone of the chain sequence planting `value` as the wrapped value.
	     *
	     * @name plant
	     * @memberOf _
	     * @since 3.2.0
	     * @category Seq
	     * @param {*} value The value to plant.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var wrapped = _([1, 2]).map(square);
	     * var other = wrapped.plant([3, 4]);
	     *
	     * other.value();
	     * // => [9, 16]
	     *
	     * wrapped.value();
	     * // => [1, 4]
	     */
	    function wrapperPlant(value) {
	      var result,
	          parent = this;

	      while (parent instanceof baseLodash) {
	        var clone = wrapperClone(parent);
	        clone.__index__ = 0;
	        clone.__values__ = undefined$1;
	        if (result) {
	          previous.__wrapped__ = clone;
	        } else {
	          result = clone;
	        }
	        var previous = clone;
	        parent = parent.__wrapped__;
	      }
	      previous.__wrapped__ = value;
	      return result;
	    }

	    /**
	     * This method is the wrapper version of `_.reverse`.
	     *
	     * **Note:** This method mutates the wrapped array.
	     *
	     * @name reverse
	     * @memberOf _
	     * @since 0.1.0
	     * @category Seq
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _(array).reverse().value()
	     * // => [3, 2, 1]
	     *
	     * console.log(array);
	     * // => [3, 2, 1]
	     */
	    function wrapperReverse() {
	      var value = this.__wrapped__;
	      if (value instanceof LazyWrapper) {
	        var wrapped = value;
	        if (this.__actions__.length) {
	          wrapped = new LazyWrapper(this);
	        }
	        wrapped = wrapped.reverse();
	        wrapped.__actions__.push({
	          'func': thru,
	          'args': [reverse],
	          'thisArg': undefined$1
	        });
	        return new LodashWrapper(wrapped, this.__chain__);
	      }
	      return this.thru(reverse);
	    }

	    /**
	     * Executes the chain sequence to resolve the unwrapped value.
	     *
	     * @name value
	     * @memberOf _
	     * @since 0.1.0
	     * @alias toJSON, valueOf
	     * @category Seq
	     * @returns {*} Returns the resolved unwrapped value.
	     * @example
	     *
	     * _([1, 2, 3]).value();
	     * // => [1, 2, 3]
	     */
	    function wrapperValue() {
	      return baseWrapperValue(this.__wrapped__, this.__actions__);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` thru `iteratee`. The corresponding value of
	     * each key is the number of times the key was returned by `iteratee`. The
	     * iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.5.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.countBy([6.1, 4.2, 6.3], Math.floor);
	     * // => { '4': 1, '6': 2 }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.countBy(['one', 'two', 'three'], 'length');
	     * // => { '3': 2, '5': 1 }
	     */
	    var countBy = createAggregator(function(result, value, key) {
	      if (hasOwnProperty.call(result, key)) {
	        ++result[key];
	      } else {
	        baseAssignValue(result, key, 1);
	      }
	    });

	    /**
	     * Checks if `predicate` returns truthy for **all** elements of `collection`.
	     * Iteration is stopped once `predicate` returns falsey. The predicate is
	     * invoked with three arguments: (value, index|key, collection).
	     *
	     * **Note:** This method returns `true` for
	     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
	     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
	     * elements of empty collections.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`.
	     * @example
	     *
	     * _.every([true, 1, null, 'yes'], Boolean);
	     * // => false
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.every(users, { 'user': 'barney', 'active': false });
	     * // => false
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.every(users, ['active', false]);
	     * // => true
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.every(users, 'active');
	     * // => false
	     */
	    function every(collection, predicate, guard) {
	      var func = isArray(collection) ? arrayEvery : baseEvery;
	      if (guard && isIterateeCall(collection, predicate, guard)) {
	        predicate = undefined$1;
	      }
	      return func(collection, getIteratee(predicate, 3));
	    }

	    /**
	     * Iterates over elements of `collection`, returning an array of all elements
	     * `predicate` returns truthy for. The predicate is invoked with three
	     * arguments: (value, index|key, collection).
	     *
	     * **Note:** Unlike `_.remove`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     * @see _.reject
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * _.filter(users, function(o) { return !o.active; });
	     * // => objects for ['fred']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.filter(users, { 'age': 36, 'active': true });
	     * // => objects for ['barney']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.filter(users, ['active', false]);
	     * // => objects for ['fred']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.filter(users, 'active');
	     * // => objects for ['barney']
	     *
	     * // Combining several predicates using `_.overEvery` or `_.overSome`.
	     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
	     * // => objects for ['fred', 'barney']
	     */
	    function filter(collection, predicate) {
	      var func = isArray(collection) ? arrayFilter : baseFilter;
	      return func(collection, getIteratee(predicate, 3));
	    }

	    /**
	     * Iterates over elements of `collection`, returning the first element
	     * `predicate` returns truthy for. The predicate is invoked with three
	     * arguments: (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': true },
	     *   { 'user': 'fred',    'age': 40, 'active': false },
	     *   { 'user': 'pebbles', 'age': 1,  'active': true }
	     * ];
	     *
	     * _.find(users, function(o) { return o.age < 40; });
	     * // => object for 'barney'
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.find(users, { 'age': 1, 'active': true });
	     * // => object for 'pebbles'
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.find(users, ['active', false]);
	     * // => object for 'fred'
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.find(users, 'active');
	     * // => object for 'barney'
	     */
	    var find = createFind(findIndex);

	    /**
	     * This method is like `_.find` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=collection.length-1] The index to search from.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * _.findLast([1, 2, 3, 4], function(n) {
	     *   return n % 2 == 1;
	     * });
	     * // => 3
	     */
	    var findLast = createFind(findLastIndex);

	    /**
	     * Creates a flattened array of values by running each element in `collection`
	     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
	     * with three arguments: (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * function duplicate(n) {
	     *   return [n, n];
	     * }
	     *
	     * _.flatMap([1, 2], duplicate);
	     * // => [1, 1, 2, 2]
	     */
	    function flatMap(collection, iteratee) {
	      return baseFlatten(map(collection, iteratee), 1);
	    }

	    /**
	     * This method is like `_.flatMap` except that it recursively flattens the
	     * mapped results.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * function duplicate(n) {
	     *   return [[[n, n]]];
	     * }
	     *
	     * _.flatMapDeep([1, 2], duplicate);
	     * // => [1, 1, 2, 2]
	     */
	    function flatMapDeep(collection, iteratee) {
	      return baseFlatten(map(collection, iteratee), INFINITY);
	    }

	    /**
	     * This method is like `_.flatMap` except that it recursively flattens the
	     * mapped results up to `depth` times.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {number} [depth=1] The maximum recursion depth.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * function duplicate(n) {
	     *   return [[[n, n]]];
	     * }
	     *
	     * _.flatMapDepth([1, 2], duplicate, 2);
	     * // => [[1, 1], [2, 2]]
	     */
	    function flatMapDepth(collection, iteratee, depth) {
	      depth = depth === undefined$1 ? 1 : toInteger(depth);
	      return baseFlatten(map(collection, iteratee), depth);
	    }

	    /**
	     * Iterates over elements of `collection` and invokes `iteratee` for each element.
	     * The iteratee is invoked with three arguments: (value, index|key, collection).
	     * Iteratee functions may exit iteration early by explicitly returning `false`.
	     *
	     * **Note:** As with other "Collections" methods, objects with a "length"
	     * property are iterated like arrays. To avoid this behavior use `_.forIn`
	     * or `_.forOwn` for object iteration.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @alias each
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     * @see _.forEachRight
	     * @example
	     *
	     * _.forEach([1, 2], function(value) {
	     *   console.log(value);
	     * });
	     * // => Logs `1` then `2`.
	     *
	     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
	     */
	    function forEach(collection, iteratee) {
	      var func = isArray(collection) ? arrayEach : baseEach;
	      return func(collection, getIteratee(iteratee, 3));
	    }

	    /**
	     * This method is like `_.forEach` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @alias eachRight
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     * @see _.forEach
	     * @example
	     *
	     * _.forEachRight([1, 2], function(value) {
	     *   console.log(value);
	     * });
	     * // => Logs `2` then `1`.
	     */
	    function forEachRight(collection, iteratee) {
	      var func = isArray(collection) ? arrayEachRight : baseEachRight;
	      return func(collection, getIteratee(iteratee, 3));
	    }

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` thru `iteratee`. The order of grouped values
	     * is determined by the order they occur in `collection`. The corresponding
	     * value of each key is an array of elements responsible for generating the
	     * key. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
	     * // => { '4': [4.2], '6': [6.1, 6.3] }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.groupBy(['one', 'two', 'three'], 'length');
	     * // => { '3': ['one', 'two'], '5': ['three'] }
	     */
	    var groupBy = createAggregator(function(result, value, key) {
	      if (hasOwnProperty.call(result, key)) {
	        result[key].push(value);
	      } else {
	        baseAssignValue(result, key, [value]);
	      }
	    });

	    /**
	     * Checks if `value` is in `collection`. If `collection` is a string, it's
	     * checked for a substring of `value`, otherwise
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * is used for equality comparisons. If `fromIndex` is negative, it's used as
	     * the offset from the end of `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to inspect.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
	     * @returns {boolean} Returns `true` if `value` is found, else `false`.
	     * @example
	     *
	     * _.includes([1, 2, 3], 1);
	     * // => true
	     *
	     * _.includes([1, 2, 3], 1, 2);
	     * // => false
	     *
	     * _.includes({ 'a': 1, 'b': 2 }, 1);
	     * // => true
	     *
	     * _.includes('abcd', 'bc');
	     * // => true
	     */
	    function includes(collection, value, fromIndex, guard) {
	      collection = isArrayLike(collection) ? collection : values(collection);
	      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

	      var length = collection.length;
	      if (fromIndex < 0) {
	        fromIndex = nativeMax(length + fromIndex, 0);
	      }
	      return isString(collection)
	        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
	        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
	    }

	    /**
	     * Invokes the method at `path` of each element in `collection`, returning
	     * an array of the results of each invoked method. Any additional arguments
	     * are provided to each invoked method. If `path` is a function, it's invoked
	     * for, and `this` bound to, each element in `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Array|Function|string} path The path of the method to invoke or
	     *  the function invoked per iteration.
	     * @param {...*} [args] The arguments to invoke each method with.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
	     * // => [[1, 5, 7], [1, 2, 3]]
	     *
	     * _.invokeMap([123, 456], String.prototype.split, '');
	     * // => [['1', '2', '3'], ['4', '5', '6']]
	     */
	    var invokeMap = baseRest(function(collection, path, args) {
	      var index = -1,
	          isFunc = typeof path == 'function',
	          result = isArrayLike(collection) ? Array(collection.length) : [];

	      baseEach(collection, function(value) {
	        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
	      });
	      return result;
	    });

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` thru `iteratee`. The corresponding value of
	     * each key is the last element responsible for generating the key. The
	     * iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * var array = [
	     *   { 'dir': 'left', 'code': 97 },
	     *   { 'dir': 'right', 'code': 100 }
	     * ];
	     *
	     * _.keyBy(array, function(o) {
	     *   return String.fromCharCode(o.code);
	     * });
	     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
	     *
	     * _.keyBy(array, 'dir');
	     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
	     */
	    var keyBy = createAggregator(function(result, value, key) {
	      baseAssignValue(result, key, value);
	    });

	    /**
	     * Creates an array of values by running each element in `collection` thru
	     * `iteratee`. The iteratee is invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * Many lodash methods are guarded to work as iteratees for methods like
	     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
	     *
	     * The guarded methods are:
	     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
	     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
	     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
	     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * _.map([4, 8], square);
	     * // => [16, 64]
	     *
	     * _.map({ 'a': 4, 'b': 8 }, square);
	     * // => [16, 64] (iteration order is not guaranteed)
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.map(users, 'user');
	     * // => ['barney', 'fred']
	     */
	    function map(collection, iteratee) {
	      var func = isArray(collection) ? arrayMap : baseMap;
	      return func(collection, getIteratee(iteratee, 3));
	    }

	    /**
	     * This method is like `_.sortBy` except that it allows specifying the sort
	     * orders of the iteratees to sort by. If `orders` is unspecified, all values
	     * are sorted in ascending order. Otherwise, specify an order of "desc" for
	     * descending or "asc" for ascending sort order of corresponding values.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
	     *  The iteratees to sort by.
	     * @param {string[]} [orders] The sort orders of `iteratees`.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'fred',   'age': 48 },
	     *   { 'user': 'barney', 'age': 34 },
	     *   { 'user': 'fred',   'age': 40 },
	     *   { 'user': 'barney', 'age': 36 }
	     * ];
	     *
	     * // Sort by `user` in ascending order and by `age` in descending order.
	     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
	     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
	     */
	    function orderBy(collection, iteratees, orders, guard) {
	      if (collection == null) {
	        return [];
	      }
	      if (!isArray(iteratees)) {
	        iteratees = iteratees == null ? [] : [iteratees];
	      }
	      orders = guard ? undefined$1 : orders;
	      if (!isArray(orders)) {
	        orders = orders == null ? [] : [orders];
	      }
	      return baseOrderBy(collection, iteratees, orders);
	    }

	    /**
	     * Creates an array of elements split into two groups, the first of which
	     * contains elements `predicate` returns truthy for, the second of which
	     * contains elements `predicate` returns falsey for. The predicate is
	     * invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the array of grouped elements.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': false },
	     *   { 'user': 'fred',    'age': 40, 'active': true },
	     *   { 'user': 'pebbles', 'age': 1,  'active': false }
	     * ];
	     *
	     * _.partition(users, function(o) { return o.active; });
	     * // => objects for [['fred'], ['barney', 'pebbles']]
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.partition(users, { 'age': 1, 'active': false });
	     * // => objects for [['pebbles'], ['barney', 'fred']]
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.partition(users, ['active', false]);
	     * // => objects for [['barney', 'pebbles'], ['fred']]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.partition(users, 'active');
	     * // => objects for [['fred'], ['barney', 'pebbles']]
	     */
	    var partition = createAggregator(function(result, value, key) {
	      result[key ? 0 : 1].push(value);
	    }, function() { return [[], []]; });

	    /**
	     * Reduces `collection` to a value which is the accumulated result of running
	     * each element in `collection` thru `iteratee`, where each successive
	     * invocation is supplied the return value of the previous. If `accumulator`
	     * is not given, the first element of `collection` is used as the initial
	     * value. The iteratee is invoked with four arguments:
	     * (accumulator, value, index|key, collection).
	     *
	     * Many lodash methods are guarded to work as iteratees for methods like
	     * `_.reduce`, `_.reduceRight`, and `_.transform`.
	     *
	     * The guarded methods are:
	     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
	     * and `sortBy`
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @returns {*} Returns the accumulated value.
	     * @see _.reduceRight
	     * @example
	     *
	     * _.reduce([1, 2], function(sum, n) {
	     *   return sum + n;
	     * }, 0);
	     * // => 3
	     *
	     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
	     *   (result[value] || (result[value] = [])).push(key);
	     *   return result;
	     * }, {});
	     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
	     */
	    function reduce(collection, iteratee, accumulator) {
	      var func = isArray(collection) ? arrayReduce : baseReduce,
	          initAccum = arguments.length < 3;

	      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
	    }

	    /**
	     * This method is like `_.reduce` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @returns {*} Returns the accumulated value.
	     * @see _.reduce
	     * @example
	     *
	     * var array = [[0, 1], [2, 3], [4, 5]];
	     *
	     * _.reduceRight(array, function(flattened, other) {
	     *   return flattened.concat(other);
	     * }, []);
	     * // => [4, 5, 2, 3, 0, 1]
	     */
	    function reduceRight(collection, iteratee, accumulator) {
	      var func = isArray(collection) ? arrayReduceRight : baseReduce,
	          initAccum = arguments.length < 3;

	      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
	    }

	    /**
	     * The opposite of `_.filter`; this method returns the elements of `collection`
	     * that `predicate` does **not** return truthy for.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     * @see _.filter
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false },
	     *   { 'user': 'fred',   'age': 40, 'active': true }
	     * ];
	     *
	     * _.reject(users, function(o) { return !o.active; });
	     * // => objects for ['fred']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.reject(users, { 'age': 40, 'active': true });
	     * // => objects for ['barney']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.reject(users, ['active', false]);
	     * // => objects for ['fred']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.reject(users, 'active');
	     * // => objects for ['barney']
	     */
	    function reject(collection, predicate) {
	      var func = isArray(collection) ? arrayFilter : baseFilter;
	      return func(collection, negate(getIteratee(predicate, 3)));
	    }

	    /**
	     * Gets a random element from `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to sample.
	     * @returns {*} Returns the random element.
	     * @example
	     *
	     * _.sample([1, 2, 3, 4]);
	     * // => 2
	     */
	    function sample(collection) {
	      var func = isArray(collection) ? arraySample : baseSample;
	      return func(collection);
	    }

	    /**
	     * Gets `n` random elements at unique keys from `collection` up to the
	     * size of `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to sample.
	     * @param {number} [n=1] The number of elements to sample.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the random elements.
	     * @example
	     *
	     * _.sampleSize([1, 2, 3], 2);
	     * // => [3, 1]
	     *
	     * _.sampleSize([1, 2, 3], 4);
	     * // => [2, 3, 1]
	     */
	    function sampleSize(collection, n, guard) {
	      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined$1)) {
	        n = 1;
	      } else {
	        n = toInteger(n);
	      }
	      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
	      return func(collection, n);
	    }

	    /**
	     * Creates an array of shuffled values, using a version of the
	     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     * @example
	     *
	     * _.shuffle([1, 2, 3, 4]);
	     * // => [4, 1, 3, 2]
	     */
	    function shuffle(collection) {
	      var func = isArray(collection) ? arrayShuffle : baseShuffle;
	      return func(collection);
	    }

	    /**
	     * Gets the size of `collection` by returning its length for array-like
	     * values or the number of own enumerable string keyed properties for objects.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to inspect.
	     * @returns {number} Returns the collection size.
	     * @example
	     *
	     * _.size([1, 2, 3]);
	     * // => 3
	     *
	     * _.size({ 'a': 1, 'b': 2 });
	     * // => 2
	     *
	     * _.size('pebbles');
	     * // => 7
	     */
	    function size(collection) {
	      if (collection == null) {
	        return 0;
	      }
	      if (isArrayLike(collection)) {
	        return isString(collection) ? stringSize(collection) : collection.length;
	      }
	      var tag = getTag(collection);
	      if (tag == mapTag || tag == setTag) {
	        return collection.size;
	      }
	      return baseKeys(collection).length;
	    }

	    /**
	     * Checks if `predicate` returns truthy for **any** element of `collection`.
	     * Iteration is stopped once `predicate` returns truthy. The predicate is
	     * invoked with three arguments: (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     * @example
	     *
	     * _.some([null, 0, 'yes', false], Boolean);
	     * // => true
	     *
	     * var users = [
	     *   { 'user': 'barney', 'active': true },
	     *   { 'user': 'fred',   'active': false }
	     * ];
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.some(users, { 'user': 'barney', 'active': false });
	     * // => false
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.some(users, ['active', false]);
	     * // => true
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.some(users, 'active');
	     * // => true
	     */
	    function some(collection, predicate, guard) {
	      var func = isArray(collection) ? arraySome : baseSome;
	      if (guard && isIterateeCall(collection, predicate, guard)) {
	        predicate = undefined$1;
	      }
	      return func(collection, getIteratee(predicate, 3));
	    }

	    /**
	     * Creates an array of elements, sorted in ascending order by the results of
	     * running each element in a collection thru each iteratee. This method
	     * performs a stable sort, that is, it preserves the original sort order of
	     * equal elements. The iteratees are invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {...(Function|Function[])} [iteratees=[_.identity]]
	     *  The iteratees to sort by.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'fred',   'age': 48 },
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 30 },
	     *   { 'user': 'barney', 'age': 34 }
	     * ];
	     *
	     * _.sortBy(users, [function(o) { return o.user; }]);
	     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
	     *
	     * _.sortBy(users, ['user', 'age']);
	     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
	     */
	    var sortBy = baseRest(function(collection, iteratees) {
	      if (collection == null) {
	        return [];
	      }
	      var length = iteratees.length;
	      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
	        iteratees = [];
	      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
	        iteratees = [iteratees[0]];
	      }
	      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
	    });

	    /*------------------------------------------------------------------------*/

	    /**
	     * Gets the timestamp of the number of milliseconds that have elapsed since
	     * the Unix epoch (1 January 1970 00:00:00 UTC).
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Date
	     * @returns {number} Returns the timestamp.
	     * @example
	     *
	     * _.defer(function(stamp) {
	     *   console.log(_.now() - stamp);
	     * }, _.now());
	     * // => Logs the number of milliseconds it took for the deferred invocation.
	     */
	    var now = ctxNow || function() {
	      return root.Date.now();
	    };

	    /*------------------------------------------------------------------------*/

	    /**
	     * The opposite of `_.before`; this method creates a function that invokes
	     * `func` once it's called `n` or more times.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {number} n The number of calls before `func` is invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var saves = ['profile', 'settings'];
	     *
	     * var done = _.after(saves.length, function() {
	     *   console.log('done saving!');
	     * });
	     *
	     * _.forEach(saves, function(type) {
	     *   asyncSave({ 'type': type, 'complete': done });
	     * });
	     * // => Logs 'done saving!' after the two async saves have completed.
	     */
	    function after(n, func) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      n = toInteger(n);
	      return function() {
	        if (--n < 1) {
	          return func.apply(this, arguments);
	        }
	      };
	    }

	    /**
	     * Creates a function that invokes `func`, with up to `n` arguments,
	     * ignoring any additional arguments.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} func The function to cap arguments for.
	     * @param {number} [n=func.length] The arity cap.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the new capped function.
	     * @example
	     *
	     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
	     * // => [6, 8, 10]
	     */
	    function ary(func, n, guard) {
	      n = guard ? undefined$1 : n;
	      n = (func && n == null) ? func.length : n;
	      return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
	    }

	    /**
	     * Creates a function that invokes `func`, with the `this` binding and arguments
	     * of the created function, while it's called less than `n` times. Subsequent
	     * calls to the created function return the result of the last `func` invocation.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {number} n The number of calls at which `func` is no longer invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * jQuery(element).on('click', _.before(5, addContactToList));
	     * // => Allows adding up to 4 contacts to the list.
	     */
	    function before(n, func) {
	      var result;
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      n = toInteger(n);
	      return function() {
	        if (--n > 0) {
	          result = func.apply(this, arguments);
	        }
	        if (n <= 1) {
	          func = undefined$1;
	        }
	        return result;
	      };
	    }

	    /**
	     * Creates a function that invokes `func` with the `this` binding of `thisArg`
	     * and `partials` prepended to the arguments it receives.
	     *
	     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
	     * property of bound functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to bind.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * function greet(greeting, punctuation) {
	     *   return greeting + ' ' + this.user + punctuation;
	     * }
	     *
	     * var object = { 'user': 'fred' };
	     *
	     * var bound = _.bind(greet, object, 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * // Bound with placeholders.
	     * var bound = _.bind(greet, object, _, '!');
	     * bound('hi');
	     * // => 'hi fred!'
	     */
	    var bind = baseRest(function(func, thisArg, partials) {
	      var bitmask = WRAP_BIND_FLAG;
	      if (partials.length) {
	        var holders = replaceHolders(partials, getHolder(bind));
	        bitmask |= WRAP_PARTIAL_FLAG;
	      }
	      return createWrap(func, bitmask, thisArg, partials, holders);
	    });

	    /**
	     * Creates a function that invokes the method at `object[key]` with `partials`
	     * prepended to the arguments it receives.
	     *
	     * This method differs from `_.bind` by allowing bound functions to reference
	     * methods that may be redefined or don't yet exist. See
	     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
	     * for more details.
	     *
	     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.10.0
	     * @category Function
	     * @param {Object} object The object to invoke the method on.
	     * @param {string} key The key of the method.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * var object = {
	     *   'user': 'fred',
	     *   'greet': function(greeting, punctuation) {
	     *     return greeting + ' ' + this.user + punctuation;
	     *   }
	     * };
	     *
	     * var bound = _.bindKey(object, 'greet', 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * object.greet = function(greeting, punctuation) {
	     *   return greeting + 'ya ' + this.user + punctuation;
	     * };
	     *
	     * bound('!');
	     * // => 'hiya fred!'
	     *
	     * // Bound with placeholders.
	     * var bound = _.bindKey(object, 'greet', _, '!');
	     * bound('hi');
	     * // => 'hiya fred!'
	     */
	    var bindKey = baseRest(function(object, key, partials) {
	      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
	      if (partials.length) {
	        var holders = replaceHolders(partials, getHolder(bindKey));
	        bitmask |= WRAP_PARTIAL_FLAG;
	      }
	      return createWrap(key, bitmask, object, partials, holders);
	    });

	    /**
	     * Creates a function that accepts arguments of `func` and either invokes
	     * `func` returning its result, if at least `arity` number of arguments have
	     * been provided, or returns a function that accepts the remaining `func`
	     * arguments, and so on. The arity of `func` may be specified if `func.length`
	     * is not sufficient.
	     *
	     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curry(abc);
	     *
	     * curried(1)(2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // Curried with placeholders.
	     * curried(1)(_, 3)(2);
	     * // => [1, 2, 3]
	     */
	    function curry(func, arity, guard) {
	      arity = guard ? undefined$1 : arity;
	      var result = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
	      result.placeholder = curry.placeholder;
	      return result;
	    }

	    /**
	     * This method is like `_.curry` except that arguments are applied to `func`
	     * in the manner of `_.partialRight` instead of `_.partial`.
	     *
	     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curryRight(abc);
	     *
	     * curried(3)(2)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(2, 3)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // Curried with placeholders.
	     * curried(3)(1, _)(2);
	     * // => [1, 2, 3]
	     */
	    function curryRight(func, arity, guard) {
	      arity = guard ? undefined$1 : arity;
	      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
	      result.placeholder = curryRight.placeholder;
	      return result;
	    }

	    /**
	     * Creates a debounced function that delays invoking `func` until after `wait`
	     * milliseconds have elapsed since the last time the debounced function was
	     * invoked. The debounced function comes with a `cancel` method to cancel
	     * delayed `func` invocations and a `flush` method to immediately invoke them.
	     * Provide `options` to indicate whether `func` should be invoked on the
	     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
	     * with the last arguments provided to the debounced function. Subsequent
	     * calls to the debounced function return the result of the last `func`
	     * invocation.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is
	     * invoked on the trailing edge of the timeout only if the debounced function
	     * is invoked more than once during the `wait` timeout.
	     *
	     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	     *
	     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	     * for details over the differences between `_.debounce` and `_.throttle`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to debounce.
	     * @param {number} [wait=0] The number of milliseconds to delay.
	     * @param {Object} [options={}] The options object.
	     * @param {boolean} [options.leading=false]
	     *  Specify invoking on the leading edge of the timeout.
	     * @param {number} [options.maxWait]
	     *  The maximum time `func` is allowed to be delayed before it's invoked.
	     * @param {boolean} [options.trailing=true]
	     *  Specify invoking on the trailing edge of the timeout.
	     * @returns {Function} Returns the new debounced function.
	     * @example
	     *
	     * // Avoid costly calculations while the window size is in flux.
	     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	     *
	     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
	     * jQuery(element).on('click', _.debounce(sendMail, 300, {
	     *   'leading': true,
	     *   'trailing': false
	     * }));
	     *
	     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
	     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
	     * var source = new EventSource('/stream');
	     * jQuery(source).on('message', debounced);
	     *
	     * // Cancel the trailing debounced invocation.
	     * jQuery(window).on('popstate', debounced.cancel);
	     */
	    function debounce(func, wait, options) {
	      var lastArgs,
	          lastThis,
	          maxWait,
	          result,
	          timerId,
	          lastCallTime,
	          lastInvokeTime = 0,
	          leading = false,
	          maxing = false,
	          trailing = true;

	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      wait = toNumber(wait) || 0;
	      if (isObject(options)) {
	        leading = !!options.leading;
	        maxing = 'maxWait' in options;
	        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
	        trailing = 'trailing' in options ? !!options.trailing : trailing;
	      }

	      function invokeFunc(time) {
	        var args = lastArgs,
	            thisArg = lastThis;

	        lastArgs = lastThis = undefined$1;
	        lastInvokeTime = time;
	        result = func.apply(thisArg, args);
	        return result;
	      }

	      function leadingEdge(time) {
	        // Reset any `maxWait` timer.
	        lastInvokeTime = time;
	        // Start the timer for the trailing edge.
	        timerId = setTimeout(timerExpired, wait);
	        // Invoke the leading edge.
	        return leading ? invokeFunc(time) : result;
	      }

	      function remainingWait(time) {
	        var timeSinceLastCall = time - lastCallTime,
	            timeSinceLastInvoke = time - lastInvokeTime,
	            timeWaiting = wait - timeSinceLastCall;

	        return maxing
	          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
	          : timeWaiting;
	      }

	      function shouldInvoke(time) {
	        var timeSinceLastCall = time - lastCallTime,
	            timeSinceLastInvoke = time - lastInvokeTime;

	        // Either this is the first call, activity has stopped and we're at the
	        // trailing edge, the system time has gone backwards and we're treating
	        // it as the trailing edge, or we've hit the `maxWait` limit.
	        return (lastCallTime === undefined$1 || (timeSinceLastCall >= wait) ||
	          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
	      }

	      function timerExpired() {
	        var time = now();
	        if (shouldInvoke(time)) {
	          return trailingEdge(time);
	        }
	        // Restart the timer.
	        timerId = setTimeout(timerExpired, remainingWait(time));
	      }

	      function trailingEdge(time) {
	        timerId = undefined$1;

	        // Only invoke if we have `lastArgs` which means `func` has been
	        // debounced at least once.
	        if (trailing && lastArgs) {
	          return invokeFunc(time);
	        }
	        lastArgs = lastThis = undefined$1;
	        return result;
	      }

	      function cancel() {
	        if (timerId !== undefined$1) {
	          clearTimeout(timerId);
	        }
	        lastInvokeTime = 0;
	        lastArgs = lastCallTime = lastThis = timerId = undefined$1;
	      }

	      function flush() {
	        return timerId === undefined$1 ? result : trailingEdge(now());
	      }

	      function debounced() {
	        var time = now(),
	            isInvoking = shouldInvoke(time);

	        lastArgs = arguments;
	        lastThis = this;
	        lastCallTime = time;

	        if (isInvoking) {
	          if (timerId === undefined$1) {
	            return leadingEdge(lastCallTime);
	          }
	          if (maxing) {
	            // Handle invocations in a tight loop.
	            clearTimeout(timerId);
	            timerId = setTimeout(timerExpired, wait);
	            return invokeFunc(lastCallTime);
	          }
	        }
	        if (timerId === undefined$1) {
	          timerId = setTimeout(timerExpired, wait);
	        }
	        return result;
	      }
	      debounced.cancel = cancel;
	      debounced.flush = flush;
	      return debounced;
	    }

	    /**
	     * Defers invoking the `func` until the current call stack has cleared. Any
	     * additional arguments are provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to defer.
	     * @param {...*} [args] The arguments to invoke `func` with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.defer(function(text) {
	     *   console.log(text);
	     * }, 'deferred');
	     * // => Logs 'deferred' after one millisecond.
	     */
	    var defer = baseRest(function(func, args) {
	      return baseDelay(func, 1, args);
	    });

	    /**
	     * Invokes `func` after `wait` milliseconds. Any additional arguments are
	     * provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {...*} [args] The arguments to invoke `func` with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.delay(function(text) {
	     *   console.log(text);
	     * }, 1000, 'later');
	     * // => Logs 'later' after one second.
	     */
	    var delay = baseRest(function(func, wait, args) {
	      return baseDelay(func, toNumber(wait) || 0, args);
	    });

	    /**
	     * Creates a function that invokes `func` with arguments reversed.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Function
	     * @param {Function} func The function to flip arguments for.
	     * @returns {Function} Returns the new flipped function.
	     * @example
	     *
	     * var flipped = _.flip(function() {
	     *   return _.toArray(arguments);
	     * });
	     *
	     * flipped('a', 'b', 'c', 'd');
	     * // => ['d', 'c', 'b', 'a']
	     */
	    function flip(func) {
	      return createWrap(func, WRAP_FLIP_FLAG);
	    }

	    /**
	     * Creates a function that memoizes the result of `func`. If `resolver` is
	     * provided, it determines the cache key for storing the result based on the
	     * arguments provided to the memoized function. By default, the first argument
	     * provided to the memoized function is used as the map cache key. The `func`
	     * is invoked with the `this` binding of the memoized function.
	     *
	     * **Note:** The cache is exposed as the `cache` property on the memoized
	     * function. Its creation may be customized by replacing the `_.memoize.Cache`
	     * constructor with one whose instances implement the
	     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to have its output memoized.
	     * @param {Function} [resolver] The function to resolve the cache key.
	     * @returns {Function} Returns the new memoized function.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2 };
	     * var other = { 'c': 3, 'd': 4 };
	     *
	     * var values = _.memoize(_.values);
	     * values(object);
	     * // => [1, 2]
	     *
	     * values(other);
	     * // => [3, 4]
	     *
	     * object.a = 2;
	     * values(object);
	     * // => [1, 2]
	     *
	     * // Modify the result cache.
	     * values.cache.set(object, ['a', 'b']);
	     * values(object);
	     * // => ['a', 'b']
	     *
	     * // Replace `_.memoize.Cache`.
	     * _.memoize.Cache = WeakMap;
	     */
	    function memoize(func, resolver) {
	      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var memoized = function() {
	        var args = arguments,
	            key = resolver ? resolver.apply(this, args) : args[0],
	            cache = memoized.cache;

	        if (cache.has(key)) {
	          return cache.get(key);
	        }
	        var result = func.apply(this, args);
	        memoized.cache = cache.set(key, result) || cache;
	        return result;
	      };
	      memoized.cache = new (memoize.Cache || MapCache);
	      return memoized;
	    }

	    // Expose `MapCache`.
	    memoize.Cache = MapCache;

	    /**
	     * Creates a function that negates the result of the predicate `func`. The
	     * `func` predicate is invoked with the `this` binding and arguments of the
	     * created function.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} predicate The predicate to negate.
	     * @returns {Function} Returns the new negated function.
	     * @example
	     *
	     * function isEven(n) {
	     *   return n % 2 == 0;
	     * }
	     *
	     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
	     * // => [1, 3, 5]
	     */
	    function negate(predicate) {
	      if (typeof predicate != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return function() {
	        var args = arguments;
	        switch (args.length) {
	          case 0: return !predicate.call(this);
	          case 1: return !predicate.call(this, args[0]);
	          case 2: return !predicate.call(this, args[0], args[1]);
	          case 3: return !predicate.call(this, args[0], args[1], args[2]);
	        }
	        return !predicate.apply(this, args);
	      };
	    }

	    /**
	     * Creates a function that is restricted to invoking `func` once. Repeat calls
	     * to the function return the value of the first invocation. The `func` is
	     * invoked with the `this` binding and arguments of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var initialize = _.once(createApplication);
	     * initialize();
	     * initialize();
	     * // => `createApplication` is invoked once
	     */
	    function once(func) {
	      return before(2, func);
	    }

	    /**
	     * Creates a function that invokes `func` with its arguments transformed.
	     *
	     * @static
	     * @since 4.0.0
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to wrap.
	     * @param {...(Function|Function[])} [transforms=[_.identity]]
	     *  The argument transforms.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function doubled(n) {
	     *   return n * 2;
	     * }
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var func = _.overArgs(function(x, y) {
	     *   return [x, y];
	     * }, [square, doubled]);
	     *
	     * func(9, 3);
	     * // => [81, 6]
	     *
	     * func(10, 5);
	     * // => [100, 10]
	     */
	    var overArgs = castRest(function(func, transforms) {
	      transforms = (transforms.length == 1 && isArray(transforms[0]))
	        ? arrayMap(transforms[0], baseUnary(getIteratee()))
	        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

	      var funcsLength = transforms.length;
	      return baseRest(function(args) {
	        var index = -1,
	            length = nativeMin(args.length, funcsLength);

	        while (++index < length) {
	          args[index] = transforms[index].call(this, args[index]);
	        }
	        return apply(func, this, args);
	      });
	    });

	    /**
	     * Creates a function that invokes `func` with `partials` prepended to the
	     * arguments it receives. This method is like `_.bind` except it does **not**
	     * alter the `this` binding.
	     *
	     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.2.0
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * function greet(greeting, name) {
	     *   return greeting + ' ' + name;
	     * }
	     *
	     * var sayHelloTo = _.partial(greet, 'hello');
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     *
	     * // Partially applied with placeholders.
	     * var greetFred = _.partial(greet, _, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     */
	    var partial = baseRest(function(func, partials) {
	      var holders = replaceHolders(partials, getHolder(partial));
	      return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
	    });

	    /**
	     * This method is like `_.partial` except that partially applied arguments
	     * are appended to the arguments it receives.
	     *
	     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.0.0
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * function greet(greeting, name) {
	     *   return greeting + ' ' + name;
	     * }
	     *
	     * var greetFred = _.partialRight(greet, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     *
	     * // Partially applied with placeholders.
	     * var sayHelloTo = _.partialRight(greet, 'hello', _);
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     */
	    var partialRight = baseRest(function(func, partials) {
	      var holders = replaceHolders(partials, getHolder(partialRight));
	      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
	    });

	    /**
	     * Creates a function that invokes `func` with arguments arranged according
	     * to the specified `indexes` where the argument value at the first index is
	     * provided as the first argument, the argument value at the second index is
	     * provided as the second argument, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} func The function to rearrange arguments for.
	     * @param {...(number|number[])} indexes The arranged argument indexes.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var rearged = _.rearg(function(a, b, c) {
	     *   return [a, b, c];
	     * }, [2, 0, 1]);
	     *
	     * rearged('b', 'c', 'a')
	     * // => ['a', 'b', 'c']
	     */
	    var rearg = flatRest(function(func, indexes) {
	      return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
	    });

	    /**
	     * Creates a function that invokes `func` with the `this` binding of the
	     * created function and arguments from `start` and beyond provided as
	     * an array.
	     *
	     * **Note:** This method is based on the
	     * [rest parameter](https://mdn.io/rest_parameters).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Function
	     * @param {Function} func The function to apply a rest parameter to.
	     * @param {number} [start=func.length-1] The start position of the rest parameter.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var say = _.rest(function(what, names) {
	     *   return what + ' ' + _.initial(names).join(', ') +
	     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
	     * });
	     *
	     * say('hello', 'fred', 'barney', 'pebbles');
	     * // => 'hello fred, barney, & pebbles'
	     */
	    function rest(func, start) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      start = start === undefined$1 ? start : toInteger(start);
	      return baseRest(func, start);
	    }

	    /**
	     * Creates a function that invokes `func` with the `this` binding of the
	     * create function and an array of arguments much like
	     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
	     *
	     * **Note:** This method is based on the
	     * [spread operator](https://mdn.io/spread_operator).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.2.0
	     * @category Function
	     * @param {Function} func The function to spread arguments over.
	     * @param {number} [start=0] The start position of the spread.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var say = _.spread(function(who, what) {
	     *   return who + ' says ' + what;
	     * });
	     *
	     * say(['fred', 'hello']);
	     * // => 'fred says hello'
	     *
	     * var numbers = Promise.all([
	     *   Promise.resolve(40),
	     *   Promise.resolve(36)
	     * ]);
	     *
	     * numbers.then(_.spread(function(x, y) {
	     *   return x + y;
	     * }));
	     * // => a Promise of 76
	     */
	    function spread(func, start) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      start = start == null ? 0 : nativeMax(toInteger(start), 0);
	      return baseRest(function(args) {
	        var array = args[start],
	            otherArgs = castSlice(args, 0, start);

	        if (array) {
	          arrayPush(otherArgs, array);
	        }
	        return apply(func, this, otherArgs);
	      });
	    }

	    /**
	     * Creates a throttled function that only invokes `func` at most once per
	     * every `wait` milliseconds. The throttled function comes with a `cancel`
	     * method to cancel delayed `func` invocations and a `flush` method to
	     * immediately invoke them. Provide `options` to indicate whether `func`
	     * should be invoked on the leading and/or trailing edge of the `wait`
	     * timeout. The `func` is invoked with the last arguments provided to the
	     * throttled function. Subsequent calls to the throttled function return the
	     * result of the last `func` invocation.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is
	     * invoked on the trailing edge of the timeout only if the throttled function
	     * is invoked more than once during the `wait` timeout.
	     *
	     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	     *
	     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	     * for details over the differences between `_.throttle` and `_.debounce`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to throttle.
	     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
	     * @param {Object} [options={}] The options object.
	     * @param {boolean} [options.leading=true]
	     *  Specify invoking on the leading edge of the timeout.
	     * @param {boolean} [options.trailing=true]
	     *  Specify invoking on the trailing edge of the timeout.
	     * @returns {Function} Returns the new throttled function.
	     * @example
	     *
	     * // Avoid excessively updating the position while scrolling.
	     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
	     *
	     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
	     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
	     * jQuery(element).on('click', throttled);
	     *
	     * // Cancel the trailing throttled invocation.
	     * jQuery(window).on('popstate', throttled.cancel);
	     */
	    function throttle(func, wait, options) {
	      var leading = true,
	          trailing = true;

	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      if (isObject(options)) {
	        leading = 'leading' in options ? !!options.leading : leading;
	        trailing = 'trailing' in options ? !!options.trailing : trailing;
	      }
	      return debounce(func, wait, {
	        'leading': leading,
	        'maxWait': wait,
	        'trailing': trailing
	      });
	    }

	    /**
	     * Creates a function that accepts up to one argument, ignoring any
	     * additional arguments.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Function
	     * @param {Function} func The function to cap arguments for.
	     * @returns {Function} Returns the new capped function.
	     * @example
	     *
	     * _.map(['6', '8', '10'], _.unary(parseInt));
	     * // => [6, 8, 10]
	     */
	    function unary(func) {
	      return ary(func, 1);
	    }

	    /**
	     * Creates a function that provides `value` to `wrapper` as its first
	     * argument. Any additional arguments provided to the function are appended
	     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
	     * binding of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {*} value The value to wrap.
	     * @param {Function} [wrapper=identity] The wrapper function.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var p = _.wrap(_.escape, function(func, text) {
	     *   return '<p>' + func(text) + '</p>';
	     * });
	     *
	     * p('fred, barney, & pebbles');
	     * // => '<p>fred, barney, &amp; pebbles</p>'
	     */
	    function wrap(value, wrapper) {
	      return partial(castFunction(wrapper), value);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Casts `value` as an array if it's not one.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.4.0
	     * @category Lang
	     * @param {*} value The value to inspect.
	     * @returns {Array} Returns the cast array.
	     * @example
	     *
	     * _.castArray(1);
	     * // => [1]
	     *
	     * _.castArray({ 'a': 1 });
	     * // => [{ 'a': 1 }]
	     *
	     * _.castArray('abc');
	     * // => ['abc']
	     *
	     * _.castArray(null);
	     * // => [null]
	     *
	     * _.castArray(undefined);
	     * // => [undefined]
	     *
	     * _.castArray();
	     * // => []
	     *
	     * var array = [1, 2, 3];
	     * console.log(_.castArray(array) === array);
	     * // => true
	     */
	    function castArray() {
	      if (!arguments.length) {
	        return [];
	      }
	      var value = arguments[0];
	      return isArray(value) ? value : [value];
	    }

	    /**
	     * Creates a shallow clone of `value`.
	     *
	     * **Note:** This method is loosely based on the
	     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
	     * and supports cloning arrays, array buffers, booleans, date objects, maps,
	     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
	     * arrays. The own enumerable properties of `arguments` objects are cloned
	     * as plain objects. An empty object is returned for uncloneable values such
	     * as error objects, functions, DOM nodes, and WeakMaps.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to clone.
	     * @returns {*} Returns the cloned value.
	     * @see _.cloneDeep
	     * @example
	     *
	     * var objects = [{ 'a': 1 }, { 'b': 2 }];
	     *
	     * var shallow = _.clone(objects);
	     * console.log(shallow[0] === objects[0]);
	     * // => true
	     */
	    function clone(value) {
	      return baseClone(value, CLONE_SYMBOLS_FLAG);
	    }

	    /**
	     * This method is like `_.clone` except that it accepts `customizer` which
	     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
	     * cloning is handled by the method instead. The `customizer` is invoked with
	     * up to four arguments; (value [, index|key, object, stack]).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to clone.
	     * @param {Function} [customizer] The function to customize cloning.
	     * @returns {*} Returns the cloned value.
	     * @see _.cloneDeepWith
	     * @example
	     *
	     * function customizer(value) {
	     *   if (_.isElement(value)) {
	     *     return value.cloneNode(false);
	     *   }
	     * }
	     *
	     * var el = _.cloneWith(document.body, customizer);
	     *
	     * console.log(el === document.body);
	     * // => false
	     * console.log(el.nodeName);
	     * // => 'BODY'
	     * console.log(el.childNodes.length);
	     * // => 0
	     */
	    function cloneWith(value, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined$1;
	      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
	    }

	    /**
	     * This method is like `_.clone` except that it recursively clones `value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.0.0
	     * @category Lang
	     * @param {*} value The value to recursively clone.
	     * @returns {*} Returns the deep cloned value.
	     * @see _.clone
	     * @example
	     *
	     * var objects = [{ 'a': 1 }, { 'b': 2 }];
	     *
	     * var deep = _.cloneDeep(objects);
	     * console.log(deep[0] === objects[0]);
	     * // => false
	     */
	    function cloneDeep(value) {
	      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
	    }

	    /**
	     * This method is like `_.cloneWith` except that it recursively clones `value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to recursively clone.
	     * @param {Function} [customizer] The function to customize cloning.
	     * @returns {*} Returns the deep cloned value.
	     * @see _.cloneWith
	     * @example
	     *
	     * function customizer(value) {
	     *   if (_.isElement(value)) {
	     *     return value.cloneNode(true);
	     *   }
	     * }
	     *
	     * var el = _.cloneDeepWith(document.body, customizer);
	     *
	     * console.log(el === document.body);
	     * // => false
	     * console.log(el.nodeName);
	     * // => 'BODY'
	     * console.log(el.childNodes.length);
	     * // => 20
	     */
	    function cloneDeepWith(value, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined$1;
	      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
	    }

	    /**
	     * Checks if `object` conforms to `source` by invoking the predicate
	     * properties of `source` with the corresponding property values of `object`.
	     *
	     * **Note:** This method is equivalent to `_.conforms` when `source` is
	     * partially applied.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.14.0
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2 };
	     *
	     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
	     * // => true
	     *
	     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
	     * // => false
	     */
	    function conformsTo(object, source) {
	      return source == null || baseConformsTo(object, source, keys(source));
	    }

	    /**
	     * Performs a
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * comparison between two values to determine if they are equivalent.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1 };
	     * var other = { 'a': 1 };
	     *
	     * _.eq(object, object);
	     * // => true
	     *
	     * _.eq(object, other);
	     * // => false
	     *
	     * _.eq('a', 'a');
	     * // => true
	     *
	     * _.eq('a', Object('a'));
	     * // => false
	     *
	     * _.eq(NaN, NaN);
	     * // => true
	     */
	    function eq(value, other) {
	      return value === other || (value !== value && other !== other);
	    }

	    /**
	     * Checks if `value` is greater than `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than `other`,
	     *  else `false`.
	     * @see _.lt
	     * @example
	     *
	     * _.gt(3, 1);
	     * // => true
	     *
	     * _.gt(3, 3);
	     * // => false
	     *
	     * _.gt(1, 3);
	     * // => false
	     */
	    var gt = createRelationalOperation(baseGt);

	    /**
	     * Checks if `value` is greater than or equal to `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than or equal to
	     *  `other`, else `false`.
	     * @see _.lte
	     * @example
	     *
	     * _.gte(3, 1);
	     * // => true
	     *
	     * _.gte(3, 3);
	     * // => true
	     *
	     * _.gte(1, 3);
	     * // => false
	     */
	    var gte = createRelationalOperation(function(value, other) {
	      return value >= other;
	    });

	    /**
	     * Checks if `value` is likely an `arguments` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	     *  else `false`.
	     * @example
	     *
	     * _.isArguments(function() { return arguments; }());
	     * // => true
	     *
	     * _.isArguments([1, 2, 3]);
	     * // => false
	     */
	    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
	        !propertyIsEnumerable.call(value, 'callee');
	    };

	    /**
	     * Checks if `value` is classified as an `Array` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	     * @example
	     *
	     * _.isArray([1, 2, 3]);
	     * // => true
	     *
	     * _.isArray(document.body.children);
	     * // => false
	     *
	     * _.isArray('abc');
	     * // => false
	     *
	     * _.isArray(_.noop);
	     * // => false
	     */
	    var isArray = Array.isArray;

	    /**
	     * Checks if `value` is classified as an `ArrayBuffer` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
	     * @example
	     *
	     * _.isArrayBuffer(new ArrayBuffer(2));
	     * // => true
	     *
	     * _.isArrayBuffer(new Array(2));
	     * // => false
	     */
	    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

	    /**
	     * Checks if `value` is array-like. A value is considered array-like if it's
	     * not a function and has a `value.length` that's an integer greater than or
	     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	     * @example
	     *
	     * _.isArrayLike([1, 2, 3]);
	     * // => true
	     *
	     * _.isArrayLike(document.body.children);
	     * // => true
	     *
	     * _.isArrayLike('abc');
	     * // => true
	     *
	     * _.isArrayLike(_.noop);
	     * // => false
	     */
	    function isArrayLike(value) {
	      return value != null && isLength(value.length) && !isFunction(value);
	    }

	    /**
	     * This method is like `_.isArrayLike` except that it also checks if `value`
	     * is an object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array-like object,
	     *  else `false`.
	     * @example
	     *
	     * _.isArrayLikeObject([1, 2, 3]);
	     * // => true
	     *
	     * _.isArrayLikeObject(document.body.children);
	     * // => true
	     *
	     * _.isArrayLikeObject('abc');
	     * // => false
	     *
	     * _.isArrayLikeObject(_.noop);
	     * // => false
	     */
	    function isArrayLikeObject(value) {
	      return isObjectLike(value) && isArrayLike(value);
	    }

	    /**
	     * Checks if `value` is classified as a boolean primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
	     * @example
	     *
	     * _.isBoolean(false);
	     * // => true
	     *
	     * _.isBoolean(null);
	     * // => false
	     */
	    function isBoolean(value) {
	      return value === true || value === false ||
	        (isObjectLike(value) && baseGetTag(value) == boolTag);
	    }

	    /**
	     * Checks if `value` is a buffer.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	     * @example
	     *
	     * _.isBuffer(new Buffer(2));
	     * // => true
	     *
	     * _.isBuffer(new Uint8Array(2));
	     * // => false
	     */
	    var isBuffer = nativeIsBuffer || stubFalse;

	    /**
	     * Checks if `value` is classified as a `Date` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
	     * @example
	     *
	     * _.isDate(new Date);
	     * // => true
	     *
	     * _.isDate('Mon April 23 2012');
	     * // => false
	     */
	    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

	    /**
	     * Checks if `value` is likely a DOM element.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
	     * @example
	     *
	     * _.isElement(document.body);
	     * // => true
	     *
	     * _.isElement('<body>');
	     * // => false
	     */
	    function isElement(value) {
	      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
	    }

	    /**
	     * Checks if `value` is an empty object, collection, map, or set.
	     *
	     * Objects are considered empty if they have no own enumerable string keyed
	     * properties.
	     *
	     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
	     * jQuery-like collections are considered empty if they have a `length` of `0`.
	     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
	     * @example
	     *
	     * _.isEmpty(null);
	     * // => true
	     *
	     * _.isEmpty(true);
	     * // => true
	     *
	     * _.isEmpty(1);
	     * // => true
	     *
	     * _.isEmpty([1, 2, 3]);
	     * // => false
	     *
	     * _.isEmpty({ 'a': 1 });
	     * // => false
	     */
	    function isEmpty(value) {
	      if (value == null) {
	        return true;
	      }
	      if (isArrayLike(value) &&
	          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
	            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
	        return !value.length;
	      }
	      var tag = getTag(value);
	      if (tag == mapTag || tag == setTag) {
	        return !value.size;
	      }
	      if (isPrototype(value)) {
	        return !baseKeys(value).length;
	      }
	      for (var key in value) {
	        if (hasOwnProperty.call(value, key)) {
	          return false;
	        }
	      }
	      return true;
	    }

	    /**
	     * Performs a deep comparison between two values to determine if they are
	     * equivalent.
	     *
	     * **Note:** This method supports comparing arrays, array buffers, booleans,
	     * date objects, error objects, maps, numbers, `Object` objects, regexes,
	     * sets, strings, symbols, and typed arrays. `Object` objects are compared
	     * by their own, not inherited, enumerable properties. Functions and DOM
	     * nodes are compared by strict equality, i.e. `===`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1 };
	     * var other = { 'a': 1 };
	     *
	     * _.isEqual(object, other);
	     * // => true
	     *
	     * object === other;
	     * // => false
	     */
	    function isEqual(value, other) {
	      return baseIsEqual(value, other);
	    }

	    /**
	     * This method is like `_.isEqual` except that it accepts `customizer` which
	     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
	     * are handled by the method instead. The `customizer` is invoked with up to
	     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * function isGreeting(value) {
	     *   return /^h(?:i|ello)$/.test(value);
	     * }
	     *
	     * function customizer(objValue, othValue) {
	     *   if (isGreeting(objValue) && isGreeting(othValue)) {
	     *     return true;
	     *   }
	     * }
	     *
	     * var array = ['hello', 'goodbye'];
	     * var other = ['hi', 'goodbye'];
	     *
	     * _.isEqualWith(array, other, customizer);
	     * // => true
	     */
	    function isEqualWith(value, other, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined$1;
	      var result = customizer ? customizer(value, other) : undefined$1;
	      return result === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result;
	    }

	    /**
	     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
	     * `SyntaxError`, `TypeError`, or `URIError` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
	     * @example
	     *
	     * _.isError(new Error);
	     * // => true
	     *
	     * _.isError(Error);
	     * // => false
	     */
	    function isError(value) {
	      if (!isObjectLike(value)) {
	        return false;
	      }
	      var tag = baseGetTag(value);
	      return tag == errorTag || tag == domExcTag ||
	        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
	    }

	    /**
	     * Checks if `value` is a finite primitive number.
	     *
	     * **Note:** This method is based on
	     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
	     * @example
	     *
	     * _.isFinite(3);
	     * // => true
	     *
	     * _.isFinite(Number.MIN_VALUE);
	     * // => true
	     *
	     * _.isFinite(Infinity);
	     * // => false
	     *
	     * _.isFinite('3');
	     * // => false
	     */
	    function isFinite(value) {
	      return typeof value == 'number' && nativeIsFinite(value);
	    }

	    /**
	     * Checks if `value` is classified as a `Function` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	     * @example
	     *
	     * _.isFunction(_);
	     * // => true
	     *
	     * _.isFunction(/abc/);
	     * // => false
	     */
	    function isFunction(value) {
	      if (!isObject(value)) {
	        return false;
	      }
	      // The use of `Object#toString` avoids issues with the `typeof` operator
	      // in Safari 9 which returns 'object' for typed arrays and other constructors.
	      var tag = baseGetTag(value);
	      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	    }

	    /**
	     * Checks if `value` is an integer.
	     *
	     * **Note:** This method is based on
	     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
	     * @example
	     *
	     * _.isInteger(3);
	     * // => true
	     *
	     * _.isInteger(Number.MIN_VALUE);
	     * // => false
	     *
	     * _.isInteger(Infinity);
	     * // => false
	     *
	     * _.isInteger('3');
	     * // => false
	     */
	    function isInteger(value) {
	      return typeof value == 'number' && value == toInteger(value);
	    }

	    /**
	     * Checks if `value` is a valid array-like length.
	     *
	     * **Note:** This method is loosely based on
	     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	     * @example
	     *
	     * _.isLength(3);
	     * // => true
	     *
	     * _.isLength(Number.MIN_VALUE);
	     * // => false
	     *
	     * _.isLength(Infinity);
	     * // => false
	     *
	     * _.isLength('3');
	     * // => false
	     */
	    function isLength(value) {
	      return typeof value == 'number' &&
	        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	    }

	    /**
	     * Checks if `value` is the
	     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	     * @example
	     *
	     * _.isObject({});
	     * // => true
	     *
	     * _.isObject([1, 2, 3]);
	     * // => true
	     *
	     * _.isObject(_.noop);
	     * // => true
	     *
	     * _.isObject(null);
	     * // => false
	     */
	    function isObject(value) {
	      var type = typeof value;
	      return value != null && (type == 'object' || type == 'function');
	    }

	    /**
	     * Checks if `value` is object-like. A value is object-like if it's not `null`
	     * and has a `typeof` result of "object".
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	     * @example
	     *
	     * _.isObjectLike({});
	     * // => true
	     *
	     * _.isObjectLike([1, 2, 3]);
	     * // => true
	     *
	     * _.isObjectLike(_.noop);
	     * // => false
	     *
	     * _.isObjectLike(null);
	     * // => false
	     */
	    function isObjectLike(value) {
	      return value != null && typeof value == 'object';
	    }

	    /**
	     * Checks if `value` is classified as a `Map` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	     * @example
	     *
	     * _.isMap(new Map);
	     * // => true
	     *
	     * _.isMap(new WeakMap);
	     * // => false
	     */
	    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

	    /**
	     * Performs a partial deep comparison between `object` and `source` to
	     * determine if `object` contains equivalent property values.
	     *
	     * **Note:** This method is equivalent to `_.matches` when `source` is
	     * partially applied.
	     *
	     * Partial comparisons will match empty array and empty object `source`
	     * values against any array or object value, respectively. See `_.isEqual`
	     * for a list of supported value comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2 };
	     *
	     * _.isMatch(object, { 'b': 2 });
	     * // => true
	     *
	     * _.isMatch(object, { 'b': 1 });
	     * // => false
	     */
	    function isMatch(object, source) {
	      return object === source || baseIsMatch(object, source, getMatchData(source));
	    }

	    /**
	     * This method is like `_.isMatch` except that it accepts `customizer` which
	     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
	     * are handled by the method instead. The `customizer` is invoked with five
	     * arguments: (objValue, srcValue, index|key, object, source).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     * @example
	     *
	     * function isGreeting(value) {
	     *   return /^h(?:i|ello)$/.test(value);
	     * }
	     *
	     * function customizer(objValue, srcValue) {
	     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
	     *     return true;
	     *   }
	     * }
	     *
	     * var object = { 'greeting': 'hello' };
	     * var source = { 'greeting': 'hi' };
	     *
	     * _.isMatchWith(object, source, customizer);
	     * // => true
	     */
	    function isMatchWith(object, source, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined$1;
	      return baseIsMatch(object, source, getMatchData(source), customizer);
	    }

	    /**
	     * Checks if `value` is `NaN`.
	     *
	     * **Note:** This method is based on
	     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
	     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
	     * `undefined` and other non-number values.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	     * @example
	     *
	     * _.isNaN(NaN);
	     * // => true
	     *
	     * _.isNaN(new Number(NaN));
	     * // => true
	     *
	     * isNaN(undefined);
	     * // => true
	     *
	     * _.isNaN(undefined);
	     * // => false
	     */
	    function isNaN(value) {
	      // An `NaN` primitive is the only value that is not equal to itself.
	      // Perform the `toStringTag` check first to avoid errors with some
	      // ActiveX objects in IE.
	      return isNumber(value) && value != +value;
	    }

	    /**
	     * Checks if `value` is a pristine native function.
	     *
	     * **Note:** This method can't reliably detect native functions in the presence
	     * of the core-js package because core-js circumvents this kind of detection.
	     * Despite multiple requests, the core-js maintainer has made it clear: any
	     * attempt to fix the detection will be obstructed. As a result, we're left
	     * with little choice but to throw an error. Unfortunately, this also affects
	     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
	     * which rely on core-js.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a native function,
	     *  else `false`.
	     * @example
	     *
	     * _.isNative(Array.prototype.push);
	     * // => true
	     *
	     * _.isNative(_);
	     * // => false
	     */
	    function isNative(value) {
	      if (isMaskable(value)) {
	        throw new Error(CORE_ERROR_TEXT);
	      }
	      return baseIsNative(value);
	    }

	    /**
	     * Checks if `value` is `null`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
	     * @example
	     *
	     * _.isNull(null);
	     * // => true
	     *
	     * _.isNull(void 0);
	     * // => false
	     */
	    function isNull(value) {
	      return value === null;
	    }

	    /**
	     * Checks if `value` is `null` or `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
	     * @example
	     *
	     * _.isNil(null);
	     * // => true
	     *
	     * _.isNil(void 0);
	     * // => true
	     *
	     * _.isNil(NaN);
	     * // => false
	     */
	    function isNil(value) {
	      return value == null;
	    }

	    /**
	     * Checks if `value` is classified as a `Number` primitive or object.
	     *
	     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
	     * classified as numbers, use the `_.isFinite` method.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
	     * @example
	     *
	     * _.isNumber(3);
	     * // => true
	     *
	     * _.isNumber(Number.MIN_VALUE);
	     * // => true
	     *
	     * _.isNumber(Infinity);
	     * // => true
	     *
	     * _.isNumber('3');
	     * // => false
	     */
	    function isNumber(value) {
	      return typeof value == 'number' ||
	        (isObjectLike(value) && baseGetTag(value) == numberTag);
	    }

	    /**
	     * Checks if `value` is a plain object, that is, an object created by the
	     * `Object` constructor or one with a `[[Prototype]]` of `null`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.8.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * _.isPlainObject(new Foo);
	     * // => false
	     *
	     * _.isPlainObject([1, 2, 3]);
	     * // => false
	     *
	     * _.isPlainObject({ 'x': 0, 'y': 0 });
	     * // => true
	     *
	     * _.isPlainObject(Object.create(null));
	     * // => true
	     */
	    function isPlainObject(value) {
	      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
	        return false;
	      }
	      var proto = getPrototype(value);
	      if (proto === null) {
	        return true;
	      }
	      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
	        funcToString.call(Ctor) == objectCtorString;
	    }

	    /**
	     * Checks if `value` is classified as a `RegExp` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
	     * @example
	     *
	     * _.isRegExp(/abc/);
	     * // => true
	     *
	     * _.isRegExp('/abc/');
	     * // => false
	     */
	    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

	    /**
	     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
	     * double precision number which isn't the result of a rounded unsafe integer.
	     *
	     * **Note:** This method is based on
	     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
	     * @example
	     *
	     * _.isSafeInteger(3);
	     * // => true
	     *
	     * _.isSafeInteger(Number.MIN_VALUE);
	     * // => false
	     *
	     * _.isSafeInteger(Infinity);
	     * // => false
	     *
	     * _.isSafeInteger('3');
	     * // => false
	     */
	    function isSafeInteger(value) {
	      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
	    }

	    /**
	     * Checks if `value` is classified as a `Set` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	     * @example
	     *
	     * _.isSet(new Set);
	     * // => true
	     *
	     * _.isSet(new WeakSet);
	     * // => false
	     */
	    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

	    /**
	     * Checks if `value` is classified as a `String` primitive or object.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
	     * @example
	     *
	     * _.isString('abc');
	     * // => true
	     *
	     * _.isString(1);
	     * // => false
	     */
	    function isString(value) {
	      return typeof value == 'string' ||
	        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
	    }

	    /**
	     * Checks if `value` is classified as a `Symbol` primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	     * @example
	     *
	     * _.isSymbol(Symbol.iterator);
	     * // => true
	     *
	     * _.isSymbol('abc');
	     * // => false
	     */
	    function isSymbol(value) {
	      return typeof value == 'symbol' ||
	        (isObjectLike(value) && baseGetTag(value) == symbolTag);
	    }

	    /**
	     * Checks if `value` is classified as a typed array.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	     * @example
	     *
	     * _.isTypedArray(new Uint8Array);
	     * // => true
	     *
	     * _.isTypedArray([]);
	     * // => false
	     */
	    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

	    /**
	     * Checks if `value` is `undefined`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
	     * @example
	     *
	     * _.isUndefined(void 0);
	     * // => true
	     *
	     * _.isUndefined(null);
	     * // => false
	     */
	    function isUndefined(value) {
	      return value === undefined$1;
	    }

	    /**
	     * Checks if `value` is classified as a `WeakMap` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
	     * @example
	     *
	     * _.isWeakMap(new WeakMap);
	     * // => true
	     *
	     * _.isWeakMap(new Map);
	     * // => false
	     */
	    function isWeakMap(value) {
	      return isObjectLike(value) && getTag(value) == weakMapTag;
	    }

	    /**
	     * Checks if `value` is classified as a `WeakSet` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
	     * @example
	     *
	     * _.isWeakSet(new WeakSet);
	     * // => true
	     *
	     * _.isWeakSet(new Set);
	     * // => false
	     */
	    function isWeakSet(value) {
	      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
	    }

	    /**
	     * Checks if `value` is less than `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than `other`,
	     *  else `false`.
	     * @see _.gt
	     * @example
	     *
	     * _.lt(1, 3);
	     * // => true
	     *
	     * _.lt(3, 3);
	     * // => false
	     *
	     * _.lt(3, 1);
	     * // => false
	     */
	    var lt = createRelationalOperation(baseLt);

	    /**
	     * Checks if `value` is less than or equal to `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than or equal to
	     *  `other`, else `false`.
	     * @see _.gte
	     * @example
	     *
	     * _.lte(1, 3);
	     * // => true
	     *
	     * _.lte(3, 3);
	     * // => true
	     *
	     * _.lte(3, 1);
	     * // => false
	     */
	    var lte = createRelationalOperation(function(value, other) {
	      return value <= other;
	    });

	    /**
	     * Converts `value` to an array.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Array} Returns the converted array.
	     * @example
	     *
	     * _.toArray({ 'a': 1, 'b': 2 });
	     * // => [1, 2]
	     *
	     * _.toArray('abc');
	     * // => ['a', 'b', 'c']
	     *
	     * _.toArray(1);
	     * // => []
	     *
	     * _.toArray(null);
	     * // => []
	     */
	    function toArray(value) {
	      if (!value) {
	        return [];
	      }
	      if (isArrayLike(value)) {
	        return isString(value) ? stringToArray(value) : copyArray(value);
	      }
	      if (symIterator && value[symIterator]) {
	        return iteratorToArray(value[symIterator]());
	      }
	      var tag = getTag(value),
	          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

	      return func(value);
	    }

	    /**
	     * Converts `value` to a finite number.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.12.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted number.
	     * @example
	     *
	     * _.toFinite(3.2);
	     * // => 3.2
	     *
	     * _.toFinite(Number.MIN_VALUE);
	     * // => 5e-324
	     *
	     * _.toFinite(Infinity);
	     * // => 1.7976931348623157e+308
	     *
	     * _.toFinite('3.2');
	     * // => 3.2
	     */
	    function toFinite(value) {
	      if (!value) {
	        return value === 0 ? value : 0;
	      }
	      value = toNumber(value);
	      if (value === INFINITY || value === -INFINITY) {
	        var sign = (value < 0 ? -1 : 1);
	        return sign * MAX_INTEGER;
	      }
	      return value === value ? value : 0;
	    }

	    /**
	     * Converts `value` to an integer.
	     *
	     * **Note:** This method is loosely based on
	     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.toInteger(3.2);
	     * // => 3
	     *
	     * _.toInteger(Number.MIN_VALUE);
	     * // => 0
	     *
	     * _.toInteger(Infinity);
	     * // => 1.7976931348623157e+308
	     *
	     * _.toInteger('3.2');
	     * // => 3
	     */
	    function toInteger(value) {
	      var result = toFinite(value),
	          remainder = result % 1;

	      return result === result ? (remainder ? result - remainder : result) : 0;
	    }

	    /**
	     * Converts `value` to an integer suitable for use as the length of an
	     * array-like object.
	     *
	     * **Note:** This method is based on
	     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.toLength(3.2);
	     * // => 3
	     *
	     * _.toLength(Number.MIN_VALUE);
	     * // => 0
	     *
	     * _.toLength(Infinity);
	     * // => 4294967295
	     *
	     * _.toLength('3.2');
	     * // => 3
	     */
	    function toLength(value) {
	      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
	    }

	    /**
	     * Converts `value` to a number.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to process.
	     * @returns {number} Returns the number.
	     * @example
	     *
	     * _.toNumber(3.2);
	     * // => 3.2
	     *
	     * _.toNumber(Number.MIN_VALUE);
	     * // => 5e-324
	     *
	     * _.toNumber(Infinity);
	     * // => Infinity
	     *
	     * _.toNumber('3.2');
	     * // => 3.2
	     */
	    function toNumber(value) {
	      if (typeof value == 'number') {
	        return value;
	      }
	      if (isSymbol(value)) {
	        return NAN;
	      }
	      if (isObject(value)) {
	        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	        value = isObject(other) ? (other + '') : other;
	      }
	      if (typeof value != 'string') {
	        return value === 0 ? value : +value;
	      }
	      value = baseTrim(value);
	      var isBinary = reIsBinary.test(value);
	      return (isBinary || reIsOctal.test(value))
	        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	        : (reIsBadHex.test(value) ? NAN : +value);
	    }

	    /**
	     * Converts `value` to a plain object flattening inherited enumerable string
	     * keyed properties of `value` to own properties of the plain object.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Object} Returns the converted plain object.
	     * @example
	     *
	     * function Foo() {
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.assign({ 'a': 1 }, new Foo);
	     * // => { 'a': 1, 'b': 2 }
	     *
	     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	     * // => { 'a': 1, 'b': 2, 'c': 3 }
	     */
	    function toPlainObject(value) {
	      return copyObject(value, keysIn(value));
	    }

	    /**
	     * Converts `value` to a safe integer. A safe integer can be compared and
	     * represented correctly.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.toSafeInteger(3.2);
	     * // => 3
	     *
	     * _.toSafeInteger(Number.MIN_VALUE);
	     * // => 0
	     *
	     * _.toSafeInteger(Infinity);
	     * // => 9007199254740991
	     *
	     * _.toSafeInteger('3.2');
	     * // => 3
	     */
	    function toSafeInteger(value) {
	      return value
	        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
	        : (value === 0 ? value : 0);
	    }

	    /**
	     * Converts `value` to a string. An empty string is returned for `null`
	     * and `undefined` values. The sign of `-0` is preserved.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {string} Returns the converted string.
	     * @example
	     *
	     * _.toString(null);
	     * // => ''
	     *
	     * _.toString(-0);
	     * // => '-0'
	     *
	     * _.toString([1, 2, 3]);
	     * // => '1,2,3'
	     */
	    function toString(value) {
	      return value == null ? '' : baseToString(value);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Assigns own enumerable string keyed properties of source objects to the
	     * destination object. Source objects are applied from left to right.
	     * Subsequent sources overwrite property assignments of previous sources.
	     *
	     * **Note:** This method mutates `object` and is loosely based on
	     * [`Object.assign`](https://mdn.io/Object/assign).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.10.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.assignIn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * function Bar() {
	     *   this.c = 3;
	     * }
	     *
	     * Foo.prototype.b = 2;
	     * Bar.prototype.d = 4;
	     *
	     * _.assign({ 'a': 0 }, new Foo, new Bar);
	     * // => { 'a': 1, 'c': 3 }
	     */
	    var assign = createAssigner(function(object, source) {
	      if (isPrototype(source) || isArrayLike(source)) {
	        copyObject(source, keys(source), object);
	        return;
	      }
	      for (var key in source) {
	        if (hasOwnProperty.call(source, key)) {
	          assignValue(object, key, source[key]);
	        }
	      }
	    });

	    /**
	     * This method is like `_.assign` except that it iterates over own and
	     * inherited source properties.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias extend
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.assign
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * function Bar() {
	     *   this.c = 3;
	     * }
	     *
	     * Foo.prototype.b = 2;
	     * Bar.prototype.d = 4;
	     *
	     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
	     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
	     */
	    var assignIn = createAssigner(function(object, source) {
	      copyObject(source, keysIn(source), object);
	    });

	    /**
	     * This method is like `_.assignIn` except that it accepts `customizer`
	     * which is invoked to produce the assigned values. If `customizer` returns
	     * `undefined`, assignment is handled by the method instead. The `customizer`
	     * is invoked with five arguments: (objValue, srcValue, key, object, source).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias extendWith
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} sources The source objects.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @see _.assignWith
	     * @example
	     *
	     * function customizer(objValue, srcValue) {
	     *   return _.isUndefined(objValue) ? srcValue : objValue;
	     * }
	     *
	     * var defaults = _.partialRight(_.assignInWith, customizer);
	     *
	     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	     * // => { 'a': 1, 'b': 2 }
	     */
	    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
	      copyObject(source, keysIn(source), object, customizer);
	    });

	    /**
	     * This method is like `_.assign` except that it accepts `customizer`
	     * which is invoked to produce the assigned values. If `customizer` returns
	     * `undefined`, assignment is handled by the method instead. The `customizer`
	     * is invoked with five arguments: (objValue, srcValue, key, object, source).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} sources The source objects.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @see _.assignInWith
	     * @example
	     *
	     * function customizer(objValue, srcValue) {
	     *   return _.isUndefined(objValue) ? srcValue : objValue;
	     * }
	     *
	     * var defaults = _.partialRight(_.assignWith, customizer);
	     *
	     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	     * // => { 'a': 1, 'b': 2 }
	     */
	    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
	      copyObject(source, keys(source), object, customizer);
	    });

	    /**
	     * Creates an array of values corresponding to `paths` of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.0.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {...(string|string[])} [paths] The property paths to pick.
	     * @returns {Array} Returns the picked values.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
	     *
	     * _.at(object, ['a[0].b.c', 'a[1]']);
	     * // => [3, 4]
	     */
	    var at = flatRest(baseAt);

	    /**
	     * Creates an object that inherits from the `prototype` object. If a
	     * `properties` object is given, its own enumerable string keyed properties
	     * are assigned to the created object.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.3.0
	     * @category Object
	     * @param {Object} prototype The object to inherit from.
	     * @param {Object} [properties] The properties to assign to the object.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * function Shape() {
	     *   this.x = 0;
	     *   this.y = 0;
	     * }
	     *
	     * function Circle() {
	     *   Shape.call(this);
	     * }
	     *
	     * Circle.prototype = _.create(Shape.prototype, {
	     *   'constructor': Circle
	     * });
	     *
	     * var circle = new Circle;
	     * circle instanceof Circle;
	     * // => true
	     *
	     * circle instanceof Shape;
	     * // => true
	     */
	    function create(prototype, properties) {
	      var result = baseCreate(prototype);
	      return properties == null ? result : baseAssign(result, properties);
	    }

	    /**
	     * Assigns own and inherited enumerable string keyed properties of source
	     * objects to the destination object for all destination properties that
	     * resolve to `undefined`. Source objects are applied from left to right.
	     * Once a property is set, additional values of the same property are ignored.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.defaultsDeep
	     * @example
	     *
	     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	     * // => { 'a': 1, 'b': 2 }
	     */
	    var defaults = baseRest(function(object, sources) {
	      object = Object(object);

	      var index = -1;
	      var length = sources.length;
	      var guard = length > 2 ? sources[2] : undefined$1;

	      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	        length = 1;
	      }

	      while (++index < length) {
	        var source = sources[index];
	        var props = keysIn(source);
	        var propsIndex = -1;
	        var propsLength = props.length;

	        while (++propsIndex < propsLength) {
	          var key = props[propsIndex];
	          var value = object[key];

	          if (value === undefined$1 ||
	              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
	            object[key] = source[key];
	          }
	        }
	      }

	      return object;
	    });

	    /**
	     * This method is like `_.defaults` except that it recursively assigns
	     * default properties.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.defaults
	     * @example
	     *
	     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
	     * // => { 'a': { 'b': 2, 'c': 3 } }
	     */
	    var defaultsDeep = baseRest(function(args) {
	      args.push(undefined$1, customDefaultsMerge);
	      return apply(mergeWith, undefined$1, args);
	    });

	    /**
	     * This method is like `_.find` except that it returns the key of the first
	     * element `predicate` returns truthy for instead of the element itself.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.1.0
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {string|undefined} Returns the key of the matched element,
	     *  else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findKey(users, function(o) { return o.age < 40; });
	     * // => 'barney' (iteration order is not guaranteed)
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findKey(users, { 'age': 1, 'active': true });
	     * // => 'pebbles'
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findKey(users, ['active', false]);
	     * // => 'fred'
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findKey(users, 'active');
	     * // => 'barney'
	     */
	    function findKey(object, predicate) {
	      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
	    }

	    /**
	     * This method is like `_.findKey` except that it iterates over elements of
	     * a collection in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {string|undefined} Returns the key of the matched element,
	     *  else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findLastKey(users, function(o) { return o.age < 40; });
	     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findLastKey(users, { 'age': 36, 'active': true });
	     * // => 'barney'
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findLastKey(users, ['active', false]);
	     * // => 'fred'
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findLastKey(users, 'active');
	     * // => 'pebbles'
	     */
	    function findLastKey(object, predicate) {
	      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
	    }

	    /**
	     * Iterates over own and inherited enumerable string keyed properties of an
	     * object and invokes `iteratee` for each property. The iteratee is invoked
	     * with three arguments: (value, key, object). Iteratee functions may exit
	     * iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.3.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forInRight
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forIn(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
	     */
	    function forIn(object, iteratee) {
	      return object == null
	        ? object
	        : baseFor(object, getIteratee(iteratee, 3), keysIn);
	    }

	    /**
	     * This method is like `_.forIn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forIn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forInRight(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
	     */
	    function forInRight(object, iteratee) {
	      return object == null
	        ? object
	        : baseForRight(object, getIteratee(iteratee, 3), keysIn);
	    }

	    /**
	     * Iterates over own enumerable string keyed properties of an object and
	     * invokes `iteratee` for each property. The iteratee is invoked with three
	     * arguments: (value, key, object). Iteratee functions may exit iteration
	     * early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.3.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forOwnRight
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forOwn(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
	     */
	    function forOwn(object, iteratee) {
	      return object && baseForOwn(object, getIteratee(iteratee, 3));
	    }

	    /**
	     * This method is like `_.forOwn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forOwn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forOwnRight(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
	     */
	    function forOwnRight(object, iteratee) {
	      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
	    }

	    /**
	     * Creates an array of function property names from own enumerable properties
	     * of `object`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the function names.
	     * @see _.functionsIn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = _.constant('a');
	     *   this.b = _.constant('b');
	     * }
	     *
	     * Foo.prototype.c = _.constant('c');
	     *
	     * _.functions(new Foo);
	     * // => ['a', 'b']
	     */
	    function functions(object) {
	      return object == null ? [] : baseFunctions(object, keys(object));
	    }

	    /**
	     * Creates an array of function property names from own and inherited
	     * enumerable properties of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the function names.
	     * @see _.functions
	     * @example
	     *
	     * function Foo() {
	     *   this.a = _.constant('a');
	     *   this.b = _.constant('b');
	     * }
	     *
	     * Foo.prototype.c = _.constant('c');
	     *
	     * _.functionsIn(new Foo);
	     * // => ['a', 'b', 'c']
	     */
	    function functionsIn(object) {
	      return object == null ? [] : baseFunctions(object, keysIn(object));
	    }

	    /**
	     * Gets the value at `path` of `object`. If the resolved value is
	     * `undefined`, the `defaultValue` is returned in its place.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to get.
	     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.get(object, 'a[0].b.c');
	     * // => 3
	     *
	     * _.get(object, ['a', '0', 'b', 'c']);
	     * // => 3
	     *
	     * _.get(object, 'a.b.c', 'default');
	     * // => 'default'
	     */
	    function get(object, path, defaultValue) {
	      var result = object == null ? undefined$1 : baseGet(object, path);
	      return result === undefined$1 ? defaultValue : result;
	    }

	    /**
	     * Checks if `path` is a direct property of `object`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
	     * @example
	     *
	     * var object = { 'a': { 'b': 2 } };
	     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
	     *
	     * _.has(object, 'a');
	     * // => true
	     *
	     * _.has(object, 'a.b');
	     * // => true
	     *
	     * _.has(object, ['a', 'b']);
	     * // => true
	     *
	     * _.has(other, 'a');
	     * // => false
	     */
	    function has(object, path) {
	      return object != null && hasPath(object, path, baseHas);
	    }

	    /**
	     * Checks if `path` is a direct or inherited property of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
	     * @example
	     *
	     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
	     *
	     * _.hasIn(object, 'a');
	     * // => true
	     *
	     * _.hasIn(object, 'a.b');
	     * // => true
	     *
	     * _.hasIn(object, ['a', 'b']);
	     * // => true
	     *
	     * _.hasIn(object, 'b');
	     * // => false
	     */
	    function hasIn(object, path) {
	      return object != null && hasPath(object, path, baseHasIn);
	    }

	    /**
	     * Creates an object composed of the inverted keys and values of `object`.
	     * If `object` contains duplicate values, subsequent values overwrite
	     * property assignments of previous values.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.7.0
	     * @category Object
	     * @param {Object} object The object to invert.
	     * @returns {Object} Returns the new inverted object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2, 'c': 1 };
	     *
	     * _.invert(object);
	     * // => { '1': 'c', '2': 'b' }
	     */
	    var invert = createInverter(function(result, value, key) {
	      if (value != null &&
	          typeof value.toString != 'function') {
	        value = nativeObjectToString.call(value);
	      }

	      result[value] = key;
	    }, constant(identity));

	    /**
	     * This method is like `_.invert` except that the inverted object is generated
	     * from the results of running each element of `object` thru `iteratee`. The
	     * corresponding inverted value of each inverted key is an array of keys
	     * responsible for generating the inverted value. The iteratee is invoked
	     * with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.1.0
	     * @category Object
	     * @param {Object} object The object to invert.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Object} Returns the new inverted object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2, 'c': 1 };
	     *
	     * _.invertBy(object);
	     * // => { '1': ['a', 'c'], '2': ['b'] }
	     *
	     * _.invertBy(object, function(value) {
	     *   return 'group' + value;
	     * });
	     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
	     */
	    var invertBy = createInverter(function(result, value, key) {
	      if (value != null &&
	          typeof value.toString != 'function') {
	        value = nativeObjectToString.call(value);
	      }

	      if (hasOwnProperty.call(result, value)) {
	        result[value].push(key);
	      } else {
	        result[value] = [key];
	      }
	    }, getIteratee);

	    /**
	     * Invokes the method at `path` of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {*} Returns the result of the invoked method.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
	     *
	     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
	     * // => [2, 3]
	     */
	    var invoke = baseRest(baseInvoke);

	    /**
	     * Creates an array of the own enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects. See the
	     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	     * for more details.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keys(new Foo);
	     * // => ['a', 'b'] (iteration order is not guaranteed)
	     *
	     * _.keys('hi');
	     * // => ['0', '1']
	     */
	    function keys(object) {
	      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	    }

	    /**
	     * Creates an array of the own and inherited enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keysIn(new Foo);
	     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	     */
	    function keysIn(object) {
	      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
	    }

	    /**
	     * The opposite of `_.mapValues`; this method creates an object with the
	     * same values as `object` and keys generated by running each own enumerable
	     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
	     * with three arguments: (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.8.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns the new mapped object.
	     * @see _.mapValues
	     * @example
	     *
	     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
	     *   return key + value;
	     * });
	     * // => { 'a1': 1, 'b2': 2 }
	     */
	    function mapKeys(object, iteratee) {
	      var result = {};
	      iteratee = getIteratee(iteratee, 3);

	      baseForOwn(object, function(value, key, object) {
	        baseAssignValue(result, iteratee(value, key, object), value);
	      });
	      return result;
	    }

	    /**
	     * Creates an object with the same keys as `object` and values generated
	     * by running each own enumerable string keyed property of `object` thru
	     * `iteratee`. The iteratee is invoked with three arguments:
	     * (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns the new mapped object.
	     * @see _.mapKeys
	     * @example
	     *
	     * var users = {
	     *   'fred':    { 'user': 'fred',    'age': 40 },
	     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
	     * };
	     *
	     * _.mapValues(users, function(o) { return o.age; });
	     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.mapValues(users, 'age');
	     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	     */
	    function mapValues(object, iteratee) {
	      var result = {};
	      iteratee = getIteratee(iteratee, 3);

	      baseForOwn(object, function(value, key, object) {
	        baseAssignValue(result, key, iteratee(value, key, object));
	      });
	      return result;
	    }

	    /**
	     * This method is like `_.assign` except that it recursively merges own and
	     * inherited enumerable string keyed properties of source objects into the
	     * destination object. Source properties that resolve to `undefined` are
	     * skipped if a destination value exists. Array and plain object properties
	     * are merged recursively. Other objects and value types are overridden by
	     * assignment. Source objects are applied from left to right. Subsequent
	     * sources overwrite property assignments of previous sources.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.5.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = {
	     *   'a': [{ 'b': 2 }, { 'd': 4 }]
	     * };
	     *
	     * var other = {
	     *   'a': [{ 'c': 3 }, { 'e': 5 }]
	     * };
	     *
	     * _.merge(object, other);
	     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
	     */
	    var merge = createAssigner(function(object, source, srcIndex) {
	      baseMerge(object, source, srcIndex);
	    });

	    /**
	     * This method is like `_.merge` except that it accepts `customizer` which
	     * is invoked to produce the merged values of the destination and source
	     * properties. If `customizer` returns `undefined`, merging is handled by the
	     * method instead. The `customizer` is invoked with six arguments:
	     * (objValue, srcValue, key, object, source, stack).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} sources The source objects.
	     * @param {Function} customizer The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function customizer(objValue, srcValue) {
	     *   if (_.isArray(objValue)) {
	     *     return objValue.concat(srcValue);
	     *   }
	     * }
	     *
	     * var object = { 'a': [1], 'b': [2] };
	     * var other = { 'a': [3], 'b': [4] };
	     *
	     * _.mergeWith(object, other, customizer);
	     * // => { 'a': [1, 3], 'b': [2, 4] }
	     */
	    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
	      baseMerge(object, source, srcIndex, customizer);
	    });

	    /**
	     * The opposite of `_.pick`; this method creates an object composed of the
	     * own and inherited enumerable property paths of `object` that are not omitted.
	     *
	     * **Note:** This method is considerably slower than `_.pick`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {...(string|string[])} [paths] The property paths to omit.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.omit(object, ['a', 'c']);
	     * // => { 'b': '2' }
	     */
	    var omit = flatRest(function(object, paths) {
	      var result = {};
	      if (object == null) {
	        return result;
	      }
	      var isDeep = false;
	      paths = arrayMap(paths, function(path) {
	        path = castPath(path, object);
	        isDeep || (isDeep = path.length > 1);
	        return path;
	      });
	      copyObject(object, getAllKeysIn(object), result);
	      if (isDeep) {
	        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
	      }
	      var length = paths.length;
	      while (length--) {
	        baseUnset(result, paths[length]);
	      }
	      return result;
	    });

	    /**
	     * The opposite of `_.pickBy`; this method creates an object composed of
	     * the own and inherited enumerable string keyed properties of `object` that
	     * `predicate` doesn't return truthy for. The predicate is invoked with two
	     * arguments: (value, key).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Function} [predicate=_.identity] The function invoked per property.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.omitBy(object, _.isNumber);
	     * // => { 'b': '2' }
	     */
	    function omitBy(object, predicate) {
	      return pickBy(object, negate(getIteratee(predicate)));
	    }

	    /**
	     * Creates an object composed of the picked `object` properties.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {...(string|string[])} [paths] The property paths to pick.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.pick(object, ['a', 'c']);
	     * // => { 'a': 1, 'c': 3 }
	     */
	    var pick = flatRest(function(object, paths) {
	      return object == null ? {} : basePick(object, paths);
	    });

	    /**
	     * Creates an object composed of the `object` properties `predicate` returns
	     * truthy for. The predicate is invoked with two arguments: (value, key).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Function} [predicate=_.identity] The function invoked per property.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.pickBy(object, _.isNumber);
	     * // => { 'a': 1, 'c': 3 }
	     */
	    function pickBy(object, predicate) {
	      if (object == null) {
	        return {};
	      }
	      var props = arrayMap(getAllKeysIn(object), function(prop) {
	        return [prop];
	      });
	      predicate = getIteratee(predicate);
	      return basePickBy(object, props, function(value, path) {
	        return predicate(value, path[0]);
	      });
	    }

	    /**
	     * This method is like `_.get` except that if the resolved value is a
	     * function it's invoked with the `this` binding of its parent object and
	     * its result is returned.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to resolve.
	     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
	     *
	     * _.result(object, 'a[0].b.c1');
	     * // => 3
	     *
	     * _.result(object, 'a[0].b.c2');
	     * // => 4
	     *
	     * _.result(object, 'a[0].b.c3', 'default');
	     * // => 'default'
	     *
	     * _.result(object, 'a[0].b.c3', _.constant('default'));
	     * // => 'default'
	     */
	    function result(object, path, defaultValue) {
	      path = castPath(path, object);

	      var index = -1,
	          length = path.length;

	      // Ensure the loop is entered when path is empty.
	      if (!length) {
	        length = 1;
	        object = undefined$1;
	      }
	      while (++index < length) {
	        var value = object == null ? undefined$1 : object[toKey(path[index])];
	        if (value === undefined$1) {
	          index = length;
	          value = defaultValue;
	        }
	        object = isFunction(value) ? value.call(object) : value;
	      }
	      return object;
	    }

	    /**
	     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
	     * it's created. Arrays are created for missing index properties while objects
	     * are created for all other missing properties. Use `_.setWith` to customize
	     * `path` creation.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.set(object, 'a[0].b.c', 4);
	     * console.log(object.a[0].b.c);
	     * // => 4
	     *
	     * _.set(object, ['x', '0', 'y', 'z'], 5);
	     * console.log(object.x[0].y.z);
	     * // => 5
	     */
	    function set(object, path, value) {
	      return object == null ? object : baseSet(object, path, value);
	    }

	    /**
	     * This method is like `_.set` except that it accepts `customizer` which is
	     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
	     * path creation is handled by the method instead. The `customizer` is invoked
	     * with three arguments: (nsValue, key, nsObject).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = {};
	     *
	     * _.setWith(object, '[0][1]', 'a', Object);
	     * // => { '0': { '1': 'a' } }
	     */
	    function setWith(object, path, value, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined$1;
	      return object == null ? object : baseSet(object, path, value, customizer);
	    }

	    /**
	     * Creates an array of own enumerable string keyed-value pairs for `object`
	     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
	     * entries are returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias entries
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the key-value pairs.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.toPairs(new Foo);
	     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
	     */
	    var toPairs = createToPairs(keys);

	    /**
	     * Creates an array of own and inherited enumerable string keyed-value pairs
	     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
	     * or set, its entries are returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias entriesIn
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the key-value pairs.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.toPairsIn(new Foo);
	     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
	     */
	    var toPairsIn = createToPairs(keysIn);

	    /**
	     * An alternative to `_.reduce`; this method transforms `object` to a new
	     * `accumulator` object which is the result of running each of its own
	     * enumerable string keyed properties thru `iteratee`, with each invocation
	     * potentially mutating the `accumulator` object. If `accumulator` is not
	     * provided, a new object with the same `[[Prototype]]` will be used. The
	     * iteratee is invoked with four arguments: (accumulator, value, key, object).
	     * Iteratee functions may exit iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.3.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The custom accumulator value.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * _.transform([2, 3, 4], function(result, n) {
	     *   result.push(n *= n);
	     *   return n % 2 == 0;
	     * }, []);
	     * // => [4, 9]
	     *
	     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
	     *   (result[value] || (result[value] = [])).push(key);
	     * }, {});
	     * // => { '1': ['a', 'c'], '2': ['b'] }
	     */
	    function transform(object, iteratee, accumulator) {
	      var isArr = isArray(object),
	          isArrLike = isArr || isBuffer(object) || isTypedArray(object);

	      iteratee = getIteratee(iteratee, 4);
	      if (accumulator == null) {
	        var Ctor = object && object.constructor;
	        if (isArrLike) {
	          accumulator = isArr ? new Ctor : [];
	        }
	        else if (isObject(object)) {
	          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
	        }
	        else {
	          accumulator = {};
	        }
	      }
	      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
	        return iteratee(accumulator, value, index, object);
	      });
	      return accumulator;
	    }

	    /**
	     * Removes the property at `path` of `object`.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to unset.
	     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
	     * _.unset(object, 'a[0].b.c');
	     * // => true
	     *
	     * console.log(object);
	     * // => { 'a': [{ 'b': {} }] };
	     *
	     * _.unset(object, ['a', '0', 'b', 'c']);
	     * // => true
	     *
	     * console.log(object);
	     * // => { 'a': [{ 'b': {} }] };
	     */
	    function unset(object, path) {
	      return object == null ? true : baseUnset(object, path);
	    }

	    /**
	     * This method is like `_.set` except that accepts `updater` to produce the
	     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
	     * is invoked with one argument: (value).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.6.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {Function} updater The function to produce the updated value.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
	     * console.log(object.a[0].b.c);
	     * // => 9
	     *
	     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
	     * console.log(object.x[0].y.z);
	     * // => 0
	     */
	    function update(object, path, updater) {
	      return object == null ? object : baseUpdate(object, path, castFunction(updater));
	    }

	    /**
	     * This method is like `_.update` except that it accepts `customizer` which is
	     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
	     * path creation is handled by the method instead. The `customizer` is invoked
	     * with three arguments: (nsValue, key, nsObject).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.6.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {Function} updater The function to produce the updated value.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = {};
	     *
	     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
	     * // => { '0': { '1': 'a' } }
	     */
	    function updateWith(object, path, updater, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined$1;
	      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
	    }

	    /**
	     * Creates an array of the own enumerable string keyed property values of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.values(new Foo);
	     * // => [1, 2] (iteration order is not guaranteed)
	     *
	     * _.values('hi');
	     * // => ['h', 'i']
	     */
	    function values(object) {
	      return object == null ? [] : baseValues(object, keys(object));
	    }

	    /**
	     * Creates an array of the own and inherited enumerable string keyed property
	     * values of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.valuesIn(new Foo);
	     * // => [1, 2, 3] (iteration order is not guaranteed)
	     */
	    function valuesIn(object) {
	      return object == null ? [] : baseValues(object, keysIn(object));
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Clamps `number` within the inclusive `lower` and `upper` bounds.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Number
	     * @param {number} number The number to clamp.
	     * @param {number} [lower] The lower bound.
	     * @param {number} upper The upper bound.
	     * @returns {number} Returns the clamped number.
	     * @example
	     *
	     * _.clamp(-10, -5, 5);
	     * // => -5
	     *
	     * _.clamp(10, -5, 5);
	     * // => 5
	     */
	    function clamp(number, lower, upper) {
	      if (upper === undefined$1) {
	        upper = lower;
	        lower = undefined$1;
	      }
	      if (upper !== undefined$1) {
	        upper = toNumber(upper);
	        upper = upper === upper ? upper : 0;
	      }
	      if (lower !== undefined$1) {
	        lower = toNumber(lower);
	        lower = lower === lower ? lower : 0;
	      }
	      return baseClamp(toNumber(number), lower, upper);
	    }

	    /**
	     * Checks if `n` is between `start` and up to, but not including, `end`. If
	     * `end` is not specified, it's set to `start` with `start` then set to `0`.
	     * If `start` is greater than `end` the params are swapped to support
	     * negative ranges.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.3.0
	     * @category Number
	     * @param {number} number The number to check.
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
	     * @see _.range, _.rangeRight
	     * @example
	     *
	     * _.inRange(3, 2, 4);
	     * // => true
	     *
	     * _.inRange(4, 8);
	     * // => true
	     *
	     * _.inRange(4, 2);
	     * // => false
	     *
	     * _.inRange(2, 2);
	     * // => false
	     *
	     * _.inRange(1.2, 2);
	     * // => true
	     *
	     * _.inRange(5.2, 4);
	     * // => false
	     *
	     * _.inRange(-3, -2, -6);
	     * // => true
	     */
	    function inRange(number, start, end) {
	      start = toFinite(start);
	      if (end === undefined$1) {
	        end = start;
	        start = 0;
	      } else {
	        end = toFinite(end);
	      }
	      number = toNumber(number);
	      return baseInRange(number, start, end);
	    }

	    /**
	     * Produces a random number between the inclusive `lower` and `upper` bounds.
	     * If only one argument is provided a number between `0` and the given number
	     * is returned. If `floating` is `true`, or either `lower` or `upper` are
	     * floats, a floating-point number is returned instead of an integer.
	     *
	     * **Note:** JavaScript follows the IEEE-754 standard for resolving
	     * floating-point values which can produce unexpected results.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.7.0
	     * @category Number
	     * @param {number} [lower=0] The lower bound.
	     * @param {number} [upper=1] The upper bound.
	     * @param {boolean} [floating] Specify returning a floating-point number.
	     * @returns {number} Returns the random number.
	     * @example
	     *
	     * _.random(0, 5);
	     * // => an integer between 0 and 5
	     *
	     * _.random(5);
	     * // => also an integer between 0 and 5
	     *
	     * _.random(5, true);
	     * // => a floating-point number between 0 and 5
	     *
	     * _.random(1.2, 5.2);
	     * // => a floating-point number between 1.2 and 5.2
	     */
	    function random(lower, upper, floating) {
	      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
	        upper = floating = undefined$1;
	      }
	      if (floating === undefined$1) {
	        if (typeof upper == 'boolean') {
	          floating = upper;
	          upper = undefined$1;
	        }
	        else if (typeof lower == 'boolean') {
	          floating = lower;
	          lower = undefined$1;
	        }
	      }
	      if (lower === undefined$1 && upper === undefined$1) {
	        lower = 0;
	        upper = 1;
	      }
	      else {
	        lower = toFinite(lower);
	        if (upper === undefined$1) {
	          upper = lower;
	          lower = 0;
	        } else {
	          upper = toFinite(upper);
	        }
	      }
	      if (lower > upper) {
	        var temp = lower;
	        lower = upper;
	        upper = temp;
	      }
	      if (floating || lower % 1 || upper % 1) {
	        var rand = nativeRandom();
	        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
	      }
	      return baseRandom(lower, upper);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the camel cased string.
	     * @example
	     *
	     * _.camelCase('Foo Bar');
	     * // => 'fooBar'
	     *
	     * _.camelCase('--foo-bar--');
	     * // => 'fooBar'
	     *
	     * _.camelCase('__FOO_BAR__');
	     * // => 'fooBar'
	     */
	    var camelCase = createCompounder(function(result, word, index) {
	      word = word.toLowerCase();
	      return result + (index ? capitalize(word) : word);
	    });

	    /**
	     * Converts the first character of `string` to upper case and the remaining
	     * to lower case.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to capitalize.
	     * @returns {string} Returns the capitalized string.
	     * @example
	     *
	     * _.capitalize('FRED');
	     * // => 'Fred'
	     */
	    function capitalize(string) {
	      return upperFirst(toString(string).toLowerCase());
	    }

	    /**
	     * Deburrs `string` by converting
	     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
	     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
	     * letters to basic Latin letters and removing
	     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to deburr.
	     * @returns {string} Returns the deburred string.
	     * @example
	     *
	     * _.deburr('dj vu');
	     * // => 'deja vu'
	     */
	    function deburr(string) {
	      string = toString(string);
	      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
	    }

	    /**
	     * Checks if `string` ends with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=string.length] The position to search up to.
	     * @returns {boolean} Returns `true` if `string` ends with `target`,
	     *  else `false`.
	     * @example
	     *
	     * _.endsWith('abc', 'c');
	     * // => true
	     *
	     * _.endsWith('abc', 'b');
	     * // => false
	     *
	     * _.endsWith('abc', 'b', 2);
	     * // => true
	     */
	    function endsWith(string, target, position) {
	      string = toString(string);
	      target = baseToString(target);

	      var length = string.length;
	      position = position === undefined$1
	        ? length
	        : baseClamp(toInteger(position), 0, length);

	      var end = position;
	      position -= target.length;
	      return position >= 0 && string.slice(position, end) == target;
	    }

	    /**
	     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
	     * corresponding HTML entities.
	     *
	     * **Note:** No other characters are escaped. To escape additional
	     * characters use a third-party library like [_he_](https://mths.be/he).
	     *
	     * Though the ">" character is escaped for symmetry, characters like
	     * ">" and "/" don't need escaping in HTML and have no special meaning
	     * unless they're part of a tag or unquoted attribute value. See
	     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
	     * (under "semi-related fun fact") for more details.
	     *
	     * When working with HTML you should always
	     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
	     * XSS vectors.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escape('fred, barney, & pebbles');
	     * // => 'fred, barney, &amp; pebbles'
	     */
	    function escape(string) {
	      string = toString(string);
	      return (string && reHasUnescapedHtml.test(string))
	        ? string.replace(reUnescapedHtml, escapeHtmlChar)
	        : string;
	    }

	    /**
	     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
	     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escapeRegExp('[lodash](https://lodash.com/)');
	     * // => '\[lodash\]\(https://lodash\.com/\)'
	     */
	    function escapeRegExp(string) {
	      string = toString(string);
	      return (string && reHasRegExpChar.test(string))
	        ? string.replace(reRegExpChar, '\\$&')
	        : string;
	    }

	    /**
	     * Converts `string` to
	     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the kebab cased string.
	     * @example
	     *
	     * _.kebabCase('Foo Bar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('fooBar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('__FOO_BAR__');
	     * // => 'foo-bar'
	     */
	    var kebabCase = createCompounder(function(result, word, index) {
	      return result + (index ? '-' : '') + word.toLowerCase();
	    });

	    /**
	     * Converts `string`, as space separated words, to lower case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the lower cased string.
	     * @example
	     *
	     * _.lowerCase('--Foo-Bar--');
	     * // => 'foo bar'
	     *
	     * _.lowerCase('fooBar');
	     * // => 'foo bar'
	     *
	     * _.lowerCase('__FOO_BAR__');
	     * // => 'foo bar'
	     */
	    var lowerCase = createCompounder(function(result, word, index) {
	      return result + (index ? ' ' : '') + word.toLowerCase();
	    });

	    /**
	     * Converts the first character of `string` to lower case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the converted string.
	     * @example
	     *
	     * _.lowerFirst('Fred');
	     * // => 'fred'
	     *
	     * _.lowerFirst('FRED');
	     * // => 'fRED'
	     */
	    var lowerFirst = createCaseFirst('toLowerCase');

	    /**
	     * Pads `string` on the left and right sides if it's shorter than `length`.
	     * Padding characters are truncated if they can't be evenly divided by `length`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.pad('abc', 8);
	     * // => '  abc   '
	     *
	     * _.pad('abc', 8, '_-');
	     * // => '_-abc_-_'
	     *
	     * _.pad('abc', 3);
	     * // => 'abc'
	     */
	    function pad(string, length, chars) {
	      string = toString(string);
	      length = toInteger(length);

	      var strLength = length ? stringSize(string) : 0;
	      if (!length || strLength >= length) {
	        return string;
	      }
	      var mid = (length - strLength) / 2;
	      return (
	        createPadding(nativeFloor(mid), chars) +
	        string +
	        createPadding(nativeCeil(mid), chars)
	      );
	    }

	    /**
	     * Pads `string` on the right side if it's shorter than `length`. Padding
	     * characters are truncated if they exceed `length`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padEnd('abc', 6);
	     * // => 'abc   '
	     *
	     * _.padEnd('abc', 6, '_-');
	     * // => 'abc_-_'
	     *
	     * _.padEnd('abc', 3);
	     * // => 'abc'
	     */
	    function padEnd(string, length, chars) {
	      string = toString(string);
	      length = toInteger(length);

	      var strLength = length ? stringSize(string) : 0;
	      return (length && strLength < length)
	        ? (string + createPadding(length - strLength, chars))
	        : string;
	    }

	    /**
	     * Pads `string` on the left side if it's shorter than `length`. Padding
	     * characters are truncated if they exceed `length`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padStart('abc', 6);
	     * // => '   abc'
	     *
	     * _.padStart('abc', 6, '_-');
	     * // => '_-_abc'
	     *
	     * _.padStart('abc', 3);
	     * // => 'abc'
	     */
	    function padStart(string, length, chars) {
	      string = toString(string);
	      length = toInteger(length);

	      var strLength = length ? stringSize(string) : 0;
	      return (length && strLength < length)
	        ? (createPadding(length - strLength, chars) + string)
	        : string;
	    }

	    /**
	     * Converts `string` to an integer of the specified radix. If `radix` is
	     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
	     * hexadecimal, in which case a `radix` of `16` is used.
	     *
	     * **Note:** This method aligns with the
	     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.1.0
	     * @category String
	     * @param {string} string The string to convert.
	     * @param {number} [radix=10] The radix to interpret `value` by.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.parseInt('08');
	     * // => 8
	     *
	     * _.map(['6', '08', '10'], _.parseInt);
	     * // => [6, 8, 10]
	     */
	    function parseInt(string, radix, guard) {
	      if (guard || radix == null) {
	        radix = 0;
	      } else if (radix) {
	        radix = +radix;
	      }
	      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
	    }

	    /**
	     * Repeats the given string `n` times.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to repeat.
	     * @param {number} [n=1] The number of times to repeat the string.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the repeated string.
	     * @example
	     *
	     * _.repeat('*', 3);
	     * // => '***'
	     *
	     * _.repeat('abc', 2);
	     * // => 'abcabc'
	     *
	     * _.repeat('abc', 0);
	     * // => ''
	     */
	    function repeat(string, n, guard) {
	      if ((guard ? isIterateeCall(string, n, guard) : n === undefined$1)) {
	        n = 1;
	      } else {
	        n = toInteger(n);
	      }
	      return baseRepeat(toString(string), n);
	    }

	    /**
	     * Replaces matches for `pattern` in `string` with `replacement`.
	     *
	     * **Note:** This method is based on
	     * [`String#replace`](https://mdn.io/String/replace).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to modify.
	     * @param {RegExp|string} pattern The pattern to replace.
	     * @param {Function|string} replacement The match replacement.
	     * @returns {string} Returns the modified string.
	     * @example
	     *
	     * _.replace('Hi Fred', 'Fred', 'Barney');
	     * // => 'Hi Barney'
	     */
	    function replace() {
	      var args = arguments,
	          string = toString(args[0]);

	      return args.length < 3 ? string : string.replace(args[1], args[2]);
	    }

	    /**
	     * Converts `string` to
	     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the snake cased string.
	     * @example
	     *
	     * _.snakeCase('Foo Bar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('fooBar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('--FOO-BAR--');
	     * // => 'foo_bar'
	     */
	    var snakeCase = createCompounder(function(result, word, index) {
	      return result + (index ? '_' : '') + word.toLowerCase();
	    });

	    /**
	     * Splits `string` by `separator`.
	     *
	     * **Note:** This method is based on
	     * [`String#split`](https://mdn.io/String/split).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to split.
	     * @param {RegExp|string} separator The separator pattern to split by.
	     * @param {number} [limit] The length to truncate results to.
	     * @returns {Array} Returns the string segments.
	     * @example
	     *
	     * _.split('a-b-c', '-', 2);
	     * // => ['a', 'b']
	     */
	    function split(string, separator, limit) {
	      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
	        separator = limit = undefined$1;
	      }
	      limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
	      if (!limit) {
	        return [];
	      }
	      string = toString(string);
	      if (string && (
	            typeof separator == 'string' ||
	            (separator != null && !isRegExp(separator))
	          )) {
	        separator = baseToString(separator);
	        if (!separator && hasUnicode(string)) {
	          return castSlice(stringToArray(string), 0, limit);
	        }
	      }
	      return string.split(separator, limit);
	    }

	    /**
	     * Converts `string` to
	     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.1.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the start cased string.
	     * @example
	     *
	     * _.startCase('--foo-bar--');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('fooBar');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('__FOO_BAR__');
	     * // => 'FOO BAR'
	     */
	    var startCase = createCompounder(function(result, word, index) {
	      return result + (index ? ' ' : '') + upperFirst(word);
	    });

	    /**
	     * Checks if `string` starts with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=0] The position to search from.
	     * @returns {boolean} Returns `true` if `string` starts with `target`,
	     *  else `false`.
	     * @example
	     *
	     * _.startsWith('abc', 'a');
	     * // => true
	     *
	     * _.startsWith('abc', 'b');
	     * // => false
	     *
	     * _.startsWith('abc', 'b', 1);
	     * // => true
	     */
	    function startsWith(string, target, position) {
	      string = toString(string);
	      position = position == null
	        ? 0
	        : baseClamp(toInteger(position), 0, string.length);

	      target = baseToString(target);
	      return string.slice(position, position + target.length) == target;
	    }

	    /**
	     * Creates a compiled template function that can interpolate data properties
	     * in "interpolate" delimiters, HTML-escape interpolated data properties in
	     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
	     * properties may be accessed as free variables in the template. If a setting
	     * object is given, it takes precedence over `_.templateSettings` values.
	     *
	     * **Note:** In the development build `_.template` utilizes
	     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
	     * for easier debugging.
	     *
	     * For more information on precompiling templates see
	     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
	     *
	     * For more information on Chrome extension sandboxes see
	     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The template string.
	     * @param {Object} [options={}] The options object.
	     * @param {RegExp} [options.escape=_.templateSettings.escape]
	     *  The HTML "escape" delimiter.
	     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
	     *  The "evaluate" delimiter.
	     * @param {Object} [options.imports=_.templateSettings.imports]
	     *  An object to import into the template as free variables.
	     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
	     *  The "interpolate" delimiter.
	     * @param {string} [options.sourceURL='lodash.templateSources[n]']
	     *  The sourceURL of the compiled template.
	     * @param {string} [options.variable='obj']
	     *  The data object variable name.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the compiled template function.
	     * @example
	     *
	     * // Use the "interpolate" delimiter to create a compiled template.
	     * var compiled = _.template('hello <%= user %>!');
	     * compiled({ 'user': 'fred' });
	     * // => 'hello fred!'
	     *
	     * // Use the HTML "escape" delimiter to escape data property values.
	     * var compiled = _.template('<b><%- value %></b>');
	     * compiled({ 'value': '<script>' });
	     * // => '<b>&lt;script&gt;</b>'
	     *
	     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
	     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // Use the internal `print` function in "evaluate" delimiters.
	     * var compiled = _.template('<% print("hello " + user); %>!');
	     * compiled({ 'user': 'barney' });
	     * // => 'hello barney!'
	     *
	     * // Use the ES template literal delimiter as an "interpolate" delimiter.
	     * // Disable support by replacing the "interpolate" delimiter.
	     * var compiled = _.template('hello ${ user }!');
	     * compiled({ 'user': 'pebbles' });
	     * // => 'hello pebbles!'
	     *
	     * // Use backslashes to treat delimiters as plain text.
	     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
	     * compiled({ 'value': 'ignored' });
	     * // => '<%- value %>'
	     *
	     * // Use the `imports` option to import `jQuery` as `jq`.
	     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
	     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
	     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
	     * compiled(data);
	     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
	     *
	     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
	     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
	     * compiled.source;
	     * // => function(data) {
	     * //   var __t, __p = '';
	     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
	     * //   return __p;
	     * // }
	     *
	     * // Use custom template delimiters.
	     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
	     * var compiled = _.template('hello {{ user }}!');
	     * compiled({ 'user': 'mustache' });
	     * // => 'hello mustache!'
	     *
	     * // Use the `source` property to inline compiled templates for meaningful
	     * // line numbers in error messages and stack traces.
	     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
	     *   var JST = {\
	     *     "main": ' + _.template(mainText).source + '\
	     *   };\
	     * ');
	     */
	    function template(string, options, guard) {
	      // Based on John Resig's `tmpl` implementation
	      // (http://ejohn.org/blog/javascript-micro-templating/)
	      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
	      var settings = lodash.templateSettings;

	      if (guard && isIterateeCall(string, options, guard)) {
	        options = undefined$1;
	      }
	      string = toString(string);
	      options = assignInWith({}, options, settings, customDefaultsAssignIn);

	      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
	          importsKeys = keys(imports),
	          importsValues = baseValues(imports, importsKeys);

	      var isEscaping,
	          isEvaluating,
	          index = 0,
	          interpolate = options.interpolate || reNoMatch,
	          source = "__p += '";

	      // Compile the regexp to match each delimiter.
	      var reDelimiters = RegExp(
	        (options.escape || reNoMatch).source + '|' +
	        interpolate.source + '|' +
	        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
	        (options.evaluate || reNoMatch).source + '|$'
	      , 'g');

	      // Use a sourceURL for easier debugging.
	      // The sourceURL gets injected into the source that's eval-ed, so be careful
	      // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
	      // and escape the comment, thus injecting code that gets evaled.
	      var sourceURL = '//# sourceURL=' +
	        (hasOwnProperty.call(options, 'sourceURL')
	          ? (options.sourceURL + '').replace(/\s/g, ' ')
	          : ('lodash.templateSources[' + (++templateCounter) + ']')
	        ) + '\n';

	      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
	        interpolateValue || (interpolateValue = esTemplateValue);

	        // Escape characters that can't be included in string literals.
	        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

	        // Replace delimiters with snippets.
	        if (escapeValue) {
	          isEscaping = true;
	          source += "' +\n__e(" + escapeValue + ") +\n'";
	        }
	        if (evaluateValue) {
	          isEvaluating = true;
	          source += "';\n" + evaluateValue + ";\n__p += '";
	        }
	        if (interpolateValue) {
	          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
	        }
	        index = offset + match.length;

	        // The JS engine embedded in Adobe products needs `match` returned in
	        // order to produce the correct `offset` value.
	        return match;
	      });

	      source += "';\n";

	      // If `variable` is not specified wrap a with-statement around the generated
	      // code to add the data object to the top of the scope chain.
	      var variable = hasOwnProperty.call(options, 'variable') && options.variable;
	      if (!variable) {
	        source = 'with (obj) {\n' + source + '\n}\n';
	      }
	      // Throw an error if a forbidden character was found in `variable`, to prevent
	      // potential command injection attacks.
	      else if (reForbiddenIdentifierChars.test(variable)) {
	        throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
	      }

	      // Cleanup code by stripping empty strings.
	      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
	        .replace(reEmptyStringMiddle, '$1')
	        .replace(reEmptyStringTrailing, '$1;');

	      // Frame code as the function body.
	      source = 'function(' + (variable || 'obj') + ') {\n' +
	        (variable
	          ? ''
	          : 'obj || (obj = {});\n'
	        ) +
	        "var __t, __p = ''" +
	        (isEscaping
	           ? ', __e = _.escape'
	           : ''
	        ) +
	        (isEvaluating
	          ? ', __j = Array.prototype.join;\n' +
	            "function print() { __p += __j.call(arguments, '') }\n"
	          : ';\n'
	        ) +
	        source +
	        'return __p\n}';

	      var result = attempt(function() {
	        return Function(importsKeys, sourceURL + 'return ' + source)
	          .apply(undefined$1, importsValues);
	      });

	      // Provide the compiled function's source by its `toString` method or
	      // the `source` property as a convenience for inlining compiled templates.
	      result.source = source;
	      if (isError(result)) {
	        throw result;
	      }
	      return result;
	    }

	    /**
	     * Converts `string`, as a whole, to lower case just like
	     * [String#toLowerCase](https://mdn.io/toLowerCase).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the lower cased string.
	     * @example
	     *
	     * _.toLower('--Foo-Bar--');
	     * // => '--foo-bar--'
	     *
	     * _.toLower('fooBar');
	     * // => 'foobar'
	     *
	     * _.toLower('__FOO_BAR__');
	     * // => '__foo_bar__'
	     */
	    function toLower(value) {
	      return toString(value).toLowerCase();
	    }

	    /**
	     * Converts `string`, as a whole, to upper case just like
	     * [String#toUpperCase](https://mdn.io/toUpperCase).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the upper cased string.
	     * @example
	     *
	     * _.toUpper('--foo-bar--');
	     * // => '--FOO-BAR--'
	     *
	     * _.toUpper('fooBar');
	     * // => 'FOOBAR'
	     *
	     * _.toUpper('__foo_bar__');
	     * // => '__FOO_BAR__'
	     */
	    function toUpper(value) {
	      return toString(value).toUpperCase();
	    }

	    /**
	     * Removes leading and trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trim('  abc  ');
	     * // => 'abc'
	     *
	     * _.trim('-_-abc-_-', '_-');
	     * // => 'abc'
	     *
	     * _.map(['  foo  ', '  bar  '], _.trim);
	     * // => ['foo', 'bar']
	     */
	    function trim(string, chars, guard) {
	      string = toString(string);
	      if (string && (guard || chars === undefined$1)) {
	        return baseTrim(string);
	      }
	      if (!string || !(chars = baseToString(chars))) {
	        return string;
	      }
	      var strSymbols = stringToArray(string),
	          chrSymbols = stringToArray(chars),
	          start = charsStartIndex(strSymbols, chrSymbols),
	          end = charsEndIndex(strSymbols, chrSymbols) + 1;

	      return castSlice(strSymbols, start, end).join('');
	    }

	    /**
	     * Removes trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimEnd('  abc  ');
	     * // => '  abc'
	     *
	     * _.trimEnd('-_-abc-_-', '_-');
	     * // => '-_-abc'
	     */
	    function trimEnd(string, chars, guard) {
	      string = toString(string);
	      if (string && (guard || chars === undefined$1)) {
	        return string.slice(0, trimmedEndIndex(string) + 1);
	      }
	      if (!string || !(chars = baseToString(chars))) {
	        return string;
	      }
	      var strSymbols = stringToArray(string),
	          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

	      return castSlice(strSymbols, 0, end).join('');
	    }

	    /**
	     * Removes leading whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimStart('  abc  ');
	     * // => 'abc  '
	     *
	     * _.trimStart('-_-abc-_-', '_-');
	     * // => 'abc-_-'
	     */
	    function trimStart(string, chars, guard) {
	      string = toString(string);
	      if (string && (guard || chars === undefined$1)) {
	        return string.replace(reTrimStart, '');
	      }
	      if (!string || !(chars = baseToString(chars))) {
	        return string;
	      }
	      var strSymbols = stringToArray(string),
	          start = charsStartIndex(strSymbols, stringToArray(chars));

	      return castSlice(strSymbols, start).join('');
	    }

	    /**
	     * Truncates `string` if it's longer than the given maximum string length.
	     * The last characters of the truncated string are replaced with the omission
	     * string which defaults to "...".
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to truncate.
	     * @param {Object} [options={}] The options object.
	     * @param {number} [options.length=30] The maximum string length.
	     * @param {string} [options.omission='...'] The string to indicate text is omitted.
	     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
	     * @returns {string} Returns the truncated string.
	     * @example
	     *
	     * _.truncate('hi-diddly-ho there, neighborino');
	     * // => 'hi-diddly-ho there, neighbo...'
	     *
	     * _.truncate('hi-diddly-ho there, neighborino', {
	     *   'length': 24,
	     *   'separator': ' '
	     * });
	     * // => 'hi-diddly-ho there,...'
	     *
	     * _.truncate('hi-diddly-ho there, neighborino', {
	     *   'length': 24,
	     *   'separator': /,? +/
	     * });
	     * // => 'hi-diddly-ho there...'
	     *
	     * _.truncate('hi-diddly-ho there, neighborino', {
	     *   'omission': ' [...]'
	     * });
	     * // => 'hi-diddly-ho there, neig [...]'
	     */
	    function truncate(string, options) {
	      var length = DEFAULT_TRUNC_LENGTH,
	          omission = DEFAULT_TRUNC_OMISSION;

	      if (isObject(options)) {
	        var separator = 'separator' in options ? options.separator : separator;
	        length = 'length' in options ? toInteger(options.length) : length;
	        omission = 'omission' in options ? baseToString(options.omission) : omission;
	      }
	      string = toString(string);

	      var strLength = string.length;
	      if (hasUnicode(string)) {
	        var strSymbols = stringToArray(string);
	        strLength = strSymbols.length;
	      }
	      if (length >= strLength) {
	        return string;
	      }
	      var end = length - stringSize(omission);
	      if (end < 1) {
	        return omission;
	      }
	      var result = strSymbols
	        ? castSlice(strSymbols, 0, end).join('')
	        : string.slice(0, end);

	      if (separator === undefined$1) {
	        return result + omission;
	      }
	      if (strSymbols) {
	        end += (result.length - end);
	      }
	      if (isRegExp(separator)) {
	        if (string.slice(end).search(separator)) {
	          var match,
	              substring = result;

	          if (!separator.global) {
	            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
	          }
	          separator.lastIndex = 0;
	          while ((match = separator.exec(substring))) {
	            var newEnd = match.index;
	          }
	          result = result.slice(0, newEnd === undefined$1 ? end : newEnd);
	        }
	      } else if (string.indexOf(baseToString(separator), end) != end) {
	        var index = result.lastIndexOf(separator);
	        if (index > -1) {
	          result = result.slice(0, index);
	        }
	      }
	      return result + omission;
	    }

	    /**
	     * The inverse of `_.escape`; this method converts the HTML entities
	     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
	     * their corresponding characters.
	     *
	     * **Note:** No other HTML entities are unescaped. To unescape additional
	     * HTML entities use a third-party library like [_he_](https://mths.be/he).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.6.0
	     * @category String
	     * @param {string} [string=''] The string to unescape.
	     * @returns {string} Returns the unescaped string.
	     * @example
	     *
	     * _.unescape('fred, barney, &amp; pebbles');
	     * // => 'fred, barney, & pebbles'
	     */
	    function unescape(string) {
	      string = toString(string);
	      return (string && reHasEscapedHtml.test(string))
	        ? string.replace(reEscapedHtml, unescapeHtmlChar)
	        : string;
	    }

	    /**
	     * Converts `string`, as space separated words, to upper case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the upper cased string.
	     * @example
	     *
	     * _.upperCase('--foo-bar');
	     * // => 'FOO BAR'
	     *
	     * _.upperCase('fooBar');
	     * // => 'FOO BAR'
	     *
	     * _.upperCase('__foo_bar__');
	     * // => 'FOO BAR'
	     */
	    var upperCase = createCompounder(function(result, word, index) {
	      return result + (index ? ' ' : '') + word.toUpperCase();
	    });

	    /**
	     * Converts the first character of `string` to upper case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the converted string.
	     * @example
	     *
	     * _.upperFirst('fred');
	     * // => 'Fred'
	     *
	     * _.upperFirst('FRED');
	     * // => 'FRED'
	     */
	    var upperFirst = createCaseFirst('toUpperCase');

	    /**
	     * Splits `string` into an array of its words.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {RegExp|string} [pattern] The pattern to match words.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the words of `string`.
	     * @example
	     *
	     * _.words('fred, barney, & pebbles');
	     * // => ['fred', 'barney', 'pebbles']
	     *
	     * _.words('fred, barney, & pebbles', /[^, ]+/g);
	     * // => ['fred', 'barney', '&', 'pebbles']
	     */
	    function words(string, pattern, guard) {
	      string = toString(string);
	      pattern = guard ? undefined$1 : pattern;

	      if (pattern === undefined$1) {
	        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
	      }
	      return string.match(pattern) || [];
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Attempts to invoke `func`, returning either the result or the caught error
	     * object. Any additional arguments are provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {Function} func The function to attempt.
	     * @param {...*} [args] The arguments to invoke `func` with.
	     * @returns {*} Returns the `func` result or error object.
	     * @example
	     *
	     * // Avoid throwing errors for invalid selectors.
	     * var elements = _.attempt(function(selector) {
	     *   return document.querySelectorAll(selector);
	     * }, '>_>');
	     *
	     * if (_.isError(elements)) {
	     *   elements = [];
	     * }
	     */
	    var attempt = baseRest(function(func, args) {
	      try {
	        return apply(func, undefined$1, args);
	      } catch (e) {
	        return isError(e) ? e : new Error(e);
	      }
	    });

	    /**
	     * Binds methods of an object to the object itself, overwriting the existing
	     * method.
	     *
	     * **Note:** This method doesn't set the "length" property of bound functions.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {Object} object The object to bind and assign the bound methods to.
	     * @param {...(string|string[])} methodNames The object method names to bind.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var view = {
	     *   'label': 'docs',
	     *   'click': function() {
	     *     console.log('clicked ' + this.label);
	     *   }
	     * };
	     *
	     * _.bindAll(view, ['click']);
	     * jQuery(element).on('click', view.click);
	     * // => Logs 'clicked docs' when clicked.
	     */
	    var bindAll = flatRest(function(object, methodNames) {
	      arrayEach(methodNames, function(key) {
	        key = toKey(key);
	        baseAssignValue(object, key, bind(object[key], object));
	      });
	      return object;
	    });

	    /**
	     * Creates a function that iterates over `pairs` and invokes the corresponding
	     * function of the first predicate to return truthy. The predicate-function
	     * pairs are invoked with the `this` binding and arguments of the created
	     * function.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {Array} pairs The predicate-function pairs.
	     * @returns {Function} Returns the new composite function.
	     * @example
	     *
	     * var func = _.cond([
	     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
	     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
	     *   [_.stubTrue,                      _.constant('no match')]
	     * ]);
	     *
	     * func({ 'a': 1, 'b': 2 });
	     * // => 'matches A'
	     *
	     * func({ 'a': 0, 'b': 1 });
	     * // => 'matches B'
	     *
	     * func({ 'a': '1', 'b': '2' });
	     * // => 'no match'
	     */
	    function cond(pairs) {
	      var length = pairs == null ? 0 : pairs.length,
	          toIteratee = getIteratee();

	      pairs = !length ? [] : arrayMap(pairs, function(pair) {
	        if (typeof pair[1] != 'function') {
	          throw new TypeError(FUNC_ERROR_TEXT);
	        }
	        return [toIteratee(pair[0]), pair[1]];
	      });

	      return baseRest(function(args) {
	        var index = -1;
	        while (++index < length) {
	          var pair = pairs[index];
	          if (apply(pair[0], this, args)) {
	            return apply(pair[1], this, args);
	          }
	        }
	      });
	    }

	    /**
	     * Creates a function that invokes the predicate properties of `source` with
	     * the corresponding property values of a given object, returning `true` if
	     * all predicates return truthy, else `false`.
	     *
	     * **Note:** The created function is equivalent to `_.conformsTo` with
	     * `source` partially applied.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {Function} Returns the new spec function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': 2, 'b': 1 },
	     *   { 'a': 1, 'b': 2 }
	     * ];
	     *
	     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
	     * // => [{ 'a': 1, 'b': 2 }]
	     */
	    function conforms(source) {
	      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
	    }

	    /**
	     * Creates a function that returns `value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Util
	     * @param {*} value The value to return from the new function.
	     * @returns {Function} Returns the new constant function.
	     * @example
	     *
	     * var objects = _.times(2, _.constant({ 'a': 1 }));
	     *
	     * console.log(objects);
	     * // => [{ 'a': 1 }, { 'a': 1 }]
	     *
	     * console.log(objects[0] === objects[1]);
	     * // => true
	     */
	    function constant(value) {
	      return function() {
	        return value;
	      };
	    }

	    /**
	     * Checks `value` to determine whether a default value should be returned in
	     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
	     * or `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.14.0
	     * @category Util
	     * @param {*} value The value to check.
	     * @param {*} defaultValue The default value.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * _.defaultTo(1, 10);
	     * // => 1
	     *
	     * _.defaultTo(undefined, 10);
	     * // => 10
	     */
	    function defaultTo(value, defaultValue) {
	      return (value == null || value !== value) ? defaultValue : value;
	    }

	    /**
	     * Creates a function that returns the result of invoking the given functions
	     * with the `this` binding of the created function, where each successive
	     * invocation is supplied the return value of the previous.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [funcs] The functions to invoke.
	     * @returns {Function} Returns the new composite function.
	     * @see _.flowRight
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flow([_.add, square]);
	     * addSquare(1, 2);
	     * // => 9
	     */
	    var flow = createFlow();

	    /**
	     * This method is like `_.flow` except that it creates a function that
	     * invokes the given functions from right to left.
	     *
	     * @static
	     * @since 3.0.0
	     * @memberOf _
	     * @category Util
	     * @param {...(Function|Function[])} [funcs] The functions to invoke.
	     * @returns {Function} Returns the new composite function.
	     * @see _.flow
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flowRight([square, _.add]);
	     * addSquare(1, 2);
	     * // => 9
	     */
	    var flowRight = createFlow(true);

	    /**
	     * This method returns the first argument it receives.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {*} value Any value.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * var object = { 'a': 1 };
	     *
	     * console.log(_.identity(object) === object);
	     * // => true
	     */
	    function identity(value) {
	      return value;
	    }

	    /**
	     * Creates a function that invokes `func` with the arguments of the created
	     * function. If `func` is a property name, the created function returns the
	     * property value for a given element. If `func` is an array or object, the
	     * created function returns `true` for elements that contain the equivalent
	     * source properties, otherwise it returns `false`.
	     *
	     * @static
	     * @since 4.0.0
	     * @memberOf _
	     * @category Util
	     * @param {*} [func=_.identity] The value to convert to a callback.
	     * @returns {Function} Returns the callback.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
	     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.filter(users, _.iteratee(['user', 'fred']));
	     * // => [{ 'user': 'fred', 'age': 40 }]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.map(users, _.iteratee('user'));
	     * // => ['barney', 'fred']
	     *
	     * // Create custom iteratee shorthands.
	     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
	     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
	     *     return func.test(string);
	     *   };
	     * });
	     *
	     * _.filter(['abc', 'def'], /ef/);
	     * // => ['def']
	     */
	    function iteratee(func) {
	      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
	    }

	    /**
	     * Creates a function that performs a partial deep comparison between a given
	     * object and `source`, returning `true` if the given object has equivalent
	     * property values, else `false`.
	     *
	     * **Note:** The created function is equivalent to `_.isMatch` with `source`
	     * partially applied.
	     *
	     * Partial comparisons will match empty array and empty object `source`
	     * values against any array or object value, respectively. See `_.isEqual`
	     * for a list of supported value comparisons.
	     *
	     * **Note:** Multiple values can be checked by combining several matchers
	     * using `_.overSome`
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new spec function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': 1, 'b': 2, 'c': 3 },
	     *   { 'a': 4, 'b': 5, 'c': 6 }
	     * ];
	     *
	     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
	     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
	     *
	     * // Checking for several possible values
	     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
	     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
	     */
	    function matches(source) {
	      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
	    }

	    /**
	     * Creates a function that performs a partial deep comparison between the
	     * value at `path` of a given object to `srcValue`, returning `true` if the
	     * object value is equivalent, else `false`.
	     *
	     * **Note:** Partial comparisons will match empty array and empty object
	     * `srcValue` values against any array or object value, respectively. See
	     * `_.isEqual` for a list of supported value comparisons.
	     *
	     * **Note:** Multiple values can be checked by combining several matchers
	     * using `_.overSome`
	     *
	     * @static
	     * @memberOf _
	     * @since 3.2.0
	     * @category Util
	     * @param {Array|string} path The path of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new spec function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': 1, 'b': 2, 'c': 3 },
	     *   { 'a': 4, 'b': 5, 'c': 6 }
	     * ];
	     *
	     * _.find(objects, _.matchesProperty('a', 4));
	     * // => { 'a': 4, 'b': 5, 'c': 6 }
	     *
	     * // Checking for several possible values
	     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
	     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
	     */
	    function matchesProperty(path, srcValue) {
	      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
	    }

	    /**
	     * Creates a function that invokes the method at `path` of a given object.
	     * Any additional arguments are provided to the invoked method.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Util
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Function} Returns the new invoker function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': { 'b': _.constant(2) } },
	     *   { 'a': { 'b': _.constant(1) } }
	     * ];
	     *
	     * _.map(objects, _.method('a.b'));
	     * // => [2, 1]
	     *
	     * _.map(objects, _.method(['a', 'b']));
	     * // => [2, 1]
	     */
	    var method = baseRest(function(path, args) {
	      return function(object) {
	        return baseInvoke(object, path, args);
	      };
	    });

	    /**
	     * The opposite of `_.method`; this method creates a function that invokes
	     * the method at a given path of `object`. Any additional arguments are
	     * provided to the invoked method.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Util
	     * @param {Object} object The object to query.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Function} Returns the new invoker function.
	     * @example
	     *
	     * var array = _.times(3, _.constant),
	     *     object = { 'a': array, 'b': array, 'c': array };
	     *
	     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
	     * // => [2, 0]
	     *
	     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
	     * // => [2, 0]
	     */
	    var methodOf = baseRest(function(object, args) {
	      return function(path) {
	        return baseInvoke(object, path, args);
	      };
	    });

	    /**
	     * Adds all own enumerable string keyed function properties of a source
	     * object to the destination object. If `object` is a function, then methods
	     * are added to its prototype as well.
	     *
	     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
	     * avoid conflicts caused by modifying the original.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {Function|Object} [object=lodash] The destination object.
	     * @param {Object} source The object of functions to add.
	     * @param {Object} [options={}] The options object.
	     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
	     * @returns {Function|Object} Returns `object`.
	     * @example
	     *
	     * function vowels(string) {
	     *   return _.filter(string, function(v) {
	     *     return /[aeiou]/i.test(v);
	     *   });
	     * }
	     *
	     * _.mixin({ 'vowels': vowels });
	     * _.vowels('fred');
	     * // => ['e']
	     *
	     * _('fred').vowels().value();
	     * // => ['e']
	     *
	     * _.mixin({ 'vowels': vowels }, { 'chain': false });
	     * _('fred').vowels();
	     * // => ['e']
	     */
	    function mixin(object, source, options) {
	      var props = keys(source),
	          methodNames = baseFunctions(source, props);

	      if (options == null &&
	          !(isObject(source) && (methodNames.length || !props.length))) {
	        options = source;
	        source = object;
	        object = this;
	        methodNames = baseFunctions(source, keys(source));
	      }
	      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
	          isFunc = isFunction(object);

	      arrayEach(methodNames, function(methodName) {
	        var func = source[methodName];
	        object[methodName] = func;
	        if (isFunc) {
	          object.prototype[methodName] = function() {
	            var chainAll = this.__chain__;
	            if (chain || chainAll) {
	              var result = object(this.__wrapped__),
	                  actions = result.__actions__ = copyArray(this.__actions__);

	              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
	              result.__chain__ = chainAll;
	              return result;
	            }
	            return func.apply(object, arrayPush([this.value()], arguments));
	          };
	        }
	      });

	      return object;
	    }

	    /**
	     * Reverts the `_` variable to its previous value and returns a reference to
	     * the `lodash` function.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @returns {Function} Returns the `lodash` function.
	     * @example
	     *
	     * var lodash = _.noConflict();
	     */
	    function noConflict() {
	      if (root._ === this) {
	        root._ = oldDash;
	      }
	      return this;
	    }

	    /**
	     * This method returns `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.3.0
	     * @category Util
	     * @example
	     *
	     * _.times(2, _.noop);
	     * // => [undefined, undefined]
	     */
	    function noop() {
	      // No operation performed.
	    }

	    /**
	     * Creates a function that gets the argument at index `n`. If `n` is negative,
	     * the nth argument from the end is returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {number} [n=0] The index of the argument to return.
	     * @returns {Function} Returns the new pass-thru function.
	     * @example
	     *
	     * var func = _.nthArg(1);
	     * func('a', 'b', 'c', 'd');
	     * // => 'b'
	     *
	     * var func = _.nthArg(-2);
	     * func('a', 'b', 'c', 'd');
	     * // => 'c'
	     */
	    function nthArg(n) {
	      n = toInteger(n);
	      return baseRest(function(args) {
	        return baseNth(args, n);
	      });
	    }

	    /**
	     * Creates a function that invokes `iteratees` with the arguments it receives
	     * and returns their results.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [iteratees=[_.identity]]
	     *  The iteratees to invoke.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var func = _.over([Math.max, Math.min]);
	     *
	     * func(1, 2, 3, 4);
	     * // => [4, 1]
	     */
	    var over = createOver(arrayMap);

	    /**
	     * Creates a function that checks if **all** of the `predicates` return
	     * truthy when invoked with the arguments it receives.
	     *
	     * Following shorthands are possible for providing predicates.
	     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
	     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [predicates=[_.identity]]
	     *  The predicates to check.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var func = _.overEvery([Boolean, isFinite]);
	     *
	     * func('1');
	     * // => true
	     *
	     * func(null);
	     * // => false
	     *
	     * func(NaN);
	     * // => false
	     */
	    var overEvery = createOver(arrayEvery);

	    /**
	     * Creates a function that checks if **any** of the `predicates` return
	     * truthy when invoked with the arguments it receives.
	     *
	     * Following shorthands are possible for providing predicates.
	     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
	     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [predicates=[_.identity]]
	     *  The predicates to check.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var func = _.overSome([Boolean, isFinite]);
	     *
	     * func('1');
	     * // => true
	     *
	     * func(null);
	     * // => true
	     *
	     * func(NaN);
	     * // => false
	     *
	     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
	     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
	     */
	    var overSome = createOver(arraySome);

	    /**
	     * Creates a function that returns the value at `path` of a given object.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Util
	     * @param {Array|string} path The path of the property to get.
	     * @returns {Function} Returns the new accessor function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': { 'b': 2 } },
	     *   { 'a': { 'b': 1 } }
	     * ];
	     *
	     * _.map(objects, _.property('a.b'));
	     * // => [2, 1]
	     *
	     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
	     * // => [1, 2]
	     */
	    function property(path) {
	      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
	    }

	    /**
	     * The opposite of `_.property`; this method creates a function that returns
	     * the value at a given path of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {Object} object The object to query.
	     * @returns {Function} Returns the new accessor function.
	     * @example
	     *
	     * var array = [0, 1, 2],
	     *     object = { 'a': array, 'b': array, 'c': array };
	     *
	     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
	     * // => [2, 0]
	     *
	     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
	     * // => [2, 0]
	     */
	    function propertyOf(object) {
	      return function(path) {
	        return object == null ? undefined$1 : baseGet(object, path);
	      };
	    }

	    /**
	     * Creates an array of numbers (positive and/or negative) progressing from
	     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
	     * `start` is specified without an `end` or `step`. If `end` is not specified,
	     * it's set to `start` with `start` then set to `0`.
	     *
	     * **Note:** JavaScript follows the IEEE-754 standard for resolving
	     * floating-point values which can produce unexpected results.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} [step=1] The value to increment or decrement by.
	     * @returns {Array} Returns the range of numbers.
	     * @see _.inRange, _.rangeRight
	     * @example
	     *
	     * _.range(4);
	     * // => [0, 1, 2, 3]
	     *
	     * _.range(-4);
	     * // => [0, -1, -2, -3]
	     *
	     * _.range(1, 5);
	     * // => [1, 2, 3, 4]
	     *
	     * _.range(0, 20, 5);
	     * // => [0, 5, 10, 15]
	     *
	     * _.range(0, -4, -1);
	     * // => [0, -1, -2, -3]
	     *
	     * _.range(1, 4, 0);
	     * // => [1, 1, 1]
	     *
	     * _.range(0);
	     * // => []
	     */
	    var range = createRange();

	    /**
	     * This method is like `_.range` except that it populates values in
	     * descending order.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} [step=1] The value to increment or decrement by.
	     * @returns {Array} Returns the range of numbers.
	     * @see _.inRange, _.range
	     * @example
	     *
	     * _.rangeRight(4);
	     * // => [3, 2, 1, 0]
	     *
	     * _.rangeRight(-4);
	     * // => [-3, -2, -1, 0]
	     *
	     * _.rangeRight(1, 5);
	     * // => [4, 3, 2, 1]
	     *
	     * _.rangeRight(0, 20, 5);
	     * // => [15, 10, 5, 0]
	     *
	     * _.rangeRight(0, -4, -1);
	     * // => [-3, -2, -1, 0]
	     *
	     * _.rangeRight(1, 4, 0);
	     * // => [1, 1, 1]
	     *
	     * _.rangeRight(0);
	     * // => []
	     */
	    var rangeRight = createRange(true);

	    /**
	     * This method returns a new empty array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {Array} Returns the new empty array.
	     * @example
	     *
	     * var arrays = _.times(2, _.stubArray);
	     *
	     * console.log(arrays);
	     * // => [[], []]
	     *
	     * console.log(arrays[0] === arrays[1]);
	     * // => false
	     */
	    function stubArray() {
	      return [];
	    }

	    /**
	     * This method returns `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {boolean} Returns `false`.
	     * @example
	     *
	     * _.times(2, _.stubFalse);
	     * // => [false, false]
	     */
	    function stubFalse() {
	      return false;
	    }

	    /**
	     * This method returns a new empty object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {Object} Returns the new empty object.
	     * @example
	     *
	     * var objects = _.times(2, _.stubObject);
	     *
	     * console.log(objects);
	     * // => [{}, {}]
	     *
	     * console.log(objects[0] === objects[1]);
	     * // => false
	     */
	    function stubObject() {
	      return {};
	    }

	    /**
	     * This method returns an empty string.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {string} Returns the empty string.
	     * @example
	     *
	     * _.times(2, _.stubString);
	     * // => ['', '']
	     */
	    function stubString() {
	      return '';
	    }

	    /**
	     * This method returns `true`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {boolean} Returns `true`.
	     * @example
	     *
	     * _.times(2, _.stubTrue);
	     * // => [true, true]
	     */
	    function stubTrue() {
	      return true;
	    }

	    /**
	     * Invokes the iteratee `n` times, returning an array of the results of
	     * each invocation. The iteratee is invoked with one argument; (index).
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {number} n The number of times to invoke `iteratee`.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * _.times(3, String);
	     * // => ['0', '1', '2']
	     *
	     *  _.times(4, _.constant(0));
	     * // => [0, 0, 0, 0]
	     */
	    function times(n, iteratee) {
	      n = toInteger(n);
	      if (n < 1 || n > MAX_SAFE_INTEGER) {
	        return [];
	      }
	      var index = MAX_ARRAY_LENGTH,
	          length = nativeMin(n, MAX_ARRAY_LENGTH);

	      iteratee = getIteratee(iteratee);
	      n -= MAX_ARRAY_LENGTH;

	      var result = baseTimes(length, iteratee);
	      while (++index < n) {
	        iteratee(index);
	      }
	      return result;
	    }

	    /**
	     * Converts `value` to a property path array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {*} value The value to convert.
	     * @returns {Array} Returns the new property path array.
	     * @example
	     *
	     * _.toPath('a.b.c');
	     * // => ['a', 'b', 'c']
	     *
	     * _.toPath('a[0].b.c');
	     * // => ['a', '0', 'b', 'c']
	     */
	    function toPath(value) {
	      if (isArray(value)) {
	        return arrayMap(value, toKey);
	      }
	      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
	    }

	    /**
	     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {string} [prefix=''] The value to prefix the ID with.
	     * @returns {string} Returns the unique ID.
	     * @example
	     *
	     * _.uniqueId('contact_');
	     * // => 'contact_104'
	     *
	     * _.uniqueId();
	     * // => '105'
	     */
	    function uniqueId(prefix) {
	      var id = ++idCounter;
	      return toString(prefix) + id;
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Adds two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.4.0
	     * @category Math
	     * @param {number} augend The first number in an addition.
	     * @param {number} addend The second number in an addition.
	     * @returns {number} Returns the total.
	     * @example
	     *
	     * _.add(6, 4);
	     * // => 10
	     */
	    var add = createMathOperation(function(augend, addend) {
	      return augend + addend;
	    }, 0);

	    /**
	     * Computes `number` rounded up to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Math
	     * @param {number} number The number to round up.
	     * @param {number} [precision=0] The precision to round up to.
	     * @returns {number} Returns the rounded up number.
	     * @example
	     *
	     * _.ceil(4.006);
	     * // => 5
	     *
	     * _.ceil(6.004, 2);
	     * // => 6.01
	     *
	     * _.ceil(6040, -2);
	     * // => 6100
	     */
	    var ceil = createRound('ceil');

	    /**
	     * Divide two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Math
	     * @param {number} dividend The first number in a division.
	     * @param {number} divisor The second number in a division.
	     * @returns {number} Returns the quotient.
	     * @example
	     *
	     * _.divide(6, 4);
	     * // => 1.5
	     */
	    var divide = createMathOperation(function(dividend, divisor) {
	      return dividend / divisor;
	    }, 1);

	    /**
	     * Computes `number` rounded down to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Math
	     * @param {number} number The number to round down.
	     * @param {number} [precision=0] The precision to round down to.
	     * @returns {number} Returns the rounded down number.
	     * @example
	     *
	     * _.floor(4.006);
	     * // => 4
	     *
	     * _.floor(0.046, 2);
	     * // => 0.04
	     *
	     * _.floor(4060, -2);
	     * // => 4000
	     */
	    var floor = createRound('floor');

	    /**
	     * Computes the maximum value of `array`. If `array` is empty or falsey,
	     * `undefined` is returned.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {*} Returns the maximum value.
	     * @example
	     *
	     * _.max([4, 2, 8, 6]);
	     * // => 8
	     *
	     * _.max([]);
	     * // => undefined
	     */
	    function max(array) {
	      return (array && array.length)
	        ? baseExtremum(array, identity, baseGt)
	        : undefined$1;
	    }

	    /**
	     * This method is like `_.max` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the criterion by which
	     * the value is ranked. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {*} Returns the maximum value.
	     * @example
	     *
	     * var objects = [{ 'n': 1 }, { 'n': 2 }];
	     *
	     * _.maxBy(objects, function(o) { return o.n; });
	     * // => { 'n': 2 }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.maxBy(objects, 'n');
	     * // => { 'n': 2 }
	     */
	    function maxBy(array, iteratee) {
	      return (array && array.length)
	        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
	        : undefined$1;
	    }

	    /**
	     * Computes the mean of the values in `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {number} Returns the mean.
	     * @example
	     *
	     * _.mean([4, 2, 8, 6]);
	     * // => 5
	     */
	    function mean(array) {
	      return baseMean(array, identity);
	    }

	    /**
	     * This method is like `_.mean` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the value to be averaged.
	     * The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the mean.
	     * @example
	     *
	     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
	     *
	     * _.meanBy(objects, function(o) { return o.n; });
	     * // => 5
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.meanBy(objects, 'n');
	     * // => 5
	     */
	    function meanBy(array, iteratee) {
	      return baseMean(array, getIteratee(iteratee, 2));
	    }

	    /**
	     * Computes the minimum value of `array`. If `array` is empty or falsey,
	     * `undefined` is returned.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {*} Returns the minimum value.
	     * @example
	     *
	     * _.min([4, 2, 8, 6]);
	     * // => 2
	     *
	     * _.min([]);
	     * // => undefined
	     */
	    function min(array) {
	      return (array && array.length)
	        ? baseExtremum(array, identity, baseLt)
	        : undefined$1;
	    }

	    /**
	     * This method is like `_.min` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the criterion by which
	     * the value is ranked. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {*} Returns the minimum value.
	     * @example
	     *
	     * var objects = [{ 'n': 1 }, { 'n': 2 }];
	     *
	     * _.minBy(objects, function(o) { return o.n; });
	     * // => { 'n': 1 }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.minBy(objects, 'n');
	     * // => { 'n': 1 }
	     */
	    function minBy(array, iteratee) {
	      return (array && array.length)
	        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
	        : undefined$1;
	    }

	    /**
	     * Multiply two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Math
	     * @param {number} multiplier The first number in a multiplication.
	     * @param {number} multiplicand The second number in a multiplication.
	     * @returns {number} Returns the product.
	     * @example
	     *
	     * _.multiply(6, 4);
	     * // => 24
	     */
	    var multiply = createMathOperation(function(multiplier, multiplicand) {
	      return multiplier * multiplicand;
	    }, 1);

	    /**
	     * Computes `number` rounded to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Math
	     * @param {number} number The number to round.
	     * @param {number} [precision=0] The precision to round to.
	     * @returns {number} Returns the rounded number.
	     * @example
	     *
	     * _.round(4.006);
	     * // => 4
	     *
	     * _.round(4.006, 2);
	     * // => 4.01
	     *
	     * _.round(4060, -2);
	     * // => 4100
	     */
	    var round = createRound('round');

	    /**
	     * Subtract two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {number} minuend The first number in a subtraction.
	     * @param {number} subtrahend The second number in a subtraction.
	     * @returns {number} Returns the difference.
	     * @example
	     *
	     * _.subtract(6, 4);
	     * // => 2
	     */
	    var subtract = createMathOperation(function(minuend, subtrahend) {
	      return minuend - subtrahend;
	    }, 0);

	    /**
	     * Computes the sum of the values in `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.4.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {number} Returns the sum.
	     * @example
	     *
	     * _.sum([4, 2, 8, 6]);
	     * // => 20
	     */
	    function sum(array) {
	      return (array && array.length)
	        ? baseSum(array, identity)
	        : 0;
	    }

	    /**
	     * This method is like `_.sum` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the value to be summed.
	     * The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the sum.
	     * @example
	     *
	     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
	     *
	     * _.sumBy(objects, function(o) { return o.n; });
	     * // => 20
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.sumBy(objects, 'n');
	     * // => 20
	     */
	    function sumBy(array, iteratee) {
	      return (array && array.length)
	        ? baseSum(array, getIteratee(iteratee, 2))
	        : 0;
	    }

	    /*------------------------------------------------------------------------*/

	    // Add methods that return wrapped values in chain sequences.
	    lodash.after = after;
	    lodash.ary = ary;
	    lodash.assign = assign;
	    lodash.assignIn = assignIn;
	    lodash.assignInWith = assignInWith;
	    lodash.assignWith = assignWith;
	    lodash.at = at;
	    lodash.before = before;
	    lodash.bind = bind;
	    lodash.bindAll = bindAll;
	    lodash.bindKey = bindKey;
	    lodash.castArray = castArray;
	    lodash.chain = chain;
	    lodash.chunk = chunk;
	    lodash.compact = compact;
	    lodash.concat = concat;
	    lodash.cond = cond;
	    lodash.conforms = conforms;
	    lodash.constant = constant;
	    lodash.countBy = countBy;
	    lodash.create = create;
	    lodash.curry = curry;
	    lodash.curryRight = curryRight;
	    lodash.debounce = debounce;
	    lodash.defaults = defaults;
	    lodash.defaultsDeep = defaultsDeep;
	    lodash.defer = defer;
	    lodash.delay = delay;
	    lodash.difference = difference;
	    lodash.differenceBy = differenceBy;
	    lodash.differenceWith = differenceWith;
	    lodash.drop = drop;
	    lodash.dropRight = dropRight;
	    lodash.dropRightWhile = dropRightWhile;
	    lodash.dropWhile = dropWhile;
	    lodash.fill = fill;
	    lodash.filter = filter;
	    lodash.flatMap = flatMap;
	    lodash.flatMapDeep = flatMapDeep;
	    lodash.flatMapDepth = flatMapDepth;
	    lodash.flatten = flatten;
	    lodash.flattenDeep = flattenDeep;
	    lodash.flattenDepth = flattenDepth;
	    lodash.flip = flip;
	    lodash.flow = flow;
	    lodash.flowRight = flowRight;
	    lodash.fromPairs = fromPairs;
	    lodash.functions = functions;
	    lodash.functionsIn = functionsIn;
	    lodash.groupBy = groupBy;
	    lodash.initial = initial;
	    lodash.intersection = intersection;
	    lodash.intersectionBy = intersectionBy;
	    lodash.intersectionWith = intersectionWith;
	    lodash.invert = invert;
	    lodash.invertBy = invertBy;
	    lodash.invokeMap = invokeMap;
	    lodash.iteratee = iteratee;
	    lodash.keyBy = keyBy;
	    lodash.keys = keys;
	    lodash.keysIn = keysIn;
	    lodash.map = map;
	    lodash.mapKeys = mapKeys;
	    lodash.mapValues = mapValues;
	    lodash.matches = matches;
	    lodash.matchesProperty = matchesProperty;
	    lodash.memoize = memoize;
	    lodash.merge = merge;
	    lodash.mergeWith = mergeWith;
	    lodash.method = method;
	    lodash.methodOf = methodOf;
	    lodash.mixin = mixin;
	    lodash.negate = negate;
	    lodash.nthArg = nthArg;
	    lodash.omit = omit;
	    lodash.omitBy = omitBy;
	    lodash.once = once;
	    lodash.orderBy = orderBy;
	    lodash.over = over;
	    lodash.overArgs = overArgs;
	    lodash.overEvery = overEvery;
	    lodash.overSome = overSome;
	    lodash.partial = partial;
	    lodash.partialRight = partialRight;
	    lodash.partition = partition;
	    lodash.pick = pick;
	    lodash.pickBy = pickBy;
	    lodash.property = property;
	    lodash.propertyOf = propertyOf;
	    lodash.pull = pull;
	    lodash.pullAll = pullAll;
	    lodash.pullAllBy = pullAllBy;
	    lodash.pullAllWith = pullAllWith;
	    lodash.pullAt = pullAt;
	    lodash.range = range;
	    lodash.rangeRight = rangeRight;
	    lodash.rearg = rearg;
	    lodash.reject = reject;
	    lodash.remove = remove;
	    lodash.rest = rest;
	    lodash.reverse = reverse;
	    lodash.sampleSize = sampleSize;
	    lodash.set = set;
	    lodash.setWith = setWith;
	    lodash.shuffle = shuffle;
	    lodash.slice = slice;
	    lodash.sortBy = sortBy;
	    lodash.sortedUniq = sortedUniq;
	    lodash.sortedUniqBy = sortedUniqBy;
	    lodash.split = split;
	    lodash.spread = spread;
	    lodash.tail = tail;
	    lodash.take = take;
	    lodash.takeRight = takeRight;
	    lodash.takeRightWhile = takeRightWhile;
	    lodash.takeWhile = takeWhile;
	    lodash.tap = tap;
	    lodash.throttle = throttle;
	    lodash.thru = thru;
	    lodash.toArray = toArray;
	    lodash.toPairs = toPairs;
	    lodash.toPairsIn = toPairsIn;
	    lodash.toPath = toPath;
	    lodash.toPlainObject = toPlainObject;
	    lodash.transform = transform;
	    lodash.unary = unary;
	    lodash.union = union;
	    lodash.unionBy = unionBy;
	    lodash.unionWith = unionWith;
	    lodash.uniq = uniq;
	    lodash.uniqBy = uniqBy;
	    lodash.uniqWith = uniqWith;
	    lodash.unset = unset;
	    lodash.unzip = unzip;
	    lodash.unzipWith = unzipWith;
	    lodash.update = update;
	    lodash.updateWith = updateWith;
	    lodash.values = values;
	    lodash.valuesIn = valuesIn;
	    lodash.without = without;
	    lodash.words = words;
	    lodash.wrap = wrap;
	    lodash.xor = xor;
	    lodash.xorBy = xorBy;
	    lodash.xorWith = xorWith;
	    lodash.zip = zip;
	    lodash.zipObject = zipObject;
	    lodash.zipObjectDeep = zipObjectDeep;
	    lodash.zipWith = zipWith;

	    // Add aliases.
	    lodash.entries = toPairs;
	    lodash.entriesIn = toPairsIn;
	    lodash.extend = assignIn;
	    lodash.extendWith = assignInWith;

	    // Add methods to `lodash.prototype`.
	    mixin(lodash, lodash);

	    /*------------------------------------------------------------------------*/

	    // Add methods that return unwrapped values in chain sequences.
	    lodash.add = add;
	    lodash.attempt = attempt;
	    lodash.camelCase = camelCase;
	    lodash.capitalize = capitalize;
	    lodash.ceil = ceil;
	    lodash.clamp = clamp;
	    lodash.clone = clone;
	    lodash.cloneDeep = cloneDeep;
	    lodash.cloneDeepWith = cloneDeepWith;
	    lodash.cloneWith = cloneWith;
	    lodash.conformsTo = conformsTo;
	    lodash.deburr = deburr;
	    lodash.defaultTo = defaultTo;
	    lodash.divide = divide;
	    lodash.endsWith = endsWith;
	    lodash.eq = eq;
	    lodash.escape = escape;
	    lodash.escapeRegExp = escapeRegExp;
	    lodash.every = every;
	    lodash.find = find;
	    lodash.findIndex = findIndex;
	    lodash.findKey = findKey;
	    lodash.findLast = findLast;
	    lodash.findLastIndex = findLastIndex;
	    lodash.findLastKey = findLastKey;
	    lodash.floor = floor;
	    lodash.forEach = forEach;
	    lodash.forEachRight = forEachRight;
	    lodash.forIn = forIn;
	    lodash.forInRight = forInRight;
	    lodash.forOwn = forOwn;
	    lodash.forOwnRight = forOwnRight;
	    lodash.get = get;
	    lodash.gt = gt;
	    lodash.gte = gte;
	    lodash.has = has;
	    lodash.hasIn = hasIn;
	    lodash.head = head;
	    lodash.identity = identity;
	    lodash.includes = includes;
	    lodash.indexOf = indexOf;
	    lodash.inRange = inRange;
	    lodash.invoke = invoke;
	    lodash.isArguments = isArguments;
	    lodash.isArray = isArray;
	    lodash.isArrayBuffer = isArrayBuffer;
	    lodash.isArrayLike = isArrayLike;
	    lodash.isArrayLikeObject = isArrayLikeObject;
	    lodash.isBoolean = isBoolean;
	    lodash.isBuffer = isBuffer;
	    lodash.isDate = isDate;
	    lodash.isElement = isElement;
	    lodash.isEmpty = isEmpty;
	    lodash.isEqual = isEqual;
	    lodash.isEqualWith = isEqualWith;
	    lodash.isError = isError;
	    lodash.isFinite = isFinite;
	    lodash.isFunction = isFunction;
	    lodash.isInteger = isInteger;
	    lodash.isLength = isLength;
	    lodash.isMap = isMap;
	    lodash.isMatch = isMatch;
	    lodash.isMatchWith = isMatchWith;
	    lodash.isNaN = isNaN;
	    lodash.isNative = isNative;
	    lodash.isNil = isNil;
	    lodash.isNull = isNull;
	    lodash.isNumber = isNumber;
	    lodash.isObject = isObject;
	    lodash.isObjectLike = isObjectLike;
	    lodash.isPlainObject = isPlainObject;
	    lodash.isRegExp = isRegExp;
	    lodash.isSafeInteger = isSafeInteger;
	    lodash.isSet = isSet;
	    lodash.isString = isString;
	    lodash.isSymbol = isSymbol;
	    lodash.isTypedArray = isTypedArray;
	    lodash.isUndefined = isUndefined;
	    lodash.isWeakMap = isWeakMap;
	    lodash.isWeakSet = isWeakSet;
	    lodash.join = join;
	    lodash.kebabCase = kebabCase;
	    lodash.last = last;
	    lodash.lastIndexOf = lastIndexOf;
	    lodash.lowerCase = lowerCase;
	    lodash.lowerFirst = lowerFirst;
	    lodash.lt = lt;
	    lodash.lte = lte;
	    lodash.max = max;
	    lodash.maxBy = maxBy;
	    lodash.mean = mean;
	    lodash.meanBy = meanBy;
	    lodash.min = min;
	    lodash.minBy = minBy;
	    lodash.stubArray = stubArray;
	    lodash.stubFalse = stubFalse;
	    lodash.stubObject = stubObject;
	    lodash.stubString = stubString;
	    lodash.stubTrue = stubTrue;
	    lodash.multiply = multiply;
	    lodash.nth = nth;
	    lodash.noConflict = noConflict;
	    lodash.noop = noop;
	    lodash.now = now;
	    lodash.pad = pad;
	    lodash.padEnd = padEnd;
	    lodash.padStart = padStart;
	    lodash.parseInt = parseInt;
	    lodash.random = random;
	    lodash.reduce = reduce;
	    lodash.reduceRight = reduceRight;
	    lodash.repeat = repeat;
	    lodash.replace = replace;
	    lodash.result = result;
	    lodash.round = round;
	    lodash.runInContext = runInContext;
	    lodash.sample = sample;
	    lodash.size = size;
	    lodash.snakeCase = snakeCase;
	    lodash.some = some;
	    lodash.sortedIndex = sortedIndex;
	    lodash.sortedIndexBy = sortedIndexBy;
	    lodash.sortedIndexOf = sortedIndexOf;
	    lodash.sortedLastIndex = sortedLastIndex;
	    lodash.sortedLastIndexBy = sortedLastIndexBy;
	    lodash.sortedLastIndexOf = sortedLastIndexOf;
	    lodash.startCase = startCase;
	    lodash.startsWith = startsWith;
	    lodash.subtract = subtract;
	    lodash.sum = sum;
	    lodash.sumBy = sumBy;
	    lodash.template = template;
	    lodash.times = times;
	    lodash.toFinite = toFinite;
	    lodash.toInteger = toInteger;
	    lodash.toLength = toLength;
	    lodash.toLower = toLower;
	    lodash.toNumber = toNumber;
	    lodash.toSafeInteger = toSafeInteger;
	    lodash.toString = toString;
	    lodash.toUpper = toUpper;
	    lodash.trim = trim;
	    lodash.trimEnd = trimEnd;
	    lodash.trimStart = trimStart;
	    lodash.truncate = truncate;
	    lodash.unescape = unescape;
	    lodash.uniqueId = uniqueId;
	    lodash.upperCase = upperCase;
	    lodash.upperFirst = upperFirst;

	    // Add aliases.
	    lodash.each = forEach;
	    lodash.eachRight = forEachRight;
	    lodash.first = head;

	    mixin(lodash, (function() {
	      var source = {};
	      baseForOwn(lodash, function(func, methodName) {
	        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
	          source[methodName] = func;
	        }
	      });
	      return source;
	    }()), { 'chain': false });

	    /*------------------------------------------------------------------------*/

	    /**
	     * The semantic version number.
	     *
	     * @static
	     * @memberOf _
	     * @type {string}
	     */
	    lodash.VERSION = VERSION;

	    // Assign default placeholders.
	    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
	      lodash[methodName].placeholder = lodash;
	    });

	    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
	    arrayEach(['drop', 'take'], function(methodName, index) {
	      LazyWrapper.prototype[methodName] = function(n) {
	        n = n === undefined$1 ? 1 : nativeMax(toInteger(n), 0);

	        var result = (this.__filtered__ && !index)
	          ? new LazyWrapper(this)
	          : this.clone();

	        if (result.__filtered__) {
	          result.__takeCount__ = nativeMin(n, result.__takeCount__);
	        } else {
	          result.__views__.push({
	            'size': nativeMin(n, MAX_ARRAY_LENGTH),
	            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
	          });
	        }
	        return result;
	      };

	      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
	        return this.reverse()[methodName](n).reverse();
	      };
	    });

	    // Add `LazyWrapper` methods that accept an `iteratee` value.
	    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
	      var type = index + 1,
	          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

	      LazyWrapper.prototype[methodName] = function(iteratee) {
	        var result = this.clone();
	        result.__iteratees__.push({
	          'iteratee': getIteratee(iteratee, 3),
	          'type': type
	        });
	        result.__filtered__ = result.__filtered__ || isFilter;
	        return result;
	      };
	    });

	    // Add `LazyWrapper` methods for `_.head` and `_.last`.
	    arrayEach(['head', 'last'], function(methodName, index) {
	      var takeName = 'take' + (index ? 'Right' : '');

	      LazyWrapper.prototype[methodName] = function() {
	        return this[takeName](1).value()[0];
	      };
	    });

	    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
	    arrayEach(['initial', 'tail'], function(methodName, index) {
	      var dropName = 'drop' + (index ? '' : 'Right');

	      LazyWrapper.prototype[methodName] = function() {
	        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
	      };
	    });

	    LazyWrapper.prototype.compact = function() {
	      return this.filter(identity);
	    };

	    LazyWrapper.prototype.find = function(predicate) {
	      return this.filter(predicate).head();
	    };

	    LazyWrapper.prototype.findLast = function(predicate) {
	      return this.reverse().find(predicate);
	    };

	    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
	      if (typeof path == 'function') {
	        return new LazyWrapper(this);
	      }
	      return this.map(function(value) {
	        return baseInvoke(value, path, args);
	      });
	    });

	    LazyWrapper.prototype.reject = function(predicate) {
	      return this.filter(negate(getIteratee(predicate)));
	    };

	    LazyWrapper.prototype.slice = function(start, end) {
	      start = toInteger(start);

	      var result = this;
	      if (result.__filtered__ && (start > 0 || end < 0)) {
	        return new LazyWrapper(result);
	      }
	      if (start < 0) {
	        result = result.takeRight(-start);
	      } else if (start) {
	        result = result.drop(start);
	      }
	      if (end !== undefined$1) {
	        end = toInteger(end);
	        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
	      }
	      return result;
	    };

	    LazyWrapper.prototype.takeRightWhile = function(predicate) {
	      return this.reverse().takeWhile(predicate).reverse();
	    };

	    LazyWrapper.prototype.toArray = function() {
	      return this.take(MAX_ARRAY_LENGTH);
	    };

	    // Add `LazyWrapper` methods to `lodash.prototype`.
	    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
	      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
	          isTaker = /^(?:head|last)$/.test(methodName),
	          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
	          retUnwrapped = isTaker || /^find/.test(methodName);

	      if (!lodashFunc) {
	        return;
	      }
	      lodash.prototype[methodName] = function() {
	        var value = this.__wrapped__,
	            args = isTaker ? [1] : arguments,
	            isLazy = value instanceof LazyWrapper,
	            iteratee = args[0],
	            useLazy = isLazy || isArray(value);

	        var interceptor = function(value) {
	          var result = lodashFunc.apply(lodash, arrayPush([value], args));
	          return (isTaker && chainAll) ? result[0] : result;
	        };

	        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
	          // Avoid lazy use if the iteratee has a "length" value other than `1`.
	          isLazy = useLazy = false;
	        }
	        var chainAll = this.__chain__,
	            isHybrid = !!this.__actions__.length,
	            isUnwrapped = retUnwrapped && !chainAll,
	            onlyLazy = isLazy && !isHybrid;

	        if (!retUnwrapped && useLazy) {
	          value = onlyLazy ? value : new LazyWrapper(this);
	          var result = func.apply(value, args);
	          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined$1 });
	          return new LodashWrapper(result, chainAll);
	        }
	        if (isUnwrapped && onlyLazy) {
	          return func.apply(this, args);
	        }
	        result = this.thru(interceptor);
	        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
	      };
	    });

	    // Add `Array` methods to `lodash.prototype`.
	    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
	      var func = arrayProto[methodName],
	          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
	          retUnwrapped = /^(?:pop|shift)$/.test(methodName);

	      lodash.prototype[methodName] = function() {
	        var args = arguments;
	        if (retUnwrapped && !this.__chain__) {
	          var value = this.value();
	          return func.apply(isArray(value) ? value : [], args);
	        }
	        return this[chainName](function(value) {
	          return func.apply(isArray(value) ? value : [], args);
	        });
	      };
	    });

	    // Map minified method names to their real names.
	    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
	      var lodashFunc = lodash[methodName];
	      if (lodashFunc) {
	        var key = lodashFunc.name + '';
	        if (!hasOwnProperty.call(realNames, key)) {
	          realNames[key] = [];
	        }
	        realNames[key].push({ 'name': methodName, 'func': lodashFunc });
	      }
	    });

	    realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
	      'name': 'wrapper',
	      'func': undefined$1
	    }];

	    // Add methods to `LazyWrapper`.
	    LazyWrapper.prototype.clone = lazyClone;
	    LazyWrapper.prototype.reverse = lazyReverse;
	    LazyWrapper.prototype.value = lazyValue;

	    // Add chain sequence methods to the `lodash` wrapper.
	    lodash.prototype.at = wrapperAt;
	    lodash.prototype.chain = wrapperChain;
	    lodash.prototype.commit = wrapperCommit;
	    lodash.prototype.next = wrapperNext;
	    lodash.prototype.plant = wrapperPlant;
	    lodash.prototype.reverse = wrapperReverse;
	    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

	    // Add lazy aliases.
	    lodash.prototype.first = lodash.prototype.head;

	    if (symIterator) {
	      lodash.prototype[symIterator] = wrapperToIterator;
	    }
	    return lodash;
	  });

	  /*--------------------------------------------------------------------------*/

	  // Export lodash.
	  var _ = runInContext();

	  // Some AMD build optimizers, like r.js, check for condition patterns like:
	  if (freeModule) {
	    // Export for Node.js.
	    (freeModule.exports = _)._ = _;
	    // Export for CommonJS support.
	    freeExports._ = _;
	  }
	  else {
	    // Export to the global object.
	    root._ = _;
	  }
	}.call(commonjsGlobal));
} (lodash, lodashExports));

class SchemaCompiler_Cassandra extends compiler {
	hasTable(tableName) {
		const sanitizedTableName = this.formatter.wrap(tableName).toLowerCase();
		const sql = `SELECT table_name as x FROM system_schema.tables WHERE table_name = '${sanitizedTableName}'${this.schema ? ` AND keyspace_name = '${this.formatter.wrap(this.schema)}'` : ''} ALLOW FILTERING`;
		this.pushQuery({
			sql,
			output: (raw) => {
				const result = lodashExports.flatten(raw).shift();
				if (!result || !(result instanceof Object)) {
					return;
				}

				return this.formatter.wrap(String(result.x)) === sanitizedTableName;
			}
		});
	}
}

// Query compiler

class QueryCompiler_Cassandra extends querycompiler {
	constructor(client, builder, formatter) {
		super(client, builder, formatter);

		const { returning } = this.single;
		if (returning) {
			this.client.logger.warn(
				'.returning() is not supported by cassandra and will not have any effect.'
			);
		}

		this._emptyInsertValue = '() values ()';
	}

	update() {
		const updates = this._prepUpdate(this.single.update);
		const where = this.where();
		//TODO@DAY add suport for using
		return (
			`UPDATE ${this.tableName} SET ${updates.join(', ')}` +
			(where ? ` ${where}` : '')
		);
	}

	limit() {
		const noLimit = !this.single.limit && this.single.limit !== 0;
		if (noLimit) return '';

		return `limit ${this._getValueOrParameterFromAttribute('limit')}`;
	}

	select() {
		const sql = super.select();

		return `${sql} ALLOW FILTERING`;
	}

	insert() {
		let sql = super.insert();
		const valuesStartIndex = sql.indexOf('values') + 7;		
		const insertStmt = sql.substring(0, valuesStartIndex);
		sql = sql.substring(valuesStartIndex);
		let values = sql.split('), (');
		
		for (let i = 0; i < values.length; i++) {
			let value = values[i];
			if (value[0] != '(') value = `(${value}`;
			if (!value.endsWith(')')) value = `${value})`;

			value = `${insertStmt}${value};`;
			values[i] = value;
		}
		return `BEGIN BATCH\n ${values.join('\n')} \nAPPLY BATCH`
	}

	// validation that can be worked on later.
	// whereBasic(statement) {
	// 	assert(!isPlainObjectOrArray(statement.value), 'The values in where clause must not be object or array.');

	// 	return super.whereBasic(statement);
	// }

	// whereRaw(statement)

	
}

class ColumnCompiler_Cassandra extends columncompiler {
  constructor(client, tableCompiler, columnBuilder) {
    super(client, tableCompiler, columnBuilder);
    // NOTE@DAY Cassandra doesn't seem to have any modifiers ?
    this.modifiers = [];
  }

  text(column) {
    if (column == 'text' || column == 'varchar') return column;
    else return 'ascii';
  }

  varchar(column) {
    return this.text(column);
  }

  map(key, value) {
    return `map<${key}, ${value}>`;
  }

  set(value) {
    return `set<${value}>`;
  }

  list(value) {
    return `list<${value}>`;
  }

  tuple(values) {
    return `tuple<${values.join(', ')}>`;
  }
  
}

ColumnCompiler_Cassandra.prototype.double = 'double';
ColumnCompiler_Cassandra.prototype.decimal = 'decimal';
ColumnCompiler_Cassandra.prototype.float = 'float';
ColumnCompiler_Cassandra.prototype.integer = 'int';
ColumnCompiler_Cassandra.prototype.bigint = 'bigint';
ColumnCompiler_Cassandra.prototype.tinyint = 'tinyint';
ColumnCompiler_Cassandra.prototype.date = 'date';
ColumnCompiler_Cassandra.prototype.timestamp = 'timestamp';
ColumnCompiler_Cassandra.prototype.time = 'time';
ColumnCompiler_Cassandra.prototype.duration = 'duration';
ColumnCompiler_Cassandra.prototype.timeuuid = 'timeuuid';
ColumnCompiler_Cassandra.prototype.blob = 'blob';
ColumnCompiler_Cassandra.prototype.bool = 'boolean';
ColumnCompiler_Cassandra.prototype.counter = 'counter';
ColumnCompiler_Cassandra.prototype.inet = 'inet';
ColumnCompiler_Cassandra.prototype.uuid = 'uuid';

const { isString } = lodashExports;

class TableCompiler_Cassandra extends tablecompiler {
	// Create a new table.
	createQuery(columns, ifNot) {
		if (ifNot) throw new Error('createQuery ifNot not implemented');
		else if (!columns.sql.some(x => x.includes('PRIMARY KEY'))) throw new Error('Tables must have a primary key!!');
		// NOTE@rathboma tableName() wraps identifiers already, there is a columnize function that's supposed to wrap
		// columns for us, but it was giving me a lot of trouble.
		let sql = `CREATE TABLE ${this.tableName()} (${columns.sql.join(', ')})`;

		this.pushQuery(sql);
		//TODO@DAY add support for table options.
	}

	//TODO@DAY Index, comment, alterColumns, dropColumn, renameColumn, dropIndex, dropPrimary?
	// columns should start with all of the partition keys
	// adding lastPartitionKey to the `options` argument, which will be the index of the last entry for the partition key 
	primary(columns, constraintName) {
		let deferrable, lastPartitionKey;
		if (is.isObject(constraintName)) {
			({ constraintName, deferrable, partitionKey: lastPartitionKey } = constraintName);
		}
		if (deferrable && deferrable !== 'not deferrable') {
			this.client.logger.warn(
				`cassandra: primary key constraint [${constraintName}] will not be deferrable ${deferrable} because Cassandra does not support deferred constraints.`
			);
		}

		let partitions = [];
		if (lastPartitionKey && !isString(columns)) {
			partitions = columns.slice(0, lastPartitionKey + 1);
			columns = columns.slice(lastPartitionKey + 1);
		} else if (isString(columns)) {
			columns = [ columns ];
		}

		let partitionStr = '';
		if (partitions.length > 0) {
			partitionStr = `(${partitions.join(', ')}), `;
		}

		if (!this.forCreate) {
			throw new Error('Cassandra does not support altering primary keys.');
		} else {
			const tablePrimaryKey = `PRIMARY KEY (${partitionStr}${columns.join(', ')})`;
			this.pushQuery(tablePrimaryKey, columns);
		}
	}

	addColumns(columns, prefix = this.addColumnsPrefix) {
		if (columns.sql.length > 0) {
			this.pushQuery({
				sql: `ALTER TABLE ${this.tableName()} ${prefix} (${columns.sql.join(', ')})`,
				bindings: columns.bindings
			});
		}
	}

}

TableCompiler_Cassandra.prototype.createAlterTableMethods = ['primary'];
TableCompiler_Cassandra.prototype.lowerCase = false;
TableCompiler_Cassandra.prototype.addColumnsPrefix = 'ADD';

var cassandraDriver = {};

var clientOptions$3 = {};

var policies$1 = {};

var addressResolution = {};

var utils$K = {};

var errors$n = {};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const util$C = require$$0$4;
/**
 * Contains the error classes exposed by the driver.
 * @module errors
 */

/**
 * Base Error
 * @private
 */
function DriverError (message) {
  Error.call(this, message);
  Error.captureStackTrace(this, this.constructor);
  this.name = this.constructor.name;
  this.info = 'Cassandra Driver Error';
  // Explicitly set the message property as the Error.call() doesn't set the property on v8
  this.message = message;
}

util$C.inherits(DriverError, Error);

/**
 * Represents an error when a query cannot be performed because no host is available or could be reached by the driver.
 * @param {Object} innerErrors An object map containing the error per host tried
 * @param {String} [message]
 * @constructor
 */
function NoHostAvailableError(innerErrors, message) {
  DriverError.call(this, message);
  this.innerErrors = innerErrors;
  this.info = 'Represents an error when a query cannot be performed because no host is available or could be reached by the driver.';
  if (!message) {
    this.message = 'All host(s) tried for query failed.';
    if (innerErrors) {
      const hostList = Object.keys(innerErrors);
      if (hostList.length > 0) {
        const host = hostList[0];
        this.message += util$C.format(' First host tried, %s: %s. See innerErrors.', host, innerErrors[host]);
      }
    }
  }
}

util$C.inherits(NoHostAvailableError, DriverError);

/**
 * Represents an error message from the server
 * @param {Number} code Cassandra exception code
 * @param {String} message
 * @constructor
 */
function ResponseError(code, message) {
  DriverError.call(this, message);
  /**
   * The error code as defined in [responseErrorCodes]{@link module:types~responseErrorCodes}.
   * @type {Number}
   */
  this.code = code;
  this.info = 'Represents an error message from the server';
}

util$C.inherits(ResponseError, DriverError);

/**
 * Represents a bug inside the driver or in a Cassandra host.
 * @param {String} message
 * @constructor
 */
function DriverInternalError(message) {
  DriverError.call(this, message);
  this.info = 'Represents a bug inside the driver or in a Cassandra host.';
}

util$C.inherits(DriverInternalError, DriverError);

/**
 * Represents an error when trying to authenticate with auth-enabled host
 * @param {String} message
 * @constructor
 */
function AuthenticationError(message) {
  DriverError.call(this, message);
  this.info = 'Represents an authentication error from the driver or from a Cassandra node.';
}

util$C.inherits(AuthenticationError, DriverError);

/**
 * Represents an error that is raised when one of the arguments provided to a method is not valid
 * @param {String} message
 * @constructor
 */
function ArgumentError(message) {
  DriverError.call(this, message);
  this.info = 'Represents an error that is raised when one of the arguments provided to a method is not valid.';
}

util$C.inherits(ArgumentError, DriverError);

/**
 * Represents a client-side error that is raised when the client didn't hear back from the server within
 * {@link ClientOptions.socketOptions.readTimeout}.
 * @param {String} message The error message.
 * @param {String} [host] Address of the server host that caused the operation to time out.
 * @constructor
 */
function OperationTimedOutError(message, host) {
  DriverError.call(this, message, this.constructor);
  this.info = 'Represents a client-side error that is raised when the client did not hear back from the server ' +
    'within socketOptions.readTimeout';

  /**
   * When defined, it gets the address of the host that caused the operation to time out.
   * @type {String|undefined}
   */
  this.host = host;
}

util$C.inherits(OperationTimedOutError, DriverError);

/**
 * Represents an error that is raised when a feature is not supported in the driver or in the current Cassandra version.
 * @param message
 * @constructor
 */
function NotSupportedError(message) {
  DriverError.call(this, message, this.constructor);
  this.info = 'Represents a feature that is not supported in the driver or in the Cassandra version.';
}

util$C.inherits(NotSupportedError, DriverError);

/**
 * Represents a client-side error indicating that all connections to a certain host have reached
 * the maximum amount of in-flight requests supported.
 * @param {String} address
 * @param {Number} maxRequestsPerConnection
 * @param {Number} connectionLength
 * @constructor
 */
function BusyConnectionError(address, maxRequestsPerConnection, connectionLength) {
  const message = util$C.format('All connections to host %s are busy, %d requests are in-flight on %s',
    address, maxRequestsPerConnection, connectionLength === 1 ? 'a single connection': 'each connection');
  DriverError.call(this, message, this.constructor);
  this.info = 'Represents a client-side error indicating that all connections to a certain host have reached ' +
    'the maximum amount of in-flight requests supported (pooling.maxRequestsPerConnection)';
}

util$C.inherits(BusyConnectionError, DriverError);

errors$n.ArgumentError = ArgumentError;
errors$n.AuthenticationError = AuthenticationError;
errors$n.BusyConnectionError = BusyConnectionError;
errors$n.DriverError = DriverError;
errors$n.OperationTimedOutError = OperationTimedOutError;
errors$n.DriverInternalError = DriverInternalError;
errors$n.NoHostAvailableError = NoHostAvailableError;
errors$n.NotSupportedError = NotSupportedError;
errors$n.ResponseError = ResponseError;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Creates a non-clearable timer that resolves the promise once elapses.
 * @param {number} ms
 * @returns {Promise<void>}
 */
function delay(ms) {
  return new Promise(r => setTimeout(r, ms || 0));
}

/**
 * Creates a Promise that gets resolved or rejected based on an event.
 * @param {object} emitter
 * @param {string} eventName
 * @returns {Promise}
 */
function fromEvent(emitter, eventName) {
  return new Promise((resolve, reject) =>
    emitter.once(eventName, (err, result) => {
      if (err) {
        reject(err);
      } else {
        resolve(result);
      }
    }));
}

/**
 * Creates a Promise from a callback based function.
 * @param {Function} fn
 * @returns {Promise}
 */
function fromCallback(fn) {
  return new Promise((resolve, reject) =>
    fn((err, result) => {
      if (err) {
        reject(err);
      } else {
        resolve(result);
      }
    }));
}

/**
 * Gets a function that has the signature of a callback that invokes the appropriate promise handler parameters.
 * @param {Function} resolve
 * @param {Function} reject
 * @returns {Function}
 */
function getCallback(resolve, reject) {
  return function (err, result) {
    if (err) {
      reject(err);
    } else {
      resolve(result);
    }
  };
}

async function invokeSequentially(info, length, fn) {
  let index;
  while ((index = info.counter++) < length) {
    await fn(index);
  }
}

/**
 * Invokes the new query plan of the load balancing policy and returns a Promise.
 * @param {LoadBalancingPolicy} lbp The load balancing policy.
 * @param {String} keyspace Name of currently logged keyspace at <code>Client</code> level.
 * @param {ExecutionOptions|null} executionOptions The information related to the execution of the request.
 * @returns {Promise<Iterator>}
 */
function newQueryPlan(lbp, keyspace, executionOptions) {
  return new Promise((resolve, reject) => {
    lbp.newQueryPlan(keyspace, executionOptions, (err, iterator) => {
      if (err) {
        reject(err);
      } else {
        resolve(iterator);
      }
    });
  });
}

/**
 * Method that handles optional callbacks (dual promise and callback support).
 * When callback is undefined it returns the promise.
 * When using a callback, it will use it as handlers of the continuation of the promise.
 * @param {Promise} promise
 * @param {Function?} callback
 * @returns {Promise|undefined}
 */
function optionalCallback(promise, callback) {
  if (!callback) {
    return promise;
  }

  toCallback(promise, callback);
}

/**
 * Invokes the provided function multiple times, considering the concurrency level limit.
 * @param {Number} count
 * @param {Number} limit
 * @param {Function} fn
 * @returns {Promise}
 */
function times$1(count, limit, fn) {
  if (limit > count) {
    limit = count;
  }

  const promises = new Array(limit);

  const info = {
    counter: 0
  };

  for (let i = 0; i < limit; i++) {
    promises[i] = invokeSequentially(info, count, fn);
  }

  return Promise.all(promises);
}

/**
 * Deals with unexpected rejections in order to avoid the unhandled promise rejection warning or failure.
 * @param {Promise} promise
 * @returns {undefined}
 */
function toBackground(promise) {
  promise.catch(() => {});
}

/**
 * Invokes the callback once outside the promise chain the promise is resolved or rejected.
 * @param {Promise} promise
 * @param {Function?} callback
 * @returns {undefined}
 */
function toCallback(promise, callback) {
  promise
    .then(
      result => process.nextTick(() => callback(null, result)),
      // Avoid marking the promise as rejected
      err => process.nextTick(() => callback(err)));
}

var promiseUtils$e = {
  delay,
  fromCallback,
  fromEvent,
  getCallback,
  newQueryPlan,
  optionalCallback,
  times: times$1,
  toBackground,
  toCallback
};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const util$B = require$$0$4;
const net$2 = require$$1$2;
const { EventEmitter: EventEmitter$2 } = require$$0;

const errors$m = errors$n;
const promiseUtils$d = promiseUtils$e;

/**
 * Max int that can be accurately represented with 64-bit Number (2^53)
 * @type {number}
 * @const
 */
const maxInt = 9007199254740992;

const maxInt32 = 0x7fffffff;

const emptyObject = Object.freeze({});

const emptyArray = Object.freeze([]);

function noop() {}

/**
 * Forward-compatible allocation of buffer, filled with zeros.
 * @type {Function}
 */
const allocBuffer = Buffer.alloc || allocBufferFillDeprecated;

/**
 * Forward-compatible unsafe allocation of buffer.
 * @type {Function}
 */
const allocBufferUnsafe = Buffer.allocUnsafe || allocBufferDeprecated;

/**
 * Forward-compatible allocation of buffer to contain a string.
 * @type {Function}
 */
const allocBufferFromString = (Int8Array.from !== Buffer.from && Buffer.from) || allocBufferFromStringDeprecated;

/**
 * Forward-compatible allocation of buffer from an array of bytes
 * @type {Function}
 */
const allocBufferFromArray = (Int8Array.from !== Buffer.from && Buffer.from) || allocBufferFromArrayDeprecated;

function allocBufferDeprecated(size) {
  // eslint-disable-next-line
  return new Buffer(size);
}

function allocBufferFillDeprecated(size) {
  const b = allocBufferDeprecated(size);
  b.fill(0);
  return b;
}

function allocBufferFromStringDeprecated(text, encoding) {
  if (typeof text !== 'string') {
    throw new TypeError('Expected string, obtained ' + util$B.inspect(text));
  }
  // eslint-disable-next-line
  return new Buffer(text, encoding);
}

function allocBufferFromArrayDeprecated(arr) {
  if (!Array.isArray(arr)) {
    throw new TypeError('Expected Array, obtained ' + util$B.inspect(arr));
  }
  // eslint-disable-next-line
  return new Buffer(arr);
}

/**
 * @returns {Function} Returns a wrapper function that invokes the underlying callback only once.
 * @param {Function} callback
 */
function callbackOnce(callback) {
  let cb = callback;

  return (function wrapperCallback(err, result) {
    cb(err, result);
    cb = noop;
  });
}

/**
 * Creates a copy of a buffer
 */
function copyBuffer(buf) {
  const targetBuffer = allocBufferUnsafe(buf.length);
  buf.copy(targetBuffer);
  return targetBuffer;
}

/**
 * Appends the original stack trace to the error after a tick of the event loop
 */
function fixStack(stackTrace, error) {
  if (stackTrace) {
    error.stack += '\n  (event loop)\n' + stackTrace.substr(stackTrace.indexOf("\n") + 1);
  }
  return error;
}

/**
 * Uses the logEmitter to emit log events
 * @param {String} type
 * @param {String} info
 * @param [furtherInfo]
 */
function log(type, info, furtherInfo, options) {
  if (!this.logEmitter) {
    const effectiveOptions = options || this.options;
    if (!effectiveOptions || !effectiveOptions.logEmitter) {
      throw new Error('Log emitter not defined');
    }
    this.logEmitter = effectiveOptions.logEmitter;
  }
  this.logEmitter('log', type, this.constructor.name, info, furtherInfo || '');
}

/**
 * Gets the sum of the length of the items of an array
 */
function totalLength (arr) {
  if (arr.length === 1) {
    return arr[0].length;
  }
  let total = 0;
  arr.forEach(function (item) {
    let length = item.length;
    length = length ? length : 0;
    total += length;
  });
  return total;
}

/**
 * Merge the contents of two or more objects together into the first object. Similar to jQuery.extend / Object.assign.
 * The main difference between this method is that declared properties with an <code>undefined</code> value are not set
 * to the target.
 */
function extend(target) {
  const sources = Array.prototype.slice.call(arguments, 1);
  sources.forEach(function (source) {
    if (!source) {
      return;
    }
    const keys = Object.keys(source);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const value = source[key];
      if (value === undefined) {
        continue;
      }
      target[key] = value;
    }
  });
  return target;
}

/**
 * Returns a new object with the property names set to lowercase.
 */
function toLowerCaseProperties(obj) {
  const keys = Object.keys(obj);
  const result = {};
  for (let i = 0; i < keys.length; i++) {
    const k = keys[i];
    result[k.toLowerCase()] = obj[k];
  }
  return result;
}

/**
 * Extends the target by the most inner props of sources
 * @param {Object} target
 * @returns {Object}
 */
function deepExtend(target) {
  const sources = Array.prototype.slice.call(arguments, 1);
  sources.forEach(function (source) {
    for (const prop in source) {
      // eslint-disable-next-line no-prototype-builtins
      if (!source.hasOwnProperty(prop)) {
        continue;
      }
      const targetProp = target[prop];
      const targetType = (typeof targetProp);
      //target prop is
      // a native single type
      // or not existent
      // or is not an anonymous object (not class instance)
      if (!targetProp ||
        targetType === 'number' ||
        targetType === 'string' ||
        Array.isArray(targetProp) ||
        util$B.isDate(targetProp) ||
        targetProp.constructor.name !== 'Object') {
        target[prop] = source[prop];
      }
      else {
        //inner extend
        target[prop] = deepExtend({}, targetProp, source[prop]);
      }
    }
  });
  return target;
}

function propCompare(propName) {
  return function (a, b) {
    if (a[propName] > b[propName]) {
      return 1;
    }
    if (a[propName] < b[propName]) {
      return -1;
    }
    return 0;
  };
}

function funcCompare(name, argArray) {
  return (function (a, b) {
    if (typeof a[name] === 'undefined') {
      return 0;
    }
    const valA = a[name].apply(a, argArray);
    const valB = b[name].apply(b, argArray);
    if (valA > valB) {
      return 1;
    }
    if (valA < valB) {
      return -1;
    }
    return 0;
  });
}
/**
 * Uses the iterator protocol to go through the items of the Array
 * @param {Array} arr
 * @returns {Iterator}
 */
function arrayIterator (arr) {
  return arr[Symbol.iterator]();
}

/**
 * Convert the iterator values into an array
 * @param iterator
 * @returns {Array}
 */
function iteratorToArray$1(iterator) {
  const values = [];
  let item = iterator.next();
  while (!item.done) {
    values.push(item.value);
    item = iterator.next();
  }
  return values;
}

/**
 * Searches the specified Array for the provided key using the binary
 * search algorithm.  The Array must be sorted.
 * @param {Array} arr
 * @param key
 * @param {function} compareFunc
 * @returns {number} The position of the key in the Array, if it is found.
 * If it is not found, it returns a negative number which is the bitwise complement of the index of the first element that is larger than key.
 */
function binarySearch(arr, key, compareFunc) {
  let low = 0;
  let high = arr.length-1;

  while (low <= high) {
    const mid = (low + high) >>> 1;
    const midVal = arr[mid];
    const cmp = compareFunc(midVal, key);
    if (cmp < 0) {
      low = mid + 1;
    }
    else if (cmp > 0) {
      high = mid - 1;
    }
    else
    {
      //The key was found in the Array
      return mid;
    }
  }
  // key not found
  return ~low;
}

/**
 * Inserts the value in the position determined by its natural order determined by the compare func
 * @param {Array} arr
 * @param item
 * @param {function} compareFunc
 */
function insertSorted(arr, item, compareFunc) {
  if (arr.length === 0) {
    return arr.push(item);
  }
  let position = binarySearch(arr, item, compareFunc);
  if (position < 0) {
    position = ~position;
  }
  arr.splice(position, 0, item);
}

/**
 * Validates the provided parameter is of type function.
 * @param {Function} fn The instance to validate.
 * @param {String} [name] Name of the function to use in the error message. Defaults to 'callback'.
 * @returns {Function}
 */
function validateFn(fn, name) {
  if (typeof fn !== 'function') {
    throw new errors$m.ArgumentError(util$B.format('%s is not a function', name || 'callback'));
  }
  return fn;
}

/**
 * Adapts the parameters based on the prepared metadata.
 * If the params are passed as an associative array (Object),
 * it adapts the object into an array with the same order as columns
 * @param {Array|Object} params
 * @param {Array} columns
 * @returns {Array} Returns an array of parameters.
 * @throws {Error} In case a parameter with a specific name is not defined
 */
function adaptNamedParamsPrepared(params, columns) {
  if (!params || Array.isArray(params) || !columns || columns.length === 0) {
    // params is an array or there aren't parameters
    return params;
  }
  const paramsArray = new Array(columns.length);
  params = toLowerCaseProperties(params);
  for (let i = 0; i < columns.length; i++) {
    const name = columns[i].name;
    // eslint-disable-next-line no-prototype-builtins
    if (!params.hasOwnProperty(name)) {
      throw new errors$m.ArgumentError(util$B.format('Parameter "%s" not defined', name));
    }
    paramsArray[i] = params[name];
  }
  return paramsArray;
}

/**
 * Adapts the associative-array of parameters and hints for simple statements
 * into Arrays based on the (arbitrary) position of the keys.
 * @param {Array|Object} params
 * @param {ExecutionOptions} execOptions
 * @returns {{ params: Array<{name, value}>, namedParameters: boolean, keyIndexes: object }} Returns an array of
 * parameters and the keys as an associative array.
 */
function adaptNamedParamsWithHints(params, execOptions) {
  if (!params || Array.isArray(params)) {
    //The parameters is an Array or there isn't parameter
    return { params: params, namedParameters: false, keyIndexes: null };
  }

  const keys = Object.keys(params);
  const paramsArray = new Array(keys.length);
  const hints = new Array(keys.length);
  const userHints = execOptions.getHints() || emptyObject;
  const keyIndexes = {};

  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    // As lower cased identifiers
    paramsArray[i] = { name: key.toLowerCase(), value: params[key]};
    hints[i] = userHints[key];
    keyIndexes[key] = i;
  }

  execOptions.setHints(hints);

  return { params: paramsArray, namedParameters: true, keyIndexes };
}

/**
 * Returns a string with a value repeated n times
 * @param {String} val
 * @param {Number} times
 * @returns {String}
 */
function stringRepeat(val, times) {
  if (!times || times < 0) {
    return null;
  }
  if (times === 1) {
    return val;
  }
  return new Array(times + 1).join(val);
}

/**
 * Returns an array containing the values of the Object, similar to Object.values().
 * If obj is null or undefined, it will return an empty array.
 * @param {Object} obj
 * @returns {Array}
 */
function objectValues(obj) {
  if (!obj) {
    return emptyArray;
  }
  const keys = Object.keys(obj);
  const values = new Array(keys.length);
  for (let i = 0; i < keys.length; i++) {
    values[i] = obj[keys[i]];
  }
  return values;
}

/**
 * Wraps the callback-based method. When no originalCallback is not defined, it returns a Promise.
 * @param {ClientOptions} options
 * @param {Function} originalCallback
 * @param {Function} handler
 * @returns {Promise|undefined}
 */
function promiseWrapper(options, originalCallback, handler) {
  if (typeof originalCallback === 'function') {
    // Callback-based invocation
    handler.call(this, originalCallback);
    return undefined;
  }
  const factory = options.promiseFactory || defaultPromiseFactory;
  const self = this;
  return factory(function handlerWrapper(callback) {
    handler.call(self, callback);
  });
}

/**
 * @param {Function} handler
 * @returns {Promise}
 */
function defaultPromiseFactory(handler) {
  return new Promise(function executor(resolve, reject) {
    handler(function handlerCallback(err, result) {
      if (err) {
        return reject(err);
      }
      resolve(result);
    });
  });
}

/**
 * Returns the first not undefined param
 */
function ifUndefined$1(v1, v2) {
  return v1 !== undefined ? v1 : v2;
}

/**
 * Returns the first not undefined param
 */
function ifUndefined3$1(v1, v2, v3) {
  if (v1 !== undefined) {
    return v1;
  }
  return v2 !== undefined ? v2 : v3;
}

/**
 * Shuffles an Array in-place.
 * @param {Array} arr
 * @returns {Array}
 * @private
 */
function shuffleArray(arr) {
  // FisherYates algorithm
  for (let i = arr.length - 1; i > 0; i--) {
    // Math.random() has an extremely short permutation cycle length but we don't care about collisions
    const j = Math.floor(Math.random() * (i + 1));
    const temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
  }

  return arr;
}

// Classes

/**
 * Represents a unique set of values.
 * @constructor
 */
function HashSet() {
  this.length = 0;
  this.items = {};
}

/**
 * Adds a new item to the set.
 * @param {Object} key
 * @returns {boolean} Returns true if it was added to the set; false if the key is already present.
 */
HashSet.prototype.add = function (key) {
  if (this.contains(key)) {
    return false;
  }
  this.items[key] = true;
  this.length++;
  return true;
};

/**
 * @returns {boolean} Returns true if the key is present in the set.
 */
HashSet.prototype.contains = function (key) {
  return this.length > 0 && this.items[key] === true;
};

/**
 * Removes the item from set.
 * @param key
 * @return {boolean} Returns true if the key existed and was removed, otherwise it returns false.
 */
HashSet.prototype.remove = function (key) {
  if (!this.contains(key)) {
    return false;
  }
  delete this.items[key];
  this.length--;
};

/**
 * Returns an array containing the set items.
 * @returns {Array}
 */
HashSet.prototype.toArray = function () {
  return Object.keys(this.items);
};

/**
 * Utility class that resolves host names into addresses.
 */
class AddressResolver {

  /**
   * Creates a new instance of the resolver.
   * @param {Object} options
   * @param {String} options.nameOrIp
   * @param {Object} [options.dns]
   */
  constructor(options) {
    if (!options || !options.nameOrIp || !options.dns) {
      throw new Error('nameOrIp and dns lib must be provided as part of the options');
    }

    this._resolve4 = util$B.promisify(options.dns.resolve4);
    this._nameOrIp = options.nameOrIp;
    this._isIp = net$2.isIP(options.nameOrIp);
    this._index = 0;
    this._addresses = null;
    this._refreshing = null;
  }

  /**
   * Resolves the addresses for the host name.
   */
  async init() {
    if (this._isIp) {
      return;
    }

    await this._resolve();
  }

  /**
   * Tries to resolve the addresses for the host name.
   */
  async refresh() {
    if (this._isIp) {
      return;
    }

    if (this._refreshing) {
      return await promiseUtils$d.fromEvent(this._refreshing, 'finished');
    }

    this._refreshing = new EventEmitter$2().setMaxListeners(0);

    try {
      await this._resolve();
    } catch (err) {
      // Ignore the possible resolution error
    }

    this._refreshing.emit('finished');
    this._refreshing = null;
  }

  async _resolve() {
    const arr = await this._resolve4(this._nameOrIp);

    if (!arr || arr.length === 0) {
      throw new Error(`${this._nameOrIp} could not be resolved`);
    }

    this._addresses = arr;
  }

  /**
   * Returns resolved ips in a round-robin fashion.
   */
  getIp() {
    if (this._isIp) {
      return this._nameOrIp;
    }

    const item = this._addresses[this._index % this._addresses.length];
    this._index = (this._index !== maxInt32) ? (this._index + 1) : 0;

    return item;
  }
}

/**
 * @param {Array} arr
 * @param {Function} fn
 * @param {Function} [callback]
 */
function each(arr, fn, callback) {
  if (!Array.isArray(arr)) {
    throw new TypeError('First parameter is not an Array');
  }
  callback = callback || noop;
  const length = arr.length;
  if (length === 0) {
    return callback();
  }
  let completed = 0;
  for (let i = 0; i < length; i++) {
    fn(arr[i], next);
  }
  function next(err) {
    if (err) {
      const cb = callback;
      callback = noop;
      cb(err);
      return;
    }
    if (++completed !== length) {
      return;
    }
    callback();
  }
}

/**
 * @param {Array} arr
 * @param {Function} fn
 * @param {Function} [callback]
 */
function eachSeries(arr, fn, callback) {
  if (!Array.isArray(arr)) {
    throw new TypeError('First parameter is not an Array');
  }
  callback = callback || noop;
  const length = arr.length;
  if (length === 0) {
    return callback();
  }
  let sync;
  let index = 1;
  fn(arr[0], next);
  if (sync === undefined) {
    sync = false;
  }

  function next(err) {
    if (err) {
      return callback(err);
    }
    if (index >= length) {
      return callback();
    }
    if (sync === undefined) {
      sync = true;
    }
    if (sync) {
      return process.nextTick(function () {
        fn(arr[index++], next);
      });
    }
    fn(arr[index++], next);
  }
}

/**
 * @param {Array} arr
 * @param {Function} fn
 * @param {Function} [callback]
 */
function forEachOf(arr, fn, callback) {
  return mapEach(arr, fn, true, callback);
}

/**
 * @param {Array} arr
 * @param {Function} fn
 * @param {Function} [callback]
 */
function map(arr, fn, callback) {
  return mapEach(arr, fn, false, callback);
}

function mapEach(arr, fn, useIndex, callback) {
  if (!Array.isArray(arr)) {
    throw new TypeError('First parameter must be an Array');
  }
  callback = callback || noop;
  const length = arr.length;
  if (length === 0) {
    return callback(null, []);
  }
  const result = new Array(length);
  let completed = 0;
  const invoke = useIndex ? invokeWithIndex : invokeWithoutIndex;
  for (let i = 0; i < length; i++) {
    invoke(i);
  }

  function invokeWithoutIndex(i) {
    fn(arr[i], function mapItemCallback(err, transformed) {
      result[i] = transformed;
      next(err);
    });
  }

  function invokeWithIndex(i) {
    fn(arr[i], i, function mapItemCallback(err, transformed) {
      result[i] = transformed;
      next(err);
    });
  }

  function next(err) {
    if (err) {
      const cb = callback;
      callback = noop;
      cb(err);
      return;
    }
    if (++completed !== length) {
      return;
    }
    callback(null, result);
  }
}

/**
 * @param {Array} arr
 * @param {Function} fn
 * @param {Function} [callback]
 */
function mapSeries(arr, fn, callback) {
  if (!Array.isArray(arr)) {
    throw new TypeError('First parameter must be an Array');
  }
  callback = callback || noop;
  const length = arr.length;
  if (length === 0) {
    return callback(null, []);
  }
  const result = new Array(length);
  let index = 0;
  let sync;
  invoke(0);
  if (sync === undefined) {
    sync = false;
  }

  function invoke(i) {
    fn(arr[i], function mapItemCallback(err, transformed) {
      result[i] = transformed;
      next(err);
    });
  }

  function next(err) {
    if (err) {
      return callback(err);
    }
    if (++index === length) {
      return callback(null, result);
    }
    if (sync === undefined) {
      sync = true;
    }
    const i = index;
    if (sync) {
      return process.nextTick(function () {
        invoke(i);
      });
    }
    invoke(index);
  }
}

/**
 * @param {Array.<Function>} arr
 * @param {Function} [callback]
 */
function parallel(arr, callback) {
  if (!Array.isArray(arr)) {
    throw new TypeError('First parameter must be an Array');
  }
  callback = callback || noop;
  const length = arr.length;
  let completed = 0;
  for (let i = 0; i < length; i++) {
    arr[i](next);
  }
  function next(err) {
    if (err) {
      const cb = callback;
      callback = noop;
      return cb(err);
    }
    if (++completed !== length) {
      return;
    }
    callback();
  }
}

/**
 * Similar to async.series(), but instead accumulating the result in an Array, it callbacks with the result of the last
 * function in the array.
 * @param {Array.<Function>} arr
 * @param {Function} [callback]
 */
function series(arr, callback) {
  if (!Array.isArray(arr)) {
    throw new TypeError('First parameter must be an Array');
  }
  callback = callback || noop;
  let index = 0;
  let sync;
  next();
  function next(err, result) {
    if (err) {
      return callback(err);
    }
    if (index === arr.length) {
      return callback(null, result);
    }
    if (sync) {
      return process.nextTick(function () {
        sync = true;
        arr[index++](next);
        sync = false;
      });
    }
    sync = true;
    arr[index++](next);
    sync = false;
  }
}

/**
 * @param {Number} count
 * @param {Function} iteratorFunc
 * @param {Function} [callback]
 */
function times(count, iteratorFunc, callback) {
  callback = callback || noop;
  count = +count;
  if (isNaN(count) || count === 0) {
    return callback();
  }
  let completed = 0;
  for (let i = 0; i < count; i++) {
    iteratorFunc(i, next);
  }
  function next(err) {
    if (err) {
      const cb = callback;
      callback = noop;
      return cb(err);
    }
    if (++completed !== count) {
      return;
    }
    callback();
  }
}

/**
 * @param {Number} count
 * @param {Number} limit
 * @param {Function} iteratorFunc
 * @param {Function} [callback]
 */
function timesLimit(count, limit, iteratorFunc, callback) {
  let sync = undefined;
  callback = callback || noop;
  limit = Math.min(limit, count);
  let index = limit - 1;
  let i;
  let completed = 0;
  for (i = 0; i < limit; i++) {
    iteratorFunc(i, next);
  }
  i = -1;
  function next(err) {
    if (err) {
      const cb = callback;
      callback = noop;
      cb(err);
      return;
    }
    if (++completed === count) {
      return callback();
    }
    index++;
    if (index >= count) {
      return;
    }
    if (sync === undefined) {
      sync = (i >= 0);
    }
    if (sync) {
      const captureIndex = index;
      return process.nextTick(function () {
        iteratorFunc(captureIndex, next);
      });
    }
    iteratorFunc(index, next);
  }
}

/**
 * @param {Number} count
 * @param {Function} iteratorFunction
 * @param {Function} callback
 */
function timesSeries(count, iteratorFunction, callback) {
  count = +count;
  if (isNaN(count) || count < 1) {
    return callback();
  }
  let index = 1;
  let sync;
  iteratorFunction(0, next);
  if (sync === undefined) {
    sync = false;
  }
  function next(err) {
    if (err) {
      return callback(err);
    }
    if (index === count) {
      return callback();
    }
    if (sync === undefined) {
      sync = true;
    }
    const i = index++;
    if (sync) {
      //Prevent "Maximum call stack size exceeded"
      return process.nextTick(function () {
        iteratorFunction(i, next);
      });
    }
    //do a sync call as the callback is going to call on a future tick
    iteratorFunction(i, next);
  }
}

/**
 * @param {Function} condition
 * @param {Function} fn
 * @param {Function} callback
 */
function whilst(condition, fn, callback) {
  let sync = 0;
  next();
  function next(err) {
    if (err) {
      return callback(err);
    }
    if (!condition()) {
      return callback();
    }
    if (sync === 0) {
      sync = 1;
      fn(function (err) {
        if (sync === 1) {
          //sync function
          sync = 4;
        }
        next(err);
      });
      if (sync === 1) {
        //async function
        sync = 2;
      }
      return;
    }
    if (sync === 4) {
      //Prevent "Maximum call stack size exceeded"
      return process.nextTick(function () {
        fn(next);
      });
    }
    //do a sync call as the callback is going to call on a future tick
    fn(next);
  }
}

utils$K.adaptNamedParamsPrepared = adaptNamedParamsPrepared;
utils$K.adaptNamedParamsWithHints = adaptNamedParamsWithHints;
utils$K.AddressResolver = AddressResolver;
utils$K.allocBuffer = allocBuffer;
utils$K.allocBufferUnsafe = allocBufferUnsafe;
utils$K.allocBufferFromArray = allocBufferFromArray;
utils$K.allocBufferFromString = allocBufferFromString;
utils$K.arrayIterator = arrayIterator;
utils$K.binarySearch = binarySearch;
utils$K.callbackOnce = callbackOnce;
utils$K.copyBuffer = copyBuffer;
utils$K.deepExtend = deepExtend;
utils$K.each = each;
utils$K.eachSeries = eachSeries;
/** @const */
utils$K.emptyArray = Object.freeze([]);
/** @const */
utils$K.emptyObject = emptyObject;
utils$K.extend = extend;
utils$K.fixStack = fixStack;
utils$K.forEachOf = forEachOf;
utils$K.funcCompare = funcCompare;
utils$K.ifUndefined = ifUndefined$1;
utils$K.ifUndefined3 = ifUndefined3$1;
utils$K.insertSorted = insertSorted;
utils$K.iteratorToArray = iteratorToArray$1;
utils$K.log = log;
utils$K.map = map;
utils$K.mapSeries = mapSeries;
utils$K.maxInt = maxInt;
utils$K.noop = noop;
utils$K.objectValues = objectValues;
utils$K.parallel = parallel;
utils$K.promiseWrapper = promiseWrapper;
utils$K.propCompare = propCompare;
utils$K.series = series;
utils$K.shuffleArray = shuffleArray;
utils$K.stringRepeat = stringRepeat;
utils$K.times = times;
utils$K.timesLimit = timesLimit;
utils$K.timesSeries = timesSeries;
utils$K.totalLength = totalLength;
utils$K.validateFn = validateFn;
utils$K.whilst = whilst;
utils$K.HashSet = HashSet;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const dns$2 = require$$0$7;
const util$A = require$$0$4;
const utils$J = utils$K;
/** @module policies/addressResolution */
/**
 * @class
 * @classdesc
 * Translates IP addresses received from Cassandra nodes into locally queryable
 * addresses.
 * <p>
 * The driver auto-detects new Cassandra nodes added to the cluster through server
 * side pushed notifications and through checking the system tables. For each
 * node, the address received will correspond to the address set as
 * <code>rpc_address</code> in the node yaml file. In most case, this is the correct
 * address to use by the driver and that is what is used by default. However,
 * sometimes the addresses received through this mechanism will either not be
 * reachable directly by the driver or should not be the preferred address to use
 * to reach the node (for instance, the <code>rpc_address</code> set on Cassandra nodes
 * might be a private IP, but some clients  may have to use a public IP, or
 * pass by a router to reach that node). This interface allows to deal with
 * such cases, by allowing to translate an address as sent by a Cassandra node
 * to another address to be used by the driver for connection.
 * <p>
 * Please note that the contact points addresses provided while creating the
 * {@link Client} instance are not "translated", only IP address retrieve from or sent
 * by Cassandra nodes to the driver are.
 * @constructor
 */
function AddressTranslator() {

}

/**
 * Translates a Cassandra <code>rpc_address</code> to another address if necessary.
 * @param {String} address the address of a node as returned by Cassandra.
 * <p>
 * Note that if the <code>rpc_address</code> of a node has been configured to <code>0.0.0.0</code>
 * server side, then the provided address will be the node <code>listen_address</code>,
 * *not* <code>0.0.0.0</code>.
 * </p>
 * @param {Number} port The port number, as specified in the [protocolOptions]{@link ClientOptions} at Client instance creation (9042 by default).
 * @param {Function} callback Callback to invoke with endpoint as first parameter.
 * The endpoint is an string composed of the IP address and the port number in the format <code>ipAddress:port</code>.
 */
AddressTranslator.prototype.translate = function (address, port, callback) {
  callback(address + ':' + port);
};

/**
 * @class
 * @classdesc
 * {@link AddressTranslator} implementation for multi-region EC2 deployments <strong>where clients are also deployed in EC2</strong>.
 * <p>
 * Its distinctive feature is that it translates addresses according to the location of the Cassandra host:
 * </p>
 * <ul>
 *  <li>addresses in different EC2 regions (than the client) are unchanged</li>
 *  <li>addresses in the same EC2 region are <strong>translated to private IPs</strong></li>
 * </ul>
 * <p>
 * This optimizes network costs, because Amazon charges more for communication over public IPs.
 * </p>
 * @constructor
 */
function EC2MultiRegionTranslator() {

}

util$A.inherits(EC2MultiRegionTranslator, AddressTranslator);

/**
 * Addresses in the same EC2 region are translated to private IPs and addresses in
 * different EC2 regions (than the client) are unchanged
 */
EC2MultiRegionTranslator.prototype.translate = function (address, port, callback) {
  let newAddress = address;
  const self = this;
  let name;
  utils$J.series([
    function resolve(next) {
      dns$2.reverse(address, function (err, hostNames) {
        if (err) {
          return next(err);
        }
        if (!hostNames) {
          return next();
        }
        name = hostNames[0];
        next();
      });
    },
    function lookup(next) {
      if (!name) {
        return next();
      }
      dns$2.lookup(name, function (err, lookupAddress) {
        if (err) {
          return next(err);
        }
        newAddress = lookupAddress;
        next();
      });
    }], function (err) {
    if (err) {
      //there was an issue while doing dns resolution
      self.logError(address, err);
    }
    callback(newAddress + ':' + port);
  });
};

/**
 * Log method called to log errors that occurred while performing dns resolution.
 * You can assign your own method to the class instance to do proper logging.
 * @param {String} address
 * @param {Error} err
 */
EC2MultiRegionTranslator.prototype.logError = function (address, err) {
  //Do nothing by default
};

addressResolution.AddressTranslator = AddressTranslator;
addressResolution.EC2MultiRegionTranslator = EC2MultiRegionTranslator;

var types$s = {};

var LongExports = {};
var Long$5 = {
  get exports(){ return LongExports; },
  set exports(v){ LongExports = v; },
};

/*
 Copyright 2013 Daniel Wirtz <dcode@dcode.io>
 Copyright 2009 The Closure Library Authors. All Rights Reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS-IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

(function (module) {
	/**
	 * @license Long.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
	 * Released under the Apache License, Version 2.0
	 * see: https://github.com/dcodeIO/Long.js for details
	 */
	(function(global, factory) {

	    /* AMD */ if (typeof commonjsRequire === 'function' && 'object' === "object" && module && module["exports"])
	        module["exports"] = factory();
	    /* Global */ else
	        (global["dcodeIO"] = global["dcodeIO"] || {})["Long"] = factory();

	})(commonjsGlobal, function() {

	    /**
	     * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
	     *  See the from* functions below for more convenient ways of constructing Longs.
	     * @exports Long
	     * @class A Long class for representing a 64 bit two's-complement integer value.
	     * @param {number} low The low (signed) 32 bits of the long
	     * @param {number} high The high (signed) 32 bits of the long
	     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
	     * @constructor
	     */
	    function Long(low, high, unsigned) {

	        /**
	         * The low 32 bits as a signed value.
	         * @type {number}
	         * @expose
	         */
	        this.low = low|0;

	        /**
	         * The high 32 bits as a signed value.
	         * @type {number}
	         * @expose
	         */
	        this.high = high|0;

	        /**
	         * Whether unsigned or not.
	         * @type {boolean}
	         * @expose
	         */
	        this.unsigned = !!unsigned;
	    }

	    // The internal representation of a long is the two given signed, 32-bit values.
	    // We use 32-bit pieces because these are the size of integers on which
	    // Javascript performs bit-operations.  For operations like addition and
	    // multiplication, we split each number into 16 bit pieces, which can easily be
	    // multiplied within Javascript's floating-point representation without overflow
	    // or change in sign.
	    //
	    // In the algorithms below, we frequently reduce the negative case to the
	    // positive case by negating the input(s) and then post-processing the result.
	    // Note that we must ALWAYS check specially whether those values are MIN_VALUE
	    // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
	    // a positive number, it overflows back into a negative).  Not handling this
	    // case would often result in infinite recursion.
	    //
	    // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
	    // methods on which they depend.

	    /**
	     * An indicator used to reliably determine if an object is a Long or not.
	     * @type {boolean}
	     * @const
	     * @expose
	     * @private
	     */
	    Long.__isLong__;

	    Object.defineProperty(Long.prototype, "__isLong__", {
	        value: true,
	        enumerable: false,
	        configurable: false
	    });

	    /**
	     * Tests if the specified object is a Long.
	     * @param {*} obj Object
	     * @returns {boolean}
	     * @expose
	     */
	    Long.isLong = function isLong(obj) {
	        return (obj && obj["__isLong__"]) === true;
	    };

	    /**
	     * A cache of the Long representations of small integer values.
	     * @type {!Object}
	     * @inner
	     */
	    var INT_CACHE = {};

	    /**
	     * A cache of the Long representations of small unsigned integer values.
	     * @type {!Object}
	     * @inner
	     */
	    var UINT_CACHE = {};

	    /**
	     * Returns a Long representing the given 32 bit integer value.
	     * @param {number} value The 32 bit integer in question
	     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
	     * @returns {!Long} The corresponding Long value
	     * @expose
	     */
	    Long.fromInt = function fromInt(value, unsigned) {
	        var obj, cachedObj;
	        if (!unsigned) {
	            value = value | 0;
	            if (-128 <= value && value < 128) {
	                cachedObj = INT_CACHE[value];
	                if (cachedObj)
	                    return cachedObj;
	            }
	            obj = new Long(value, value < 0 ? -1 : 0, false);
	            if (-128 <= value && value < 128)
	                INT_CACHE[value] = obj;
	            return obj;
	        } else {
	            value = value >>> 0;
	            if (0 <= value && value < 256) {
	                cachedObj = UINT_CACHE[value];
	                if (cachedObj)
	                    return cachedObj;
	            }
	            obj = new Long(value, (value | 0) < 0 ? -1 : 0, true);
	            if (0 <= value && value < 256)
	                UINT_CACHE[value] = obj;
	            return obj;
	        }
	    };

	    /**
	     * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
	     * @param {number} value The number in question
	     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
	     * @returns {!Long} The corresponding Long value
	     * @expose
	     */
	    Long.fromNumber = function fromNumber(value, unsigned) {
	        unsigned = !!unsigned;
	        if (isNaN(value) || !isFinite(value))
	            return Long.ZERO;
	        if (!unsigned && value <= -TWO_PWR_63_DBL)
	            return Long.MIN_VALUE;
	        if (!unsigned && value + 1 >= TWO_PWR_63_DBL)
	            return Long.MAX_VALUE;
	        if (unsigned && value >= TWO_PWR_64_DBL)
	            return Long.MAX_UNSIGNED_VALUE;
	        if (value < 0)
	            return Long.fromNumber(-value, unsigned).negate();
	        return new Long((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
	    };

	    /**
	     * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
	     *  assumed to use 32 bits.
	     * @param {number} lowBits The low 32 bits
	     * @param {number} highBits The high 32 bits
	     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
	     * @returns {!Long} The corresponding Long value
	     * @expose
	     */
	    Long.fromBits = function fromBits(lowBits, highBits, unsigned) {
	        return new Long(lowBits, highBits, unsigned);
	    };

	    /**
	     * Returns a Long representation of the given string, written using the specified radix.
	     * @param {string} str The textual representation of the Long
	     * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to `false` for signed
	     * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
	     * @returns {!Long} The corresponding Long value
	     * @expose
	     */
	    Long.fromString = function fromString(str, unsigned, radix) {
	        if (str.length === 0)
	            throw Error('number format error: empty string');
	        if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
	            return Long.ZERO;
	        if (typeof unsigned === 'number') // For goog.math.long compatibility
	            radix = unsigned,
	            unsigned = false;
	        radix = radix || 10;
	        if (radix < 2 || 36 < radix)
	            throw Error('radix out of range: ' + radix);

	        var p;
	        if ((p = str.indexOf('-')) > 0)
	            throw Error('number format error: interior "-" character: ' + str);
	        else if (p === 0)
	            return Long.fromString(str.substring(1), unsigned, radix).negate();

	        // Do several (8) digits each time through the loop, so as to
	        // minimize the calls to the very expensive emulated div.
	        var radixToPower = Long.fromNumber(Math.pow(radix, 8));

	        var result = Long.ZERO;
	        for (var i = 0; i < str.length; i += 8) {
	            var size = Math.min(8, str.length - i);
	            var value = parseInt(str.substring(i, i + size), radix);
	            if (size < 8) {
	                var power = Long.fromNumber(Math.pow(radix, size));
	                result = result.multiply(power).add(Long.fromNumber(value));
	            } else {
	                result = result.multiply(radixToPower);
	                result = result.add(Long.fromNumber(value));
	            }
	        }
	        result.unsigned = unsigned;
	        return result;
	    };

	    /**
	     * Converts the specified value to a Long.
	     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
	     * @returns {!Long}
	     * @expose
	     */
	    Long.fromValue = function fromValue(val) {
	        if (val /* is compatible */ instanceof Long)
	            return val;
	        if (typeof val === 'number')
	            return Long.fromNumber(val);
	        if (typeof val === 'string')
	            return Long.fromString(val);
	        // Throws for non-objects, converts non-instanceof Long:
	        return new Long(val.low, val.high, val.unsigned);
	    };

	    // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
	    // no runtime penalty for these.

	    /**
	     * @type {number}
	     * @const
	     * @inner
	     */
	    var TWO_PWR_16_DBL = 1 << 16;

	    /**
	     * @type {number}
	     * @const
	     * @inner
	     */
	    var TWO_PWR_24_DBL = 1 << 24;

	    /**
	     * @type {number}
	     * @const
	     * @inner
	     */
	    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

	    /**
	     * @type {number}
	     * @const
	     * @inner
	     */
	    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

	    /**
	     * @type {number}
	     * @const
	     * @inner
	     */
	    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

	    /**
	     * @type {!Long}
	     * @const
	     * @inner
	     */
	    var TWO_PWR_24 = Long.fromInt(TWO_PWR_24_DBL);

	    /**
	     * Signed zero.
	     * @type {!Long}
	     * @expose
	     */
	    Long.ZERO = Long.fromInt(0);

	    /**
	     * Unsigned zero.
	     * @type {!Long}
	     * @expose
	     */
	    Long.UZERO = Long.fromInt(0, true);

	    /**
	     * Signed one.
	     * @type {!Long}
	     * @expose
	     */
	    Long.ONE = Long.fromInt(1);

	    /**
	     * Unsigned one.
	     * @type {!Long}
	     * @expose
	     */
	    Long.UONE = Long.fromInt(1, true);

	    /**
	     * Signed negative one.
	     * @type {!Long}
	     * @expose
	     */
	    Long.NEG_ONE = Long.fromInt(-1);

	    /**
	     * Maximum signed value.
	     * @type {!Long}
	     * @expose
	     */
	    Long.MAX_VALUE = Long.fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

	    /**
	     * Maximum unsigned value.
	     * @type {!Long}
	     * @expose
	     */
	    Long.MAX_UNSIGNED_VALUE = Long.fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

	    /**
	     * Minimum signed value.
	     * @type {!Long}
	     * @expose
	     */
	    Long.MIN_VALUE = Long.fromBits(0, 0x80000000|0, false);

	    /**
	     * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
	     * @returns {number}
	     * @expose
	     */
	    Long.prototype.toInt = function toInt() {
	        return this.unsigned ? this.low >>> 0 : this.low;
	    };

	    /**
	     * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
	     * @returns {number}
	     * @expose
	     */
	    Long.prototype.toNumber = function toNumber() {
	        if (this.unsigned) {
	            return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
	        }
	        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
	    };

	    /**
	     * Converts the Long to a string written in the specified radix.
	     * @param {number=} radix Radix (2-36), defaults to 10
	     * @returns {string}
	     * @override
	     * @throws {RangeError} If `radix` is out of range
	     * @expose
	     */
	    Long.prototype.toString = function toString(radix) {
	        radix = radix || 10;
	        if (radix < 2 || 36 < radix)
	            throw RangeError('radix out of range: ' + radix);
	        if (this.isZero())
	            return '0';
	        var rem;
	        if (this.isNegative()) { // Unsigned Longs are never negative
	            if (this.equals(Long.MIN_VALUE)) {
	                // We need to change the Long value before it can be negated, so we remove
	                // the bottom-most digit in this base and then recurse to do the rest.
	                var radixLong = Long.fromNumber(radix);
	                var div = this.divide(radixLong);
	                rem = div.multiply(radixLong).subtract(this);
	                return div.toString(radix) + rem.toInt().toString(radix);
	            } else
	                return '-' + this.negate().toString(radix);
	        }

	        // Do several (6) digits each time through the loop, so as to
	        // minimize the calls to the very expensive emulated div.
	        var radixToPower = Long.fromNumber(Math.pow(radix, 6), this.unsigned);
	        rem = this;
	        var result = '';
	        while (true) {
	            var remDiv = rem.divide(radixToPower),
	                intval = rem.subtract(remDiv.multiply(radixToPower)).toInt() >>> 0,
	                digits = intval.toString(radix);
	            rem = remDiv;
	            if (rem.isZero())
	                return digits + result;
	            else {
	                while (digits.length < 6)
	                    digits = '0' + digits;
	                result = '' + digits + result;
	            }
	        }
	    };

	    /**
	     * Gets the high 32 bits as a signed integer.
	     * @returns {number} Signed high bits
	     * @expose
	     */
	    Long.prototype.getHighBits = function getHighBits() {
	        return this.high;
	    };

	    /**
	     * Gets the high 32 bits as an unsigned integer.
	     * @returns {number} Unsigned high bits
	     * @expose
	     */
	    Long.prototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
	        return this.high >>> 0;
	    };

	    /**
	     * Gets the low 32 bits as a signed integer.
	     * @returns {number} Signed low bits
	     * @expose
	     */
	    Long.prototype.getLowBits = function getLowBits() {
	        return this.low;
	    };

	    /**
	     * Gets the low 32 bits as an unsigned integer.
	     * @returns {number} Unsigned low bits
	     * @expose
	     */
	    Long.prototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
	        return this.low >>> 0;
	    };

	    /**
	     * Gets the number of bits needed to represent the absolute value of this Long.
	     * @returns {number}
	     * @expose
	     */
	    Long.prototype.getNumBitsAbs = function getNumBitsAbs() {
	        if (this.isNegative()) // Unsigned Longs are never negative
	            return this.equals(Long.MIN_VALUE) ? 64 : this.negate().getNumBitsAbs();
	        var val = this.high != 0 ? this.high : this.low;
	        for (var bit = 31; bit > 0; bit--)
	            if ((val & (1 << bit)) != 0)
	                break;
	        return this.high != 0 ? bit + 33 : bit + 1;
	    };

	    /**
	     * Tests if this Long's value equals zero.
	     * @returns {boolean}
	     * @expose
	     */
	    Long.prototype.isZero = function isZero() {
	        return this.high === 0 && this.low === 0;
	    };

	    /**
	     * Tests if this Long's value is negative.
	     * @returns {boolean}
	     * @expose
	     */
	    Long.prototype.isNegative = function isNegative() {
	        return !this.unsigned && this.high < 0;
	    };

	    /**
	     * Tests if this Long's value is positive.
	     * @returns {boolean}
	     * @expose
	     */
	    Long.prototype.isPositive = function isPositive() {
	        return this.unsigned || this.high >= 0;
	    };

	    /**
	     * Tests if this Long's value is odd.
	     * @returns {boolean}
	     * @expose
	     */
	    Long.prototype.isOdd = function isOdd() {
	        return (this.low & 1) === 1;
	    };

	    /**
	     * Tests if this Long's value is even.
	     * @returns {boolean}
	     * @expose
	     */
	    Long.prototype.isEven = function isEven() {
	        return (this.low & 1) === 0;
	    };

	    /**
	     * Tests if this Long's value equals the specified's.
	     * @param {!Long|number|string} other Other value
	     * @returns {boolean}
	     * @expose
	     */
	    Long.prototype.equals = function equals(other) {
	        if (!Long.isLong(other))
	            other = Long.fromValue(other);
	        if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
	            return false;
	        return this.high === other.high && this.low === other.low;
	    };

	    /**
	     * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
	     * @function
	     * @param {!Long|number|string} other Other value
	     * @returns {boolean}
	     * @expose
	     */
	    Long.eq = Long.prototype.equals;

	    /**
	     * Tests if this Long's value differs from the specified's.
	     * @param {!Long|number|string} other Other value
	     * @returns {boolean}
	     * @expose
	     */
	    Long.prototype.notEquals = function notEquals(other) {
	        return !this.equals(/* validates */ other);
	    };

	    /**
	     * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
	     * @function
	     * @param {!Long|number|string} other Other value
	     * @returns {boolean}
	     * @expose
	     */
	    Long.neq = Long.prototype.notEquals;

	    /**
	     * Tests if this Long's value is less than the specified's.
	     * @param {!Long|number|string} other Other value
	     * @returns {boolean}
	     * @expose
	     */
	    Long.prototype.lessThan = function lessThan(other) {
	        return this.compare(/* validates */ other) < 0;
	    };

	    /**
	     * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
	     * @function
	     * @param {!Long|number|string} other Other value
	     * @returns {boolean}
	     * @expose
	     */
	    Long.prototype.lt = Long.prototype.lessThan;

	    /**
	     * Tests if this Long's value is less than or equal the specified's.
	     * @param {!Long|number|string} other Other value
	     * @returns {boolean}
	     * @expose
	     */
	    Long.prototype.lessThanOrEqual = function lessThanOrEqual(other) {
	        return this.compare(/* validates */ other) <= 0;
	    };

	    /**
	     * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
	     * @function
	     * @param {!Long|number|string} other Other value
	     * @returns {boolean}
	     * @expose
	     */
	    Long.prototype.lte = Long.prototype.lessThanOrEqual;

	    /**
	     * Tests if this Long's value is greater than the specified's.
	     * @param {!Long|number|string} other Other value
	     * @returns {boolean}
	     * @expose
	     */
	    Long.prototype.greaterThan = function greaterThan(other) {
	        return this.compare(/* validates */ other) > 0;
	    };

	    /**
	     * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
	     * @function
	     * @param {!Long|number|string} other Other value
	     * @returns {boolean}
	     * @expose
	     */
	    Long.prototype.gt = Long.prototype.greaterThan;

	    /**
	     * Tests if this Long's value is greater than or equal the specified's.
	     * @param {!Long|number|string} other Other value
	     * @returns {boolean}
	     * @expose
	     */
	    Long.prototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
	        return this.compare(/* validates */ other) >= 0;
	    };

	    /**
	     * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
	     * @function
	     * @param {!Long|number|string} other Other value
	     * @returns {boolean}
	     * @expose
	     */
	    Long.prototype.gte = Long.prototype.greaterThanOrEqual;

	    /**
	     * Compares this Long's value with the specified's.
	     * @param {!Long|number|string} other Other value
	     * @returns {number} 0 if they are the same, 1 if the this is greater and -1
	     *  if the given one is greater
	     * @expose
	     */
	    Long.prototype.compare = function compare(other) {
	        if (!Long.isLong(other))
	            other = Long.fromValue(other);
	        if (this.equals(other))
	            return 0;
	        var thisNeg = this.isNegative(),
	            otherNeg = other.isNegative();
	        if (thisNeg && !otherNeg)
	            return -1;
	        if (!thisNeg && otherNeg)
	            return 1;
	        // At this point the sign bits are the same
	        if (!this.unsigned)
	            return this.subtract(other).isNegative() ? -1 : 1;
	        // Both are positive if at least one is unsigned
	        return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
	    };

	    /**
	     * Negates this Long's value.
	     * @returns {!Long} Negated Long
	     * @expose
	     */
	    Long.prototype.negate = function negate() {
	        if (!this.unsigned && this.equals(Long.MIN_VALUE))
	            return Long.MIN_VALUE;
	        return this.not().add(Long.ONE);
	    };

	    /**
	     * Negates this Long's value. This is an alias of {@link Long#negate}.
	     * @function
	     * @returns {!Long} Negated Long
	     * @expose
	     */
	    Long.prototype.neg = Long.prototype.negate;

	    /**
	     * Returns the sum of this and the specified Long.
	     * @param {!Long|number|string} addend Addend
	     * @returns {!Long} Sum
	     * @expose
	     */
	    Long.prototype.add = function add(addend) {
	        if (!Long.isLong(addend))
	            addend = Long.fromValue(addend);

	        // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

	        var a48 = this.high >>> 16;
	        var a32 = this.high & 0xFFFF;
	        var a16 = this.low >>> 16;
	        var a00 = this.low & 0xFFFF;

	        var b48 = addend.high >>> 16;
	        var b32 = addend.high & 0xFFFF;
	        var b16 = addend.low >>> 16;
	        var b00 = addend.low & 0xFFFF;

	        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
	        c00 += a00 + b00;
	        c16 += c00 >>> 16;
	        c00 &= 0xFFFF;
	        c16 += a16 + b16;
	        c32 += c16 >>> 16;
	        c16 &= 0xFFFF;
	        c32 += a32 + b32;
	        c48 += c32 >>> 16;
	        c32 &= 0xFFFF;
	        c48 += a48 + b48;
	        c48 &= 0xFFFF;
	        return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
	    };

	    /**
	     * Returns the difference of this and the specified Long.
	     * @param {!Long|number|string} subtrahend Subtrahend
	     * @returns {!Long} Difference
	     * @expose
	     */
	    Long.prototype.subtract = function subtract(subtrahend) {
	        if (!Long.isLong(subtrahend))
	            subtrahend = Long.fromValue(subtrahend);
	        return this.add(subtrahend.negate());
	    };

	    /**
	     * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
	     * @function
	     * @param {!Long|number|string} subtrahend Subtrahend
	     * @returns {!Long} Difference
	     * @expose
	     */
	    Long.prototype.sub = Long.prototype.subtract;

	    /**
	     * Returns the product of this and the specified Long.
	     * @param {!Long|number|string} multiplier Multiplier
	     * @returns {!Long} Product
	     * @expose
	     */
	    Long.prototype.multiply = function multiply(multiplier) {
	        if (this.isZero())
	            return Long.ZERO;
	        if (!Long.isLong(multiplier))
	            multiplier = Long.fromValue(multiplier);
	        if (multiplier.isZero())
	            return Long.ZERO;
	        if (this.equals(Long.MIN_VALUE))
	            return multiplier.isOdd() ? Long.MIN_VALUE : Long.ZERO;
	        if (multiplier.equals(Long.MIN_VALUE))
	            return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;

	        if (this.isNegative()) {
	            if (multiplier.isNegative())
	                return this.negate().multiply(multiplier.negate());
	            else
	                return this.negate().multiply(multiplier).negate();
	        } else if (multiplier.isNegative())
	            return this.multiply(multiplier.negate()).negate();

	        // If both longs are small, use float multiplication
	        if (this.lessThan(TWO_PWR_24) && multiplier.lessThan(TWO_PWR_24))
	            return Long.fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

	        // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
	        // We can skip products that would overflow.

	        var a48 = this.high >>> 16;
	        var a32 = this.high & 0xFFFF;
	        var a16 = this.low >>> 16;
	        var a00 = this.low & 0xFFFF;

	        var b48 = multiplier.high >>> 16;
	        var b32 = multiplier.high & 0xFFFF;
	        var b16 = multiplier.low >>> 16;
	        var b00 = multiplier.low & 0xFFFF;

	        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
	        c00 += a00 * b00;
	        c16 += c00 >>> 16;
	        c00 &= 0xFFFF;
	        c16 += a16 * b00;
	        c32 += c16 >>> 16;
	        c16 &= 0xFFFF;
	        c16 += a00 * b16;
	        c32 += c16 >>> 16;
	        c16 &= 0xFFFF;
	        c32 += a32 * b00;
	        c48 += c32 >>> 16;
	        c32 &= 0xFFFF;
	        c32 += a16 * b16;
	        c48 += c32 >>> 16;
	        c32 &= 0xFFFF;
	        c32 += a00 * b32;
	        c48 += c32 >>> 16;
	        c32 &= 0xFFFF;
	        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
	        c48 &= 0xFFFF;
	        return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
	    };

	    /**
	     * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
	     * @function
	     * @param {!Long|number|string} multiplier Multiplier
	     * @returns {!Long} Product
	     * @expose
	     */
	    Long.prototype.mul = Long.prototype.multiply;

	    /**
	     * Returns this Long divided by the specified.
	     * @param {!Long|number|string} divisor Divisor
	     * @returns {!Long} Quotient
	     * @expose
	     */
	    Long.prototype.divide = function divide(divisor) {
	        if (!Long.isLong(divisor))
	            divisor = Long.fromValue(divisor);
	        if (divisor.isZero())
	            throw(new Error('division by zero'));
	        if (this.isZero())
	            return this.unsigned ? Long.UZERO : Long.ZERO;
	        var approx, rem, res;
	        if (this.equals(Long.MIN_VALUE)) {
	            if (divisor.equals(Long.ONE) || divisor.equals(Long.NEG_ONE))
	                return Long.MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
	            else if (divisor.equals(Long.MIN_VALUE))
	                return Long.ONE;
	            else {
	                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
	                var halfThis = this.shiftRight(1);
	                approx = halfThis.divide(divisor).shiftLeft(1);
	                if (approx.equals(Long.ZERO)) {
	                    return divisor.isNegative() ? Long.ONE : Long.NEG_ONE;
	                } else {
	                    rem = this.subtract(divisor.multiply(approx));
	                    res = approx.add(rem.divide(divisor));
	                    return res;
	                }
	            }
	        } else if (divisor.equals(Long.MIN_VALUE))
	            return this.unsigned ? Long.UZERO : Long.ZERO;
	        if (this.isNegative()) {
	            if (divisor.isNegative())
	                return this.negate().divide(divisor.negate());
	            return this.negate().divide(divisor).negate();
	        } else if (divisor.isNegative())
	            return this.divide(divisor.negate()).negate();

	        // Repeat the following until the remainder is less than other:  find a
	        // floating-point that approximates remainder / other *from below*, add this
	        // into the result, and subtract it from the remainder.  It is critical that
	        // the approximate value is less than or equal to the real value so that the
	        // remainder never becomes negative.
	        res = Long.ZERO;
	        rem = this;
	        while (rem.greaterThanOrEqual(divisor)) {
	            // Approximate the result of division. This may be a little greater or
	            // smaller than the actual value.
	            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

	            // We will tweak the approximate result by changing it in the 48-th digit or
	            // the smallest non-fractional digit, whichever is larger.
	            var log2 = Math.ceil(Math.log(approx) / Math.LN2),
	                delta = (log2 <= 48) ? 1 : Math.pow(2, log2 - 48),

	            // Decrease the approximation until it is smaller than the remainder.  Note
	            // that if it is too large, the product overflows and is negative.
	                approxRes = Long.fromNumber(approx),
	                approxRem = approxRes.multiply(divisor);
	            while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
	                approx -= delta;
	                approxRes = Long.fromNumber(approx, this.unsigned);
	                approxRem = approxRes.multiply(divisor);
	            }

	            // We know the answer can't be zero... and actually, zero would cause
	            // infinite recursion since we would make no progress.
	            if (approxRes.isZero())
	                approxRes = Long.ONE;

	            res = res.add(approxRes);
	            rem = rem.subtract(approxRem);
	        }
	        return res;
	    };

	    /**
	     * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
	     * @function
	     * @param {!Long|number|string} divisor Divisor
	     * @returns {!Long} Quotient
	     * @expose
	     */
	    Long.prototype.div = Long.prototype.divide;

	    /**
	     * Returns this Long modulo the specified.
	     * @param {!Long|number|string} divisor Divisor
	     * @returns {!Long} Remainder
	     * @expose
	     */
	    Long.prototype.modulo = function modulo(divisor) {
	        if (!Long.isLong(divisor))
	            divisor = Long.fromValue(divisor);
	        return this.subtract(this.divide(divisor).multiply(divisor));
	    };

	    /**
	     * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
	     * @function
	     * @param {!Long|number|string} divisor Divisor
	     * @returns {!Long} Remainder
	     * @expose
	     */
	    Long.prototype.mod = Long.prototype.modulo;

	    /**
	     * Returns the bitwise NOT of this Long.
	     * @returns {!Long}
	     * @expose
	     */
	    Long.prototype.not = function not() {
	        return Long.fromBits(~this.low, ~this.high, this.unsigned);
	    };

	    /**
	     * Returns the bitwise AND of this Long and the specified.
	     * @param {!Long|number|string} other Other Long
	     * @returns {!Long}
	     * @expose
	     */
	    Long.prototype.and = function and(other) {
	        if (!Long.isLong(other))
	            other = Long.fromValue(other);
	        return Long.fromBits(this.low & other.low, this.high & other.high, this.unsigned);
	    };

	    /**
	     * Returns the bitwise OR of this Long and the specified.
	     * @param {!Long|number|string} other Other Long
	     * @returns {!Long}
	     * @expose
	     */
	    Long.prototype.or = function or(other) {
	        if (!Long.isLong(other))
	            other = Long.fromValue(other);
	        return Long.fromBits(this.low | other.low, this.high | other.high, this.unsigned);
	    };

	    /**
	     * Returns the bitwise XOR of this Long and the given one.
	     * @param {!Long|number|string} other Other Long
	     * @returns {!Long}
	     * @expose
	     */
	    Long.prototype.xor = function xor(other) {
	        if (!Long.isLong(other))
	            other = Long.fromValue(other);
	        return Long.fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
	    };

	    /**
	     * Returns this Long with bits shifted to the left by the given amount.
	     * @param {number|!Long} numBits Number of bits
	     * @returns {!Long} Shifted Long
	     * @expose
	     */
	    Long.prototype.shiftLeft = function shiftLeft(numBits) {
	        if (Long.isLong(numBits))
	            numBits = numBits.toInt();
	        if ((numBits &= 63) === 0)
	            return this;
	        else if (numBits < 32)
	            return Long.fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
	        else
	            return Long.fromBits(0, this.low << (numBits - 32), this.unsigned);
	    };

	    /**
	     * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
	     * @function
	     * @param {number|!Long} numBits Number of bits
	     * @returns {!Long} Shifted Long
	     * @expose
	     */
	    Long.prototype.shl = Long.prototype.shiftLeft;

	    /**
	     * Returns this Long with bits arithmetically shifted to the right by the given amount.
	     * @param {number|!Long} numBits Number of bits
	     * @returns {!Long} Shifted Long
	     * @expose
	     */
	    Long.prototype.shiftRight = function shiftRight(numBits) {
	        if (Long.isLong(numBits))
	            numBits = numBits.toInt();
	        if ((numBits &= 63) === 0)
	            return this;
	        else if (numBits < 32)
	            return Long.fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
	        else
	            return Long.fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
	    };

	    /**
	     * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
	     * @function
	     * @param {number|!Long} numBits Number of bits
	     * @returns {!Long} Shifted Long
	     * @expose
	     */
	    Long.prototype.shr = Long.prototype.shiftRight;

	    /**
	     * Returns this Long with bits logically shifted to the right by the given amount.
	     * @param {number|!Long} numBits Number of bits
	     * @returns {!Long} Shifted Long
	     * @expose
	     */
	    Long.prototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
	        if (Long.isLong(numBits))
	            numBits = numBits.toInt();
	        numBits &= 63;
	        if (numBits === 0)
	            return this;
	        else {
	            var high = this.high;
	            if (numBits < 32) {
	                var low = this.low;
	                return Long.fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
	            } else if (numBits === 32)
	                return Long.fromBits(high, 0, this.unsigned);
	            else
	                return Long.fromBits(high >>> (numBits - 32), 0, this.unsigned);
	        }
	    };

	    /**
	     * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
	     * @function
	     * @param {number|!Long} numBits Number of bits
	     * @returns {!Long} Shifted Long
	     * @expose
	     */
	    Long.prototype.shru = Long.prototype.shiftRightUnsigned;

	    /**
	     * Converts this Long to signed.
	     * @returns {!Long} Signed long
	     * @expose
	     */
	    Long.prototype.toSigned = function toSigned() {
	        if (!this.unsigned)
	            return this;
	        return new Long(this.low, this.high, false);
	    };

	    /**
	     * Converts this Long to unsigned.
	     * @returns {!Long} Unsigned long
	     * @expose
	     */
	    Long.prototype.toUnsigned = function toUnsigned() {
	        if (this.unsigned)
	            return this;
	        return new Long(this.low, this.high, true);
	    };

	    return Long;
	});
} (Long$5));

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const crypto$1 = require$$0$8;
const utils$I = utils$K;

/** @module types */

/**
 * Creates a new instance of Uuid based on a Buffer
 * @class
 * @classdesc Represents an immutable universally unique identifier (UUID). A UUID represents a 128-bit value.
 * @param {Buffer} buffer The 16-length buffer.
 * @constructor
 */
function Uuid$1(buffer) {
  if (!buffer || buffer.length !== 16) {
    throw new Error('You must provide a buffer containing 16 bytes');
  }
  this.buffer = buffer;
}

/**
 * Parses a string representation of a Uuid
 * @param {String} value
 * @returns {Uuid}
 */
Uuid$1.fromString = function (value) {
  //36 chars: 32 + 4 hyphens
  if (typeof value !== 'string' || value.length !== 36) {
    throw new Error('Invalid string representation of Uuid, it should be in the 00000000-0000-0000-0000-000000000000');
  }
  return new Uuid$1(utils$I.allocBufferFromString(value.replace(/-/g, ''), 'hex'));
};

/**
 * Creates a new random (version 4) Uuid.
 * @param {function} [callback] Optional callback to be invoked with the error as first parameter and the created Uuid as
 * second parameter.
 * @returns {Uuid}
 */
Uuid$1.random = function (callback) {
  if (callback) {
    getRandomBytes$1(function(err, buffer) {
      if (err) {
        return callback(err);
      }
      return callback(null, createUuidFromBuffer(buffer));
    });
  } else {
    const buffer = getRandomBytes$1();
    return createUuidFromBuffer(buffer);
  }
};

/**
 * Gets the bytes representation of a Uuid
 * @returns {Buffer}
 */
Uuid$1.prototype.getBuffer = function () {
  return this.buffer;
};
/**
 * Compares this object to the specified object.
 * The result is true if and only if the argument is not null, is a UUID object, and contains the same value, bit for bit, as this UUID.
 * @param {Uuid} other The other value to test for equality.
 */
Uuid$1.prototype.equals = function (other) {
  return other instanceof Uuid$1 && this.buffer.equals(other.buffer);
};

/**
 * Returns a string representation of the value of this Uuid instance.
 * 32 hex separated by hyphens, in the form of 00000000-0000-0000-0000-000000000000.
 * @returns {String}
 */
Uuid$1.prototype.toString = function () {
  //32 hex representation of the Buffer
  const hexValue = getHex(this);
  return (
    hexValue.substr(0, 8) + '-' +
    hexValue.substr(8, 4) + '-' +
    hexValue.substr(12, 4) + '-' +
    hexValue.substr(16, 4) + '-' +
    hexValue.substr(20, 12));
};

/**
 * Provide the name of the constructor and the string representation
 * @returns {string}
 */
Uuid$1.prototype.inspect = function () {
  return this.constructor.name + ': ' + this.toString();
};

/**
 * Returns the string representation.
 * Method used by the native JSON.stringify() to serialize this instance.
 */
Uuid$1.prototype.toJSON = function () {
  return this.toString();
};


/**
 * Returns new Uuid
 * @private
 * @returns {Uuid}
 */
function createUuidFromBuffer (buffer) {
  //clear the version
  buffer[6] &= 0x0f;
  //set the version 4
  buffer[6] |= 0x40;
  //clear the variant
  buffer[8] &= 0x3f;
  //set the IETF variant
  buffer[8] |= 0x80;
  return new Uuid$1(buffer);
}

/**
 * @private
 * @returns {String} 32 hex representation of the instance, without separators
 */
function getHex (uuid) {
  return uuid.buffer.toString('hex');
}

/**
 * Gets a crypto generated 16 bytes
 * @private
 * @returns {Buffer}
 */
function getRandomBytes$1 (cb) {
  return crypto$1.randomBytes(16, cb);
}

var uuid = Uuid$1;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const util$z = require$$0$4;
const crypto = require$$0$8;
const Long$4 = LongExports;

const Uuid = uuid;
const utils$H = utils$K;

/** @module types */
/**
 * Oct 15, 1582 in milliseconds since unix epoch
 * @const
 * @private
 */
const _unixToGregorian = 12219292800000;
/**
 * 10,000 ticks in a millisecond
 * @const
 * @private
 */
const _ticksInMs = 10000;

const minNodeId = utils$H.allocBufferFromString('808080808080', 'hex');
const minClockId = utils$H.allocBufferFromString('8080', 'hex');
const maxNodeId = utils$H.allocBufferFromString('7f7f7f7f7f7f', 'hex');
const maxClockId = utils$H.allocBufferFromString('7f7f', 'hex');

/**
 * Counter used to generate up to 10000 different timeuuid values with the same Date
 * @private
 * @type {number}
 */
let _ticks = 0;
/**
 * Counter used to generate ticks for the current time
 * @private
 * @type {number}
 */
let _ticksForCurrentTime = 0;
/**
 * Remember the last time when a ticks for the current time so that it can be reset
 * @private
 * @type {number}
 */
let _lastTimestamp = 0;

/**
 * Creates a new instance of Uuid based on the parameters provided according to rfc4122.
 * If any of the arguments is not provided, it will be randomly generated, except for the date that will use the current
 * date.
 * <p>
 *   Note that when nodeId and/or clockId portions are not provided, the constructor will generate them using
 *   <code>crypto.randomBytes()</code>. As it's possible that <code>crypto.randomBytes()</code> might block, it's
 *   recommended that you use the callback-based version of the static methods <code>fromDate()</code> or
 *   <code>now()</code> in that case.
 * </p>
 * @class
 * @classdesc Represents an immutable version 1 universally unique identifier (UUID). A UUID represents a 128-bit value.
 * <p>Usage: <code>TimeUuid.now()</code></p>
 * @extends module:types~Uuid
 * @param {Date} [value] The datetime for the instance, if not provided, it will use the current Date.
 * @param {Number} [ticks] A number from 0 to 10000 representing the 100-nanoseconds units for this instance to fill in the information not available in the Date,
 * as Ecmascript Dates have only milliseconds precision.
 * @param {String|Buffer} [nodeId] A 6-length Buffer or string of 6 ascii characters representing the node identifier, ie: 'host01'.
 * @param {String|Buffer} [clockId] A 2-length Buffer or string of 6 ascii characters representing the clock identifier.
 * @constructor
 */
function TimeUuid(value, ticks, nodeId, clockId) {
  let buffer;
  if (value instanceof Buffer) {
    if (value.length !== 16) {
      throw new Error('Buffer for v1 uuid not valid');
    }
    buffer = value;
  }
  else {
    buffer = generateBuffer(value, ticks, nodeId, clockId);
  }
  Uuid.call(this, buffer);
}

util$z.inherits(TimeUuid, Uuid);

/**
 * Generates a TimeUuid instance based on the Date provided using random node and clock values.
 * @param {Date} date Date to generate the v1 uuid.
 * @param {Number} [ticks] A number from 0 to 10000 representing the 100-nanoseconds units for this instance to fill in the information not available in the Date,
 * as Ecmascript Dates have only milliseconds precision.
 * @param {String|Buffer} [nodeId] A 6-length Buffer or string of 6 ascii characters representing the node identifier, ie: 'host01'.
 * If not provided, a random nodeId will be generated.
 * @param {String|Buffer} [clockId] A 2-length Buffer or string of 6 ascii characters representing the clock identifier.
 * If not provided a random clockId will be generated.
 * @param {Function} [callback] An optional callback to be invoked with the error as first parameter and the created
 * <code>TimeUuid</code> as second parameter. When a callback is provided, the random portions of the
 * <code>TimeUuid</code> instance are created asynchronously.
 * <p>
 *   When nodeId and/or clockId portions are not provided, this method will generate them using
 *   <code>crypto.randomBytes()</code>. As it's possible that <code>crypto.randomBytes()</code> might block, it's
 *   recommended that you use the callback-based version of this method in that case.
 * </p>
 * @example <caption>Generate a TimeUuid from a ECMAScript Date</caption>
 * const timeuuid = TimeUuid.fromDate(new Date());
 * @example <caption>Generate a TimeUuid from a Date with ticks portion</caption>
 * const timeuuid = TimeUuid.fromDate(new Date(), 1203);
 * @example <caption>Generate a TimeUuid from a Date without any random portion</caption>
 * const timeuuid = TimeUuid.fromDate(new Date(), 1203, 'host01', '02');
 * @example <caption>Generate a TimeUuid from a Date with random node and clock identifiers</caption>
 * TimeUuid.fromDate(new Date(), 1203, function (err, timeuuid) {
 *   // do something with the generated timeuuid
 * });
 */
TimeUuid.fromDate = function (date, ticks, nodeId, clockId, callback) {
  if (typeof ticks === 'function') {
    callback = ticks;
    ticks = nodeId = clockId = null;
  } else if (typeof nodeId === 'function') {
    callback = nodeId;
    nodeId = clockId = null;
  } else if (typeof clockId === 'function') {
    callback = clockId;
    clockId = null;
  }

  if (!callback) {
    return new TimeUuid(date, ticks, nodeId, clockId);
  }

  utils$H.parallel([
    next => getOrGenerateRandom(nodeId, 6, (err, buffer) => next(err, nodeId = buffer)),
    next => getOrGenerateRandom(clockId, 2, (err, buffer) => next(err, clockId = buffer)),
  ], (err) => {
    if (err) {
      return callback(err);
    }

    let timeUuid;
    try {
      timeUuid = new TimeUuid(date, ticks, nodeId, clockId);
    }
    catch (e) {
      return callback(e);
    }

    callback(null, timeUuid);
  });
};

/**
 * Parses a string representation of a TimeUuid
 * @param {String} value
 * @returns {TimeUuid}
 */
TimeUuid.fromString = function (value) {
  return new TimeUuid(Uuid.fromString(value).getBuffer());
};

/**
 * Returns the smaller possible type 1 uuid with the provided Date.
 */
TimeUuid.min = function (date, ticks) {
  return new TimeUuid(date, ticks, minNodeId, minClockId);
};

/**
 * Returns the biggest possible type 1 uuid with the provided Date.
 */
TimeUuid.max = function (date, ticks) {
  return new TimeUuid(date, ticks, maxNodeId, maxClockId);
};

/**
 * Generates a TimeUuid instance based on the current date using random node and clock values.
 * @param {String|Buffer} [nodeId] A 6-length Buffer or string of 6 ascii characters representing the node identifier, ie: 'host01'.
 * If not provided, a random nodeId will be generated.
 * @param {String|Buffer} [clockId] A 2-length Buffer or string of 6 ascii characters representing the clock identifier.
 * If not provided a random clockId will be generated.
 * @param {Function} [callback] An optional callback to be invoked with the error as first parameter and the created
 * <code>TimeUuid</code> as second parameter. When a callback is provided, the random portions of the
 * <code>TimeUuid</code> instance are created asynchronously.
 * <p>
 *   When nodeId and/or clockId portions are not provided, this method will generate them using
 *   <code>crypto.randomBytes()</code>. As it's possible that <code>crypto.randomBytes()</code> might block, it's
 *   recommended that you use the callback-based version of this method in that case.
 * </p>
 * @example <caption>Generate a TimeUuid from a Date without any random portion</caption>
 * const timeuuid = TimeUuid.now('host01', '02');
 * @example <caption>Generate a TimeUuid with random node and clock identifiers</caption>
 * TimeUuid.now(function (err, timeuuid) {
 *   // do something with the generated timeuuid
 * });
 * @example <caption>Generate a TimeUuid based on the current date (might block)</caption>
 * const timeuuid = TimeUuid.now();
 */
TimeUuid.now = function (nodeId, clockId, callback) {
  return TimeUuid.fromDate(null, null, nodeId, clockId, callback);
};


/**
 * Gets the Date and 100-nanoseconds units representation of this instance.
 * @returns {{date: Date, ticks: Number}}
 */
TimeUuid.prototype.getDatePrecision = function () {
  const timeLow = this.buffer.readUInt32BE(0);

  let timeHigh = 0;
  timeHigh |= ( this.buffer[4] & 0xff ) << 8;
  timeHigh |= this.buffer[5] & 0xff;
  timeHigh |= ( this.buffer[6] & 0x0f ) << 24;
  timeHigh |= ( this.buffer[7] & 0xff ) << 16;

  const val = Long$4.fromBits(timeLow, timeHigh);
  const ticksInMsLong = Long$4.fromNumber(_ticksInMs);
  const ticks = val.modulo(ticksInMsLong);
  const time = val
    .div(ticksInMsLong)
    .subtract(Long$4.fromNumber(_unixToGregorian));
  return { date: new Date(time.toNumber()), ticks: ticks.toNumber()};
};

/**
 * Gets the Date representation of this instance.
 * @returns {Date}
 */
TimeUuid.prototype.getDate = function () {
  return this.getDatePrecision().date;
};

/**
 * Returns the node id this instance
 * @returns {Buffer}
 */
TimeUuid.prototype.getNodeId = function () {
  return this.buffer.slice(10);
};

/**
 * Returns the clock id this instance, with the variant applied (first 2 msb being 1 and 0).
 * @returns {Buffer}
 */
TimeUuid.prototype.getClockId = function () {
  return this.buffer.slice(8, 10);
};

/**
 * Returns the node id this instance as an ascii string
 * @returns {String}
 */
TimeUuid.prototype.getNodeIdString = function () {
  return this.buffer.slice(10).toString('ascii');
};

function writeTime(buffer, time, ticks) {
  //value time expressed in ticks precision
  const val = Long$4
    .fromNumber(time + _unixToGregorian)
    .multiply(Long$4.fromNumber(10000))
    .add(Long$4.fromNumber(ticks));
  const timeHigh = val.getHighBitsUnsigned();
  buffer.writeUInt32BE(val.getLowBitsUnsigned(), 0);
  buffer.writeUInt16BE(timeHigh & 0xffff, 4);
  buffer.writeUInt16BE(timeHigh >>> 16 & 0xffff, 6);
}

/**
 * Returns a buffer of length 2 representing the clock identifier
 * @param {String|Buffer} clockId
 * @returns {Buffer}
 * @private
 */
function getClockId(clockId) {
  let buffer = clockId;
  if (typeof clockId === 'string') {
    buffer = utils$H.allocBufferFromString(clockId, 'ascii');
  }
  if (!(buffer instanceof Buffer)) {
    //Generate
    buffer = getRandomBytes(2);
  }
  else if (buffer.length !== 2) {
    throw new Error('Clock identifier must have 2 bytes');
  }
  return buffer;
}

/**
 * Returns a buffer of length 6 representing the clock identifier
 * @param {String|Buffer} nodeId
 * @returns {Buffer}
 * @private
 */
function getNodeId(nodeId) {
  let buffer = nodeId;
  if (typeof nodeId === 'string') {
    buffer = utils$H.allocBufferFromString(nodeId, 'ascii');
  }
  if (!(buffer instanceof Buffer)) {
    //Generate
    buffer = getRandomBytes(6);
  }
  else if (buffer.length !== 6) {
    throw new Error('Node identifier must have 6 bytes');
  }
  return buffer;
}

/**
 * Returns the ticks portion of a timestamp.  If the ticks are not provided an internal counter is used that gets reset at 10000.
 * @private
 * @param {Number} [ticks] 
 * @returns {Number} 
 */
function getTicks(ticks) {
  if (typeof ticks !== 'number'|| ticks >= _ticksInMs) {
    _ticks++;
    if (_ticks >= _ticksInMs) {
      _ticks = 0;
    }
    ticks = _ticks;
  }
  return ticks;
}

/**
 * Returns an object with the time representation of the date expressed in milliseconds since unix epoch 
 * and a ticks property for the 100-nanoseconds precision.
 * @private
 * @returns {{time: Number, ticks: Number}} 
 */
function getTimeWithTicks(date, ticks) {
  if (!(date instanceof Date) || isNaN(date.getTime())) {
    // time with ticks for the current time
    date = new Date();
    const time = date.getTime();
    _ticksForCurrentTime++;
    if(_ticksForCurrentTime > _ticksInMs || time > _lastTimestamp) {
      _ticksForCurrentTime = 0;
      _lastTimestamp = time;
    }
    ticks = _ticksForCurrentTime;
  }
  return {
    time: date.getTime(),
    ticks: getTicks(ticks)
  };
}

function getRandomBytes(length) {
  return crypto.randomBytes(length);
}

function getOrGenerateRandom(id, length, callback) {
  if (id) {
    return callback(null, id);
  }
  crypto.randomBytes(length, callback);
}

/**
 * Generates a 16-length Buffer instance
 * @private
 * @param {Date} date
 * @param {Number} ticks
 * @param {String|Buffer} nodeId
 * @param {String|Buffer} clockId
 * @returns {Buffer}
 */
function generateBuffer(date, ticks, nodeId, clockId) {
  const timeWithTicks = getTimeWithTicks(date, ticks);
  nodeId = getNodeId(nodeId);
  clockId = getClockId(clockId);
  const buffer = utils$H.allocBufferUnsafe(16);
  //Positions 0-7 Timestamp
  writeTime(buffer, timeWithTicks.time, timeWithTicks.ticks);
  //Position 8-9 Clock
  clockId.copy(buffer, 8, 0);
  //Positions 10-15 Node
  nodeId.copy(buffer, 10, 0);
  //Version Byte: Time based
  //0001xxxx
  //turn off first 4 bits
  buffer[6] = buffer[6] & 0x0f;
  //turn on fifth bit
  buffer[6] = buffer[6] | 0x10;

  //IETF Variant Byte: 1.0.x
  //10xxxxxx
  //turn off first 2 bits
  buffer[8] = buffer[8] & 0x3f;
  //turn on first bit
  buffer[8] = buffer[8] | 0x80;
  return buffer;
}

var timeUuid = TimeUuid;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const _versionPattern = /(\d+)\.(\d+)(?:\.(\d+))?(?:\.(\d+)?)?(?:[-~]([\w+]*(?:-\w[.\w]*)*))?(?:\+([.\w]+))?/;

/**
 * Represents a version number in the form of X.Y.Z with optional pre-release and build metadata.
 *
 * Version numbers compare the usual way, the major version number (X) is compared first, then
 * the minor one (Y) and then the patch level one (Z).  If pre-release or other build metadata
 * is present for a version, that version is considered less than an otherwise equivalent version
 * that doesn't have these labels, otherwise they are considered equal.
 *
 * As of initial implementation versions are only compared against those with at most patch versions
 * more refined comparisons are not needed.
 *
 * @property {Number} major The major version, X of X.Y.Z.
 * @property {Number} minor The minor version, Y of X.Y.Z.
 * @property {Number} patch The patch version, Z of X.Y.Z.
 * @property {Number} dsePatch The dsePatch version, A of X.Y.Z.A or undefined if not present.
 * @property {String[]} preReleases Prerelease indicators if present, i.e. SNAPSHOT of X.Y.Z-SNAPSHOT.
 * @property {String} build Build string if present, i.e. build1 of X.Y.Z+build1.
 *
 * @ignore
 */
let VersionNumber$2 = class VersionNumber {
  constructor(major, minor, patch, dsePatch, preReleases, build) {
    this.major = major;
    this.minor = minor;
    this.patch = patch;
    this.dsePatch = dsePatch;
    this.preReleases = preReleases;
    this.build = build;
  }

  /**
   * @return {String} String representation of this version.
   */
  toString() {
    let str = this.major + '.' + this.minor;
    if (this.patch !== undefined) {
      str += '.' + this.patch;
    }
    if (this.dsePatch !== undefined) {
      str += '.' + this.dsePatch;
    }
    if (this.preReleases !== undefined) {
      this.preReleases.forEach((preRelease) => {
        str += '-' + preRelease;
      });
    }
    if (this.build) {
      str += '+' + this.build;
    }
    return str;
  }

  /**
   * Compares this version with the provided version. 
   * @param {VersionNumber} other 
   * @return {Number} -1 if less than other, 0 if equal, 1 if greater than.
   */
  compare(other) {
    if (this.major < other.major) {
      return -1;
    } else if (this.major > other.major) {
      return 1;
    } else if (this.minor < other.minor) {
      return -1;
    } else if (this.minor > other.minor) {
      return 1;
    }

    // sanitize patch by setting to 0 if undefined.
    const thisPatch = this.patch || 0;
    const otherPatch = other.patch || 0;
    if (thisPatch < otherPatch) {
      return -1;
    } else if (thisPatch > otherPatch) {
      return 1;
    }

    // if dsePatch is set in one case, but not other, consider the one where it is set as greater.
    if (this.dsePatch === undefined) {
      if (other.dsePatch !== undefined) {
        return -1;
      }
    } else if (other.dsePatch === undefined) {
      return 1;
    } else {
      if (this.dsePatch < other.dsePatch) {
        return -1;
      } else if (this.dsePatch > other.dsePatch) {
        return 1;
      }
    }

    // If prereleases are present, consider less than those that don't have any.
    if (this.preReleases === undefined) {
      if (other.preReleases !== undefined) {
        return 1;
      }
    } else if (other.preReleases === undefined) {
      return -1;
    }
   
    // Don't consider build.
    return 0;
  }

  static parse(version) {
    if (!version) {
      return null;
    }

    const match = version.match(_versionPattern);
    if (match) {
      const major = parseInt(match[1], 10);
      const minor = parseInt(match[2], 10);
      const patch = match[3] ? parseInt(match[3], 10) : undefined;
      const dsePatch = match[4] ? parseInt(match[4], 10) : undefined;
      const preReleases = match[5] ? match[5].split('-') : undefined;
      const build = match[6];
      return new VersionNumber(major, minor, patch, dsePatch, preReleases, build);
    }
    throw new TypeError('Could not extract version from \'' + version + '\'');
  }
};

var versionNumber = VersionNumber$2;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const utils$G = utils$K;
const VersionNumber$1 = versionNumber;
const v200 = VersionNumber$1.parse('2.0.0');
const v210 = VersionNumber$1.parse('2.1.0');
const v220 = VersionNumber$1.parse('2.2.0');
const v300 = VersionNumber$1.parse('3.0.0');
const v510 = VersionNumber$1.parse('5.1.0');
const v600 = VersionNumber$1.parse('6.0.0');

/**
 * Contains information for the different protocol versions supported by the driver.
 * @type {Object}
 * @property {Number} v1 Cassandra protocol v1, supported in Apache Cassandra 1.2-->2.2.
 * @property {Number} v2 Cassandra protocol v2, supported in Apache Cassandra 2.0-->2.2.
 * @property {Number} v3 Cassandra protocol v3, supported in Apache Cassandra 2.1-->3.x.
 * @property {Number} v4 Cassandra protocol v4, supported in Apache Cassandra 2.2-->3.x.
 * @property {Number} v5 Cassandra protocol v5, in beta from Apache Cassandra 3.x+. Currently not supported by the
 * driver.
 * @property {Number} dseV1 DataStax Enterprise protocol v1, DSE 5.1+
 * @property {Number} dseV2 DataStax Enterprise protocol v2, DSE 6.0+
 * @property {Number} maxSupported Returns the higher protocol version that is supported by this driver.
 * @property {Number} minSupported Returns the lower protocol version that is supported by this driver.
 * @property {Function} isSupported A function that returns a boolean determining whether a given protocol version
 * is supported.
 * @alias module:types~protocolVersion
 */
const protocolVersion = {
  // Strict equality operators to compare versions are allowed, other comparison operators are discouraged. Instead,
  // use a function that checks if a functionality is present on a certain version, for maintainability purposes.
  v1: 0x01,
  v2: 0x02,
  v3: 0x03,
  v4: 0x04,
  v5: 0x05,
  v6: 0x06,
  dseV1: 0x41,
  dseV2: 0x42,
  maxSupported: 0x42,
  minSupported: 0x01,

  /**
   * Determines whether the protocol version is a DSE-specific protocol version.
   * @param {Number} version
   * @returns {Boolean}
   * @ignore
   */
  isDse: function(version) {
    return ((version >= this.dseV1 && version <= this.dseV2));
  },
  /**
   * Returns true if the protocol version represents a version of Cassandra
   * supported by this driver, false otherwise
   * @param {Number} version
   * @returns {Boolean}
   * @ignore
   */
  isSupportedCassandra: function(version) {
    return (version <= 0x04 && version >= 0x01);
  },
  /**
   * Determines whether the protocol version is supported by this driver.
   * @param {Number} version
   * @returns {Boolean}
   * @ignore
   */
  isSupported: function (version) {
    return (this.isDse(version) || this.isSupportedCassandra(version));
  },

  /**
   * Determines whether the protocol includes flags for PREPARE messages.
   * @param {Number} version
   * @returns {Boolean}
   * @ignore
   */
  supportsPrepareFlags: function (version) {
    return (version === this.dseV2);
  },
  /**
   * Determines whether the protocol supports sending the keyspace as part of PREPARE, QUERY, EXECUTE, and BATCH.
   * @param {Number} version
   * @returns {Boolean}
   * @ignore
   */
  supportsKeyspaceInRequest: function (version) {
    return (version === this.dseV2);
  },
  /**
   * Determines whether the protocol supports result_metadata_id on `prepared` response and
   * and `execute` request.
   * @param {Number} version
   * @returns {Boolean}
   * @ignore
   */
  supportsResultMetadataId: function (version) {
    return (version === this.dseV2);
  },
  /**
   * Determines whether the protocol supports partition key indexes in the `prepared` RESULT responses.
   * @param {Number} version
   * @returns {Boolean}
   * @ignore
   */
  supportsPreparedPartitionKey: function (version) {
    return (version >= this.v4);
  },
  /**
   * Determines whether the protocol supports up to 4 strings (ie: change_type, target, keyspace and table) in the
   * schema change responses.
   * @param version
   * @return {boolean}
   * @ignore
   */
  supportsSchemaChangeFullMetadata: function (version) {
    return (version >= this.v3);
  },
  /**
   * Determines whether the protocol supports continuous paging.
   * @param version
   * @return {boolean}
   * @ignore
   */
  supportsContinuousPaging: function (version) {
    return (this.isDse(version));
  },
  /**
   * Determines whether the protocol supports paging state and serial consistency parameters in QUERY and EXECUTE
   * requests.
   * @param version
   * @return {boolean}
   * @ignore
   */
  supportsPaging: function (version) {
    return (version >= this.v2);
  },
  /**
   * Determines whether the protocol supports timestamps parameters in BATCH, QUERY and EXECUTE requests.
   * @param {Number} version
   * @return {boolean}
   * @ignore
   */
  supportsTimestamp: function (version) {
    return (version >= this.v3);
  },
  /**
   * Determines whether the protocol supports named parameters in QUERY and EXECUTE requests.
   * @param {Number} version
   * @return {boolean}
   * @ignore
   */
  supportsNamedParameters: function (version) {
    return (version >= this.v3);
  },
  /**
   * Determines whether the protocol supports unset parameters.
   * @param {Number} version
   * @return {boolean}
   * @ignore
   */
  supportsUnset: function (version) {
    return (version >= this.v4);
  },
  /**
   * Determines whether the protocol provides a reason map for read and write failure errors.
   * @param version
   * @return {boolean}
   * @ignore
   */
  supportsFailureReasonMap: function (version) {
    return (version >= this.v5);
  },
  /**
   * Determines whether the protocol supports timestamp and serial consistency parameters in BATCH requests.
   * @param {Number} version
   * @return {boolean}
   * @ignore
   */
  uses2BytesStreamIds: function (version) {
    return (version >= this.v3);
  },
  /**
   * Determines whether the collection length is encoded using 32 bits.
   * @param {Number} version
   * @return {boolean}
   * @ignore
   */
  uses4BytesCollectionLength: function (version) {
    return (version >= this.v3);
  },
  /**
   * Determines whether the QUERY, EXECUTE and BATCH flags are encoded using 32 bits.
   * @param {Number} version
   * @return {boolean}
   * @ignore
   */
  uses4BytesQueryFlags: function (version) {
    return (this.isDse(version));
  },
  /**
   * Startup responses using protocol v4+ can be a SERVER_ERROR wrapping a ProtocolException, this method returns true
   * when is possible to receive such error.
   * @param {Number} version
   * @return {boolean}
   * @ignore
   */
  canStartupResponseErrorBeWrapped: function (version) {
    return (version >= this.v4);
  },
  /**
   * Gets the first version number that is supported, lower than the one provided.
   * Returns zero when there isn't a lower supported version.
   * @param {Number} version
   * @return {Number}
   * @ignore
   */
  getLowerSupported: function (version) {
    if (version >= this.v5) {
      return this.v4;
    }
    if (version <= this.v1) {
      return 0;
    }
    return version - 1;
  },

  /**
   * Computes the highest supported protocol version collectively by the given hosts.
   *
   * Considers the cassandra_version of the input hosts to determine what protocol versions
   * are supported and uses the highest common protocol version among them.
   *
   * If hosts >= C* 3.0 are detected, any hosts older than C* 2.1 will not be considered
   * as those cannot be connected to.  In general this will not be a problem as C* does
   * not support clusters with nodes that have versions that are more than one major
   * version away from each other.
   * @param {Connection} connection Connection hosts were discovered from.
   * @param {Array.<Host>} hosts The hosts to determine highest protocol version from.
   * @return {Number} Highest supported protocol version among hosts.
   */
  getHighestCommon: function(connection, hosts) {
    const log = connection.log ? connection.log.bind(connection) : utils$G.noop;
    let maxVersion = connection.protocolVersion;
    // whether or not protocol v3 is required (nodes detected that don't support < 3).
    let v3Requirement = false;
    // track the common protocol version >= v3 in case we encounter older versions.
    let maxVersionWith3OrMore = maxVersion;
    hosts.forEach(h => {
      let dseVersion = null;
      if (h.dseVersion) {
        // As of DSE 5.1, DSE has it's own specific protocol versions.  If we detect 5.1+
        // consider those protocol versions.
        dseVersion = VersionNumber$1.parse(h.dseVersion);
        log('verbose', `Encountered host ${h.address} with dse version ${dseVersion}`);
        if (dseVersion.compare(v510) >= 0) {
          v3Requirement = true;
          if (dseVersion.compare(v600) >= 0) {
            maxVersion = Math.min(this.dseV2, maxVersion);
          } else {
            maxVersion = Math.min(this.dseV1, maxVersion);
          }
          maxVersionWith3OrMore = maxVersion;
          return;
        }
        // If DSE < 5.1, we fall back on the cassandra protocol logic.
      }

      if (!h.cassandraVersion || h.cassandraVersion.length === 0) {
        log('warning', 'Encountered host ' + h.address + ' with no cassandra version,' +
          ' skipping as part of protocol version evaluation');
        return;
      }

      try {
        const cassandraVersion = VersionNumber$1.parse(h.cassandraVersion);
        if (!dseVersion) {
          log('verbose', 'Encountered host ' + h.address + ' with cassandra version ' + cassandraVersion);
        }
        if (cassandraVersion.compare(v300) >= 0) {
          // Anything 3.0.0+ has a max protocol version of V4 and requires at least V3.
          v3Requirement = true;
          maxVersion = Math.min(this.v4, maxVersion);
          maxVersionWith3OrMore = maxVersion;
        } else if (cassandraVersion.compare(v220) >= 0) {
          // Cassandra 2.2.x has a max protocol version of V4.
          maxVersion = Math.min(this.v4, maxVersion);
          maxVersionWith3OrMore = maxVersion;
        } else if (cassandraVersion.compare(v210) >= 0) {
          // Cassandra 2.1.x has a max protocol version of V3.
          maxVersion = Math.min(this.v3, maxVersion);
          maxVersionWith3OrMore = maxVersion;
        } else if (cassandraVersion.compare(v200) >= 0) {
          // Cassandra 2.0.x has a max protocol version of V2.
          maxVersion = Math.min(this.v2, maxVersion);
        } else {
          // Anything else is < 2.x and requires protocol version V1.
          maxVersion = this.v1;
        }
      } catch (e) {
        log('warning', 'Encountered host ' + h.address + ' with unparseable cassandra version ' + h.cassandraVersion
          + ' skipping as part of protocol version evaluation');
      }
    });

    if (v3Requirement && maxVersion < this.v3) {
      const addendum = '. This should not be possible as nodes within a cluster can\'t be separated by more than one major version';
      if (maxVersionWith3OrMore < this.v3) {
        log('error', 'Detected hosts that require at least protocol version 0x3, but currently connected to '
         + connection.address + ':' + connection.port + ' using protocol version 0x' + maxVersionWith3OrMore
         + '. Will not be able to connect to these hosts' + addendum);
      } else {
        log('error', 'Detected hosts with maximum protocol version of 0x' + maxVersion.toString(16)
          + ' but there are some hosts that require at least version 0x3. Will not be able to connect to these older hosts'
          + addendum);
      }
      maxVersion = maxVersionWith3OrMore;
    }

    log('verbose', 'Resolved protocol version 0x' + maxVersion.toString(16) + ' as the highest common protocol version among hosts');
    return maxVersion;
  },

  /**
   * Determines if the protocol is a BETA version of the protocol.
   * @param {Number} version
   * @return {Number}
   */
  isBeta: function (version) {
    return version === this.v5;
  }
};

var protocolVersion_1 = protocolVersion;

var integer;
var hasRequiredInteger;

function requireInteger () {
	if (hasRequiredInteger) return integer;
	hasRequiredInteger = 1;
	// Copyright 2009 The Closure Library Authors. All Rights Reserved.
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//      http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS-IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.

	/** @module types */

	var utils = utils$K;

	/**
	 * Constructs a two's-complement integer an array containing bits of the
	 * integer in 32-bit (signed) pieces, given in little-endian order (i.e.,
	 * lowest-order bits in the first piece), and the sign of -1 or 0.
	 *
	 * See the from* functions below for other convenient ways of constructing
	 * Integers.
	 *
	 * The internal representation of an integer is an array of 32-bit signed
	 * pieces, along with a sign (0 or -1) that indicates the contents of all the
	 * other 32-bit pieces out to infinity.  We use 32-bit pieces because these are
	 * the size of integers on which Javascript performs bit-operations.  For
	 * operations like addition and multiplication, we split each number into 16-bit
	 * pieces, which can easily be multiplied within Javascript's floating-point
	 * representation without overflow or change in sign.
	 *
	 * @constructor
	 * @param {Array.<number>} bits Array containing the bits of the number.
	 * @param {number} sign The sign of the number: -1 for negative and 0 positive.
	 * @final
	 */
	function Integer (bits, sign) {
	  /**
	   * @type {!Array.<number>}
	   * @private
	   */
	  this.bits_ = [];

	  /**
	   * @type {number}
	   * @private
	   */
	  this.sign_ = sign;

	  // Copy the 32-bit signed integer values passed in.  We prune out those at the
	  // top that equal the sign since they are redundant.
	  var top = true;
	  for (var i = bits.length - 1; i >= 0; i--) {
	    var val = bits[i] | 0;
	    if (!top || val != sign) {
	      this.bits_[i] = val;
	      top = false;
	    }
	  }
	}


	// NOTE: Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the
	// from* methods on which they depend.


	/**
	 * A cache of the Integer representations of small integer values.
	 * @type {!Object}
	 * @private
	 */
	Integer.IntCache_ = {};


	/**
	 * Returns an Integer representing the given (32-bit) integer value.
	 * @param {number} value A 32-bit integer value.
	 * @return {!Integer} The corresponding Integer value.
	 */
	Integer.fromInt = function(value) {
	  if (-128 <= value && value < 128) {
	    var cachedObj = Integer.IntCache_[value];
	    if (cachedObj) {
	      return cachedObj;
	    }
	  }

	  var obj = new Integer([value | 0], value < 0 ? -1 : 0);
	  if (-128 <= value && value < 128) {
	    Integer.IntCache_[value] = obj;
	  }
	  return obj;
	};


	/**
	 * Returns an Integer representing the given value, provided that it is a finite
	 * number.  Otherwise, zero is returned.
	 * @param {number} value The value in question.
	 * @return {!Integer} The corresponding Integer value.
	 */
	Integer.fromNumber = function(value) {
	  if (isNaN(value) || !isFinite(value)) {
	    return Integer.ZERO;
	  } else if (value < 0) {
	    return Integer.fromNumber(-value).negate();
	  } else {
	    var bits = [];
	    var pow = 1;
	    for (var i = 0; value >= pow; i++) {
	      bits[i] = (value / pow) | 0;
	      pow *= Integer.TWO_PWR_32_DBL_;
	    }
	    return new Integer(bits, 0);
	  }
	};


	/**
	 * Returns a Integer representing the value that comes by concatenating the
	 * given entries, each is assumed to be 32 signed bits, given in little-endian
	 * order (lowest order bits in the lowest index), and sign-extending the highest
	 * order 32-bit value.
	 * @param {Array.<number>} bits The bits of the number, in 32-bit signed pieces,
	 *     in little-endian order.
	 * @return {!Integer} The corresponding Integer value.
	 */
	Integer.fromBits = function(bits) {
	  var high = bits[bits.length - 1];
	  //noinspection JSBitwiseOperatorUsage
	  return new Integer(bits, high & (1 << 31) ? -1 : 0);
	};


	/**
	 * Returns an Integer representation of the given string, written using the
	 * given radix.
	 * @param {string} str The textual representation of the Integer.
	 * @param {number=} opt_radix The radix in which the text is written.
	 * @return {!Integer} The corresponding Integer value.
	 */
	Integer.fromString = function(str, opt_radix) {
	  if (str.length == 0) {
	    throw TypeError('number format error: empty string');
	  }

	  var radix = opt_radix || 10;
	  if (radix < 2 || 36 < radix) {
	    throw Error('radix out of range: ' + radix);
	  }

	  if (str.charAt(0) == '-') {
	    return Integer.fromString(str.substring(1), radix).negate();
	  } else if (str.indexOf('-') >= 0) {
	    throw TypeError('number format error: interior "-" character');
	  }

	  // Do several (8) digits each time through the loop, so as to
	  // minimize the calls to the very expensive emulated div.
	  var radixToPower = Integer.fromNumber(Math.pow(radix, 8));

	  var result = Integer.ZERO;
	  for (var i = 0; i < str.length; i += 8) {
	    var size = Math.min(8, str.length - i);
	    var value = parseInt(str.substring(i, i + size), radix);
	    if (size < 8) {
	      var power = Integer.fromNumber(Math.pow(radix, size));
	      result = result.multiply(power).add(Integer.fromNumber(value));
	    } else {
	      result = result.multiply(radixToPower);
	      result = result.add(Integer.fromNumber(value));
	    }
	  }
	  return result;
	};

	/**
	 * Returns an Integer representation of a given big endian Buffer.
	 * The internal representation of bits contains bytes in groups of 4
	 * @param {Buffer} buf
	 * @returns {Integer}
	 */
	Integer.fromBuffer = function (buf) {
	  var bits = new Array(Math.ceil(buf.length / 4));
	  //noinspection JSBitwiseOperatorUsage
	  var sign = buf[0] & (1 << 7) ? -1 : 0;
	  for (var i = 0; i < bits.length; i++) {
	    var offset = buf.length - ((i + 1) * 4);
	    var value;
	    if (offset < 0) {
	      //The buffer length is not multiple of 4
	      offset = offset + 4;
	      value = 0;
	      for (var j = 0; j < offset; j++) {
	        var byte = buf[j];
	        if (sign === -1) {
	          //invert the bits
	          byte = ~byte & 0xff;
	        }
	        value = value | (byte << (offset - j - 1) * 8);
	      }
	      if (sign === -1) {
	        //invert all the bits
	        value = ~value;
	      }
	    }
	    else {
	      value = buf.readInt32BE(offset);
	    }
	    bits[i] = value;
	  }
	  return new Integer(bits, sign);
	};

	/**
	 * Returns a big endian buffer representation of an Integer.
	 * Internally the bits are represented using 4 bytes groups (numbers),
	 * in the Buffer representation there might be the case where we need less than the 4 bytes.
	 * For example: 0x00000001 -> '01', 0xFFFFFFFF -> 'FF', 0xFFFFFF01 -> 'FF01'
	 * @param {Integer} value
	 * @returns {Buffer}
	*/
	Integer.toBuffer = function (value) {
	  var sign = value.sign_;
	  var bits = value.bits_;
	  if (bits.length === 0) {
	    //[0] or [0xffffffff]
	    return utils.allocBufferFromArray([value.sign_]);
	  }
	  //the high bits might need to be represented in less than 4 bytes
	  var highBits = bits[bits.length-1];
	  if (sign === -1) {
	    highBits = ~highBits;
	  }
	  var high = [];
	  if (highBits >>> 24 > 0) {
	    high.push((highBits >> 24) & 0xff);
	  }
	  if (highBits >>> 16 > 0) {
	    high.push((highBits >> 16) & 0xff);
	  }
	  if (highBits >>> 8 > 0) {
	    high.push((highBits >> 8) & 0xff);
	  }
	  high.push(highBits & 0xff);
	  if (sign === -1) {
	    //The byte containing the sign bit got removed
	    if (high[0] >> 7 !== 0) {
	      //it is going to be negated
	      high.unshift(0);
	    }
	  }
	  else if (high[0] >> 7 !== 0) {
	    //its positive but it lost the byte containing the sign bit
	    high.unshift(0);
	  }
	  var buf = utils.allocBufferUnsafe(high.length + ((bits.length-1) * 4));
	  for (var j = 0; j < high.length; j++) {
	    var b = high[j];
	    if (sign === -1) {
	      buf[j] = ~b;
	    }
	    else {
	      buf[j] = b;
	    }
	  }
	  for (var i = 0; i < bits.length - 1; i++) {
	    var group = bits[bits.length - 2 - i];
	    var offset = high.length + i * 4;
	    buf.writeInt32BE(group, offset);
	  }
	  return buf;
	};


	/**
	 * A number used repeatedly in calculations.  This must appear before the first
	 * call to the from* functions below.
	 * @type {number}
	 * @private
	 */
	Integer.TWO_PWR_32_DBL_ = (1 << 16) * (1 << 16);


	/** @type {!Integer} */
	Integer.ZERO = Integer.fromInt(0);


	/** @type {!Integer} */
	Integer.ONE = Integer.fromInt(1);


	/**
	 * @type {!Integer}
	 * @private
	 */
	Integer.TWO_PWR_24_ = Integer.fromInt(1 << 24);


	/**
	 * Returns the value, assuming it is a 32-bit integer.
	 * @return {number} The corresponding int value.
	 */
	Integer.prototype.toInt = function() {
	  return this.bits_.length > 0 ? this.bits_[0] : this.sign_;
	};


	/** @return {number} The closest floating-point representation to this value. */
	Integer.prototype.toNumber = function() {
	  if (this.isNegative()) {
	    return -this.negate().toNumber();
	  } else {
	    var val = 0;
	    var pow = 1;
	    for (var i = 0; i < this.bits_.length; i++) {
	      val += this.getBitsUnsigned(i) * pow;
	      pow *= Integer.TWO_PWR_32_DBL_;
	    }
	    return val;
	  }
	};


	/**
	 * @param {number=} opt_radix The radix in which the text should be written.
	 * @return {string} The textual representation of this value.
	 * @override
	 */
	Integer.prototype.toString = function(opt_radix) {
	  var radix = opt_radix || 10;
	  if (radix < 2 || 36 < radix) {
	    throw Error('radix out of range: ' + radix);
	  }

	  if (this.isZero()) {
	    return '0';
	  } else if (this.isNegative()) {
	    return '-' + this.negate().toString(radix);
	  }

	  // Do several (6) digits each time through the loop, so as to
	  // minimize the calls to the very expensive emulated div.
	  var radixToPower = Integer.fromNumber(Math.pow(radix, 6));

	  var rem = this;
	  var result = '';
	  while (true) {
	    var remDiv = rem.divide(radixToPower);
	    var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
	    var digits = intval.toString(radix);

	    rem = remDiv;
	    if (rem.isZero()) {
	      return digits + result;
	    } else {
	      while (digits.length < 6) {
	        digits = '0' + digits;
	      }
	      result = '' + digits + result;
	    }
	  }
	};


	/**
	 * Returns the index-th 32-bit (signed) piece of the Integer according to
	 * little-endian order (i.e., index 0 contains the smallest bits).
	 * @param {number} index The index in question.
	 * @return {number} The requested 32-bits as a signed number.
	 */
	Integer.prototype.getBits = function(index) {
	  if (index < 0) {
	    return 0;  // Allowing this simplifies bit shifting operations below...
	  } else if (index < this.bits_.length) {
	    return this.bits_[index];
	  } else {
	    return this.sign_;
	  }
	};


	/**
	 * Returns the index-th 32-bit piece as an unsigned number.
	 * @param {number} index The index in question.
	 * @return {number} The requested 32-bits as an unsigned number.
	 */
	Integer.prototype.getBitsUnsigned = function(index) {
	  var val = this.getBits(index);
	  return val >= 0 ? val : Integer.TWO_PWR_32_DBL_ + val;
	};


	/** @return {number} The sign bit of this number, -1 or 0. */
	Integer.prototype.getSign = function() {
	  return this.sign_;
	};


	/** @return {boolean} Whether this value is zero. */
	Integer.prototype.isZero = function() {
	  if (this.sign_ != 0) {
	    return false;
	  }
	  for (var i = 0; i < this.bits_.length; i++) {
	    if (this.bits_[i] != 0) {
	      return false;
	    }
	  }
	  return true;
	};


	/** @return {boolean} Whether this value is negative. */
	Integer.prototype.isNegative = function() {
	  return this.sign_ == -1;
	};


	/** @return {boolean} Whether this value is odd. */
	Integer.prototype.isOdd = function() {
	  return (this.bits_.length == 0) && (this.sign_ == -1) ||
	    (this.bits_.length > 0) && ((this.bits_[0] & 1) != 0);
	};


	/**
	 * @param {Integer} other Integer to compare against.
	 * @return {boolean} Whether this Integer equals the other.
	 */
	Integer.prototype.equals = function(other) {
	  if (this.sign_ != other.sign_) {
	    return false;
	  }
	  var len = Math.max(this.bits_.length, other.bits_.length);
	  for (var i = 0; i < len; i++) {
	    if (this.getBits(i) != other.getBits(i)) {
	      return false;
	    }
	  }
	  return true;
	};


	/**
	 * @param {Integer} other Integer to compare against.
	 * @return {boolean} Whether this Integer does not equal the other.
	 */
	Integer.prototype.notEquals = function(other) {
	  return !this.equals(other);
	};


	/**
	 * @param {Integer} other Integer to compare against.
	 * @return {boolean} Whether this Integer is greater than the other.
	 */
	Integer.prototype.greaterThan = function(other) {
	  return this.compare(other) > 0;
	};


	/**
	 * @param {Integer} other Integer to compare against.
	 * @return {boolean} Whether this Integer is greater than or equal to the other.
	 */
	Integer.prototype.greaterThanOrEqual = function(other) {
	  return this.compare(other) >= 0;
	};


	/**
	 * @param {Integer} other Integer to compare against.
	 * @return {boolean} Whether this Integer is less than the other.
	 */
	Integer.prototype.lessThan = function(other) {
	  return this.compare(other) < 0;
	};


	/**
	 * @param {Integer} other Integer to compare against.
	 * @return {boolean} Whether this Integer is less than or equal to the other.
	 */
	Integer.prototype.lessThanOrEqual = function(other) {
	  return this.compare(other) <= 0;
	};


	/**
	 * Compares this Integer with the given one.
	 * @param {Integer} other Integer to compare against.
	 * @return {number} 0 if they are the same, 1 if the this is greater, and -1
	 *     if the given one is greater.
	 */
	Integer.prototype.compare = function(other) {
	  var diff = this.subtract(other);
	  if (diff.isNegative()) {
	    return -1;
	  } else if (diff.isZero()) {
	    return 0;
	  } else {
	    return +1;
	  }
	};


	/**
	 * Returns an integer with only the first numBits bits of this value, sign
	 * extended from the final bit.
	 * @param {number} numBits The number of bits by which to shift.
	 * @return {!Integer} The shorted integer value.
	 */
	Integer.prototype.shorten = function(numBits) {
	  var arr_index = (numBits - 1) >> 5;
	  var bit_index = (numBits - 1) % 32;
	  var bits = [];
	  for (var i = 0; i < arr_index; i++) {
	    bits[i] = this.getBits(i);
	  }
	  var sigBits = bit_index == 31 ? 0xFFFFFFFF : (1 << (bit_index + 1)) - 1;
	  var val = this.getBits(arr_index) & sigBits;
	  //noinspection JSBitwiseOperatorUsage
	  if (val & (1 << bit_index)) {
	    val |= 0xFFFFFFFF - sigBits;
	    bits[arr_index] = val;
	    return new Integer(bits, -1);
	  } else {
	    bits[arr_index] = val;
	    return new Integer(bits, 0);
	  }
	};


	/** @return {!Integer} The negation of this value. */
	Integer.prototype.negate = function() {
	  return this.not().add(Integer.ONE);
	};


	/**
	 * Returns the sum of this and the given Integer.
	 * @param {Integer} other The Integer to add to this.
	 * @return {!Integer} The Integer result.
	 */
	Integer.prototype.add = function(other) {
	  var len = Math.max(this.bits_.length, other.bits_.length);
	  var arr = [];
	  var carry = 0;

	  for (var i = 0; i <= len; i++) {
	    var a1 = this.getBits(i) >>> 16;
	    var a0 = this.getBits(i) & 0xFFFF;

	    var b1 = other.getBits(i) >>> 16;
	    var b0 = other.getBits(i) & 0xFFFF;

	    var c0 = carry + a0 + b0;
	    var c1 = (c0 >>> 16) + a1 + b1;
	    carry = c1 >>> 16;
	    c0 &= 0xFFFF;
	    c1 &= 0xFFFF;
	    arr[i] = (c1 << 16) | c0;
	  }
	  return Integer.fromBits(arr);
	};


	/**
	 * Returns the difference of this and the given Integer.
	 * @param {Integer} other The Integer to subtract from this.
	 * @return {!Integer} The Integer result.
	 */
	Integer.prototype.subtract = function(other) {
	  return this.add(other.negate());
	};


	/**
	 * Returns the product of this and the given Integer.
	 * @param {Integer} other The Integer to multiply against this.
	 * @return {!Integer} The product of this and the other.
	 */
	Integer.prototype.multiply = function(other) {
	  if (this.isZero()) {
	    return Integer.ZERO;
	  } else if (other.isZero()) {
	    return Integer.ZERO;
	  }

	  if (this.isNegative()) {
	    if (other.isNegative()) {
	      return this.negate().multiply(other.negate());
	    } else {
	      return this.negate().multiply(other).negate();
	    }
	  } else if (other.isNegative()) {
	    return this.multiply(other.negate()).negate();
	  }

	  // If both numbers are small, use float multiplication
	  if (this.lessThan(Integer.TWO_PWR_24_) &&
	    other.lessThan(Integer.TWO_PWR_24_)) {
	    return Integer.fromNumber(this.toNumber() * other.toNumber());
	  }

	  // Fill in an array of 16-bit products.
	  var len = this.bits_.length + other.bits_.length;
	  var arr = [];
	  for (var i = 0; i < 2 * len; i++) {
	    arr[i] = 0;
	  }
	  for (var i = 0; i < this.bits_.length; i++) {
	    for (var j = 0; j < other.bits_.length; j++) {
	      var a1 = this.getBits(i) >>> 16;
	      var a0 = this.getBits(i) & 0xFFFF;

	      var b1 = other.getBits(j) >>> 16;
	      var b0 = other.getBits(j) & 0xFFFF;

	      arr[2 * i + 2 * j] += a0 * b0;
	      Integer.carry16_(arr, 2 * i + 2 * j);
	      arr[2 * i + 2 * j + 1] += a1 * b0;
	      Integer.carry16_(arr, 2 * i + 2 * j + 1);
	      arr[2 * i + 2 * j + 1] += a0 * b1;
	      Integer.carry16_(arr, 2 * i + 2 * j + 1);
	      arr[2 * i + 2 * j + 2] += a1 * b1;
	      Integer.carry16_(arr, 2 * i + 2 * j + 2);
	    }
	  }

	  // Combine the 16-bit values into 32-bit values.
	  for (var i = 0; i < len; i++) {
	    arr[i] = (arr[2 * i + 1] << 16) | arr[2 * i];
	  }
	  for (var i = len; i < 2 * len; i++) {
	    arr[i] = 0;
	  }
	  return new Integer(arr, 0);
	};


	/**
	 * Carries any overflow from the given index into later entries.
	 * @param {Array.<number>} bits Array of 16-bit values in little-endian order.
	 * @param {number} index The index in question.
	 * @private
	 */
	Integer.carry16_ = function(bits, index) {
	  while ((bits[index] & 0xFFFF) != bits[index]) {
	    bits[index + 1] += bits[index] >>> 16;
	    bits[index] &= 0xFFFF;
	  }
	};


	/**
	 * Returns this Integer divided by the given one.
	 * @param {Integer} other Th Integer to divide this by.
	 * @return {!Integer} This value divided by the given one.
	 */
	Integer.prototype.divide = function(other) {
	  if (other.isZero()) {
	    throw Error('division by zero');
	  } else if (this.isZero()) {
	    return Integer.ZERO;
	  }

	  if (this.isNegative()) {
	    if (other.isNegative()) {
	      return this.negate().divide(other.negate());
	    } else {
	      return this.negate().divide(other).negate();
	    }
	  } else if (other.isNegative()) {
	    return this.divide(other.negate()).negate();
	  }

	  // Repeat the following until the remainder is less than other:  find a
	  // floating-point that approximates remainder / other *from below*, add this
	  // into the result, and subtract it from the remainder.  It is critical that
	  // the approximate value is less than or equal to the real value so that the
	  // remainder never becomes negative.
	  var res = Integer.ZERO;
	  var rem = this;
	  while (rem.greaterThanOrEqual(other)) {
	    // Approximate the result of division. This may be a little greater or
	    // smaller than the actual value.
	    var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));

	    // We will tweak the approximate result by changing it in the 48-th digit or
	    // the smallest non-fractional digit, whichever is larger.
	    var log2 = Math.ceil(Math.log(approx) / Math.LN2);
	    var delta = (log2 <= 48) ? 1 : Math.pow(2, log2 - 48);

	    // Decrease the approximation until it is smaller than the remainder.  Note
	    // that if it is too large, the product overflows and is negative.
	    var approxRes = Integer.fromNumber(approx);
	    var approxRem = approxRes.multiply(other);
	    while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
	      approx -= delta;
	      approxRes = Integer.fromNumber(approx);
	      approxRem = approxRes.multiply(other);
	    }

	    // We know the answer can't be zero... and actually, zero would cause
	    // infinite recursion since we would make no progress.
	    if (approxRes.isZero()) {
	      approxRes = Integer.ONE;
	    }

	    res = res.add(approxRes);
	    rem = rem.subtract(approxRem);
	  }
	  return res;
	};


	/**
	 * Returns this Integer modulo the given one.
	 * @param {Integer} other The Integer by which to mod.
	 * @return {!Integer} This value modulo the given one.
	 */
	Integer.prototype.modulo = function(other) {
	  return this.subtract(this.divide(other).multiply(other));
	};


	/** @return {!Integer} The bitwise-NOT of this value. */
	Integer.prototype.not = function() {
	  var len = this.bits_.length;
	  var arr = [];
	  for (var i = 0; i < len; i++) {
	    arr[i] = ~this.bits_[i];
	  }
	  return new Integer(arr, ~this.sign_);
	};


	/**
	 * Returns the bitwise-AND of this Integer and the given one.
	 * @param {Integer} other The Integer to AND with this.
	 * @return {!Integer} The bitwise-AND of this and the other.
	 */
	Integer.prototype.and = function(other) {
	  var len = Math.max(this.bits_.length, other.bits_.length);
	  var arr = [];
	  for (var i = 0; i < len; i++) {
	    arr[i] = this.getBits(i) & other.getBits(i);
	  }
	  return new Integer(arr, this.sign_ & other.sign_);
	};


	/**
	 * Returns the bitwise-OR of this Integer and the given one.
	 * @param {Integer} other The Integer to OR with this.
	 * @return {!Integer} The bitwise-OR of this and the other.
	 */
	Integer.prototype.or = function(other) {
	  var len = Math.max(this.bits_.length, other.bits_.length);
	  var arr = [];
	  for (var i = 0; i < len; i++) {
	    arr[i] = this.getBits(i) | other.getBits(i);
	  }
	  return new Integer(arr, this.sign_ | other.sign_);
	};


	/**
	 * Returns the bitwise-XOR of this Integer and the given one.
	 * @param {Integer} other The Integer to XOR with this.
	 * @return {!Integer} The bitwise-XOR of this and the other.
	 */
	Integer.prototype.xor = function(other) {
	  var len = Math.max(this.bits_.length, other.bits_.length);
	  var arr = [];
	  for (var i = 0; i < len; i++) {
	    arr[i] = this.getBits(i) ^ other.getBits(i);
	  }
	  return new Integer(arr, this.sign_ ^ other.sign_);
	};


	/**
	 * Returns this value with bits shifted to the left by the given amount.
	 * @param {number} numBits The number of bits by which to shift.
	 * @return {!Integer} This shifted to the left by the given amount.
	 */
	Integer.prototype.shiftLeft = function(numBits) {
	  var arr_delta = numBits >> 5;
	  var bit_delta = numBits % 32;
	  var len = this.bits_.length + arr_delta + (bit_delta > 0 ? 1 : 0);
	  var arr = [];
	  for (var i = 0; i < len; i++) {
	    if (bit_delta > 0) {
	      arr[i] = (this.getBits(i - arr_delta) << bit_delta) |
	      (this.getBits(i - arr_delta - 1) >>> (32 - bit_delta));
	    } else {
	      arr[i] = this.getBits(i - arr_delta);
	    }
	  }
	  return new Integer(arr, this.sign_);
	};


	/**
	 * Returns this value with bits shifted to the right by the given amount.
	 * @param {number} numBits The number of bits by which to shift.
	 * @return {!Integer} This shifted to the right by the given amount.
	 */
	Integer.prototype.shiftRight = function(numBits) {
	  var arr_delta = numBits >> 5;
	  var bit_delta = numBits % 32;
	  var len = this.bits_.length - arr_delta;
	  var arr = [];
	  for (var i = 0; i < len; i++) {
	    if (bit_delta > 0) {
	      arr[i] = (this.getBits(i + arr_delta) >>> bit_delta) |
	      (this.getBits(i + arr_delta + 1) << (32 - bit_delta));
	    } else {
	      arr[i] = this.getBits(i + arr_delta);
	    }
	  }
	  return new Integer(arr, this.sign_);
	};

	/**
	 * Provide the name of the constructor and the string representation
	 * @returns {string}
	 */
	Integer.prototype.inspect = function () {
	  return this.constructor.name + ': ' + this.toString();
	};

	/**
	 * Returns a Integer whose value is the absolute value of this
	 * @returns {Integer}
	 */
	Integer.prototype.abs = function () {
	  return this.sign_ === 0 ? this : this.negate();
	};

	/**
	 * Returns the string representation.
	 * Method used by the native JSON.stringify() to serialize this instance.
	 */
	Integer.prototype.toJSON = function () {
	  return this.toString();
	};

	integer = Integer;
	return integer;
}

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var bigDecimal;
var hasRequiredBigDecimal;

function requireBigDecimal () {
	if (hasRequiredBigDecimal) return bigDecimal;
	hasRequiredBigDecimal = 1;
	const Integer = requireInteger();
	const utils = utils$K;

	/** @module types */
	/**
	 * Constructs an immutable arbitrary-precision signed decimal number.
	 * A <code>BigDecimal</code> consists of an [arbitrary precision integer]{@link module:types~Integer}
	 * <i>unscaled value</i> and a 32-bit integer <i>scale</i>.  If zero
	 * or positive, the scale is the number of digits to the right of the
	 * decimal point.  If negative, the unscaled value of the number is
	 * multiplied by ten to the power of the negation of the scale.  The
	 * value of the number represented by the <code>BigDecimal</code> is
	 * therefore <tt>(unscaledValue &times; 10<sup>-scale</sup>)</tt>.
	 * @class
	 * @classdesc The <code>BigDecimal</code> class provides operations for
	 * arithmetic, scale manipulation, rounding, comparison and
	 * format conversion.  The {@link #toString} method provides a
	 * canonical representation of a <code>BigDecimal</code>.
	 * @param {Integer|Number} unscaledValue The integer part of the decimal.
	 * @param {Number} scale The scale of the decimal.
	 * @constructor
	 */
	function BigDecimal(unscaledValue, scale) {
	  if (typeof unscaledValue === 'number') {
	    unscaledValue = Integer.fromNumber(unscaledValue);
	  }
	  /**
	   * @type {Integer}
	   * @private
	   */
	  this._intVal = unscaledValue;
	  /**
	   * @type {Number}
	   * @private
	   */
	  this._scale = scale;
	}

	/**
	 * Returns the BigDecimal representation of a buffer composed of the scale (int32BE) and the unsigned value (varint BE)
	 * @param {Buffer} buf
	 * @returns {BigDecimal}
	 */
	BigDecimal.fromBuffer = function (buf) {
	  const scale = buf.readInt32BE(0);
	  const unscaledValue = Integer.fromBuffer(buf.slice(4));
	  return new BigDecimal(unscaledValue, scale);
	};

	/**
	 * Returns a buffer representation composed of the scale as a BE int 32 and the unsigned value as a BE varint
	 * @param {BigDecimal} value
	 * @returns {Buffer}
	 */
	BigDecimal.toBuffer = function (value) {
	  const unscaledValueBuffer = Integer.toBuffer(value._intVal);
	  const scaleBuffer = utils.allocBufferUnsafe(4);
	  scaleBuffer.writeInt32BE(value._scale, 0);
	  return Buffer.concat([scaleBuffer, unscaledValueBuffer], scaleBuffer.length + unscaledValueBuffer.length);
	};

	/**
	 * Returns a BigDecimal representation of the string
	 * @param {String} value
	 * @returns {BigDecimal}
	 */
	BigDecimal.fromString = function (value) {
	  if (!value) {
	    throw new TypeError('Invalid null or undefined value');
	  }
	  value = value.trim();
	  const scaleIndex = value.indexOf('.');
	  let scale = 0;
	  if (scaleIndex >= 0) {
	    scale = value.length - 1 - scaleIndex;
	    value = value.substr(0, scaleIndex) + value.substr(scaleIndex + 1);
	  }
	  return new BigDecimal(Integer.fromString(value), scale);
	};

	/**
	 * Returns a BigDecimal representation of the Number
	 * @param {Number} value
	 * @returns {BigDecimal}
	 */
	BigDecimal.fromNumber = function (value) {
	  if (isNaN(value)) {
	    return new BigDecimal(Integer.ZERO, 0);
	  }
	  let textValue = value.toString();
	  if (textValue.indexOf('e') >= 0) {
	    //get until scale 20
	    textValue = value.toFixed(20);
	  }
	  return BigDecimal.fromString(textValue);
	};

	/**
	 * Returns true if the value of the BigDecimal instance and other are the same
	 * @param {BigDecimal} other
	 * @returns {Boolean}
	 */
	BigDecimal.prototype.equals = function (other) {
	  return ((other instanceof BigDecimal) && this.compare(other) === 0);
	};

	BigDecimal.prototype.inspect = function () {
	  return this.constructor.name + ': ' + this.toString();
	};

	/**
	 * @param {BigDecimal} other
	 * @returns {boolean}
	 */
	BigDecimal.prototype.notEquals = function (other) {
	  return !this.equals(other);
	};

	/**
	 * Compares this BigDecimal with the given one.
	 * @param {BigDecimal} other Integer to compare against.
	 * @return {number} 0 if they are the same, 1 if the this is greater, and -1
	 *     if the given one is greater.
	 */
	BigDecimal.prototype.compare = function (other) {
	  const diff = this.subtract(other);
	  if (diff.isNegative()) {
	    return -1;
	  }
	  if (diff.isZero()) {
	    return 0;
	  }
	  return +1;
	};

	/**
	 * Returns the difference of this and the given BigDecimal.
	 * @param {BigDecimal} other The BigDecimal to subtract from this.
	 * @return {!BigDecimal} The BigDecimal result.
	 */
	BigDecimal.prototype.subtract = function (other) {
	  const first = this;
	  if (first._scale === other._scale) {
	    return new BigDecimal(first._intVal.subtract(other._intVal), first._scale);
	  }
	  let diffScale;
	  let unscaledValue;
	  if (first._scale < other._scale) {
	    //The scale of this is lower
	    diffScale = other._scale - first._scale;
	    //multiple this unScaledValue to compare in the same scale
	    unscaledValue = first._intVal
	      .multiply(Integer.fromNumber(Math.pow(10, diffScale)))
	      .subtract(other._intVal);
	    return new BigDecimal(unscaledValue, other._scale);
	  }
	  //The scale of this is higher
	  diffScale = first._scale - other._scale;
	  //multiple this unScaledValue to compare in the same scale
	  unscaledValue = first._intVal
	    .subtract(
	      other._intVal.multiply(Integer.fromNumber(Math.pow(10, diffScale))));
	  return new BigDecimal(unscaledValue, first._scale);
	};

	/**
	 * Returns the sum of this and the given <code>BigDecimal</code>.
	 * @param {BigDecimal} other The BigDecimal to sum to this.
	 * @return {!BigDecimal} The BigDecimal result.
	 */
	BigDecimal.prototype.add = function (other) {
	  const first = this;
	  if (first._scale === other._scale) {
	    return new BigDecimal(first._intVal.add(other._intVal), first._scale);
	  }
	  let diffScale;
	  let unscaledValue;
	  if (first._scale < other._scale) {
	    //The scale of this is lower
	    diffScale = other._scale - first._scale;
	    //multiple this unScaledValue to compare in the same scale
	    unscaledValue = first._intVal
	      .multiply(Integer.fromNumber(Math.pow(10, diffScale)))
	      .add(other._intVal);
	    return new BigDecimal(unscaledValue, other._scale);
	  }
	  //The scale of this is higher
	  diffScale = first._scale - other._scale;
	  //multiple this unScaledValue to compare in the same scale
	  unscaledValue = first._intVal
	    .add(
	      other._intVal.multiply(Integer.fromNumber(Math.pow(10, diffScale))));
	  return new BigDecimal(unscaledValue, first._scale);
	};

	/**
	 * Returns true if the current instance is greater than the other
	 * @param {BigDecimal} other
	 * @returns {boolean}
	 */
	BigDecimal.prototype.greaterThan = function (other) {
	  return this.compare(other) === 1;
	};

	/** @return {boolean} Whether this value is negative. */
	BigDecimal.prototype.isNegative = function () {
	  return this._intVal.isNegative();
	};

	/** @return {boolean} Whether this value is zero. */
	BigDecimal.prototype.isZero = function () {
	  return this._intVal.isZero();
	};

	/**
	 * Returns the string representation of this <code>BigDecimal</code>
	 * @returns {string}
	 */
	BigDecimal.prototype.toString = function () {
	  let intString = this._intVal.toString();
	  if (this._scale === 0) {
	    return intString;
	  }
	  let signSymbol = '';
	  if (intString.charAt(0) === '-') {
	    signSymbol = '-';
	    intString = intString.substr(1);
	  }
	  let separatorIndex = intString.length - this._scale;
	  if (separatorIndex <= 0) {
	    //add zeros at the beginning, plus an additional zero
	    intString = utils.stringRepeat('0', (-separatorIndex) + 1) + intString;
	    separatorIndex = intString.length - this._scale;
	  }
	  return signSymbol + intString.substr(0, separatorIndex) + '.' + intString.substr(separatorIndex);
	};

	/**
	 * Returns a Number representation of this <code>BigDecimal</code>.
	 * @returns {Number}
	 */
	BigDecimal.prototype.toNumber = function () {
	  return parseFloat(this.toString());
	};

	/**
	 * Returns the string representation.
	 * Method used by the native JSON.stringify() to serialize this instance.
	 */
	BigDecimal.prototype.toJSON = function () {
	  return this.toString();
	};


	bigDecimal = BigDecimal;
	return bigDecimal;
}

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var duration;
var hasRequiredDuration;

function requireDuration () {
	if (hasRequiredDuration) return duration;
	hasRequiredDuration = 1;
	const Long = LongExports;
	const util = require$$0$4;
	const utils = utils$K;

	/** @module types */

	// Reuse the same buffers that should perform slightly better than built-in buffer pool
	const reusableBuffers = {
	  months: utils.allocBuffer(9),
	  days: utils.allocBuffer(9),
	  nanoseconds: utils.allocBuffer(9)
	};

	const maxInt32 = 0x7FFFFFFF;
	const longOneThousand = Long.fromInt(1000);
	const nanosPerMicro = longOneThousand;
	const nanosPerMilli = longOneThousand.multiply(nanosPerMicro);
	const nanosPerSecond = longOneThousand.multiply(nanosPerMilli);
	const nanosPerMinute = Long.fromInt(60).multiply(nanosPerSecond);
	const nanosPerHour = Long.fromInt(60).multiply(nanosPerMinute);
	const daysPerWeek = 7;
	const monthsPerYear = 12;
	const standardRegex = /(\d+)(y|mo|w|d|h|s|ms|us|s|ns|m)/gi;
	const iso8601Regex = /P((\d+)Y)?((\d+)M)?((\d+)D)?(T((\d+)H)?((\d+)M)?((\d+)S)?)?/;
	const iso8601WeekRegex = /P(\d+)W/;
	const iso8601AlternateRegex = /P(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})/;

	/**
	 * Creates a new instance of {@link Duration}.
	 * @classdesc
	 * Represents a duration. A duration stores separately months, days, and seconds due to the fact that the number of
	 * days in a month varies, and a day can have 23 or 25 hours if a daylight saving is involved.
	 * @param {Number} months The number of months.
	 * @param {Number} days The number of days.
	 * @param {Number|Long} nanoseconds The number of nanoseconds.
	 * @constructor
	 */
	function Duration(months, days, nanoseconds) {
	  /**
	   * Gets the number of months.
	   * @type {Number}
	   */
	  this.months = months;
	  /**
	   * Gets the number of days.
	   * @type {Number}
	   */
	  this.days = days;
	  /**
	   * Gets the number of nanoseconds represented as a <code>int64</code>.
	   * @type {Long}
	   */
	  this.nanoseconds = typeof nanoseconds === 'number' ? Long.fromNumber(nanoseconds) : nanoseconds;
	}

	Duration.prototype.equals = function (other) {
	  if (!(other instanceof Duration)) {
	    return false;
	  }
	  return this.months === other.months &&
	    this.days === other.days &&
	    this.nanoseconds.equals(other.nanoseconds);
	};

	/**
	 * Serializes the duration and returns the representation of the value in bytes.
	 * @returns {Buffer}
	 */
	Duration.prototype.toBuffer = function () {
	  const lengthMonths = VIntCoding.writeVInt(Long.fromNumber(this.months), reusableBuffers.months);
	  const lengthDays = VIntCoding.writeVInt(Long.fromNumber(this.days), reusableBuffers.days);
	  const lengthNanoseconds = VIntCoding.writeVInt(this.nanoseconds, reusableBuffers.nanoseconds);
	  const buffer = utils.allocBufferUnsafe(lengthMonths + lengthDays + lengthNanoseconds);
	  reusableBuffers.months.copy(buffer, 0, 0, lengthMonths);
	  let offset = lengthMonths;
	  reusableBuffers.days.copy(buffer, offset, 0, lengthDays);
	  offset += lengthDays;
	  reusableBuffers.nanoseconds.copy(buffer, offset, 0, lengthNanoseconds);
	  return buffer;
	};

	/**
	 * Returns the string representation of the value.
	 * @return {string}
	 */
	Duration.prototype.toString = function () {
	  let value = '';
	  function append(dividend, divisor, unit) {
	    if (dividend === 0 || dividend < divisor) {
	      return dividend;
	    }
	    // string concatenation is supposed to be fasted than join()
	    value += (dividend / divisor).toFixed(0) + unit;
	    return dividend % divisor;
	  }
	  function append64(dividend, divisor, unit) {
	    if (dividend.equals(Long.ZERO) || dividend.lessThan(divisor)) {
	      return dividend;
	    }
	    // string concatenation is supposed to be fasted than join()
	    value += dividend.divide(divisor).toString() + unit;
	    return dividend.modulo(divisor);
	  }
	  if (this.months < 0 || this.days < 0 || this.nanoseconds.isNegative()) {
	    value = '-';
	  }
	  let remainder = append(Math.abs(this.months), monthsPerYear, "y");
	  append(remainder, 1, "mo");
	  append(Math.abs(this.days), 1, "d");

	  if (!this.nanoseconds.equals(Long.ZERO)) {
	    const nanos = this.nanoseconds.isNegative() ? this.nanoseconds.negate() : this.nanoseconds;
	    remainder = append64(nanos, nanosPerHour, "h");
	    remainder = append64(remainder, nanosPerMinute, "m");
	    remainder = append64(remainder, nanosPerSecond, "s");
	    remainder = append64(remainder, nanosPerMilli, "ms");
	    remainder = append64(remainder, nanosPerMicro, "us");
	    append64(remainder, Long.ONE, "ns");
	  }
	  return value;
	};

	/**
	 * Creates a new {@link Duration} instance from the binary representation of the value.
	 * @param {Buffer} buffer
	 * @returns {Duration}
	 */
	Duration.fromBuffer = function (buffer) {
	  const offset = { value: 0 };
	  const months = VIntCoding.readVInt(buffer, offset).toNumber();
	  const days = VIntCoding.readVInt(buffer, offset).toNumber();
	  const nanoseconds = VIntCoding.readVInt(buffer, offset);
	  return new Duration(months, days, nanoseconds);
	};

	/**
	 * Creates a new {@link Duration} instance from the string representation of the value.
	 * <p>
	 *   Accepted formats:
	 * </p>
	 * <ul>
	 * <li>multiple digits followed by a time unit like: 12h30m where the time unit can be:
	 *   <ul>
	 *     <li>{@code y}: years</li>
	 *     <li>{@code m}: months</li>
	 *     <li>{@code w}: weeks</li>
	 *     <li>{@code d}: days</li>
	 *     <li>{@code h}: hours</li>
	 *     <li>{@code m}: minutes</li>
	 *     <li>{@code s}: seconds</li>
	 *     <li>{@code ms}: milliseconds</li>
	 *     <li>{@code us} or {@code s}: microseconds</li>
	 *     <li>{@code ns}: nanoseconds</li>
	 *   </ul>
	 * </li>
	 * <li>ISO 8601 format:  <code>P[n]Y[n]M[n]DT[n]H[n]M[n]S or P[n]W</code></li>
	 * <li>ISO 8601 alternative format: <code>P[YYYY]-[MM]-[DD]T[hh]:[mm]:[ss]</code></li>
	 * </ul>
	 * @param {String} input
	 * @returns {Duration}
	 */
	Duration.fromString = function (input) {
	  const isNegative = input.charAt(0) === '-';
	  const source = isNegative ? input.substr(1) : input;
	  if (source.charAt(0) === 'P') {
	    if (source.charAt(source.length - 1) === 'W') {
	      return parseIso8601WeekFormat(isNegative, source);
	    }
	    if (source.indexOf('-') > 0) {
	      return parseIso8601AlternativeFormat(isNegative, source);
	    }
	    return parseIso8601Format(isNegative, source);
	  }
	  return parseStandardFormat(isNegative, source);
	};

	/**
	 * @param {Boolean} isNegative
	 * @param {String} source
	 * @returns {Duration}
	 * @private
	 */
	function parseStandardFormat(isNegative, source) {
	  const builder = new Builder(isNegative);
	  standardRegex.lastIndex = 0;
	  let matches;
	  while ((matches = standardRegex.exec(source)) && matches.length <= 3) {
	    builder.add(matches[1], matches[2]);
	  }
	  return builder.build();
	}

	/**
	 * @param {Boolean} isNegative
	 * @param {String} source
	 * @returns {Duration}
	 * @private
	 */
	function parseIso8601Format(isNegative, source) {
	  const matches = iso8601Regex.exec(source);
	  if (!matches || matches[0] !== source) {
	    throw new TypeError(util.format("Unable to convert '%s' to a duration", source));
	  }
	  const builder = new Builder(isNegative);
	  if (matches[1]) {
	    builder.addYears(matches[2]);
	  }
	  if (matches[3]) {
	    builder.addMonths(matches[4]);
	  }
	  if (matches[5]) {
	    builder.addDays(matches[6]);
	  }
	  if (matches[7]) {
	    if (matches[8]) {
	      builder.addHours(matches[9]);
	    }
	    if (matches[10]) {
	      builder.addMinutes(matches[11]);
	    }
	    if (matches[12]) {
	      builder.addSeconds(matches[13]);
	    }
	  }
	  return builder.build();
	}

	/**
	 * @param {Boolean} isNegative
	 * @param {String} source
	 * @returns {Duration}
	 * @private
	 */
	function parseIso8601WeekFormat(isNegative, source) {
	  const matches = iso8601WeekRegex.exec(source);
	  if (!matches || matches[0] !== source) {
	    throw new TypeError(util.format("Unable to convert '%s' to a duration", source));
	  }
	  return new Builder(isNegative)
	    .addWeeks(matches[1])
	    .build();
	}

	/**
	 * @param {Boolean} isNegative
	 * @param {String} source
	 * @returns {Duration}
	 * @private
	 */
	function parseIso8601AlternativeFormat(isNegative, source) {
	  const matches = iso8601AlternateRegex.exec(source);
	  if (!matches || matches[0] !== source) {
	    throw new TypeError(util.format("Unable to convert '%s' to a duration", source));
	  }
	  return new Builder(isNegative).addYears(matches[1])
	    .addMonths(matches[2])
	    .addDays(matches[3])
	    .addHours(matches[4])
	    .addMinutes(matches[5])
	    .addSeconds(matches[6])
	    .build();
	}

	/**
	 * @param {Boolean} isNegative
	 * @private
	 * @constructor
	 */
	function Builder(isNegative) {
	  this._isNegative = isNegative;
	  this._unitIndex = 0;
	  this._months = 0;
	  this._days = 0;
	  this._nanoseconds = Long.ZERO;
	  this._addMethods = {
	    'y': this.addYears,
	    'mo': this.addMonths,
	    'w': this.addWeeks,
	    'd': this.addDays,
	    'h': this.addHours,
	    'm': this.addMinutes,
	    's': this.addSeconds,
	    'ms': this.addMillis,
	    // s
	    '\u00B5s': this.addMicros,
	    'us': this.addMicros,
	    'ns': this.addNanos
	  };
	  this._unitByIndex = [
	    null, 'years', 'months', 'weeks', 'days', 'hours', 'minutes', 'seconds', 'milliseconds', 'microseconds',
	    'nanoseconds'
	  ];
	}

	Builder.prototype._validateOrder = function (unitIndex) {
	  if (unitIndex === this._unitIndex) {
	    throw new TypeError(util.format("Invalid duration. The %s are specified multiple times", this._getUnitName(unitIndex)));
	  }

	  if (unitIndex <= this._unitIndex) {
	    throw new TypeError(util.format("Invalid duration. The %s should be after %s",
	      this._getUnitName(this._unitIndex),
	      this._getUnitName(unitIndex)));
	  }
	  this._unitIndex = unitIndex;
	};

	/**
	 * @param {Number} units
	 * @param {Number} monthsPerUnit
	 */
	Builder.prototype._validateMonths = function(units, monthsPerUnit) {
	  this._validate32(units, (maxInt32 - this._months) / monthsPerUnit, "months");
	};

	/**
	 * @param {Number} units
	 * @param {Number} daysPerUnit
	 */
	Builder.prototype._validateDays = function(units, daysPerUnit) {
	  this._validate32(units, (maxInt32 - this._days) / daysPerUnit, "days");
	};

	/**
	 * @param {Long} units
	 * @param {Long} nanosPerUnit
	 */
	Builder.prototype._validateNanos = function(units, nanosPerUnit) {
	  this._validate64(units, Long.MAX_VALUE.subtract(this._nanoseconds).divide(nanosPerUnit), "nanoseconds");
	};

	/**
	 * @param {Number} units
	 * @param {Number} limit
	 * @param {String} unitName
	 */
	Builder.prototype._validate32 = function(units, limit, unitName) {
	  if (units > limit) {
	    throw new TypeError(util.format('Invalid duration. The total number of %s must be less or equal to %s',
	      unitName,
	      maxInt32));
	  }
	};

	/**
	 * @param {Long} units
	 * @param {Long} limit
	 * @param {String} unitName
	 */
	Builder.prototype._validate64 = function(units, limit, unitName) {
	  if (units.greaterThan(limit)) {
	    throw new TypeError(util.format('Invalid duration. The total number of %s must be less or equal to %s',
	      unitName,
	      Long.MAX_VALUE.toString()));
	  }
	};

	Builder.prototype._getUnitName = function(unitIndex) {
	  const name = this._unitByIndex[+unitIndex];
	  if (!name) {
	    throw new Error('unknown unit index: ' + unitIndex);
	  }
	  return name;
	};

	Builder.prototype.add = function (textValue, symbol) {
	  const addMethod = this._addMethods[symbol.toLowerCase()];
	  if (!addMethod) {
	    throw new TypeError(util.format("Unknown duration symbol '%s'", symbol));
	  }
	  return addMethod.call(this, textValue);
	};

	/**
	 * @param {String|Number} years
	 * @return {Builder}
	 */
	Builder.prototype.addYears = function (years) {
	  const value = +years;
	  this._validateOrder(1);
	  this._validateMonths(value, monthsPerYear);
	  this._months += value * monthsPerYear;
	  return this;
	};

	/**
	 * @param {String|Number} months
	 * @return {Builder}
	 */
	Builder.prototype.addMonths = function(months) {
	  const value = +months;
	  this._validateOrder(2);
	  this._validateMonths(value, 1);
	  this._months += value;
	  return this;
	};

	/**
	 * @param {String|Number} weeks
	 * @return {Builder}
	 */
	Builder.prototype.addWeeks = function(weeks) {
	  const value = +weeks;
	  this._validateOrder(3);
	  this._validateDays(value, daysPerWeek);
	  this._days += value * daysPerWeek;
	  return this;
	};

	/**
	 * @param {String|Number} days
	 * @return {Builder}
	 */
	Builder.prototype.addDays = function(days) {
	  const value = +days;
	  this._validateOrder(4);
	  this._validateDays(value, 1);
	  this._days += value;
	  return this;
	};

	/**
	 * @param {String|Long} hours
	 * @return {Builder}
	 */
	Builder.prototype.addHours = function(hours) {
	  const value = typeof hours === 'string' ? Long.fromString(hours) : hours;
	  this._validateOrder(5);
	  this._validateNanos(value, nanosPerHour);
	  this._nanoseconds = this._nanoseconds.add(value.multiply(nanosPerHour));
	  return this;
	};

	/**
	 * @param {String|Long} minutes
	 * @return {Builder}
	 */
	Builder.prototype.addMinutes = function(minutes) {
	  const value = typeof minutes === 'string' ? Long.fromString(minutes) : minutes;
	  this._validateOrder(6);
	  this._validateNanos(value, nanosPerMinute);
	  this._nanoseconds = this._nanoseconds.add(value.multiply(nanosPerMinute));
	  return this;
	};

	/**
	 * @param {String|Long} seconds
	 * @return {Builder}
	 */
	Builder.prototype.addSeconds = function(seconds) {
	  const value = typeof seconds === 'string' ? Long.fromString(seconds) : seconds;
	  this._validateOrder(7);
	  this._validateNanos(value, nanosPerSecond);
	  this._nanoseconds = this._nanoseconds.add(value.multiply(nanosPerSecond));
	  return this;
	};

	/**
	 * @param {String|Long} millis
	 * @return {Builder}
	 */
	Builder.prototype.addMillis = function(millis) {
	  const value = typeof millis === 'string' ? Long.fromString(millis) : millis;
	  this._validateOrder(8);
	  this._validateNanos(value, nanosPerMilli);
	  this._nanoseconds = this._nanoseconds.add(value.multiply(nanosPerMilli));
	  return this;
	};

	/**
	 * @param {String|Long} micros
	 * @return {Builder}
	 */
	Builder.prototype.addMicros = function(micros) {
	  const value = typeof micros === 'string' ? Long.fromString(micros) : micros;
	  this._validateOrder(9);
	  this._validateNanos(value, nanosPerMicro);
	  this._nanoseconds = this._nanoseconds.add(value.multiply(nanosPerMicro));
	  return this;
	};

	/**
	 * @param {String|Long} nanos
	 * @return {Builder}
	 */
	Builder.prototype.addNanos = function(nanos) {
	  const value = typeof nanos === 'string' ? Long.fromString(nanos) : nanos;
	  this._validateOrder(10);
	  this._validateNanos(value, Long.ONE);
	  this._nanoseconds = this._nanoseconds.add(value);
	  return this;
	};

	/** @return {Duration} */
	Builder.prototype.build = function () {
	  return (this._isNegative ?
	    new Duration(-this._months, -this._days, this._nanoseconds.negate()) :
	    new Duration(this._months, this._days, this._nanoseconds));
	};

	/**
	 * Contains the methods for reading and writing vints into binary format.
	 * Exposes only 2 internal methods, the rest are hidden.
	 * @private
	 */
	const VIntCoding = (function () {
	  /** @param {Long} n */
	  function encodeZigZag64(n) {
	    //     (n << 1) ^ (n >> 63);
	    return n.toUnsigned().shiftLeft(1).xor(n.shiftRight(63));
	  }

	  /** @param {Long} n */
	  function decodeZigZag64(n) {
	    //     (n >>> 1) ^ -(n & 1);
	    return n.shiftRightUnsigned(1).xor(n.and(Long.ONE).negate());
	  }

	  /**
	   * @param {Long} value
	   * @param {Buffer} buffer
	   * @returns {Number}
	   */
	  function writeVInt(value, buffer) {
	    return writeUnsignedVInt(encodeZigZag64(value), buffer);
	  }

	  /**
	   * @param {Long} value
	   * @param {Buffer} buffer
	   * @returns {number}
	   */
	  function writeUnsignedVInt(value, buffer) {
	    const size = computeUnsignedVIntSize(value);
	    if (size === 1) {
	      buffer[0] = value.getLowBits();
	      return 1;
	    }
	    encodeVInt(value, size, buffer);
	    return size;
	  }

	  /**
	   * @param {Long} value
	   * @returns {number}
	   */
	  function computeUnsignedVIntSize(value) {
	    const magnitude = numberOfLeadingZeros(value.or(Long.ONE));
	    return (639 - magnitude * 9) >> 6;
	  }

	  /**
	   * @param {Long} value
	   * @param {Number} size
	   * @param {Buffer} buffer
	   */
	  function encodeVInt(value, size, buffer) {
	    const extraBytes = size - 1;
	    let intValue = value.getLowBits();
	    let i;
	    let intBytes = 4;
	    for (i = extraBytes; i >= 0 && (intBytes--) > 0; i--) {
	      buffer[i] = 0xFF & intValue;
	      intValue >>= 8;
	    }
	    intValue = value.getHighBits();
	    for (; i >= 0; i--) {
	      buffer[i] = 0xFF & intValue;
	      intValue >>= 8;
	    }
	    buffer[0] |= encodeExtraBytesToRead(extraBytes);
	  }
	  /**
	   * Returns the number of zero bits preceding the highest-order one-bit in the binary representation of the value.
	   * @param {Long} value
	   * @returns {Number}
	   */
	  function numberOfLeadingZeros(value) {
	    if (value.equals(Long.ZERO)) {
	      return 64;
	    }
	    let n = 1;
	    let x = value.getHighBits();
	    if (x === 0) {
	      n += 32;
	      x = value.getLowBits();
	    }
	    if (x >>> 16 === 0) {
	      n += 16;
	      x <<= 16;
	    }
	    if (x >>> 24 === 0) {
	      n += 8;
	      x <<= 8;
	    }
	    if (x >>> 28 === 0) {
	      n += 4;
	      x <<= 4;
	    }
	    if (x >>> 30 === 0) {
	      n += 2;
	      x <<= 2;
	    }
	    n -= x >>> 31;
	    return n;
	  }


	  function encodeExtraBytesToRead(extraBytesToRead) {
	    return ~(0xff >> extraBytesToRead);
	  }

	  /**
	   * @param {Buffer} buffer
	   * @param {{value: number}} offset
	   * @returns {Long}
	   */
	  function readVInt(buffer, offset) {
	    return decodeZigZag64(readUnsignedVInt(buffer, offset));
	  }

	  /**
	   * @param {Buffer} input
	   * @param {{ value: number}} offset
	   * @returns {Long}
	   */
	  function readUnsignedVInt(input, offset) {
	    const firstByte = input[offset.value++];
	    if ((firstByte & 0x80) === 0) {
	      return Long.fromInt(firstByte);
	    }
	    const sByteInt = fromSignedByteToInt(firstByte);
	    const size = numberOfExtraBytesToRead(sByteInt);
	    let result = Long.fromInt(sByteInt & firstByteValueMask(size));
	    for (let ii = 0; ii < size; ii++) {
	      const b = Long.fromInt(input[offset.value++]);
	      //       (result << 8) | b
	      result = result.shiftLeft(8).or(b);
	    }
	    return result;
	  }

	  function fromSignedByteToInt(value) {
	    if (value > 0x7f) {
	      return value - 0x0100;
	    }
	    return value;
	  }

	  function numberOfLeadingZerosInt32(i) {
	    if (i === 0) {
	      return 32;
	    }
	    let n = 1;
	    if (i >>> 16 === 0) {
	      n += 16;
	      i <<= 16;
	    }
	    if (i >>> 24 === 0) {
	      n += 8;
	      i <<= 8;
	    }
	    if (i >>> 28 === 0) {
	      n += 4;
	      i <<= 4;
	    }
	    if (i >>> 30 === 0) {
	      n += 2;
	      i <<= 2;
	    }
	    n -= i >>> 31;
	    return n;
	  }

	  /**
	   * @param {Number} firstByte
	   * @returns {Number}
	   */
	  function numberOfExtraBytesToRead(firstByte) {
	    // Instead of counting 1s of the byte, we negate and count 0 of the byte
	    return numberOfLeadingZerosInt32(~firstByte) - 24;
	  }

	  /**
	   * @param {Number} extraBytesToRead
	   * @returns {Number}
	   */
	  function firstByteValueMask(extraBytesToRead) {
	    return 0xff >> extraBytesToRead;
	  }

	  return {
	    readVInt: readVInt,
	    writeVInt: writeVInt
	  };
	})();

	duration = Duration;
	return duration;
}

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var inetAddress;
var hasRequiredInetAddress;

function requireInetAddress () {
	if (hasRequiredInetAddress) return inetAddress;
	hasRequiredInetAddress = 1;

	const utils = utils$K;

	/** @module types */
	/**
	 * Creates a new instance of InetAddress
	 * @class
	 * @classdesc Represents an v4 or v6 Internet Protocol (IP) address.
	 * @param {Buffer} buffer
	 * @constructor
	 */
	function InetAddress(buffer) {
	  if (!(buffer instanceof Buffer) || (buffer.length !== 4 && buffer.length !== 16)) {
	    throw new TypeError('The ip address must contain 4 or 16 bytes');
	  }

	  /**
	   * Immutable buffer that represents the IP address 
	   * @type Array
	   */
	  this.buffer = buffer;

	  /**
	   * Returns the length of the underlying buffer
	   * @type Number
	   */
	  this.length = buffer.length;

	  /**
	   * Returns the Ip version (4 or 6)
	   * @type Number
	   */
	  this.version = buffer.length === 4 ? 4 : 6;
	}

	/**
	 * Parses the string representation and returns an Ip address
	 * @param {String} value
	 */
	InetAddress.fromString = function (value) {
	  if (!value) {
	    return new InetAddress(utils.allocBufferFromArray([0, 0, 0, 0]));
	  }
	  const ipv4Pattern = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
	  const ipv6Pattern = /^[\da-f:.]+$/i;
	  let parts;
	  if (ipv4Pattern.test(value)) {
	    parts = value.split('.');
	    return new InetAddress(utils.allocBufferFromArray(parts));
	  }
	  if (!ipv6Pattern.test(value)) {
	    throw new TypeError('Value could not be parsed as InetAddress: ' + value);
	  }
	  parts = value.split(':');
	  if (parts.length < 3) {
	    throw new TypeError('Value could not be parsed as InetAddress: ' + value);
	  }
	  const buffer = utils.allocBufferUnsafe(16);
	  let filling = 8 - parts.length + 1;
	  let applied = false;
	  let offset = 0;
	  const embeddedIp4 = ipv4Pattern.test(parts[parts.length - 1]);
	  if (embeddedIp4) {
	    // Its IPv6 address with an embedded IPv4 address:
	    // subtract 1 from the potential empty filling as ip4 contains 4 bytes instead of 2 of a ipv6 section
	    filling -= 1;
	  }
	  function writeItem(uIntValue) {
	    buffer.writeUInt8(+uIntValue, offset++);
	  }
	  for (let i = 0; i < parts.length; i++) {
	    const item = parts[i];
	    if (item) {
	      if (embeddedIp4 && i === parts.length - 1) {
	        item.split('.').forEach(writeItem);
	        break;
	      }
	      buffer.writeUInt16BE(parseInt(item, 16), offset);
	      offset = offset + 2;
	      continue;
	    }
	    //its an empty string
	    if (applied) {
	      //there could be 2 occurrences of empty string
	      filling = 1;
	    }
	    applied = true;
	    for (let j = 0; j < filling; j++) {
	      buffer[offset++] = 0;
	      buffer[offset++] = 0;
	    }
	  }
	  if (embeddedIp4 && !isValidIPv4Mapped(buffer)) {
	    throw new TypeError('Only IPv4-Mapped IPv6 addresses are allowed as IPv6 address with embedded IPv4 address');
	  }
	  return new InetAddress(buffer);
	};

	/**
	 * Compares 2 addresses and returns true if the underlying bytes are the same
	 * @param {InetAddress} other
	 * @returns {Boolean}
	 */
	InetAddress.prototype.equals = function (other) {
	  if (!(other instanceof InetAddress)) {
	    return false;
	  }
	  return (this.buffer.length === other.buffer.length &&
	    this.buffer.toString('hex') === other.buffer.toString('hex'));
	};

	/**
	 * Returns the underlying buffer
	 * @returns {Buffer}
	 */
	InetAddress.prototype.getBuffer = function () {
	  return this.buffer;
	};

	/**
	 * Provide the name of the constructor and the string representation
	 * @returns {string}
	 */
	InetAddress.prototype.inspect = function () {
	  return this.constructor.name + ': ' + this.toString();
	};

	/**
	 * Returns the string representation of the IP address.
	 * <p>For v4 IP addresses, a string in the form of d.d.d.d is returned.</p>
	 * <p>
	 *   For v6 IP addresses, a string in the form of x:x:x:x:x:x:x:x is returned, where the 'x's are the hexadecimal
	 *   values of the eight 16-bit pieces of the address, according to rfc5952.
	 *   In cases where there is more than one field of only zeros, it can be shortened. For example, 2001:0db8:0:0:0:1:0:1
	 *   will be expressed as 2001:0db8::1:0:1.
	 * </p>
	 * @param {String} [encoding]
	 * @returns {String}
	 */
	InetAddress.prototype.toString = function (encoding) {
	  if (encoding === 'hex') {
	    //backward compatibility: behave in the same way as the buffer
	    return this.buffer.toString('hex');
	  }
	  if (this.buffer.length === 4) {
	    return (
	      this.buffer[0] + '.' +
	      this.buffer[1] + '.' +
	      this.buffer[2] + '.' +
	      this.buffer[3]
	    );
	  }
	  let start = -1;
	  const longest = { length: 0, start: -1};
	  function checkLongest (i) {
	    if (start >= 0) {
	      //close the group
	      const length = i - start;
	      if (length > longest.length) {
	        longest.length = length;
	        longest.start = start;
	        start = -1;
	      }
	    }
	  }
	  //get the longest 16-bit group of zeros
	  for (let i = 0; i < this.buffer.length; i = i + 2) {
	    if (this.buffer[i] === 0 && this.buffer[i + 1] === 0) {
	      //its a group of zeros
	      if (start < 0) {
	        start = i;
	      }

	      // at the end of the buffer, make a final call to checkLongest.
	      if(i === this.buffer.length - 2) {
	        checkLongest(i+2);
	      }
	      continue;
	    }
	    //its a group of non-zeros
	    checkLongest(i);
	  }

	  let address = '';
	  for (let h = 0; h < this.buffer.length; h = h + 2) {
	    if (h === longest.start) {
	      address += ':';
	      continue;
	    }
	    if (h < (longest.start + longest.length) && h > longest.start) {
	      //its a group of zeros
	      continue;
	    }
	    if (address.length > 0) {
	      address += ':';
	    }
	    address += ((this.buffer[h] << 8) | this.buffer[h+1]).toString(16);
	  }
	  if (address.charAt(address.length-1) === ':') {
	    address += ':';
	  }
	  return address;
	};

	/**
	 * Returns the string representation.
	 * Method used by the native JSON.stringify() to serialize this instance.
	 */
	InetAddress.prototype.toJSON = function () {
	  return this.toString();
	};

	/**
	 * Validates for a IPv4-Mapped IPv6 according to https://tools.ietf.org/html/rfc4291#section-2.5.5
	 * @private
	 * @param {Buffer} buffer
	 */
	function isValidIPv4Mapped(buffer) {
	  // check the form
	  // |      80 bits   | 16 |   32 bits
	  // +----------------+----+-------------
	  // |0000........0000|FFFF| IPv4 address

	  for (let i = 0; i < buffer.length - 6; i++) {
	    if (buffer[i] !== 0) {
	      return false;
	    }
	  }
	  return !(buffer[10] !== 255 || buffer[11] !== 255);
	}

	inetAddress = InetAddress;
	return inetAddress;
}

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var localDate;
var hasRequiredLocalDate;

function requireLocalDate () {
	if (hasRequiredLocalDate) return localDate;
	hasRequiredLocalDate = 1;
	const util = require$$0$4;

	const utils = utils$K;
	/** @module types */

	/**
	 * @private
	 * @const
	 */
	const millisecondsPerDay = 86400000;
	/**
	 * @private
	 */
	const dateCenter = Math.pow(2,31);
	/**
	 *
	 * Creates a new instance of LocalDate.
	 * @class
	 * @classdesc A date without a time-zone in the ISO-8601 calendar system, such as 2010-08-05.
	 * <p>
	 *   LocalDate is an immutable object that represents a date, often viewed as year-month-day. For example, the value "1st October 2014" can be stored in a LocalDate.
	 * </p>
	 * <p>
	 *   This class does not store or represent a time or time-zone. Instead, it is a description of the date, as used for birthdays. It cannot represent an instant on the time-line without additional information such as an offset or time-zone.
	 * </p>
	 * <p>
	 *   Note that this type can represent dates in the range [-5877641-06-23; 5881580-07-17] while the ES5 date type can only represent values in the range of [-271821-04-20; 275760-09-13].
	 *   In the event that year, month, day parameters do not fall within the ES5 date range an Error will be thrown.  If you wish to represent a date outside of this range, pass a single
	 *   parameter indicating the days since epoch.  For example, -1 represents 1969-12-31.
	 * </p>
	 * @param {Number} year The year or days since epoch.  If days since epoch, month and day should not be provided.
	 * @param {Number} month Between 1 and 12 inclusive.
	 * @param {Number} day Between 1 and the number of days in the given month of the given year.
	 *
	 * @property {Date} date The date representation if falls within a range of an ES5 data type, otherwise an invalid date.
	 *
	 * @constructor
	 */
	function LocalDate(year, month, day) {
	  //implementation detail: internally uses a UTC based date
	  if (typeof year === 'number' && typeof month === 'number' && typeof day === 'number') {
	    // Use setUTCFullYear as if there is a 2 digit year, Date.UTC() assumes
	    // that is the 20th century.
	    this.date = new Date();
	    this.date.setUTCHours(0, 0, 0, 0);
	    this.date.setUTCFullYear(year, month-1, day);
	    if(isNaN(this.date.getTime())) {
	      throw new Error(util.format('%d-%d-%d does not form a valid ES5 date!',
	        year, month, day));
	    }
	  }
	  else if (typeof month === 'undefined' && typeof day === 'undefined') {
	    if (typeof year === 'number') {
	      //in days since epoch.
	      if(year < -2147483648 || year > 2147483647) {
	        throw new Error('You must provide a valid value for days since epoch (-2147483648 <= value <= 2147483647).');
	      }
	      this.date = new Date(year * millisecondsPerDay);
	    }
	  }

	  if (typeof this.date === 'undefined') {
	    throw new Error('You must provide a valid year, month and day');
	  }

	  /** 
	   * If date cannot be represented yet given a valid days since epoch, track
	   * it internally.
	   */
	  this._value = isNaN(this.date.getTime()) ? year : null;

	  /**
	   * A number representing the year.  May return NaN if cannot be represented as
	   * a Date.
	   * @type Number
	   */
	  this.year = this.date.getUTCFullYear();
	  /**
	   * A number between 1 and 12 inclusive representing the month.  May return
	   * NaN if cannot be represented as a Date.
	   * @type Number
	   */
	  this.month = this.date.getUTCMonth() + 1;
	  /**
	   * A number between 1 and the number of days in the given month of the given year (28, 29, 30, 31).
	   * May return NaN if cannot be represented as a Date.
	   * @type Number
	   */
	  this.day = this.date.getUTCDate();
	}

	/**
	 * Creates a new instance of LocalDate using the current year, month and day from the system clock in the default time-zone.
	 */
	LocalDate.now = function () {
	  return LocalDate.fromDate(new Date());
	};

	/**
	 * Creates a new instance of LocalDate using the current date from the system clock at UTC.
	 */
	LocalDate.utcNow = function () {
	  return new LocalDate(Date.now());
	};


	/**
	 * Creates a new instance of LocalDate using the year, month and day from the provided local date time.
	 * @param {Date} date
	 */
	LocalDate.fromDate = function (date) {
	  if (isNaN(date.getTime())) {
	    throw new TypeError('Invalid date: ' + date);
	  }
	  return new LocalDate(date.getFullYear(), date.getMonth() + 1, date.getDate());
	};

	/**
	 * Creates a new instance of LocalDate using the year, month and day provided in the form: yyyy-mm-dd or
	 * days since epoch (i.e. -1 for Dec 31, 1969).
	 * @param {String} value
	 */
	LocalDate.fromString = function (value) {
	  const dashCount = (value.match(/-/g) || []).length;
	  if(dashCount >= 2) {
	    let multiplier = 1;
	    if (value[0] === '-') {
	      value = value.substring(1);
	      multiplier = -1;
	    }
	    const parts = value.split('-');
	    return new LocalDate(multiplier * parseInt(parts[0], 10), parseInt(parts[1], 10), parseInt(parts[2], 10));
	  }
	  if(value.match(/^-?\d+$/)) {
	    // Parse as days since epoch.
	    return new LocalDate(parseInt(value, 10));
	  }
	  throw new Error("Invalid input '" + value + "'.");
	};

	/**
	 * Creates a new instance of LocalDate using the bytes representation.
	 * @param {Buffer} buffer
	 */
	LocalDate.fromBuffer = function (buffer) {
	  //move to unix epoch: 0.
	  return new LocalDate((buffer.readUInt32BE(0) - dateCenter));
	};

	/**
	 * Compares this LocalDate with the given one.
	 * @param {LocalDate} other date to compare against.
	 * @return {number} 0 if they are the same, 1 if the this is greater, and -1
	 * if the given one is greater.
	 */
	LocalDate.prototype.compare = function (other) {
	  const thisValue = isNaN(this.date.getTime()) ? this._value * millisecondsPerDay : this.date.getTime();
	  const otherValue = isNaN(other.date.getTime()) ? other._value * millisecondsPerDay : other.date.getTime();
	  const diff = thisValue - otherValue;
	  if (diff < 0) {
	    return -1;
	  }
	  if (diff > 0) {
	    return 1;
	  }
	  return 0;
	};

	/**
	 * Returns true if the value of the LocalDate instance and other are the same
	 * @param {LocalDate} other
	 * @returns {Boolean}
	 */
	LocalDate.prototype.equals = function (other) {
	  return ((other instanceof LocalDate)) && this.compare(other) === 0;
	};

	LocalDate.prototype.inspect = function () {
	  return this.constructor.name + ': ' + this.toString();
	};

	/**
	 * Gets the bytes representation of the instance.
	 * @returns {Buffer}
	 */
	LocalDate.prototype.toBuffer = function () {
	  //days since unix epoch
	  const daysSinceEpoch = isNaN(this.date.getTime()) ? this._value : Math.floor(this.date.getTime() / millisecondsPerDay);
	  const value = daysSinceEpoch + dateCenter;
	  const buf = utils.allocBufferUnsafe(4);
	  buf.writeUInt32BE(value, 0);
	  return buf;
	};

	/**
	 * Gets the string representation of the instance in the form: yyyy-mm-dd if
	 * the value can be parsed as a Date, otherwise days since epoch.
	 * @returns {String}
	 */
	LocalDate.prototype.toString = function () {
	  let result;
	  //if cannot be parsed as date, return days since epoch representation.
	  if (isNaN(this.date.getTime())) {
	    return this._value.toString();
	  }
	  if (this.year < 0) {
	    result = '-' + fillZeros((this.year * -1).toString(), 4);
	  }
	  else {
	    result = fillZeros(this.year.toString(), 4);
	  }
	  result += '-' + fillZeros(this.month.toString(), 2) + '-' + fillZeros(this.day.toString(), 2);
	  return result;
	};

	/**
	 * Gets the string representation of the instance in the form: yyyy-mm-dd, valid for JSON.
	 * @returns {String}
	 */
	LocalDate.prototype.toJSON = function () {
	  return this.toString();
	};

	/**
	 * @param {String} value
	 * @param {Number} amount
	 * @private
	 */
	function fillZeros(value, amount) {
	  if (value.length >= amount) {
	    return value;
	  }
	  return utils.stringRepeat('0', amount - value.length) + value;
	}

	localDate = LocalDate;
	return localDate;
}

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var localTime;
var hasRequiredLocalTime;

function requireLocalTime () {
	if (hasRequiredLocalTime) return localTime;
	hasRequiredLocalTime = 1;
	const Long = LongExports;
	const util = require$$0$4;
	const utils = utils$K;
	/** @module types */

	/**
	 * @const
	 * @private
	 * */
	const maxNanos = Long.fromString('86399999999999');
	/**
	 * Nanoseconds in a second
	 * @const
	 * @private
	 * */
	const nanoSecInSec = Long.fromNumber(1000000000);
	/**
	 * Nanoseconds in a millisecond
	 * @const
	 * @private
	 * */
	const nanoSecInMillis = Long.fromNumber(1000000);
	/**
	 * Milliseconds in day
	 * @const
	 * @private
	 * */
	const millisInDay = 86400000;
	/**
	 *
	 * Creates a new instance of LocalTime.
	 * @class
	 * @classdesc A time without a time-zone in the ISO-8601 calendar system, such as 10:30:05.
	 * <p>
	 *   LocalTime is an immutable date-time object that represents a time, often viewed as hour-minute-second. Time is represented to nanosecond precision. For example, the value "13:45.30.123456789" can be stored in a LocalTime.
	 * </p>
	 * @param {Long} totalNanoseconds Total nanoseconds since midnight.
	 * @constructor
	 */
	function LocalTime(totalNanoseconds) {
	  if (!(totalNanoseconds instanceof Long)) {
	    throw new Error('You must specify a Long value as totalNanoseconds');
	  }
	  if (totalNanoseconds.lessThan(Long.ZERO) || totalNanoseconds.greaterThan(maxNanos)) {
	    throw new Error('Total nanoseconds out of range');
	  }
	  this.value = totalNanoseconds;
	  
	  /**
	   * Gets the hour component of the time represented by the current instance, a number from 0 to 23.
	   * @type Number
	   */
	  this.hour = this._getParts()[0];
	  /**
	   * Gets the minute component of the time represented by the current instance, a number from 0 to 59.
	   * @type Number
	   */
	  this.minute = this._getParts()[1];
	  /**
	   * Gets the second component of the time represented by the current instance, a number from 0 to 59.
	   * @type Number
	   */
	  this.second = this._getParts()[2];
	  /**
	   * Gets the nanoseconds component of the time represented by the current instance, a number from 0 to 999999999.
	   * @type Number
	   */
	  this.nanosecond = this._getParts()[3];
	}

	/**
	 * Parses an string representation and returns a new LocalDate.
	 * @param {String} value
	 * @returns {LocalTime}
	 */
	LocalTime.fromString = function (value) {
	  if (typeof value !== 'string') {
	    throw new Error('Argument type invalid: ' + util.inspect(value));
	  }
	  const parts = value.split(':');
	  let millis = parseInt(parts[0], 10) * 3600000 + parseInt(parts[1], 10) * 60000;
	  let nanos;
	  if (parts.length === 3) {
	    const secParts = parts[2].split('.');
	    millis += parseInt(secParts[0], 10) * 1000;
	    if (secParts.length === 2) {
	      nanos = secParts[1];
	      //add zeros at the end
	      nanos = nanos + utils.stringRepeat('0', 9 - nanos.length);
	    }
	  }
	  return LocalTime.fromMilliseconds(millis, parseInt(nanos, 10) || 0);
	};

	/**
	 * Uses the current local time (in milliseconds) and the nanoseconds to create a new instance of LocalTime
	 * @param {Number} [nanoseconds] A Number from 0 to 999,999, representing the time nanosecond portion.
	 * @returns {LocalTime}
	 */
	LocalTime.now = function (nanoseconds) {
	  return LocalTime.fromDate(new Date(), nanoseconds);
	};

	/**
	 * Uses the provided local time (in milliseconds) and the nanoseconds to create a new instance of LocalTime
	 * @param {Date} date Local date portion to extract the time passed since midnight.
	 * @param {Number} [nanoseconds] A Number from 0 to 999,999, representing the nanosecond time portion.
	 * @returns {LocalTime}
	 */
	LocalTime.fromDate = function (date, nanoseconds) {
	  if (!util.isDate(date)) {
	    throw new Error('Not a valid date');
	  }
	  //Use the local representation, only the milliseconds portion
	  const millis = (date.getTime() + date.getTimezoneOffset() * -60000) % millisInDay;
	  return LocalTime.fromMilliseconds(millis, nanoseconds);
	};

	/**
	 * Uses the provided local time (in milliseconds) and the nanoseconds to create a new instance of LocalTime
	 * @param {Number} milliseconds A Number from 0 to 86,399,999.
	 * @param {Number} [nanoseconds] A Number from 0 to 999,999, representing the time nanosecond portion.
	 * @returns {LocalTime}
	 */
	LocalTime.fromMilliseconds = function (milliseconds, nanoseconds) {
	  if (typeof nanoseconds !== 'number') {
	    nanoseconds = 0;
	  }
	  return new LocalTime(Long
	    .fromNumber(milliseconds)
	    .multiply(nanoSecInMillis)
	    .add(Long.fromNumber(nanoseconds)));
	};

	/**
	 * Creates a new instance of LocalTime from the bytes representation.
	 * @param {Buffer} value
	 * @returns {LocalTime}
	 */
	LocalTime.fromBuffer = function (value) {
	  if (!(value instanceof Buffer)) {
	    throw new TypeError('Expected Buffer, obtained ' + util.inspect(value));
	  }
	  return new LocalTime(new Long(value.readInt32BE(4), value.readInt32BE(0)));
	};

	/**
	 * Compares this LocalTime with the given one.
	 * @param {LocalTime} other time to compare against.
	 * @return {number} 0 if they are the same, 1 if the this is greater, and -1
	 * if the given one is greater.
	 */
	LocalTime.prototype.compare = function (other) {
	  return this.value.compare(other.value);
	};

	/**
	 * Returns true if the value of the LocalTime instance and other are the same
	 * @param {LocalTime} other
	 * @returns {Boolean}
	 */
	LocalTime.prototype.equals = function (other) {
	  return ((other instanceof LocalTime)) && this.compare(other) === 0;
	};

	/**
	 * Gets the total amount of nanoseconds since midnight for this instance.
	 * @returns {Long}
	 */
	LocalTime.prototype.getTotalNanoseconds = function () {
	  return this.value;
	};

	LocalTime.prototype.inspect = function () {
	  return this.constructor.name + ': ' + this.toString();
	};

	/**
	 * Returns a big-endian bytes representation of the instance
	 * @returns {Buffer}
	 */
	LocalTime.prototype.toBuffer = function () {
	  const buffer = utils.allocBufferUnsafe(8);
	  buffer.writeUInt32BE(this.value.getHighBitsUnsigned(), 0);
	  buffer.writeUInt32BE(this.value.getLowBitsUnsigned(), 4);
	  return buffer;
	};

	/**
	 * Returns the string representation of the instance in the form of hh:MM:ss.ns
	 * @returns {String}
	 */
	LocalTime.prototype.toString = function () {
	  return formatTime(this._getParts());
	};

	/**
	 * Gets the string representation of the instance in the form: hh:MM:ss.ns
	 * @returns {String}
	 */
	LocalTime.prototype.toJSON = function () {
	  return this.toString();
	};

	/**
	 * @returns {Array.<Number>}
	 * @ignore
	 */
	LocalTime.prototype._getParts = function () {
	  if (!this._partsCache) {
	    //hours, minutes, seconds and nanos
	    const parts = [0, 0, 0, 0];
	    const secs = this.value.div(nanoSecInSec);
	    //faster modulo
	    //total nanos
	    parts[3] = this.value.subtract(secs.multiply(nanoSecInSec)).toNumber();
	    //seconds
	    parts[2] = secs.toNumber();
	    if (parts[2] >= 60) {
	      //minutes
	      parts[1] = Math.floor(parts[2] / 60);
	      parts[2] = parts[2] % 60;
	    }
	    if (parts[1] >= 60) {
	      //hours
	      parts[0] = Math.floor(parts[1] / 60);
	      parts[1] = parts[1] % 60;
	    }
	    this._partsCache = parts;
	  }
	  return this._partsCache;
	};

	/**
	 * @param {Array.<Number>} values
	 * @private
	 */
	function formatTime(values) {
	  let result;
	  if (values[0] < 10) {
	    result = '0' + values[0] + ':';
	  }
	  else {
	    result = values[0] + ':';
	  }
	  if (values[1] < 10) {
	    result += '0' + values[1] + ':';
	  }
	  else {
	    result += values[1] + ':';
	  }
	  if (values[2] < 10) {
	    result += '0' + values[2];
	  }
	  else {
	    result += values[2];
	  }
	  if (values[3] > 0) {
	    let nanos = values[3].toString();
	    //nine digits
	    if (nanos.length < 9) {
	      nanos = utils.stringRepeat('0', 9 - nanos.length) + nanos;
	    }
	    let lastPosition;
	    for (let i = nanos.length - 1; i > 0; i--) {
	      if (nanos[i] !== '0') {
	        break;
	      }
	      lastPosition = i;
	    }
	    if (lastPosition) {
	      nanos = nanos.substring(0, lastPosition);
	    }
	    result += '.' + nanos;
	  }
	  return result;
	}

	localTime = LocalTime;
	return localTime;
}

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var resultSet$1;
var hasRequiredResultSet;

function requireResultSet () {
	if (hasRequiredResultSet) return resultSet$1;
	hasRequiredResultSet = 1;

	const utils = utils$K;
	const errors = errors$n;

	const asyncIteratorSymbol = Symbol.asyncIterator || '@@asyncIterator';

	/** @module types */

	/**
	 * Creates a new instance of ResultSet.
	 * @class
	 * @classdesc Represents the result of a query.
	 * @param {Object} response
	 * @param {String} host
	 * @param {Object} triedHosts
	 * @param {Number} speculativeExecutions
	 * @param {Number} consistency
	 * @param {Boolean} isSchemaInAgreement
	 * @constructor
	 */
	function ResultSet(response, host, triedHosts, speculativeExecutions, consistency, isSchemaInAgreement) {
	  // if no execution was made at all, set to 0.
	  if (speculativeExecutions === -1) {
	    speculativeExecutions = 0;
	  }
	  /**
	   * Information on the execution of a successful query:
	   * @member {Object}
	   * @property {Number} achievedConsistency The consistency level that has been actually achieved by the query.
	   * @property {String} queriedHost The Cassandra host that coordinated this query.
	   * @property {Object} triedHosts Gets the associative array of host that were queried before getting a valid response,
	   * being the last host the one that replied correctly.
	   * @property {Object} speculativeExecutions The number of speculative executions (not including the first) executed before
	   * getting a valid response.
	   * @property {Uuid} traceId Identifier of the trace session.
	   * @property {Array.<string>} warnings Warning messages generated by the server when executing the query.
	   * @property {Boolean} isSchemaInAgreement Whether the cluster had reached schema agreement after the execution of
	   * this query.
	   * <p>
	   *   After a successful schema-altering query (ex: creating a table), the driver will check if
	   *   the cluster's nodes agree on the new schema version. If not, it will keep retrying for a given
	   *   delay (see <code>protocolOptions.maxSchemaAgreementWaitSeconds</code>).
	   * </p>
	   * <p>
	   *   Note that the schema agreement check is only performed for schema-altering queries For other
	   *   query types, this method will always return <code>true</code>. If this method returns <code>false</code>,
	   *   clients can call [Metadata.checkSchemaAgreement()]{@link module:metadata~Metadata#checkSchemaAgreement} later to
	   *   perform the check manually.
	   * </p>
	   */
	  this.info = {
	    queriedHost: host,
	    triedHosts: triedHosts,
	    speculativeExecutions: speculativeExecutions,
	    achievedConsistency: consistency,
	    traceId: null,
	    warnings: null,
	    customPayload: null,
	    isSchemaInAgreement
	  };

	  if (response.flags) {
	    this.info.traceId = response.flags.traceId;
	    this.info.warnings = response.flags.warnings;
	    this.info.customPayload = response.flags.customPayload;
	  }

	  /**
	   * Gets an array rows returned by the query.
	   * When the result set represents a response from a write query, this property will be <code>undefined</code>.
	   * When the read query result contains more rows than the fetch size (5000), this property will only contain the
	   * first rows up to fetch size. To obtain all the rows, you can use the built-in async iterator that will retrieve the
	   * following pages of results.
	   * @type {Array<Row>|undefined}
	   */
	  this.rows = response.rows;

	  /**
	   * Gets the row length of the result, regardless if the result has been buffered or not
	   * @type {Number|undefined}
	   */
	  this.rowLength = this.rows ? this.rows.length : response.rowLength;

	  /**
	   * Gets the columns returned in this ResultSet.
	   * @type {Array.<{name, type}>}
	   * @default null
	   */
	  this.columns = null;

	  /**
	   * A string token representing the current page state of query. It can be used in the following executions to
	   * continue paging and retrieve the remained of the result for the query.
	   * @type {String|null}
	   * @default null
	   */
	  this.pageState = null;

	  /**
	   * Method used to manually fetch the next page of results.
	   * This method is only exposed when using the {@link Client#eachRow} method and there are more rows available in
	   * following pages.
	   * @type Function
	   */
	  this.nextPage = undefined;

	  /**
	   * Method used internally to fetch the next page of results using promises.
	   * @internal
	   * @ignore
	   * @type {Function}
	   */
	  this.nextPageAsync = undefined;

	  const meta = response.meta;

	  if (meta) {
	    this.columns = meta.columns;

	    if (meta.pageState) {
	      this.pageState = meta.pageState.toString('hex');

	      // Expose rawPageState internally
	      Object.defineProperty(this, 'rawPageState', { value: meta.pageState, enumerable: false });
	    }
	  }
	}

	/**
	 * Returns the first row or null if the result rows are empty.
	 */
	ResultSet.prototype.first = function () {
	  if (this.rows && this.rows.length) {
	    return this.rows[0];
	  }
	  return null;
	};

	ResultSet.prototype.getPageState = function () {
	  // backward-compatibility
	  return this.pageState;
	};

	ResultSet.prototype.getColumns = function () {
	  // backward-compatibility
	  return this.columns;
	};

	/**
	 * When this instance is the result of a conditional update query, it returns whether it was successful.
	 * Otherwise, it returns <code>true</code>.
	 * <p>
	 *   For consistency, this method always returns <code>true</code> for non-conditional queries (although there is
	 *   no reason to call the method in that case). This is also the case for conditional DDL statements
	 *   (CREATE KEYSPACE... IF NOT EXISTS, CREATE TABLE... IF NOT EXISTS), for which the server doesn't return
	 *   information whether it was applied or not.
	 * </p>
	 */
	ResultSet.prototype.wasApplied = function () {
	  if (!this.rows || this.rows.length === 0) {
	    return true;
	  }
	  const firstRow = this.rows[0];
	  const applied = firstRow['[applied]'];
	  return typeof applied === 'boolean' ? applied : true;
	};

	/**
	 * Gets the iterator function.
	 * <p>
	 *   Retrieves the iterator of the underlying fetched rows, without causing the driver to fetch the following
	 *   result pages. For more information on result paging,
	 *   [visit the documentation]{@link http://docs.datastax.com/en/developer/nodejs-driver/latest/features/paging/}.
	 * </p>
	 * @alias module:types~ResultSet#@@iterator
	 * @see {@link module:types~ResultSet#@@asyncIterator}
	 * @example <caption>Using for...of statement</caption>
	 * const query = 'SELECT user_id, post_id, content FROM timeline WHERE user_id = ?';
	 * const result = await client.execute(query, [ id ], { prepare: true });
	 * for (const row of result) {
	 *   console.log(row['email']);
	 * }
	 * @returns {Iterator.<Row>}
	 */
	ResultSet.prototype[Symbol.iterator] = function getIterator() {
	  if (!this.rows) {
	    return utils.emptyArray[Symbol.iterator]();
	  }
	  return this.rows[Symbol.iterator]();
	};

	/**
	 * Gets the async iterator function.
	 * <p>
	 *   Retrieves the async iterator representing the entire query result, the driver will fetch the following result
	 *   pages.
	 * </p>
	 * <p>Use the async iterator when the query result might contain more rows than the <code>fetchSize</code>.</p>
	 * <p>
	 *   Note that using the async iterator will not affect the internal state of the <code>ResultSet</code> instance.
	 *   You should avoid using both <code>rows</code> property that contains the row instances of the first page of
	 *   results, and the async iterator, that will yield all the rows in the result regardless on the number of pages.
	 * </p>
	 * <p>Multiple concurrent async iterations are not supported.</p>
	 * @alias module:types~ResultSet#@@asyncIterator
	 * @example <caption>Using for await...of statement</caption>
	 * const query = 'SELECT user_id, post_id, content FROM timeline WHERE user_id = ?';
	 * const result = await client.execute(query, [ id ], { prepare: true });
	 * for await (const row of result) {
	 *   console.log(row['email']);
	 * }
	 * @returns {AsyncIterator<Row>}
	 */
	ResultSet.prototype[asyncIteratorSymbol] = function getAsyncGenerator() {
	  let index = 0;
	  let pageState = this.rawPageState;
	  let rows = this.rows;

	  if (!rows || rows.length === 0) {
	    return { next: () => Promise.resolve({ done: true }) };
	  }

	  const self = this;

	  // Async generators are not present in Node.js 8, implement it manually
	  return {
	    async next() {
	      if (index >= rows.length && pageState) {
	        if (!self.nextPageAsync) {
	          throw new errors.DriverInternalError('Property nextPageAsync should be set when pageState is defined');
	        }

	        const rs = await self.nextPageAsync(pageState);
	        rows = rs.rows;
	        index = 0;
	        pageState = rs.rawPageState;
	      }

	      if (index < rows.length) {
	        return { done: false, value: rows[index++] };
	      }

	      return { done: true };
	    }
	  };
	};

	/**
	 * Determines whether there are more pages of results.
	 * If so, the driver will initially retrieve and contain only the first page of results.
	 * To obtain all the rows, use the [AsyncIterator]{@linkcode module:types~ResultSet#@@asyncIterator}.
	 * @returns {boolean}
	 */
	ResultSet.prototype.isPaged = function() {
	  return !!this.rawPageState;
	};

	resultSet$1 = ResultSet;
	return resultSet$1;
}

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var resultStream;
var hasRequiredResultStream;

function requireResultStream () {
	if (hasRequiredResultStream) return resultStream;
	hasRequiredResultStream = 1;

	const { Readable } = require$$0$1;
	const utils = utils$K;
	const errors = errors$n;
	const clientOptions = requireClientOptions();

	/** @module types */
	/**
	 * Readable stream using to yield data from a result or a field
	 */
	class ResultStream extends Readable {
	  constructor(opt) {
	    super(opt);
	    this.buffer = [];
	    this.paused = true;
	    this._cancelAllowed = false;
	    this._handlersObject = null;
	    this._highWaterMarkRows = 0;
	  }

	  _read() {
	    this.paused = false;
	    if (this.buffer.length === 0) {
	      this._readableState.reading = false;
	    }
	    while (!this.paused && this.buffer.length > 0) {
	      this.paused = !this.push(this.buffer.shift());
	    }
	    this._checkBelowHighWaterMark();
	    if (!this.paused && !this.buffer.length && this._readNext) {
	      this._readNext();
	      this._readNext = null;
	    }
	  }

	  /**
	   * Allows for throttling, helping nodejs keep the internal buffers reasonably sized.
	   * @param {function} readNext function that triggers reading the next result chunk
	   * @ignore
	   */
	  _valve(readNext) {
	    this._readNext = null;
	    if (!readNext) {
	      return;
	    }
	    if (this.paused || this.buffer.length) {
	      this._readNext = readNext;
	    }
	    else {
	      readNext();
	    }
	  }

	  add(chunk) {
	    const length = this.buffer.push(chunk);
	    this.read(0);
	    this._checkAboveHighWaterMark();
	    return length;
	  }

	  _checkAboveHighWaterMark() {
	    if (!this._handlersObject || !this._handlersObject.resumeReadingHandler) {
	      return;
	    }
	    if (this._highWaterMarkRows === 0 || this.buffer.length !== this._highWaterMarkRows) {
	      return;
	    }
	    this._handlersObject.resumeReadingHandler(false);
	  }

	  _checkBelowHighWaterMark() {
	    if (!this._handlersObject || !this._handlersObject.resumeReadingHandler) {
	      return;
	    }
	    if (this._highWaterMarkRows === 0 || this.buffer.length >= this._highWaterMarkRows) {
	      return;
	    }
	    // The consumer has dequeued below the watermark
	    this._handlersObject.resumeReadingHandler(true);
	  }

	  /**
	   * When continuous paging is enabled, allows the client to notify to the server to stop pushing further pages.
	   * <p>Note: This is not part of the public API yet.</p>
	   * @param {Function} [callback] The cancel method accepts an optional callback.
	   * @example <caption>Cancelling a continuous paging execution</caption>
	   * const stream = client.stream(query, params, { prepare: true, continuousPaging: true });
	   * // ...
	   * // Ask the server to stop pushing rows.
	   * stream.cancel();
	   * @ignore
	   */
	  cancel(callback) {
	    if (!this._cancelAllowed) {
	      const err = new Error('You can only cancel streaming executions when continuous paging is enabled');
	      if (!callback) {
	        throw err;
	      }
	      return callback(err);
	    }
	    if (!this._handlersObject) {
	      throw new errors.DriverInternalError('ResultStream cancel is allowed but the cancel options were not set');
	    }
	    callback = callback || utils.noop;
	    if (!this._handlersObject.cancelHandler) {
	      // The handler is not yet set
	      // Set the callback as a flag to identify that the cancel handler must be invoked when set
	      this._handlersObject.cancelHandler = callback;
	      return;
	    }
	    this._handlersObject.cancelHandler(callback);
	  }

	  /**
	   * Sets the pointer to the handler to be used to cancel the continuous page execution.
	   * @param options
	   * @internal
	   * @ignore
	   */
	  setHandlers(options) {
	    if (!options.continuousPaging) {
	      return;
	    }
	    this._cancelAllowed = true;
	    this._handlersObject = options;
	    this._highWaterMarkRows =
	      options.continuousPaging.highWaterMarkRows || clientOptions.continuousPageDefaultHighWaterMark;
	  }
	}

	resultStream = ResultStream;
	return resultStream;
}

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var row;
var hasRequiredRow;

function requireRow () {
	if (hasRequiredRow) return row;
	hasRequiredRow = 1;
	/** @module types */
	/**
	 * Represents a result row
	 * @param {Array} columns
	 * @constructor
	 */
	function Row(columns) {
	  if (!columns) {
	    throw new Error('Columns not defined');
	  }
	  //Private non-enumerable properties, with double underscore to avoid interfering with column names
	  Object.defineProperty(this, '__columns', { value: columns, enumerable: false, writable: false});
	}

	/**
	 * Returns the cell value.
	 * @param {String|Number} columnName Name or index of the column
	 */
	Row.prototype.get = function (columnName) {
	  if (typeof columnName === 'number') {
	    //its an index
	    return this[this.__columns[columnName].name];
	  }
	  return this[columnName];
	};

	/**
	 * Returns an array of the values of the row
	 * @returns {Array}
	 */
	Row.prototype.values = function () {
	  const valuesArray = [];
	  this.forEach(function (val) {
	    valuesArray.push(val);
	  });
	  return valuesArray;
	};

	/**
	 * Returns an array of the column names of the row
	 * @returns {Array}
	 */
	Row.prototype.keys = function () {
	  const keysArray = [];
	  this.forEach(function (val, key) {
	    keysArray.push(key);
	  });
	  return keysArray;
	};

	/**
	 * Executes the callback for each field in the row, containing the value as first parameter followed by the columnName
	 * @param {Function} callback
	 */
	Row.prototype.forEach = function (callback) {
	  for (const columnName in this) {
	    if (!this.hasOwnProperty(columnName)) {
	      continue;
	    }
	    callback(this[columnName], columnName);
	  }
	};

	row = Row;
	return row;
}

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var tuple;
var hasRequiredTuple;

function requireTuple () {
	if (hasRequiredTuple) return tuple;
	hasRequiredTuple = 1;

	/** @module types */

	/**
	 * Creates a new sequence of immutable objects with the parameters provided.
	 * @class
	 * @classdesc A tuple is a sequence of immutable objects.
	 * Tuples are sequences, just like [Arrays]{@link Array}. The only difference is that tuples can't be changed.
	 * <p>
	 *   As tuples can be used as a Map keys, the {@link Tuple#toString toString()} method calls toString of each element,
	 *   to try to get a unique string key.
	 * </p>
	 * @param args The sequence elements as arguments.
	 * @constructor
	 */
	function Tuple(...args) {

	  /**
	   * Immutable elements of Tuple object.
	   * @type Array
	   */
	  this.elements = args;

	  if (this.elements.length === 0) {
	    throw new TypeError('Tuple must contain at least one value');
	  }

	  /**
	   * Returns the number of the elements.
	   * @type Number
	   */
	  this.length = this.elements.length;
	}

	/**
	 * Creates a new instance of a tuple based on the Array
	 * @param {Array} elements
	 * @returns {Tuple}
	 */
	Tuple.fromArray = function (elements) {
	  // Apply the elements Array as parameters
	  return new Tuple(...elements);
	};

	/**
	 * Returns the value located at the index.
	 * @param {Number} index Element index
	 */
	Tuple.prototype.get = function (index) {
	  return this.elements[index || 0];
	};

	/**
	 * Returns the string representation of the sequence surrounded by parenthesis, ie: (1, 2).
	 * <p>
	 *   The returned value attempts to be a unique string representation of its values.
	 * </p>
	 * @returns {string}
	 */
	Tuple.prototype.toString = function () {
	  return ('(' +
	    this.elements.reduce(function (prev, x, i) {
	      return prev + (i > 0 ? ',' : '') + x.toString();
	    }, '') +
	    ')');
	};

	/**
	 * Returns the Array representation of the sequence.
	 * @returns {Array}
	 */
	Tuple.prototype.toJSON = function () {
	  return this.elements;
	};

	/**
	 * Gets the elements as an array
	 * @returns {Array}
	 */
	Tuple.prototype.values = function () {
	  // Clone the elements
	  return this.elements.slice(0);
	};

	tuple = Tuple;
	return tuple;
}

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var hasRequiredTypes;

function requireTypes () {
	if (hasRequiredTypes) return types$s;
	hasRequiredTypes = 1;
	const util = require$$0$4;

	const errors = errors$n;
	const TimeUuid = timeUuid;
	const Uuid = uuid;
	const protocolVersion = protocolVersion_1;
	const utils = utils$K;

	/** @module types */
	/**
	 * Long constructor, wrapper of the internal library used: {@link https://github.com/dcodeIO/long.js Long.js}.
	 * @constructor
	 */
	const Long = LongExports;


	/**
	 * Consistency levels
	 * @type {Object}
	 * @property {Number} any Writing: A write must be written to at least one node. If all replica nodes for the given row key are down, the write can still succeed after a hinted handoff has been written. If all replica nodes are down at write time, an ANY write is not readable until the replica nodes for that row have recovered.
	 * @property {Number} one Returns a response from the closest replica, as determined by the snitch.
	 * @property {Number} two Returns the most recent data from two of the closest replicas.
	 * @property {Number} three Returns the most recent data from three of the closest replicas.
	 * @property {Number} quorum Reading: Returns the record with the most recent timestamp after a quorum of replicas has responded regardless of data center. Writing: A write must be written to the commit log and memory table on a quorum of replica nodes.
	 * @property {Number} all Reading: Returns the record with the most recent timestamp after all replicas have responded. The read operation will fail if a replica does not respond. Writing: A write must be written to the commit log and memory table on all replica nodes in the cluster for that row.
	 * @property {Number} localQuorum Reading: Returns the record with the most recent timestamp once a quorum of replicas in the current data center as the coordinator node has reported. Writing: A write must be written to the commit log and memory table on a quorum of replica nodes in the same data center as the coordinator node. Avoids latency of inter-data center communication.
	 * @property {Number} eachQuorum Reading: Returns the record once a quorum of replicas in each data center of the cluster has responded. Writing: Strong consistency. A write must be written to the commit log and memtable on a quorum of replica nodes in all data centers.
	 * @property {Number} serial Achieves linearizable consistency for lightweight transactions by preventing unconditional updates.
	 * @property {Number} localSerial Same as serial but confined to the data center. A write must be written conditionally to the commit log and memtable on a quorum of replica nodes in the same data center.
	 * @property {Number} localOne Similar to One but only within the DC the coordinator is in.
	 */
	const consistencies = {
	  any:          0x00,
	  one:          0x01,
	  two:          0x02,
	  three:        0x03,
	  quorum:       0x04,
	  all:          0x05,
	  localQuorum:  0x06,
	  eachQuorum:   0x07,
	  serial:       0x08,
	  localSerial:  0x09,
	  localOne:     0x0a
	};

	/**
	 * Mapping of consistency level codes to their string representation.
	 * @type {Object}
	 */
	const consistencyToString = {};
	consistencyToString[consistencies.any] = 'ANY';
	consistencyToString[consistencies.one] = 'ONE';
	consistencyToString[consistencies.two] = 'TWO';
	consistencyToString[consistencies.three] = 'THREE';
	consistencyToString[consistencies.quorum] = 'QUORUM';
	consistencyToString[consistencies.all] = 'ALL';
	consistencyToString[consistencies.localQuorum] = 'LOCAL_QUORUM';
	consistencyToString[consistencies.eachQuorum] = 'EACH_QUORUM';
	consistencyToString[consistencies.serial] = 'SERIAL';
	consistencyToString[consistencies.localSerial] = 'LOCAL_SERIAL';
	consistencyToString[consistencies.localOne] = 'LOCAL_ONE';

	/**
	 * CQL data types
	 * @type {Object}
	 * @property {Number} custom A custom type.
	 * @property {Number} ascii ASCII character string.
	 * @property {Number} bigint 64-bit signed long.
	 * @property {Number} blob Arbitrary bytes (no validation).
	 * @property {Number} boolean true or false.
	 * @property {Number} counter Counter column (64-bit signed value).
	 * @property {Number} decimal Variable-precision decimal.
	 * @property {Number} double 64-bit IEEE-754 floating point.
	 * @property {Number} float 32-bit IEEE-754 floating point.
	 * @property {Number} int 32-bit signed integer.
	 * @property {Number} text UTF8 encoded string.
	 * @property {Number} timestamp A timestamp.
	 * @property {Number} uuid Type 1 or type 4 UUID.
	 * @property {Number} varchar UTF8 encoded string.
	 * @property {Number} varint Arbitrary-precision integer.
	 * @property {Number} timeuuid  Type 1 UUID.
	 * @property {Number} inet An IP address. It can be either 4 bytes long (IPv4) or 16 bytes long (IPv6).
	 * @property {Number} date A date without a time-zone in the ISO-8601 calendar system.
	 * @property {Number} time A value representing the time portion of the day.
	 * @property {Number} smallint 16-bit two's complement integer.
	 * @property {Number} tinyint 8-bit two's complement integer.
	 * @property {Number} list A collection of elements.
	 * @property {Number} map Key/value pairs.
	 * @property {Number} set A collection that contains no duplicate elements.
	 * @property {Number} udt User-defined type.
	 * @property {Number} tuple A sequence of values.
	 */
	const dataTypes = {
	  custom:     0x0000,
	  ascii:      0x0001,
	  bigint:     0x0002,
	  blob:       0x0003,
	  boolean:    0x0004,
	  counter:    0x0005,
	  decimal:    0x0006,
	  double:     0x0007,
	  float:      0x0008,
	  int:        0x0009,
	  text:       0x000a,
	  timestamp:  0x000b,
	  uuid:       0x000c,
	  varchar:    0x000d,
	  varint:     0x000e,
	  timeuuid:   0x000f,
	  inet:       0x0010,
	  date:       0x0011,
	  time:       0x0012,
	  smallint:   0x0013,
	  tinyint:    0x0014,
	  duration:   0x0015,
	  list:       0x0020,
	  map:        0x0021,
	  set:        0x0022,
	  udt:        0x0030,
	  tuple:      0x0031,
	  /**
	   * Returns the typeInfo of a given type name
	   * @param name
	   * @returns {{code: number, info: *|Object}}
	   */
	  getByName:  function(name) {
	    name = name.toLowerCase();
	    if (name.indexOf('<') > 0) {
	      const listMatches = /^(list|set)<(.+)>$/.exec(name);
	      if (listMatches) {
	        return { code: this[listMatches[1]], info: this.getByName(listMatches[2])};
	      }
	      const mapMatches = /^(map)< *(.+) *, *(.+)>$/.exec(name);
	      if (mapMatches) {
	        return { code: this[mapMatches[1]], info: [this.getByName(mapMatches[2]), this.getByName(mapMatches[3])]};
	      }
	      const udtMatches = /^(udt)<(.+)>$/.exec(name);
	      if (udtMatches) {
	        //udt name as raw string
	        return { code: this[udtMatches[1]], info: udtMatches[2]};
	      }
	      const tupleMatches = /^(tuple)<(.+)>$/.exec(name);
	      if (tupleMatches) {
	        //tuple info as an array of types
	        return { code: this[tupleMatches[1]], info: tupleMatches[2].split(',').map(function (x) {
	          return this.getByName(x.trim());
	        }, this)};
	      }
	    }
	    const typeInfo = { code: this[name], info: null};
	    if (typeof typeInfo.code !== 'number') {
	      throw new TypeError('Data type with name ' + name + ' not valid');
	    }
	    return typeInfo;
	  }
	};

	/**
	 * Map of Data types by code
	 * @internal
	 * @private
	 */
	const _dataTypesByCode = (function () {
	  const result = {};
	  for (const key in dataTypes) {
	    if (!dataTypes.hasOwnProperty(key)) {
	      continue;
	    }
	    const val = dataTypes[key];
	    if (typeof val !== 'number') {
	      continue;
	    }
	    result[val] = key;
	  }
	  return result;
	})();

	/**
	 * Represents the distance of Cassandra node as assigned by a LoadBalancingPolicy relatively to the driver instance.
	 * @type {Object}
	 * @property {Number} local A local node.
	 * @property {Number} remote A remote node.
	 * @property {Number} ignored A node that is meant to be ignored.
	 */
	const distance = {
	  local:    0,
	  remote:   1,
	  ignored:  2
	};

	/**
	 * An integer byte that distinguish the actual message from and to Cassandra
	 * @internal
	 * @ignore
	 */
	const opcodes = {
	  error:          0x00,
	  startup:        0x01,
	  ready:          0x02,
	  authenticate:   0x03,
	  credentials:    0x04,
	  options:        0x05,
	  supported:      0x06,
	  query:          0x07,
	  result:         0x08,
	  prepare:        0x09,
	  execute:        0x0a,
	  register:       0x0b,
	  event:          0x0c,
	  batch:          0x0d,
	  authChallenge:  0x0e,
	  authResponse:   0x0f,
	  authSuccess:    0x10,
	  cancel:         0xff,

	  /**
	   * Determines if the code is a valid opcode
	   */
	  isInRange: function (code) {
	    return code > this.error && code > this.event;
	  }
	};

	/**
	 * Event types from Cassandra
	 * @type {{topologyChange: string, statusChange: string, schemaChange: string}}
	 * @internal
	 * @ignore
	 */
	const protocolEvents = {
	  topologyChange: 'TOPOLOGY_CHANGE',
	  statusChange: 'STATUS_CHANGE',
	  schemaChange: 'SCHEMA_CHANGE'
	};

	/**
	 * Server error codes returned by Cassandra
	 * @type {Object}
	 * @property {Number} serverError Something unexpected happened.
	 * @property {Number} protocolError Some client message triggered a protocol violation.
	 * @property {Number} badCredentials Authentication was required and failed.
	 * @property {Number} unavailableException Raised when coordinator knows there is not enough replicas alive to perform a query with the requested consistency level.
	 * @property {Number} overloaded The request cannot be processed because the coordinator is overloaded.
	 * @property {Number} isBootstrapping The request was a read request but the coordinator node is bootstrapping.
	 * @property {Number} truncateError Error encountered during a truncate request.
	 * @property {Number} writeTimeout Timeout encountered on write query on coordinator waiting for response(s) from replicas.
	 * @property {Number} readTimeout Timeout encountered on read query on coordinator waitign for response(s) from replicas.
	 * @property {Number} readFailure A non-timeout error encountered during a read request.
	 * @property {Number} functionFailure A (user defined) function encountered during execution.
	 * @property {Number} writeFailure A non-timeout error encountered during a write request.
	 * @property {Number} syntaxError The submitted query has a syntax error.
	 * @property {Number} unauthorized The logged user doesn't have the right to perform the query.
	 * @property {Number} invalid The query is syntactically correct but invalid.
	 * @property {Number} configError The query is invalid because of some configuration issue.
	 * @property {Number} alreadyExists The query attempted to create a schema element (i.e. keyspace, table) that already exists.
	 * @property {Number} unprepared Can be thrown while a prepared statement tries to be executed if the provided statement is not known by the coordinator.
	 */
	const responseErrorCodes = {
	  serverError:            0x0000,
	  protocolError:          0x000A,
	  badCredentials:         0x0100,
	  unavailableException:   0x1000,
	  overloaded:             0x1001,
	  isBootstrapping:        0x1002,
	  truncateError:          0x1003,
	  writeTimeout:           0x1100,
	  readTimeout:            0x1200,
	  readFailure:            0x1300,
	  functionFailure:        0x1400,
	  writeFailure:           0x1500,
	  syntaxError:            0x2000,
	  unauthorized:           0x2100,
	  invalid:                0x2200,
	  configError:            0x2300,
	  alreadyExists:          0x2400,
	  unprepared:             0x2500,
	  clientWriteFailure:     0x8000,
	};

	/**
	 * Type of result included in a response
	 * @internal
	 * @ignore
	 */
	const resultKind = {
	  voidResult:      0x0001,
	  rows:            0x0002,
	  setKeyspace:     0x0003,
	  prepared:        0x0004,
	  schemaChange:    0x0005
	};

	/**
	 * Message frame flags
	 * @internal
	 * @ignore
	 */
	const frameFlags = {
	  compression:    0x01,
	  tracing:        0x02,
	  customPayload:  0x04,
	  warning:        0x08
	};

	/**
	 * Unset representation.
	 * <p>
	 *   Use this field if you want to set a parameter to <code>unset</code>. Valid for Cassandra 2.2 and above.
	 * </p>
	 */
	const unset = Object.freeze({'unset': true});

	/**
	 * A long representing the value 1000
	 * @const
	 * @private
	 */
	const _longOneThousand = Long.fromInt(1000);

	/**
	 * Counter used to generate up to 1000 different timestamp values with the same Date
	 * @private
	 */
	let _timestampTicks = 0;

	/**
	 * <p><strong>Backward compatibility only, use [TimeUuid]{@link module:types~TimeUuid} instead</strong>.</p>
	 * Generates and returns a RFC4122 v1 (timestamp based) UUID in a string representation.
	 * @param {{msecs, node, clockseq, nsecs}} [options]
	 * @param {Buffer} [buffer]
	 * @param {Number} [offset]
	 * @deprecated Use [TimeUuid]{@link module:types~TimeUuid} instead
	 */
	function timeuuid(options, buffer, offset) {
	  let date;
	  let ticks;
	  let nodeId;
	  let clockId;
	  if (options) {
	    if (typeof options.msecs === 'number') {
	      date = new Date(options.msecs);
	    }
	    if (options.msecs instanceof Date) {
	      date = options.msecs;
	    }
	    if (Array.isArray(options.node)) {
	      nodeId = utils.allocBufferFromArray(options.node);
	    }
	    if (typeof options.clockseq === 'number') {
	      clockId = utils.allocBufferUnsafe(2);
	      clockId.writeUInt16BE(options.clockseq, 0);
	    }
	    if (typeof options.nsecs === 'number') {
	      ticks = options.nsecs;
	    }
	  }
	  const uuid = new TimeUuid(date, ticks, nodeId, clockId);
	  if (buffer instanceof Buffer) {
	    //copy the values into the buffer
	    uuid.getBuffer().copy(buffer, offset || 0);
	    return buffer;
	  }
	  return uuid.toString();
	}

	/**
	 * <p><strong>Backward compatibility only, use [Uuid]{@link module:types~Uuid} class instead</strong>.</p>
	 * Generate and return a RFC4122 v4 UUID in a string representation.
	 * @deprecated Use [Uuid]{@link module:types~Uuid} class instead
	 */
	function uuid$1(options, buffer, offset) {
	  let uuid;
	  if (options) {
	    if (Array.isArray(options.random)) {
	      uuid = new Uuid(utils.allocBufferFromArray(options.random));
	    }
	  }
	  if (!uuid) {
	    uuid = Uuid.random();
	  }
	  if (buffer instanceof Buffer) {
	    //copy the values into the buffer
	    uuid.getBuffer().copy(buffer, offset || 0);
	    return buffer;
	  }
	  return uuid.toString();
	}

	/**
	 * Gets the data type name for a given type definition
	 * @internal
	 * @ignore
	 * @throws {ArgumentError}
	 */
	function getDataTypeNameByCode(item) {
	  if (!item || typeof item.code !== 'number') {
	    throw new errors.ArgumentError('Invalid signature type definition');
	  }
	  const typeName = _dataTypesByCode[item.code];
	  if (!typeName) {
	    throw new errors.ArgumentError(util.format('Type with code %d not found', item.code));
	  }
	  if (!item.info) {
	    return typeName;
	  }
	  if (Array.isArray(item.info)) {
	    return (typeName +
	      '<' +
	      item.info.map(function (t) {
	        return getDataTypeNameByCode(t);
	      }).join(', ') +
	      '>');
	  }
	  if (typeof item.info.code === 'number') {
	    return typeName + '<' + getDataTypeNameByCode(item.info) + '>';
	  }
	  return typeName;
	}

	//classes

	/**
	 * Represents a frame header that could be used to read from a Buffer or to write to a Buffer
	 * @ignore
	 * @param {Number} version Protocol version
	 * @param {Number} flags
	 * @param {Number} streamId
	 * @param {Number} opcode
	 * @param {Number} bodyLength
	 * @constructor
	 */
	function FrameHeader(version, flags, streamId, opcode, bodyLength) {
	  this.version = version;
	  this.flags = flags;
	  this.streamId = streamId;
	  this.opcode = opcode;
	  this.bodyLength = bodyLength;
	}

	/**
	 * The length of the header of the frame based on the protocol version
	 * @returns {Number}
	 */
	FrameHeader.size = function (version) {
	  if (protocolVersion.uses2BytesStreamIds(version)) {
	    return 9;
	  }
	  return 8;
	};

	/**
	 * Gets the protocol version based on the first byte of the header
	 * @param {Buffer} buffer
	 * @returns {Number}
	 */
	FrameHeader.getProtocolVersion = function (buffer) {
	  return buffer[0] & 0x7F;
	};

	/**
	 * @param {Buffer} buf
	 * @param {Number} [offset]
	 * @returns {FrameHeader}
	 */
	FrameHeader.fromBuffer = function (buf, offset) {
	  let streamId = 0;
	  if (!offset) {
	    offset = 0;
	  }
	  const version = buf[offset++] & 0x7F;
	  const flags = buf.readUInt8(offset++);
	  if (!protocolVersion.uses2BytesStreamIds(version)) {
	    streamId = buf.readInt8(offset++);
	  }
	  else {
	    streamId = buf.readInt16BE(offset);
	    offset += 2;
	  }
	  return new FrameHeader(version, flags, streamId, buf.readUInt8(offset++), buf.readUInt32BE(offset));
	};

	/** @returns {Buffer} */
	FrameHeader.prototype.toBuffer = function () {
	  const buf = utils.allocBufferUnsafe(FrameHeader.size(this.version));
	  buf.writeUInt8(this.version, 0);
	  buf.writeUInt8(this.flags, 1);
	  let offset = 3;
	  if (!protocolVersion.uses2BytesStreamIds(this.version)) {
	    buf.writeInt8(this.streamId, 2);
	  }
	  else {
	    buf.writeInt16BE(this.streamId, 2);
	    offset = 4;
	  }
	  buf.writeUInt8(this.opcode, offset++);
	  buf.writeUInt32BE(this.bodyLength, offset);
	  return buf;
	};
	/**
	 * Returns a long representation.
	 * Used internally for deserialization
	 */
	Long.fromBuffer = function (value) {
	  if (!(value instanceof Buffer)) {
	    throw new TypeError('Expected Buffer, obtained ' + util.inspect(value));
	  }
	  return new Long(value.readInt32BE(4), value.readInt32BE(0));
	};

	/**
	 * Returns a big-endian buffer representation of the Long instance
	 * @param {Long} value
	 */
	Long.toBuffer = function (value) {
	  if (!(value instanceof Long)) {
	    throw new TypeError('Expected Long, obtained ' + util.inspect(value));
	  }
	  const buffer = utils.allocBufferUnsafe(8);
	  buffer.writeUInt32BE(value.getHighBitsUnsigned(), 0);
	  buffer.writeUInt32BE(value.getLowBitsUnsigned(), 4);
	  return buffer;
	};

	/**
	 * Provide the name of the constructor and the string representation
	 * @returns {string}
	 */
	Long.prototype.inspect = function () {
	  return 'Long: ' + this.toString();
	};

	/**
	 * Returns the string representation.
	 * Method used by the native JSON.stringify() to serialize this instance
	 */
	Long.prototype.toJSON = function () {
	  return this.toString();
	};

	/**
	 * Generates a value representing the timestamp for the query in microseconds based on the date and the microseconds provided
	 * @param {Date} [date] The date to generate the value, if not provided it will use the current date.
	 * @param {Number} [microseconds] A number from 0 to 999 used to build the microseconds part of the date.
	 * @returns {Long}
	 */
	function generateTimestamp(date, microseconds) {
	  if (!date) {
	    date = new Date();
	  }
	  let longMicro = Long.ZERO;
	  if (typeof microseconds === 'number' && microseconds >= 0 && microseconds < 1000) {
	    longMicro = Long.fromInt(microseconds);
	  }
	  else {
	    if (_timestampTicks > 999) {
	      _timestampTicks = 0;
	    }
	    longMicro = Long.fromInt(_timestampTicks);
	    _timestampTicks++;
	  }
	  return Long
	    .fromNumber(date.getTime())
	    .multiply(_longOneThousand)
	    .add(longMicro);
	}

	//error classes

	/** @private */
	function QueryParserError(e) {
	  QueryParserError.super_.call(this, e.message, this.constructor);
	  this.internalError = e;
	}
	util.inherits(QueryParserError, errors.DriverError);

	/** @private */
	function TimeoutError (message) {
	  TimeoutError.super_.call(this, message, this.constructor);
	  this.info = 'Represents an error that happens when the maximum amount of time for an operation passed.';
	}
	util.inherits(TimeoutError, errors.DriverError);

	types$s.opcodes = opcodes;
	types$s.consistencies = consistencies;
	types$s.consistencyToString = consistencyToString;
	types$s.dataTypes = dataTypes;
	types$s.getDataTypeNameByCode = getDataTypeNameByCode;
	types$s.distance = distance;
	types$s.frameFlags = frameFlags;
	types$s.protocolEvents = protocolEvents;
	types$s.protocolVersion = protocolVersion;
	types$s.responseErrorCodes = responseErrorCodes;
	types$s.resultKind = resultKind;
	types$s.timeuuid = timeuuid;
	types$s.uuid = uuid$1;
	types$s.BigDecimal = requireBigDecimal();
	types$s.Duration = requireDuration();
	types$s.FrameHeader = FrameHeader;
	types$s.InetAddress = requireInetAddress();
	types$s.Integer = requireInteger();
	types$s.LocalDate = requireLocalDate();
	types$s.LocalTime = requireLocalTime();
	types$s.Long = Long;
	types$s.ResultSet = requireResultSet();
	types$s.ResultStream = requireResultStream();
	types$s.Row = requireRow();
	//export DriverError for backward-compatibility
	types$s.DriverError = errors.DriverError;
	types$s.TimeoutError = TimeoutError;
	types$s.TimeUuid = TimeUuid;
	types$s.Tuple = requireTuple();
	types$s.Uuid = Uuid;
	types$s.unset = unset;
	types$s.generateTimestamp = generateTimestamp;
	return types$s;
}

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var loadBalancing;
var hasRequiredLoadBalancing;

function requireLoadBalancing () {
	if (hasRequiredLoadBalancing) return loadBalancing;
	hasRequiredLoadBalancing = 1;

	const util = require$$0$4;
	const types = requireTypes();
	const utils = utils$K;
	const errors = errors$n;

	const doneIteratorObject = Object.freeze({ done: true });
	const newlyUpInterval = 60000;

	/** @module policies/loadBalancing */
	/**
	 * Base class for Load Balancing Policies
	 * @constructor
	 */
	function LoadBalancingPolicy() {

	}

	/**
	 * Initializes the load balancing policy, called after the driver obtained the information of the cluster.
	 * @param {Client} client
	 * @param {HostMap} hosts
	 * @param {Function} callback
	 */
	LoadBalancingPolicy.prototype.init = function (client, hosts, callback) {
	  this.client = client;
	  this.hosts = hosts;
	  callback();
	};

	/**
	 * Returns the distance assigned by this policy to the provided host.
	 * @param {Host} host
	 */
	LoadBalancingPolicy.prototype.getDistance = function (host) {
	  return types.distance.local;
	};

	/**
	 * Returns an iterator with the hosts for a new query.
	 * Each new query will call this method. The first host in the result will
	 * then be used to perform the query.
	 * @param {String} keyspace Name of currently logged keyspace at <code>Client</code> level.
	 * @param {ExecutionOptions|null} executionOptions The information related to the execution of the request.
	 * @param {Function} callback The function to be invoked with the error as first parameter and the host iterator as
	 * second parameter.
	 */
	LoadBalancingPolicy.prototype.newQueryPlan = function (keyspace, executionOptions, callback) {
	  callback(new Error('You must implement a query plan for the LoadBalancingPolicy class'));
	};

	/**
	 * Gets an associative array containing the policy options.
	 */
	LoadBalancingPolicy.prototype.getOptions = function () {
	  return new Map();
	};

	/**
	 * This policy yield nodes in a round-robin fashion.
	 * @extends LoadBalancingPolicy
	 * @constructor
	 */
	function RoundRobinPolicy() {
	  this.index = 0;
	}

	util.inherits(RoundRobinPolicy, LoadBalancingPolicy);

	/**
	 * Returns an iterator with the hosts to be used as coordinator for a query.
	 * @param {String} keyspace Name of currently logged keyspace at <code>Client</code> level.
	 * @param {ExecutionOptions|null} executionOptions The information related to the execution of the request.
	 * @param {Function} callback The function to be invoked with the error as first parameter and the host iterator as
	 * second parameter.
	 */
	RoundRobinPolicy.prototype.newQueryPlan = function (keyspace, executionOptions, callback) {
	  if (!this.hosts) {
	    return callback(new Error('Load balancing policy not initialized'));
	  }
	  const hosts = this.hosts.values();
	  const self = this;
	  let counter = 0;

	  let planIndex = self.index % hosts.length;
	  self.index += 1;
	  if (self.index >= utils.maxInt) {
	    self.index = 0;
	  }

	  callback(null, {
	    next: function () {
	      if (++counter > hosts.length) {
	        return doneIteratorObject;
	      }
	      return {value: hosts[planIndex++ % hosts.length], done: false};
	    }
	  });
	};

	/**
	 * A data-center aware Round-robin load balancing policy.
	 * This policy provides round-robin queries over the nodes of the local
	 * data center.
	 * @param {?String} [localDc] local datacenter name.  This value overrides the 'localDataCenter' Client option \
	 * and is useful for cases where you have multiple execution profiles that you intend on using for routing
	 * requests to different data centers.
	 * @extends {LoadBalancingPolicy}
	 * @constructor
	 */
	function DCAwareRoundRobinPolicy(localDc) {
	  this.localDc = localDc;
	  this.index = 0;
	  /** @type {Array} */
	  this.localHostsArray = null;
	}

	util.inherits(DCAwareRoundRobinPolicy, LoadBalancingPolicy);

	/**
	 * Initializes the load balancing policy.
	 * @param {Client} client
	 * @param {HostMap} hosts
	 * @param {Function} callback
	 */
	DCAwareRoundRobinPolicy.prototype.init = function (client, hosts, callback) {
	  this.client = client;
	  this.hosts = hosts;
	  hosts.on('add', this._cleanHostCache.bind(this));
	  hosts.on('remove', this._cleanHostCache.bind(this));

	  try {
	    setLocalDc(this, client, this.hosts);
	  } catch (err) {
	    return callback(err);
	  }

	  callback();
	};

	/**
	 * Returns the distance depending on the datacenter.
	 * @param {Host} host
	 */
	DCAwareRoundRobinPolicy.prototype.getDistance = function (host) {
	  if (host.datacenter === this.localDc) {
	    return types.distance.local;
	  }

	  return types.distance.ignored;
	};

	DCAwareRoundRobinPolicy.prototype._cleanHostCache = function () {
	  this.localHostsArray = null;
	};

	DCAwareRoundRobinPolicy.prototype._resolveLocalHosts = function() {
	  const hosts = this.hosts.values();
	  if (this.localHostsArray) {
	    //there were already calculated
	    return;
	  }
	  this.localHostsArray = [];
	  hosts.forEach(function (h) {
	    if (!h.datacenter) {
	      //not a remote dc node
	      return;
	    }
	    if (h.datacenter === this.localDc) {
	      this.localHostsArray.push(h);
	    }
	  }, this);
	};

	/**
	 * It returns an iterator that yields local nodes.
	 * @param {String} keyspace Name of currently logged keyspace at <code>Client</code> level.
	 * @param {ExecutionOptions|null} executionOptions The information related to the execution of the request.
	 * @param {Function} callback The function to be invoked with the error as first parameter and the host iterator as
	 * second parameter.
	 */
	DCAwareRoundRobinPolicy.prototype.newQueryPlan = function (keyspace, executionOptions, callback) {
	  if (!this.hosts) {
	    return callback(new Error('Load balancing policy not initialized'));
	  }
	  this.index += 1;
	  if (this.index >= utils.maxInt) {
	    this.index = 0;
	  }
	  this._resolveLocalHosts();
	  // Use a local reference of hosts
	  const localHostsArray = this.localHostsArray;
	  let planLocalIndex = this.index;
	  let counter = 0;
	  callback(null, {
	    next: function () {
	      let host;
	      if (counter++ < localHostsArray.length) {
	        host = localHostsArray[planLocalIndex++ % localHostsArray.length];
	        return { value: host, done: false };
	      }
	      return doneIteratorObject;
	    }
	  });
	};

	/**
	 * Gets an associative array containing the policy options.
	 */
	DCAwareRoundRobinPolicy.prototype.getOptions = function () {
	  return new Map([
	    ['localDataCenter', this.localDc ]
	  ]);
	};

	/**
	 * A wrapper load balancing policy that add token awareness to a child policy.
	 * @param {LoadBalancingPolicy} childPolicy
	 * @extends LoadBalancingPolicy
	 * @constructor
	 */
	function TokenAwarePolicy (childPolicy) {
	  if (!childPolicy) {
	    throw new Error("You must specify a child load balancing policy");
	  }
	  this.childPolicy = childPolicy;
	}

	util.inherits(TokenAwarePolicy, LoadBalancingPolicy);

	TokenAwarePolicy.prototype.init = function (client, hosts, callback) {
	  this.client = client;
	  this.hosts = hosts;
	  this.childPolicy.init(client, hosts, callback);
	};

	TokenAwarePolicy.prototype.getDistance = function (host) {
	  return this.childPolicy.getDistance(host);
	};

	/**
	 * Returns the hosts to use for a new query.
	 * The returned plan will return local replicas first, if replicas can be determined, followed by the plan of the
	 * child policy.
	 * @param {String} keyspace Name of currently logged keyspace at <code>Client</code> level.
	 * @param {ExecutionOptions|null} executionOptions The information related to the execution of the request.
	 * @param {Function} callback The function to be invoked with the error as first parameter and the host iterator as
	 * second parameter.
	 */
	TokenAwarePolicy.prototype.newQueryPlan = function (keyspace, executionOptions, callback) {
	  let routingKey;
	  if (executionOptions) {
	    routingKey = executionOptions.getRoutingKey();
	    if (executionOptions.getKeyspace()) {
	      keyspace = executionOptions.getKeyspace();
	    }
	  }
	  let replicas;
	  if (routingKey) {
	    replicas = this.client.getReplicas(keyspace, routingKey);
	  }
	  if (!routingKey || !replicas) {
	    return this.childPolicy.newQueryPlan(keyspace, executionOptions, callback);
	  }
	  const iterator = new TokenAwareIterator(keyspace, executionOptions, replicas, this.childPolicy);
	  iterator.iterate(callback);
	};

	/**
	 * An iterator that holds the context for the subsequent next() calls
	 * @param {String} keyspace
	 * @param {ExecutionOptions} execOptions
	 * @param {Array} replicas
	 * @param childPolicy
	 * @constructor
	 * @ignore
	 */
	function TokenAwareIterator(keyspace, execOptions, replicas, childPolicy) {
	  this.keyspace = keyspace;
	  this.childPolicy = childPolicy;
	  this.options = execOptions;
	  this.localReplicas = [];
	  this.replicaIndex = 0;
	  this.replicaMap = {};
	  this.childIterator = null;
	  // Memoize the local replicas
	  // The amount of local replicas should be defined before start iterating, in order to select an
	  // appropriate (pseudo random) startIndex
	  for (let i = 0; i < replicas.length; i++) {
	    const host = replicas[i];
	    if (this.childPolicy.getDistance(host) !== types.distance.local) {
	      continue;
	    }
	    this.replicaMap[host.address] = true;
	    this.localReplicas.push(host);
	  }
	  // We use a PRNG to set the replica index
	  // We only care about proportional fair scheduling between replicas of a given token
	  // Math.random() has an extremely short permutation cycle length but we don't care about collisions
	  this.startIndex = Math.floor(Math.random() * this.localReplicas.length);
	}

	TokenAwareIterator.prototype.iterate = function (callback) {
	  //Load the child policy hosts
	  const self = this;
	  this.childPolicy.newQueryPlan(this.keyspace, this.options, function (err, iterator) {
	    if (err) {
	      return callback(err);
	    }
	    //get the iterator of the child policy in case is needed
	    self.childIterator = iterator;
	    callback(null, {
	      next: function () { return self.computeNext(); }
	    });
	  });
	};

	TokenAwareIterator.prototype.computeNext = function () {
	  let host;
	  if (this.replicaIndex < this.localReplicas.length) {
	    host = this.localReplicas[(this.startIndex + (this.replicaIndex++)) % this.localReplicas.length];
	    return { value: host, done: false };
	  }
	  // Return hosts from child policy
	  let item;
	  while ((item = this.childIterator.next()) && !item.done) {
	    if (this.replicaMap[item.value.address]) {
	      // Avoid yielding local replicas from the child load balancing policy query plan
	      continue;
	    }
	    return item;
	  }
	  return doneIteratorObject;
	};

	/**
	 * Gets an associative array containing the policy options.
	 */
	TokenAwarePolicy.prototype.getOptions = function () {
	  const map = new Map([
	    ['childPolicy', this.childPolicy.constructor !== undefined ? this.childPolicy.constructor.name : null ]
	  ]);

	  if (this.childPolicy instanceof DCAwareRoundRobinPolicy) {
	    map.set('localDataCenter', this.childPolicy.localDc);
	  }

	  return map;
	};

	/**
	 * Create a new policy that wraps the provided child policy but only "allow" hosts
	 * from the provided list.
	 * @class
	 * @classdesc
	 * A load balancing policy wrapper that ensure that only hosts from a provided
	 * allow list will ever be returned.
	 * <p>
	 * This policy wraps another load balancing policy and will delegate the choice
	 * of hosts to the wrapped policy with the exception that only hosts contained
	 * in the allow list provided when constructing this policy will ever be
	 * returned. Any host not in the while list will be considered ignored
	 * and thus will not be connected to.
	 * <p>
	 * This policy can be useful to ensure that the driver only connects to a
	 * predefined set of hosts. Keep in mind however that this policy defeats
	 * somewhat the host auto-detection of the driver. As such, this policy is only
	 * useful in a few special cases or for testing, but is not optimal in general.
	 * If all you want to do is limiting connections to hosts of the local
	 * data-center then you should use DCAwareRoundRobinPolicy and *not* this policy
	 * in particular.
	 * @param {LoadBalancingPolicy} childPolicy the wrapped policy.
	 * @param {Array.<string>}  allowList The hosts address in the format ipAddress:port.
	 * Only hosts from this list may get connected
	 * to (whether they will get connected to or not depends on the child policy).
	 * @extends LoadBalancingPolicy
	 * @constructor
	 */
	function AllowListPolicy (childPolicy, allowList) {
	  if (!childPolicy) {
	    throw new Error("You must specify a child load balancing policy");
	  }
	  if (!Array.isArray(allowList)) {
	    throw new Error("You must provide the list of allowed host addresses");
	  }

	  this.childPolicy = childPolicy;
	  this.allowList = new Map(allowList.map(address => [ address, true ]));
	}

	util.inherits(AllowListPolicy, LoadBalancingPolicy);

	AllowListPolicy.prototype.init = function (client, hosts, callback) {
	  this.childPolicy.init(client, hosts, callback);
	};

	/**
	 * Uses the child policy to return the distance to the host if included in the allow list.
	 * Any host not in the while list will be considered ignored.
	 * @param host
	 */
	AllowListPolicy.prototype.getDistance = function (host) {
	  if (!this._contains(host)) {
	    return types.distance.ignored;
	  }
	  return this.childPolicy.getDistance(host);
	};

	/**
	 * @param {Host} host
	 * @returns {boolean}
	 * @private
	 */
	AllowListPolicy.prototype._contains = function (host) {
	  return !!this.allowList.get(host.address);
	};

	/**
	 * Returns the hosts to use for a new query filtered by the allow list.
	 */
	AllowListPolicy.prototype.newQueryPlan = function (keyspace, info, callback) {
	  const self = this;
	  this.childPolicy.newQueryPlan(keyspace, info, function (err, iterator) {
	    if (err) {
	      return callback(err);
	    }
	    callback(null, self._filter(iterator));
	  });
	};

	AllowListPolicy.prototype._filter = function (childIterator) {
	  const self = this;
	  return {
	    next: function () {
	      const item = childIterator.next();
	      if (!item.done && !self._contains(item.value)) {
	        return this.next();
	      }
	      return item;
	    }
	  };
	};

	/**
	 * Gets an associative array containing the policy options.
	 */
	AllowListPolicy.prototype.getOptions = function () {
	  return new Map([
	    ['childPolicy', this.childPolicy.constructor !== undefined ? this.childPolicy.constructor.name : null ],
	    ['allowList', Array.from(this.allowList.keys())]
	  ]);
	};

	/**
	 * Creates a new instance of the policy.
	 * @classdesc
	 * Exposed for backward-compatibility only, it's recommended that you use {@link AllowListPolicy} instead.
	 * @param {LoadBalancingPolicy} childPolicy the wrapped policy.
	 * @param {Array.<string>} allowList The hosts address in the format ipAddress:port.
	 * Only hosts from this list may get connected to (whether they will get connected to or not depends on the child
	 * policy).
	 * @extends AllowListPolicy
	 * @deprecated Use allow-list instead. It will be removed in future major versions.
	 * @constructor
	 */
	function WhiteListPolicy(childPolicy, allowList) {
	  AllowListPolicy.call(this, childPolicy, allowList);
	}

	util.inherits(WhiteListPolicy, AllowListPolicy);

	/**
	 * A load-balancing policy implementation that attempts to fairly distribute the load based on the amount of in-flight
	 * request per hosts. The local replicas are initially shuffled and
	 * <a href="https://www.eecs.harvard.edu/~michaelm/postscripts/mythesis.pdf">between the first two nodes in the
	 * shuffled list, the one with fewer in-flight requests is selected as coordinator</a>.
	 *
	 * <p>
	 *   Additionally, it detects unresponsive replicas and reorders them at the back of the query plan.
	 * </p>
	 *
	 * <p>
	 *   For graph analytics queries, it uses the preferred analytics graph server previously obtained by driver as first
	 *   host in the query plan.
	 * </p>
	 */
	class DefaultLoadBalancingPolicy extends LoadBalancingPolicy {

	  /**
	   * Creates a new instance of <code>DefaultLoadBalancingPolicy</code>.
	   * @param {String|Object} [options] The local data center name or the optional policy options object.
	   * <p>
	   *   Note that when providing the local data center name, it overrides <code>localDataCenter</code> option at
	   *   <code>Client</code> level.
	   * </p>
	   * @param {String} [options.localDc] local data center name.  This value overrides the 'localDataCenter' Client option
	   * and is useful for cases where you have multiple execution profiles that you intend on using for routing
	   * requests to different data centers.
	   * @param {Function} [options.filter] A function to apply to determine if hosts are included in the query plan.
	   * The function takes a Host parameter and returns a Boolean.
	   */
	  constructor(options) {
	    super();

	    if (typeof options === 'string') {
	      options = { localDc: options };
	    } else if (!options) {
	      options = utils.emptyObject;
	    }

	    this._client = null;
	    this._hosts = null;
	    this._filteredHosts = null;
	    this._preferredHost = null;
	    this._index = 0;
	    this.localDc = options.localDc;
	    this._filter = options.filter || this._defaultFilter;

	    // Allow some checks to be injected
	    if (options.isHostNewlyUp) {
	      this._isHostNewlyUp = options.isHostNewlyUp;
	    }
	    if (options.healthCheck) {
	      this._healthCheck = options.healthCheck;
	    }
	    if (options.compare) {
	      this._compare = options.compare;
	    }
	    if (options.getReplicas) {
	      this._getReplicas = options.getReplicas;
	    }
	  }

	  /**
	   * Initializes the load balancing policy, called after the driver obtained the information of the cluster.
	   * @param {Client} client
	   * @param {HostMap} hosts
	   * @param {Function} callback
	   */
	  init(client, hosts, callback) {
	    this._client = client;
	    this._hosts = hosts;

	    // Clean local host cache
	    this._hosts.on('add', () => this._filteredHosts = null);
	    this._hosts.on('remove', () => this._filteredHosts = null);

	    try {
	      setLocalDc(this, client, this._hosts);
	    } catch (err) {
	      return callback(err);
	    }

	    callback();
	  }

	  /**
	   * Returns the distance assigned by this policy to the provided host, relatively to the client instance.
	   * @param {Host} host
	   */
	  getDistance(host) {
	    if (this._preferredHost !== null && host === this._preferredHost) {
	      // Set the last preferred host as local.
	      // It ensures that the pool for the graph analytics host has the appropriate size
	      return types.distance.local;
	    }

	    if (!this._filter(host)) {
	      return types.distance.ignored;
	    }

	    return host.datacenter === this.localDc ? types.distance.local : types.distance.ignored;
	  }

	  /**
	   * Returns a host iterator to be used for a query execution.
	   * @override
	   * @param {String} keyspace
	   * @param {ExecutionOptions} executionOptions
	   * @param {Function} callback
	   */
	  newQueryPlan(keyspace, executionOptions, callback) {
	    let routingKey;
	    let preferredHost;

	    if (executionOptions) {
	      routingKey = executionOptions.getRoutingKey();

	      if (executionOptions.getKeyspace()) {
	        keyspace = executionOptions.getKeyspace();
	      }

	      preferredHost = executionOptions.getPreferredHost();
	    }

	    let iterable;

	    if (!keyspace || !routingKey) {
	      iterable = this._getLocalHosts();
	    } else {
	      iterable = this._getReplicasAndLocalHosts(keyspace, routingKey);
	    }

	    if (preferredHost) {
	      // Set it on an instance level field to set the distance
	      this._preferredHost = preferredHost;
	      iterable = DefaultLoadBalancingPolicy._getPreferredHostFirst(preferredHost, iterable);
	    }

	    return callback(null, iterable);
	  }

	  /**
	   * Yields the preferred host first, followed by the host in the provided iterable
	   * @param preferredHost
	   * @param iterable
	   * @private
	   */
	  static *_getPreferredHostFirst(preferredHost, iterable) {
	    yield preferredHost;

	    for (const host of iterable) {
	      if (host !== preferredHost) {
	        yield host;
	      }
	    }
	  }

	  /**
	   * Yields the local hosts without the replicas already yielded
	   * @param {Array<Host>} [localReplicas] The local replicas that we should avoid to include again
	   * @private
	   */
	  *_getLocalHosts(localReplicas) {
	    // Use a local reference
	    const hosts = this._getFilteredLocalHosts();
	    const initialIndex = this._getIndex();

	    // indexOf() over an Array is a O(n) operation but given that there should be 3 to 7 replicas,
	    // it shouldn't be an expensive call. Additionally, this will only be executed when the local replicas
	    // have been exhausted in a lazy manner.
	    const canBeYield = localReplicas
	      ? h => localReplicas.indexOf(h) === -1
	      : h => true;

	    for (let i = 0; i < hosts.length; i++) {
	      const h = hosts[(i + initialIndex) % hosts.length];
	      if (canBeYield(h) && h.isUp()) {
	        yield h;
	      }
	    }
	  }

	  _getReplicasAndLocalHosts(keyspace, routingKey) {
	    let replicas = this._getReplicas(keyspace, routingKey);
	    if (replicas === null) {
	      return this._getLocalHosts();
	    }

	    const filteredReplicas = [];
	    let newlyUpReplica = null;
	    let newlyUpReplicaTimestamp = Number.MIN_SAFE_INTEGER;
	    let unhealthyReplicas = 0;

	    // Filter by DC, predicate and UP replicas
	    // Use the same iteration to perform other checks: whether if its newly UP or unhealthy
	    // As this is part of the hot path, we use a simple loop and avoid using Array.prototype.filter() + closure
	    for (let i = 0; i < replicas.length; i++) {
	      const h = replicas[i];
	      if (!this._filter(h) || h.datacenter !== this.localDc || !h.isUp()) {
	        continue;
	      }
	      const isUpSince = this._isHostNewlyUp(h);
	      if (isUpSince !== null && isUpSince > newlyUpReplicaTimestamp) {
	        newlyUpReplica = h;
	        newlyUpReplicaTimestamp = isUpSince;
	      }
	      if (newlyUpReplica === null && !this._healthCheck(h)) {
	        unhealthyReplicas++;
	      }
	      filteredReplicas.push(h);
	    }

	    replicas = filteredReplicas;

	    // Shuffle remaining local replicas
	    utils.shuffleArray(replicas);

	    if (replicas.length < 3) {
	      // Avoid reordering replicas of a set of 2 as we could be doing more harm than good
	      return this.yieldReplicasFirst(replicas);
	    }

	    let temp;

	    if (newlyUpReplica === null) {
	      if (unhealthyReplicas > 0 && unhealthyReplicas < Math.floor(replicas.length / 2 + 1)) {
	        // There is one or more unhealthy replicas and there is a majority of healthy replicas
	        this._sendUnhealthyToTheBack(replicas, unhealthyReplicas);
	      }
	    }
	    else if ((newlyUpReplica === replicas[0] || newlyUpReplica === replicas[1]) && Math.random() * 4 >= 1) {
	      // There is a newly UP replica and the replica in first or second position is the most recent replica
	      // marked as UP and dice roll 1d4!=1 -> Send it to the back of the Array
	      const index = newlyUpReplica === replicas[0] ? 0 : 1;
	      temp = replicas[replicas.length - 1];
	      replicas[replicas.length - 1] = replicas[index];
	      replicas[index] = temp;
	    }

	    if (this._compare(replicas[1], replicas[0]) > 0) {
	      // Power of two random choices
	      temp = replicas[0];
	      replicas[0] = replicas[1];
	      replicas[1] = temp;
	    }

	    return this.yieldReplicasFirst(replicas);
	  }

	  /**
	   * Yields the local replicas followed by the rest of local nodes.
	   * @param {Array<Host>} replicas The local replicas
	   */
	  *yieldReplicasFirst(replicas) {
	    for (let i = 0; i < replicas.length; i++) {
	      yield replicas[i];
	    }
	    yield* this._getLocalHosts(replicas);
	  }

	  _isHostNewlyUp(h) {
	    return (h.isUpSince !== null && Date.now() - h.isUpSince < newlyUpInterval) ? h.isUpSince : null;
	  }

	  /**
	   * Returns a boolean determining whether the host health is ok or not.
	   * A Host is considered unhealthy when there are enough items in the queue (10 items in-flight) but the
	   * Host is not responding to those requests.
	   * @param {Host} h
	   * @return {boolean}
	   * @private
	   */
	  _healthCheck(h) {
	    return !(h.getInFlight() >= 10 && h.getResponseCount() <= 1);
	  }

	  /**
	   * Compares to host and returns 1 if it needs to favor the first host otherwise, -1.
	   * @return {number}
	   * @private
	   */
	  _compare(h1, h2) {
	    return h1.getInFlight() < h2.getInFlight() ? 1 : -1;
	  }

	  _getReplicas(keyspace, routingKey) {
	    return this._client.getReplicas(keyspace, routingKey);
	  }

	  /**
	   * Returns an Array of hosts filtered by DC and predicate.
	   * @returns {Array<Host>}
	   * @private
	   */
	  _getFilteredLocalHosts() {
	    if (this._filteredHosts === null) {
	      this._filteredHosts = this._hosts.values()
	        .filter(h => this._filter(h) && h.datacenter === this.localDc);
	    }
	    return this._filteredHosts;
	  }

	  _getIndex() {
	    const result = this._index++;
	    // Overflow protection
	    if (this._index === 0x7fffffff) {
	      this._index = 0;
	    }
	    return result;
	  }

	  _sendUnhealthyToTheBack(replicas, unhealthyReplicas) {
	    let counter = 0;

	    // Start from the back, move backwards and stop once all unhealthy replicas are at the back
	    for (let i = replicas.length - 1; i >= 0 && counter < unhealthyReplicas; i--) {
	      const host = replicas[i];
	      if (this._healthCheck(host)) {
	        continue;
	      }

	      const targetIndex = replicas.length - 1 - counter;
	      if (targetIndex !== i) {
	        const temp = replicas[targetIndex];
	        replicas[targetIndex] = host;
	        replicas[i] = temp;
	      }
	      counter++;
	    }
	  }

	  _defaultFilter() {
	    return true;
	  }

	  /**
	   * Gets an associative array containing the policy options.
	   */
	  getOptions() {
	    return new Map([
	      ['localDataCenter', this.localDc ],
	      ['filterFunction', this._filter !== this._defaultFilter ]
	    ]);
	  }
	}

	/**
	 * Validates and sets the local data center to be used.
	 * @param {LoadBalancingPolicy} lbp
	 * @param {Client} client
	 * @param {HostMap} hosts
	 * @private
	 */
	function setLocalDc(lbp, client, hosts) {
	  if (!(lbp instanceof LoadBalancingPolicy)) {
	    throw new errors.DriverInternalError('LoadBalancingPolicy instance was not provided');
	  }

	  if (client && client.options) {
	    if (lbp.localDc && !client.options.localDataCenter) {
	      client.log('info', `Local data center '${lbp.localDc}' was provided as an argument to the load-balancing` +
	        ` policy. It is preferable to specify the local data center using 'localDataCenter' in Client` +
	        ` options instead when your application is targeting a single data center.`);
	    }

	    // If localDc is unset, use value set in client options.
	    lbp.localDc = lbp.localDc || client.options.localDataCenter;
	  }

	  const dcs = getDataCenters(hosts);

	  if (!lbp.localDc) {
	    throw new errors.ArgumentError(
	      `'localDataCenter' is not defined in Client options and also was not specified in constructor.` +
	      ` At least one is required. Available DCs are: [${Array.from(dcs)}]`);
	  }

	  if (!dcs.has(lbp.localDc)) {
	    throw new errors.ArgumentError(`Datacenter ${lbp.localDc} was not found. Available DCs are: [${Array.from(dcs)}]`);
	  }
	}

	function getDataCenters(hosts) {
	  return new Set(hosts.values().map(h => h.datacenter));
	}

	loadBalancing = {
	  AllowListPolicy,
	  DCAwareRoundRobinPolicy,
	  DefaultLoadBalancingPolicy,
	  LoadBalancingPolicy,
	  RoundRobinPolicy,
	  TokenAwarePolicy,
	  // Deprecated: for backward compatibility only.
	  WhiteListPolicy
	};
	return loadBalancing;
}

var reconnection = {};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const util$y = require$$0$4;

/** @module policies/reconnection */
/**
 * Base class for Reconnection Policies
 * @constructor
 */
function ReconnectionPolicy() {

}

/**
 * A new reconnection schedule.
 * @returns {{next: function}} An infinite iterator
 */
ReconnectionPolicy.prototype.newSchedule = function () {
  throw new Error('You must implement a new schedule for the Reconnection class');
};

/**
 * Gets an associative array containing the policy options.
 */
ReconnectionPolicy.prototype.getOptions = function () {
  return new Map();
};

/**
 * A reconnection policy that waits a constant time between each reconnection attempt.
 * @param {Number} delay Delay in ms
 * @constructor
 */
function ConstantReconnectionPolicy(delay) {
  this.delay = delay;
}

util$y.inherits(ConstantReconnectionPolicy, ReconnectionPolicy);

/**
 * A new reconnection schedule that returns the same next delay value
 * @returns {{next: Function}} An infinite iterator
 */
ConstantReconnectionPolicy.prototype.newSchedule = function () {
  const self = this;
  return {
    next: function () {
      return {value: self.delay, done: false};
    }
  };
};

/**
 * Gets an associative array containing the policy options.
 */
ConstantReconnectionPolicy.prototype.getOptions = function () {
  return new Map([['delay', this.delay ]]);
};

/**
 * A reconnection policy that waits exponentially longer between each
 * reconnection attempt (but keeps a constant delay once a maximum delay is reached).
 * <p>
 *   A random amount of jitter (+/- 15%) will be added to the pure exponential delay value to avoid situations
 *   where many clients are in the reconnection process at exactly the same time. The jitter will never cause the
 *   delay to be less than the base delay, or more than the max delay.
 * </p>
 * @param {Number} baseDelay The base delay in milliseconds to use for the schedules created by this policy.
 * @param {Number} maxDelay The maximum delay in milliseconds to wait between two reconnection attempt.
 * @param {Boolean} startWithNoDelay Determines if the first attempt should be zero delay
 * @constructor
 */
function ExponentialReconnectionPolicy(baseDelay, maxDelay, startWithNoDelay) {
  this.baseDelay = baseDelay;
  this.maxDelay = maxDelay;
  this.startWithNoDelay = startWithNoDelay;
}

util$y.inherits(ExponentialReconnectionPolicy, ReconnectionPolicy);

/**
 * A new schedule that uses an exponentially growing delay between reconnection attempts.
 * @returns {{next: Function}} An infinite iterator.
 */
ExponentialReconnectionPolicy.prototype.newSchedule = function* () {
  let index = this.startWithNoDelay ? -1 : 0;

  while (true) {
    let delay = 0;

    if (index >= 64) {
      delay = this.maxDelay;
    } else if (index !== -1) {
      delay = Math.min(Math.pow(2, index) * this.baseDelay, this.maxDelay);
    }

    index++;

    yield this._addJitter(delay);
  }
};

/**
 * Adds a random portion of +-15% to the delay provided.
 * Initially, its adds a random value of 15% to avoid reconnection before reaching the base delay.
 * When the schedule reaches max delay, only subtracts a random portion of 15%.
 */
ExponentialReconnectionPolicy.prototype._addJitter = function (value) {
  if (value === 0) {
    // Instant reconnection without jitter
    return value;
  }

  // Use the formula: 85% + rnd() * 30% to calculate the percentage of the original delay
  let minPercentage = 0.85;
  let range = 0.30;

  if (!this.startWithNoDelay && value === this.baseDelay) {
    // Between 100% to 115% of the original value
    minPercentage = 1;
    range = 0.15;
  } else if (value === this.maxDelay) {
    // Between 85% to 100% of the original value
    range = 0.15;
  }

  return Math.floor(value * (Math.random() * range + minPercentage));
};

/**
 * Gets an associative array containing the policy options.
 */
ExponentialReconnectionPolicy.prototype.getOptions = function () {
  return new Map([
    ['baseDelay', this.baseDelay ],
    ['maxDelay', this.maxDelay ],
    ['startWithNoDelay', this.startWithNoDelay ]
  ]);
};

reconnection.ReconnectionPolicy = ReconnectionPolicy;
reconnection.ConstantReconnectionPolicy = ConstantReconnectionPolicy;
reconnection.ExponentialReconnectionPolicy = ExponentialReconnectionPolicy;

var retry$1 = {};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const util$x = require$$0$4;


/** @module policies/retry */
/**
 * Base and default RetryPolicy.
 * Determines what to do when the drivers runs into an specific Cassandra exception
 * @constructor
 */
function RetryPolicy() {

}

/**
 * Determines what to do when the driver gets an UnavailableException response from a Cassandra node.
 * @param {OperationInfo} info
 * @param {Number} consistency The [consistency]{@link module:types~consistencies} level of the query that triggered
 * the exception.
 * @param {Number} required The number of replicas whose response is required to achieve the
 * required [consistency]{@link module:types~consistencies}.
 * @param {Number} alive The number of replicas that were known to be alive when the request had been processed
 * (since an unavailable exception has been triggered, there will be alive &lt; required)
 * @returns {DecisionInfo}
 */
RetryPolicy.prototype.onUnavailable = function (info, consistency, required, alive) {
  if (info.nbRetry > 0) {
    return this.rethrowResult();
  }
  return this.retryResult(undefined, false);
};

/**
 * Determines what to do when the driver gets a ReadTimeoutException response from a Cassandra node.
 * @param {OperationInfo} info
 * @param {Number} consistency The [consistency]{@link module:types~consistencies} level of the query that triggered
 * the exception.
 * @param {Number} received The number of nodes having answered the request.
 * @param {Number} blockFor The number of replicas whose response is required to achieve the
 * required [consistency]{@link module:types~consistencies}.
 * @param {Boolean} isDataPresent When <code>false</code>, it means the replica that was asked for data has not responded.
 * @returns {DecisionInfo}
 */
RetryPolicy.prototype.onReadTimeout = function (info, consistency, received, blockFor, isDataPresent) {
  if (info.nbRetry > 0) {
    return this.rethrowResult();
  }
  return ((received >= blockFor && !isDataPresent) ?
    this.retryResult() :
    this.rethrowResult());
};

/**
 * Determines what to do when the driver gets a WriteTimeoutException response from a Cassandra node.
 * @param {OperationInfo} info
 * @param {Number} consistency The [consistency]{@link module:types~consistencies} level of the query that triggered
 * the exception.
 * @param {Number} received The number of nodes having acknowledged the request.
 * @param {Number} blockFor The number of replicas whose acknowledgement is required to achieve the required
 * [consistency]{@link module:types~consistencies}.
 * @param {String} writeType A <code>string</code> that describes the type of the write that timed out ("SIMPLE"
 * / "BATCH" / "BATCH_LOG" / "UNLOGGED_BATCH" / "COUNTER").
 * @returns {DecisionInfo}
 */
RetryPolicy.prototype.onWriteTimeout = function (info, consistency, received, blockFor, writeType) {
  if (info.nbRetry > 0) {
    return this.rethrowResult();
  }
  // If the batch log write failed, retry the operation as this might just be we were unlucky at picking candidates
  return writeType === "BATCH_LOG" ? this.retryResult() : this.rethrowResult();
};

/**
 * Defines whether to retry and at which consistency level on an unexpected error.
 * <p>
 * This method might be invoked in the following situations:
 * </p>
 * <ol>
 * <li>On a client timeout, while waiting for the server response
 * (see [socketOptions.readTimeout]{@link ClientOptions}), being the error an instance of
 * [OperationTimedOutError]{@link module:errors~OperationTimedOutError}.</li>
 * <li>On a connection error (socket closed, etc.).</li>
 * <li>When the contacted host replies with an error, such as <code>overloaded</code>, <code>isBootstrapping</code>,
 * </code>serverError, etc. In this case, the error is instance of [ResponseError]{@link module:errors~ResponseError}.
 * </li>
 * </ol>
 * <p>
 * Note that when this method is invoked, <em>the driver cannot guarantee that the mutation has been effectively
 * applied server-side</em>; a retry should only be attempted if the request is known to be idempotent.
 * </p>
 * @param {OperationInfo} info
 * @param {Number|undefined} consistency The [consistency]{@link module:types~consistencies} level of the query that triggered
 * the exception.
 * @param {Error} err The error that caused this request to fail.
 * @returns {DecisionInfo}
 */
RetryPolicy.prototype.onRequestError = function (info, consistency, err) {
  // The default implementation triggers a retry on the next host in the query plan with the same consistency level,
  // regardless of the statement's idempotence, for historical reasons.
  return this.retryResult(undefined, false);
};

/**
 * Returns a {@link DecisionInfo} to retry the request with the given [consistency]{@link module:types~consistencies}.
 * @param {Number|undefined} [consistency] When specified, it retries the request with the given consistency.
 * @param {Boolean} [useCurrentHost] When specified, determines if the retry should be made using the same coordinator.
 * Default: true.
 * @returns {DecisionInfo}
 */
RetryPolicy.prototype.retryResult = function (consistency, useCurrentHost) {
  return {
    decision: RetryPolicy.retryDecision.retry,
    consistency: consistency,
    useCurrentHost: useCurrentHost !== false
  };
};

/**
 * Returns a {@link DecisionInfo} to callback in error when a err is obtained for a given request.
 * @returns {DecisionInfo}
 */
RetryPolicy.prototype.rethrowResult = function () {
  return { decision: RetryPolicy.retryDecision.rethrow };
};

/**
 * Determines the retry decision for the retry policies.
 * @type {Object}
 * @property {Number} rethrow
 * @property {Number} retry
 * @property {Number} ignore
 * @static
 */
RetryPolicy.retryDecision = {
  rethrow:  0,
  retry:    1,
  ignore:   2
};

/**
 * Creates a new instance of <code>IdempotenceAwareRetryPolicy</code>.
 * @classdesc
 * A retry policy that avoids retrying non-idempotent statements.
 * <p>
 * In case of write timeouts or unexpected errors, this policy will always return
 * [rethrowResult()]{@link module:policies/retry~RetryPolicy#rethrowResult} if the statement is deemed non-idempotent
 * (see [QueryOptions.isIdempotent]{@link QueryOptions}).
 * <p/>
 * For all other cases, this policy delegates the decision to the child policy.
 * @param {RetryPolicy} [childPolicy] The child retry policy to wrap. When not defined, it will use an instance of
 * [RetryPolicy]{@link module:policies/retry~RetryPolicy} as child policy.
 * @extends module:policies/retry~RetryPolicy
 * @constructor
 * @deprecated Since version 4.0 non-idempotent operations are never tried for write timeout or request error, use the
 * default retry policy instead.
 */
function IdempotenceAwareRetryPolicy(childPolicy) {
  this._childPolicy = childPolicy || new RetryPolicy();
}

util$x.inherits(IdempotenceAwareRetryPolicy, RetryPolicy);

IdempotenceAwareRetryPolicy.prototype.onReadTimeout = function (info, consistency, received, blockFor, isDataPresent) {
  return this._childPolicy.onReadTimeout(info, consistency, received, blockFor, isDataPresent);
};

/**
 * If the query is not idempotent, it returns a rethrow decision. Otherwise, it relies on the child policy to decide.
 */
IdempotenceAwareRetryPolicy.prototype.onRequestError = function (info, consistency, err) {
  if (info.executionOptions.isIdempotent()) {
    return this._childPolicy.onRequestError(info, consistency, err);
  }
  return this.rethrowResult();
};

IdempotenceAwareRetryPolicy.prototype.onUnavailable = function (info, consistency, required, alive) {
  return this._childPolicy.onUnavailable(info, consistency, required, alive);
};

/**
 * If the query is not idempotent, it return a rethrow decision. Otherwise, it relies on the child policy to decide.
 */
IdempotenceAwareRetryPolicy.prototype.onWriteTimeout = function (info, consistency, received, blockFor, writeType) {
  if (info.executionOptions.isIdempotent()) {
    return this._childPolicy.onWriteTimeout(info, consistency, received, blockFor, writeType);
  }
  return this.rethrowResult();
};

/**
 * Creates a new instance of FallthroughRetryPolicy.
 * @classdesc
 * A retry policy that never retries nor ignores.
 * <p>
 * All of the methods of this retry policy unconditionally return
 * [rethrow]{@link module:policies/retry~Retry#rethrowResult()}. If this policy is used, retry logic will have to be
 * implemented in business code.
 * </p>
 * @alias module:policies/retry~FallthroughRetryPolicy
 * @extends RetryPolicy
 * @constructor
 */
function FallthroughRetryPolicy() {

}

util$x.inherits(FallthroughRetryPolicy, RetryPolicy);

/**
 * Implementation of RetryPolicy method that returns [rethrow]{@link module:policies/retry~Retry#rethrowResult()}.
 */
FallthroughRetryPolicy.prototype.onReadTimeout = function () {
  return this.rethrowResult();
};

/**
 * Implementation of RetryPolicy method that returns [rethrow]{@link module:policies/retry~Retry#rethrowResult()}.
 */
FallthroughRetryPolicy.prototype.onRequestError = function () {
  return this.rethrowResult();
};

/**
 * Implementation of RetryPolicy method that returns [rethrow]{@link module:policies/retry~Retry#rethrowResult()}.
 */
FallthroughRetryPolicy.prototype.onUnavailable = function () {
  return this.rethrowResult();
};

/**
 * Implementation of RetryPolicy method that returns [rethrow]{@link module:policies/retry~Retry#rethrowResult()}.
 */
FallthroughRetryPolicy.prototype.onWriteTimeout = function () {
  return this.rethrowResult();
};

/**
 * Decision information
 * @typedef {Object} DecisionInfo
 * @property {Number} decision The decision as specified in
 * [retryDecision]{@link module:policies/retry~RetryPolicy.retryDecision}.
 * @property {Number} [consistency] The [consistency level]{@link module:types~consistencies}.
 * @property {useCurrentHost} [useCurrentHost] Determines if it should use the same host to retry the request.
 * <p>
 *   In the case that the current host is not available anymore, it will be retried on the next host even when
 *   <code>useCurrentHost</code> is set to <code>true</code>.
 * </p>
 */

/**
 * Information of the execution to be used to determine whether the operation should be retried.
 * @typedef {Object} OperationInfo
 * @property {String} query The query that was executed.
 * @param {ExecutionOptions} executionOptions The options related to the execution of the request.
 * @property {Number} nbRetry The number of retries already performed for this operation.
 */

retry$1.IdempotenceAwareRetryPolicy = IdempotenceAwareRetryPolicy;
retry$1.FallthroughRetryPolicy = FallthroughRetryPolicy;
retry$1.RetryPolicy = RetryPolicy;

var speculativeExecution = {};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const util$w = require$$0$4;
const errors$l = errors$n;

/** @module policies/speculativeExecution */

/**
 * @classdesc
 * The policy that decides if the driver will send speculative queries to the next hosts when the current host takes too
 * long to respond.
 * <p>Note that only idempotent statements will be speculatively retried.</p>
 * @constructor
 * @abstract
 */
function SpeculativeExecutionPolicy() {
  
}

/**
 * Initialization method that gets invoked on Client startup.
 * @param {Client} client
 * @abstract
 */
SpeculativeExecutionPolicy.prototype.init = function (client) {

};

/**
 * Gets invoked at client shutdown, giving the opportunity to the implementor to perform cleanup.
 * @abstract
 */
SpeculativeExecutionPolicy.prototype.shutdown = function () {

};

/**
 * Gets the plan to use for a new query.
 * Returns an object with a <code>nextExecution()</code> method, which returns a positive number representing the
 * amount of milliseconds to delay the next execution or a non-negative number to avoid further executions.
 * @param {String} keyspace The currently logged keyspace.
 * @param {String|Array<String>} queryInfo The query, or queries in the case of batches, for which to build a plan.
 * @return {{nextExecution: function}}
 * @abstract
 */
SpeculativeExecutionPolicy.prototype.newPlan = function (keyspace, queryInfo) {
  throw new Error('You must implement newPlan() method in the SpeculativeExecutionPolicy');
};

/**
 * Gets an associative array containing the policy options.
 */
SpeculativeExecutionPolicy.prototype.getOptions = function () {
  return new Map();
};

/**
 * Creates a new instance of NoSpeculativeExecutionPolicy.
 * @classdesc
 * A {@link SpeculativeExecutionPolicy} that never schedules speculative executions.
 * @constructor
 * @extends {SpeculativeExecutionPolicy}
 */
function NoSpeculativeExecutionPolicy() {
  this._plan = {
    nextExecution: function () {
      return -1;
    }
  };
}

util$w.inherits(NoSpeculativeExecutionPolicy, SpeculativeExecutionPolicy);

NoSpeculativeExecutionPolicy.prototype.newPlan = function () {
  return this._plan;
};


/**
 * Creates a new instance of ConstantSpeculativeExecutionPolicy.
 * @classdesc
 * A {@link SpeculativeExecutionPolicy} that schedules a given number of speculative executions,
 * separated by a fixed delay.
 * @constructor
 * @param {Number} delay The delay between each speculative execution.
 * @param {Number} maxSpeculativeExecutions The amount of speculative executions that should be scheduled after the
 * initial execution. Must be strictly positive.
 * @extends {SpeculativeExecutionPolicy}
 */
function ConstantSpeculativeExecutionPolicy(delay, maxSpeculativeExecutions) {
  if (!(delay >= 0)) {
    throw new errors$l.ArgumentError('delay must be a positive number or zero');
  }
  if (!(maxSpeculativeExecutions > 0)) {
    throw new errors$l.ArgumentError('maxSpeculativeExecutions must be a positive number');
  }
  this._delay = delay;
  this._maxSpeculativeExecutions = maxSpeculativeExecutions;
}

util$w.inherits(ConstantSpeculativeExecutionPolicy, SpeculativeExecutionPolicy);

ConstantSpeculativeExecutionPolicy.prototype.newPlan = function () {
  let executions = 0;
  const self = this;
  return {
    nextExecution: function () {
      if (executions++ < self._maxSpeculativeExecutions) {
        return self._delay;
      }
      return -1;
    }
  };
};

/**
 * Gets an associative array containing the policy options.
 */
ConstantSpeculativeExecutionPolicy.prototype.getOptions = function () {
  return new Map([
    ['delay', this._delay ],
    ['maxSpeculativeExecutions', this._maxSpeculativeExecutions ]
  ]);
};

speculativeExecution.NoSpeculativeExecutionPolicy = NoSpeculativeExecutionPolicy;
speculativeExecution.SpeculativeExecutionPolicy = SpeculativeExecutionPolicy;
speculativeExecution.ConstantSpeculativeExecutionPolicy = ConstantSpeculativeExecutionPolicy;

var timestampGeneration = {};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var hasRequiredTimestampGeneration;

function requireTimestampGeneration () {
	if (hasRequiredTimestampGeneration) return timestampGeneration;
	hasRequiredTimestampGeneration = 1;

	const util = require$$0$4;
	const { Long } = requireTypes();
	const errors = errors$n;

	/** @module policies/timestampGeneration */

	/**
	 * Defines the maximum date in milliseconds that can be represented in microseconds using Number ((2 ^ 53) / 1000)
	 * @const
	 * @private
	 */
	const _maxSafeNumberDate = 9007199254740;

	/**
	 * A long representing the value 1000
	 * @const
	 * @private
	 */
	const _longOneThousand = Long.fromInt(1000);

	/**
	 * Creates a new instance of {@link TimestampGenerator}.
	 * @classdesc
	 * Generates client-side, microsecond-precision query timestamps.
	 * <p>
	 *   Given that Cassandra uses those timestamps to resolve conflicts, implementations should generate
	 *   monotonically increasing timestamps for successive invocations of {@link TimestampGenerator.next()}.
	 * </p>
	 * @constructor
	 */
	function TimestampGenerator() {

	}

	/**
	 * Returns the next timestamp.
	 * <p>
	 *   Implementors should enforce increasing monotonicity of timestamps, that is,
	 *   a timestamp returned should always be strictly greater that any previously returned
	 *   timestamp.
	 * <p/>
	 * <p>
	 *   Implementors should strive to achieve microsecond precision in the best possible way,
	 *   which is usually largely dependent on the underlying operating system's capabilities.
	 * </p>
	 * @param {Client} client The {@link Client} instance to generate timestamps to.
	 * @returns {Long|Number|null} the next timestamp (in microseconds). If it's equals to <code>null</code>, it won't be
	 * sent by the driver, letting the server to generate the timestamp.
	 * @abstract
	 */
	TimestampGenerator.prototype.next = function (client) {
	  throw new Error('next() must be implemented');
	};

	/**
	 * A timestamp generator that guarantees monotonically increasing timestamps and logs warnings when timestamps
	 * drift in the future.
	 * <p>
	 *   {@link Date} has millisecond precision and client timestamps require microsecond precision. This generator
	 *   keeps track of the last generated timestamp, and if the current time is within the same millisecond as the last,
	 *   it fills the microsecond portion of the new timestamp with the value of an incrementing counter.
	 * </p>
	 * @param {Number} [warningThreshold] Determines how far in the future timestamps are allowed to drift before a
	 * warning is logged, expressed in milliseconds. Default: <code>1000</code>.
	 * @param {Number} [minLogInterval] In case of multiple log events, it determines the time separation between log
	 * events, expressed in milliseconds. Use 0 to disable. Default: <code>1000</code>.
	 * @extends {TimestampGenerator}
	 * @constructor
	 */
	function MonotonicTimestampGenerator(warningThreshold, minLogInterval) {
	  if (warningThreshold < 0) {
	    throw new errors.ArgumentError('warningThreshold can not be lower than 0');
	  }
	  this._warningThreshold = warningThreshold || 1000;
	  this._minLogInterval = 1000;
	  if (typeof minLogInterval === 'number') {
	    // A value under 1 will disable logging
	    this._minLogInterval = minLogInterval;
	  }
	  this._micros = -1;
	  this._lastDate = 0;
	  this._lastLogDate = 0;
	}

	util.inherits(MonotonicTimestampGenerator, TimestampGenerator);

	/**
	 * Returns the current time in milliseconds since UNIX epoch
	 * @returns {Number}
	 */
	MonotonicTimestampGenerator.prototype.getDate = function () {
	  return Date.now();
	};

	MonotonicTimestampGenerator.prototype.next = function (client) {
	  let date = this.getDate();
	  let drifted = 0;
	  if (date > this._lastDate) {
	    this._micros = 0;
	    this._lastDate = date;
	    return this._generateMicroseconds();
	  }

	  if (date < this._lastDate) {
	    drifted = this._lastDate - date;
	    date = this._lastDate;
	  }
	  if (++this._micros === 1000) {
	    this._micros = 0;
	    if (date === this._lastDate) {
	      // Move date 1 millisecond into the future
	      date++;
	      drifted++;
	    }
	  }
	  const lastDate = this._lastDate;
	  this._lastDate = date;
	  const result = this._generateMicroseconds();
	  if (drifted >= this._warningThreshold) {
	    // Avoid logging an unbounded amount of times within a clock-skew event or during an interval when more than 1
	    // query is being issued by microsecond
	    const currentLogDate = Date.now();
	    if (this._minLogInterval > 0 && this._lastLogDate + this._minLogInterval <= currentLogDate){
	      const message = util.format(
	        'Timestamp generated using current date was %d milliseconds behind the last generated timestamp (which ' +
	        'millisecond portion was %d), the returned value (%s) is being artificially incremented to guarantee ' +
	        'monotonicity.',
	        drifted, lastDate, result);
	      this._lastLogDate = currentLogDate;
	      client.log('warning', message);
	    }
	  }
	  return result;
	};

	/**
	 * @private
	 * @returns {Number|Long}
	 */
	MonotonicTimestampGenerator.prototype._generateMicroseconds = function () {
	  if (this._lastDate < _maxSafeNumberDate) {
	    // We are safe until Jun 06 2255, its faster to perform this operations on Number than on Long
	    // We hope to have native int64 by then :)
	    return this._lastDate * 1000 + this._micros;
	  }
	  return Long
	    .fromNumber(this._lastDate)
	    .multiply(_longOneThousand)
	    .add(Long.fromInt(this._micros));
	};

	timestampGeneration.TimestampGenerator = TimestampGenerator;
	timestampGeneration.MonotonicTimestampGenerator = MonotonicTimestampGenerator;
	return timestampGeneration;
}

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var hasRequiredPolicies;

function requirePolicies () {
	if (hasRequiredPolicies) return policies$1;
	hasRequiredPolicies = 1;

	/**
	 * Contains driver tuning policies to determine [load balancing]{@link module:policies/loadBalancing},
	 *  [retrying]{@link module:policies/retry} queries, [reconnecting]{@link module:policies/reconnection} to a node,
	 *  [address resolution]{@link module:policies/addressResolution},
	 *  [timestamp generation]{@link module:policies/timestampGeneration} and
	 *  [speculative execution]{@link module:policies/speculativeExecution}.
	 * @module policies
	 */
	const addressResolution$1 = policies$1.addressResolution = addressResolution;
	const loadBalancing = policies$1.loadBalancing = requireLoadBalancing();
	const reconnection$1 = policies$1.reconnection = reconnection;
	const retry = policies$1.retry = retry$1;
	const speculativeExecution$1 = policies$1.speculativeExecution = speculativeExecution;
	const timestampGeneration = policies$1.timestampGeneration = requireTimestampGeneration();

	/**
	 * Returns a new instance of the default address translator policy used by the driver.
	 * @returns {AddressTranslator}
	 */
	policies$1.defaultAddressTranslator = function () {
	  return new addressResolution$1.AddressTranslator();
	};

	/**
	 * Returns a new instance of the default load-balancing policy used by the driver.
	 * @param {string} [localDc] When provided, it sets the data center that is going to be used as local for the
	 * load-balancing policy instance.
	 * <p>When localDc is undefined, the load-balancing policy instance will use the <code>localDataCenter</code>
	 * provided in the {@link ClientOptions}.</p>
	 * @returns {LoadBalancingPolicy}
	 */
	policies$1.defaultLoadBalancingPolicy = function (localDc) {
	  return new loadBalancing.DefaultLoadBalancingPolicy(localDc);
	};

	/**
	 * Returns a new instance of the default retry policy used by the driver.
	 * @returns {RetryPolicy}
	 */
	policies$1.defaultRetryPolicy = function () {
	  return new retry.RetryPolicy();
	};

	/**
	 * Returns a new instance of the default reconnection policy used by the driver.
	 * @returns {ReconnectionPolicy}
	 */
	policies$1.defaultReconnectionPolicy = function () {
	  return new reconnection$1.ExponentialReconnectionPolicy(1000, 10 * 60 * 1000, false);
	};


	/**
	 * Returns a new instance of the default speculative execution policy used by the driver.
	 * @returns {SpeculativeExecutionPolicy}
	 */
	policies$1.defaultSpeculativeExecutionPolicy = function () {
	  return new speculativeExecution$1.NoSpeculativeExecutionPolicy();
	};

	/**
	 * Returns a new instance of the default timestamp generator used by the driver.
	 * @returns {TimestampGenerator}
	 */
	policies$1.defaultTimestampGenerator = function () {
	  return new timestampGeneration.MonotonicTimestampGenerator();
	};
	return policies$1;
}

var tracker = {};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Tracks request execution for a {@link Client}.
 * <p>
 *   A {@link RequestTracker} can be configured in the client options. The <code>Client</code> will execute
 *   {@link RequestTracker#onSuccess} or {@link RequestTracker#onError} for every query or batch
 *   executed (QUERY, EXECUTE and BATCH requests).
 * </p>
 * @interface
 * @alias module:tracker~RequestTracker
 */
let RequestTracker$1 = class RequestTracker {

  /**
   * Invoked each time a query or batch request succeeds.
   * @param {Host} host The node that acted as coordinator of the request.
   * @param {String|Array} query In the case of prepared or unprepared query executions, the provided
   * query string. For batch requests, an Array containing the queries and parameters provided.
   * @param {Array|Object|null} parameters In the case of prepared or unprepared query executions, the provided
   * parameters.
   * @param {ExecutionOptions} executionOptions The information related to the execution of the request.
   * @param {Number} requestLength Length of the body of the request.
   * @param {Number} responseLength Length of the body of the response.
   * @param {Array<Number>} latency An array containing [seconds, nanoseconds] tuple, where nanoseconds is the
   * remaining part of the real time that can't be represented in second precision (see <code>process.hrtime()</code>).
   */
  onSuccess(host, query, parameters, executionOptions, requestLength, responseLength, latency) {

  }

  /**
   * Invoked each time a query or batch request fails.
   * @param {Host} host The node that acted as coordinator of the request.
   * @param {String|Array} query In the case of prepared or unprepared query executions, the provided
   * query string. For batch requests, an Array containing the queries and parameters provided.
   * @param {Array|Object|null} parameters In the case of prepared or unprepared query executions, the provided
   * parameters.
   * @param {ExecutionOptions} executionOptions The information related to the execution of the request.
   * @param {Number} requestLength Length of the body of the request. When the failure occurred before the request was
   * written to the wire, the length will be <code>0</code>.
   * @param {Error} err The error that caused that caused the request to fail.
   * @param {Array<Number>} latency An array containing [seconds, nanoseconds] tuple, where nanoseconds is the
   * remaining part of the real time that can't be represented in second precision (see <code>process.hrtime()</code>).
   */
  onError(host, query, parameters, executionOptions, requestLength, err, latency) {

  }

  /**
   * Invoked when the Client is being shutdown.
   */
  shutdown() {

  }
};

var requestTracker = RequestTracker$1;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const events$9 = require$$0;
const RequestTracker = requestTracker;
const errors$k = errors$n;
const { format: format$1 } = require$$0$4;

const nanosToMillis = 1000000;
const defaultMessageMaxQueryLength = 500;
const defaultMaxParameterValueLength = 50;
const defaultMaxErrorStackTraceLength = 200;

/**
 * A request tracker that logs the requests executed through the session, according to a set of
 * configurable options.
 * @implements {module:tracker~RequestTracker}
 * @alias module:tracker~RequestLogger
 * @example <caption>Logging slow queries</caption>
 * const requestLogger = new RequestLogger({ slowThreshold: 1000 });
 * requestLogger.emitter.on('show', message => console.log(message));
 * // Add the requestLogger to the client options
 * const client = new Client({ contactPoints, requestTracker: requestLogger });
 */
class RequestLogger extends RequestTracker {

  /**
   * Creates a new instance of {@link RequestLogger}.
   * @param {Object} options
   * @param {Number} [options.slowThreshold] The threshold in milliseconds beyond which queries are considered 'slow'
   * and logged as such by the driver.
   * @param {Number} [options.requestSizeThreshold] The threshold in bytes beyond which requests are considered 'large'
   * and logged as such by the driver.
   * @param {Boolean} [options.logNormalRequests] Determines whether it should emit 'normal' events for every
   * EXECUTE, QUERY and BATCH request executed successfully, useful only for debugging. This option can be modified
   * after the client is connected using the property {@link RequestLogger#logNormalRequests}.
   * @param {Boolean} [options.logErroredRequests] Determines whether it should emit 'failure' events for every
   * EXECUTE, QUERY and BATCH request execution that resulted in an error. This option can be modified
   * after the client is connected using the property {@link RequestLogger#logErroredRequests}.
   * @param {Number} [options.messageMaxQueryLength] The maximum amount of characters that are logged from the query
   * portion of the message. Defaults to 500.
   * @param {Number} [options.messageMaxParameterValueLength] The maximum amount of characters of each query parameter
   * value that will be included in the message. Defaults to 50.
   * @param {Number} [options.messageMaxErrorStackTraceLength] The maximum amount of characters of the stack trace
   * that will be included in the message. Defaults to 200.
   */
  constructor(options) {
    super();
    if (!options) {
      throw new errors$k.ArgumentError('RequestLogger options parameter is required');
    }

    this._options = options;

    /**
     * Determines whether it should emit 'normal' events for every EXECUTE, QUERY and BATCH request executed
     * successfully, useful only for debugging
     * @type {Boolean}
     */
    this.logNormalRequests = this._options.logNormalRequests;

    /**
     * Determines whether it should emit 'failure' events for every EXECUTE, QUERY and BATCH request execution that
     * resulted in an error
     * @type {Boolean}
     */
    this.logErroredRequests = this._options.logErroredRequests;

    /**
     * The object instance that emits <code>'slow'</code>, <code>'large'</code>, <code>'normal'</code> and
     * <code>'failure'</code> events.
     * @type {EventEmitter}
     */
    this.emitter = new events$9.EventEmitter();
  }

  /**
   * Logs message if request execution was deemed too slow, large or if normal requests are logged.
   * @override
   */
  onSuccess(host, query, parameters, execOptions, requestLength, responseLength, latency) {
    if (this._options.slowThreshold > 0 && toMillis(latency) > this._options.slowThreshold) {
      this._logSlow(host, query, parameters, execOptions, requestLength, responseLength, latency);
    }
    else if (this._options.requestSizeThreshold > 0 && requestLength > this._options.requestSizeThreshold) {
      this._logLargeRequest(host, query, parameters, execOptions, requestLength, responseLength, latency);
    }
    else if (this.logNormalRequests) {
      this._logNormalRequest(host, query, parameters, execOptions, requestLength, responseLength, latency);
    }
  }

  /**
   * Logs message if request execution was too large and/or encountered an error.
   * @override
   */
  onError(host, query, parameters, execOptions, requestLength, err, latency) {
    if (this._options.requestSizeThreshold > 0 && requestLength > this._options.requestSizeThreshold) {
      this._logLargeErrorRequest(host, query, parameters, execOptions, requestLength, err, latency);
    }
    else if (this.logErroredRequests) {
      this._logErrorRequest(host, query, parameters, execOptions, requestLength, err, latency);
    }
  }

  _logSlow(host, query, parameters, execOptions, requestLength, responseLength, latency) {
    const message = format$1('[%s] Slow request, took %d ms (%s): %s', host.address, Math.floor(toMillis(latency)),
      getPayloadSizes(requestLength, responseLength), getStatementInfo(query, parameters, execOptions, this._options));
    this.emitter.emit('slow', message);
  }

  _logLargeRequest(host, query, parameters, execOptions, requestLength, responseLength, latency) {
    const message = format$1('[%s] Request exceeded length, %s (took %d ms): %s', host.address,
      getPayloadSizes(requestLength, responseLength), ~~toMillis(latency),
      getStatementInfo(query, parameters, execOptions, this._options));
    this.emitter.emit('large', message);
  }

  _logNormalRequest(host, query, parameters, execOptions, requestLength, responseLength, latency) {
    const message = format$1('[%s] Request completed normally, took %d ms (%s): %s', host.address, ~~toMillis(latency),
      getPayloadSizes(requestLength, responseLength), getStatementInfo(query, parameters, execOptions, this._options));
    this.emitter.emit('normal', message);
  }

  _logLargeErrorRequest(host, query, parameters, execOptions, requestLength, err, latency) {
    const maxStackTraceLength = this._options.messageMaxErrorStackTraceLength || defaultMaxErrorStackTraceLength;
    const message = format$1('[%s] Request exceeded length and execution failed, %s (took %d ms): %s; error: %s',
      host.address, getPayloadSizes(requestLength), ~~toMillis(latency),
      getStatementInfo(query, parameters, execOptions, this._options), err.stack.substr(0, maxStackTraceLength));

    // Use 'large' event and not 'failure' as this log is caused by exceeded length
    this.emitter.emit('large', message);
  }

  _logErrorRequest(host, query, parameters, execOptions, requestLength, err, latency) {
    const maxStackTraceLength = this._options.messageMaxErrorStackTraceLength || defaultMaxErrorStackTraceLength;
    const message = format$1('[%s] Request execution failed, took %d ms (%s): %s; error: %s', host.address,
      ~~toMillis(latency), getPayloadSizes(requestLength),
      getStatementInfo(query, parameters, execOptions, this._options), err.stack.substr(0, maxStackTraceLength));

    // Avoid using 'error' as its a special event
    this.emitter.emit('failure', message);
  }
}

function toMillis(latency) {
  return latency[0] * 1000 + latency[1] / nanosToMillis;
}

function getStatementInfo(query, parameters, execOptions, options) {
  const maxQueryLength = options.messageMaxQueryLength || defaultMessageMaxQueryLength;
  const maxParameterLength = options.messageMaxParameterValueLength || defaultMaxParameterValueLength;

  if (Array.isArray(query)) {
    return getBatchStatementInfo(query, execOptions, maxQueryLength, maxParameterLength);
  }

  // String concatenation is usually faster than Array#join() in V8
  let message = query.substr(0, maxQueryLength);
  const remaining = maxQueryLength - message.length - 1;
  message += getParametersInfo(parameters, remaining, maxParameterLength);

  if (!execOptions.isPrepared()) {
    // This part of the message is not accounted for in "maxQueryLength"
    message += ' (not prepared)';
  }

  return message;
}

function getBatchStatementInfo(queries, execOptions, maxQueryLength, maxParameterLength) {
  // This part of the message is not accounted for in "maxQueryLength"
  let message = (execOptions.isBatchLogged() ? 'LOGGED ' : '') + 'BATCH w/ ' + queries.length +
    (!execOptions.isPrepared() ? ' not prepared' : '') + ' queries (';
  let remaining = maxQueryLength;
  let i;

  for (i = 0; i < queries.length && remaining > 0; i++) {
    let q = queries[i];
    const params = q.params;
    if (typeof q !== 'string') {
      q = q.query;
    }

    if (i > 0) {
      message += ',';
      remaining--;
    }

    const queryLength = Math.min(remaining, q.length);
    message += q.substr(0, queryLength);
    remaining -= queryLength;

    if (remaining <= 0) {
      break;
    }

    const parameters = getParametersInfo(params, remaining, maxParameterLength);
    remaining -= parameters.length;
    message += parameters;
  }

  message += i < queries.length ? ',...)' : ')';
  return message;
}

function getParametersInfo(params, remaining, maxParameterLength) {
  if (remaining <= 3) {
    // We need at least 3 chars to describe the parameters
    // its OK to add more chars in an effort to be descriptive
    return ' [...]';
  }

  if (!params) {
    return ' []';
  }

  let paramStringifier = (index, length) => formatParam(params[index], length);
  if (!Array.isArray(params)) {
    const obj = params;
    params = Object.keys(params);
    paramStringifier = (index, length) => {
      const key = params[index];
      let result = key.substr(0, length);
      const rem = length - result.length - 1;
      if (rem <= 0) {
        return result;
      }
      result += ":" + formatParam(obj[key], rem);
      return result;
    };
  }

  let message = ' [';
  let i;
  for (i = 0; remaining > 0 && i < params.length; i++) {
    if (i > 0) {
      message += ',';
      remaining--;
    }

    const paramString = paramStringifier(i, Math.min(maxParameterLength, remaining));
    remaining -= paramString.length;
    message += paramString;
  }

  if (i < params.length) {
    message += '...';
  }

  message += ']';
  return message;
}

function formatParam(value, maxLength) {
  if (value === undefined) {
    return 'undefined';
  }

  if (value === null) {
    return 'null';
  }

  return value.toString().substr(0, maxLength);
}

function getPayloadSizes(requestLength, responseLength) {
  let message = 'request size ' + formatSize(requestLength);
  if (responseLength !== undefined) {
    message += ' / response size ' + formatSize(responseLength);
  }
  return message;
}

function formatSize(length) {
  return length > 1000 ? Math.round(length / 1024) + ' KB' : length + ' bytes';
}

var requestLogger = RequestLogger;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Tracker module.
 * @module tracker
 */

tracker.RequestLogger = requestLogger;
tracker.RequestTracker = requestTracker;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Represents a base class that is used to measure events from the server and the client as seen by the driver.
 * @alias module:metrics~ClientMetrics
 * @interface
 */
let ClientMetrics$2 = class ClientMetrics {
  /**
   * Method invoked when an authentication error is obtained from the server.
   * @param {AuthenticationError|Error} e The error encountered.
   */
  onAuthenticationError(e) {}

  /**
   * Method invoked when an error (different than a server or client timeout, authentication or connection error) is
   * encountered when executing a request.
   * @param {OperationTimedOutError} e The timeout error.
   */
  onClientTimeoutError(e) {}

  /**
   * Method invoked when there is a connection error.
   * @param {Error} e The error encountered.
   */
  onConnectionError(e) {}

  /**
   * Method invoked when an error (different than a server or client timeout, authentication or connection error) is
   * encountered when executing a request.
   * @param {Error} e The error encountered.
   */
  onOtherError(e) {}

  /**
   * Method invoked when a read timeout error is obtained from the server.
   * @param {ResponseError} e The error encountered.
   */
  onReadTimeoutError(e) {}

  /**
   * Method invoked when a write timeout error is obtained from the server.
   * @param {ResponseError} e The error encountered.
   */
  onWriteTimeoutError(e) {}

  /**
   * Method invoked when an unavailable error is obtained from the server.
   * @param {ResponseError} e The error encountered.
   */
  onUnavailableError(e) {}

  /**
   * Method invoked when an execution is retried as a result of a client-level timeout.
   * @param {Error} e The error that caused the retry.
   */
  onClientTimeoutRetry(e) {}

  /**
   * Method invoked when an error (other than a server or client timeout) is retried.
   * @param {Error} e The error that caused the retry.
   */
  onOtherErrorRetry(e) {}

  /**
   * Method invoked when an execution is retried as a result of a read timeout from the server (coordinator to replica).
   * @param {Error} e The error that caused the retry.
   */
  onReadTimeoutRetry(e) {}

  /**
   * Method invoked when an execution is retried as a result of an unavailable error from the server.
   * @param {Error} e The error that caused the retry.
   */
  onUnavailableRetry(e) {}

  /**
   * Method invoked when an execution is retried as a result of a write timeout from the server (coordinator to
   * replica).
   * @param {Error} e The error that caused the retry.
   */
  onWriteTimeoutRetry(e) {}

  /**
   * Method invoked when an error is marked as ignored by the retry policy.
   * @param {Error} e The error that was ignored by the retry policy.
   */
  onIgnoreError(e) {}

  /**
   * Method invoked when a speculative execution is started.
   */
  onSpeculativeExecution() {}

  /**
   * Method invoked when a response is obtained successfully.
   * @param {Array<Number>} latency The latency represented in a <code>[seconds, nanoseconds]</code> tuple
   * Array, where nanoseconds is the remaining part of the real time that can't be represented in second precision.
   */
  onSuccessfulResponse(latency) {}

  /**
   * Method invoked when any response is obtained, the response can be the result of a successful execution or a
   * server-side error.
   * @param {Array<Number>} latency The latency represented in a <code>[seconds, nanoseconds]</code> tuple
   * Array, where nanoseconds is the remaining part of the real time that can't be represented in second precision.
   */
  onResponse(latency) {

  }
};

var clientMetrics = ClientMetrics$2;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const ClientMetrics$1 = clientMetrics;
const EventEmitter$1 = require$$0;

/**
 * A default implementation of [ClientMetrics]{@link module:metrics~ClientMetrics} that exposes the driver events as
 * Node.js events.
 * <p>
 *   An instance of [DefaultMetrics]{@link module:metrics~DefaultMetrics} is configured by default in the client,
 *   you can access this instance using [Client#metrics]{@link Client#metrics} property.
 * </p>
 * @implements {module:metrics~ClientMetrics}
 * @alias module:metrics~DefaultMetrics
 * @example <caption>Listening to events emitted</caption>
 * defaultMetrics.errors.on('increment', err => totalErrors++);
 * defaultMetrics.errors.clientTimeout.on('increment', () => clientTimeoutErrors++);
 * defaultMetrics.speculativeRetries.on('increment', () => specExecsCount++);
 * defaultMetrics.responses.on('increment', latency => myHistogram.record(latency));
 */
let DefaultMetrics$1 = class DefaultMetrics extends ClientMetrics$1 {
  /**
   * Creates a new instance of [DefaultMetrics]{@link module:metrics~DefaultMetrics}.
   */
  constructor() {
    super();

    /**
     * Emits all the error events.
     * <p>Use each of the properties to measure events of specific errors.</p>
     * @type {EventEmitter}
     * @property {EventEmitter} authentication Emits the authentication timeout error events.
     * @property {EventEmitter} clientTimeout Emits the client timeout error events.
     * @property {EventEmitter} connection Emits the connection error events.
     * @property {EventEmitter} readTimeout Emits the read timeout error events obtained from the server.
     * @property {EventEmitter} other Emits the error events, that are not part of the other categories.
     * @property {EventEmitter} unavailable Emits the unavailable error events obtained from the server.
     * @property {EventEmitter} writeTimeout Emits the write timeout error events obtained from the server
     */
    this.errors = new EventEmitter$1();
    this.errors.authentication = new EventEmitter$1();
    this.errors.clientTimeout = new EventEmitter$1();
    this.errors.connection = new EventEmitter$1();
    this.errors.other = new EventEmitter$1();
    this.errors.readTimeout = new EventEmitter$1();
    this.errors.unavailable = new EventEmitter$1();
    this.errors.writeTimeout = new EventEmitter$1();

    /**
     * Emits all the retry events.
     * <p>Use each of the properties to measure events of specific retries.</p>
     * @type {EventEmitter}
     * @property {EventEmitter} clientTimeout Emits when an execution is retried as a result of an client timeout.
     * @property {EventEmitter} other Emits the error events, that are not part of the other categories.
     * @property {EventEmitter} readTimeout Emits an execution is retried as a result of an read timeout error from the
     * server (coordinator to replica).
     * @property {EventEmitter} unavailable Emits an execution is retried as a result of an unavailable error from the
     * server.
     * @property {EventEmitter} writeTimeout Emits an execution is retried as a result of a write timeout error from the
     * server (coordinator to replica).
     */
    this.retries = new EventEmitter$1();
    this.retries.clientTimeout = new EventEmitter$1();
    this.retries.other = new EventEmitter$1();
    this.retries.readTimeout = new EventEmitter$1();
    this.retries.unavailable = new EventEmitter$1();
    this.retries.writeTimeout = new EventEmitter$1();

    /**
     * Emits events when a speculative execution is started.
     * @type {EventEmitter}
     */
    this.speculativeExecutions = new EventEmitter$1();

    /**
     * Emits events when an error is ignored by the retry policy.
     * @type {EventEmitter}
     */
    this.ignoredErrors = new EventEmitter$1();

    /**
     * Emits events when a response message is obtained.
     * @type {EventEmitter}
     * @property {EventEmitter} success Emits when a response was obtained as the result of a successful execution.
     */
    this.responses = new EventEmitter$1();
    this.responses.success = new EventEmitter$1();
  }

  /** @override */
  onAuthenticationError(e) {
    this.errors.authentication.emit('increment', e);
    this.errors.emit('increment', e);}

  /** @override */
  onConnectionError(e) {
    this.errors.connection.emit('increment', e);
    this.errors.emit('increment', e);
  }

  /** @override */
  onReadTimeoutError(e) {
    this.errors.readTimeout.emit('increment', e);
    this.errors.emit('increment', e);
  }

  /** @override */
  onWriteTimeoutError(e) {
    this.errors.writeTimeout.emit('increment', e);
    this.errors.emit('increment', e);
  }

  /** @override */
  onUnavailableError(e) {
    this.errors.unavailable.emit('increment', e);
    this.errors.emit('increment', e);
  }

  /** @override */
  onClientTimeoutError(e) {
    this.errors.clientTimeout.emit('increment', e);
    this.errors.emit('increment', e);
  }

  /** @override */
  onOtherError(e) {
    this.errors.other.emit('increment', e);
    this.errors.emit('increment', e);
  }

  /** @override */
  onClientTimeoutRetry(e) {
    this.retries.clientTimeout.emit('increment', e);
    this.retries.emit('increment', e);
  }

  /** @override */
  onOtherErrorRetry(e) {
    this.retries.other.emit('increment', e);
    this.retries.emit('increment', e);
  }

  /** @override */
  onReadTimeoutRetry(e) {
    this.retries.readTimeout.emit('increment', e);
    this.retries.emit('increment', e);
  }

  /** @override */
  onUnavailableRetry(e) {
    this.retries.unavailable.emit('increment', e);
    this.retries.emit('increment', e);
  }

  /** @override */
  onWriteTimeoutRetry(e) {
    this.retries.writeTimeout.emit('increment', e);
    this.retries.emit('increment', e);
  }

  /** @override */
  onIgnoreError(e) {
    this.ignoredErrors.emit('increment', e);
  }

  /** @override */
  onSpeculativeExecution() {
    this.speculativeExecutions.emit('increment');
  }

  /** @override */
  onSuccessfulResponse(latency) {
    this.responses.success.emit('increment', latency);
  }

  /** @override */
  onResponse(latency) {
    this.responses.emit('increment', latency);
  }
};

var defaultMetrics = DefaultMetrics$1;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const ClientMetrics = clientMetrics;
const DefaultMetrics = defaultMetrics;

/**
 * The <code>metrics</code> module contains interfaces and implementations used by the driver to expose
 * measurements of its internal behavior and of the server as seen from the driver side.
 * @module metrics
 */

var metrics = { ClientMetrics, DefaultMetrics };

var provider$1 = {};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @classdesc Provides [Authenticator]{@link module:auth~Authenticator} instances to be used when connecting to a host.
 * @constructor
 * @abstract
 * @alias module:auth~AuthProvider
 */
function AuthProvider$5() {

}

/**
 * Returns an [Authenticator]{@link module:auth~Authenticator} instance to be used when connecting to a host.
 * @param {String} endpoint The ip address and port number in the format ip:port
 * @param {String} name Authenticator name
 * @abstract
 * @returns {Authenticator}
 */
AuthProvider$5.prototype.newAuthenticator = function (endpoint, name) {
  throw new Error('This is an abstract class, you must implement newAuthenticator method or ' +
    'use another auth provider that inherits from this class');
};

/**
 * @class
 * @classdesc Handles SASL authentication with Cassandra servers.
 * Each time a new connection is created and the server requires authentication,
 * a new instance of this class will be created by the corresponding.
 * @constructor
 * @alias module:auth~Authenticator
 */
function Authenticator$4() {

}

/**
 * Obtain an initial response token for initializing the SASL handshake.
 * @param {Function} callback
 */
Authenticator$4.prototype.initialResponse = function (callback) {
  callback(new Error('Not implemented'));
};

/**
 * Evaluates a challenge received from the Server. Generally, this method should callback with
 * no error and no additional params when authentication is complete from the client perspective.
 * @param {Buffer} challenge
 * @param {Function} callback
 */
Authenticator$4.prototype.evaluateChallenge = function (challenge, callback) {
  callback(new Error('Not implemented'));
};

/**
 * Called when authentication is successful with the last information
 * optionally sent by the server.
 * @param {Buffer} [token]
 */
Authenticator$4.prototype.onAuthenticationSuccess = function (token) {

};

provider$1.AuthProvider = AuthProvider$5;
provider$1.Authenticator = Authenticator$4;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const util$v = require$$0$4;

const provider = provider$1;
const utils$F = utils$K;
const AuthProvider$4 = provider.AuthProvider;
const Authenticator$3 = provider.Authenticator;
/**
 * Creates a new instance of the Authenticator provider
 * @classdesc Provides plain text [Authenticator]{@link module:auth~Authenticator} instances to be used when
 * connecting to a host.
 * @extends module:auth~AuthProvider
 * @example
 * var authProvider = new cassandra.auth.PlainTextAuthProvider('my_user', 'p@ssword1!');
 * //Set the auth provider in the clientOptions when creating the Client instance
 * const client = new Client({ contactPoints: contactPoints, authProvider: authProvider });
 * @param {String} username User name in plain text
 * @param {String} password Password in plain text
 * @alias module:auth~PlainTextAuthProvider
 * @constructor
 */
function PlainTextAuthProvider$1(username, password) {
  this.username = username;
  this.password = password;
}

util$v.inherits(PlainTextAuthProvider$1, AuthProvider$4);

/**
 * Returns a new [Authenticator]{@link module:auth~Authenticator} instance to be used for plain text authentication.
 * @override
 * @returns {Authenticator}
 */
PlainTextAuthProvider$1.prototype.newAuthenticator = function () {
  return new PlainTextAuthenticator$2(this.username, this.password);
};

/**
 * @ignore
 */
function PlainTextAuthenticator$2(username, password) {
  this.username = username;
  this.password = password;
}

util$v.inherits(PlainTextAuthenticator$2, Authenticator$3);

PlainTextAuthenticator$2.prototype.initialResponse = function (callback) {
  const initialToken = Buffer.concat([
    utils$F.allocBufferFromArray([0]),
    utils$F.allocBufferFromString(this.username, 'utf8'),
    utils$F.allocBufferFromArray([0]),
    utils$F.allocBufferFromString(this.password, 'utf8')
  ]);
  callback(null, initialToken);
};

PlainTextAuthenticator$2.prototype.evaluateChallenge = function (challenge, callback) {
  //noop
  callback();
};

var plainTextAuthProvider = {
  PlainTextAuthenticator: PlainTextAuthenticator$2,
  PlainTextAuthProvider: PlainTextAuthProvider$1,
};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const util$u = require$$0$4;
const { Authenticator: Authenticator$2 } = provider$1;

const dseAuthenticatorName = 'com.datastax.bdp.cassandra.auth.DseAuthenticator';

/**
 * Base class for Authenticator implementations that want to make use of
 * the authentication scheme negotiation in the DseAuthenticator
 * @param {String} authenticatorName
 * @extends Authenticator
 * @constructor
 * @ignore
 */
function BaseDseAuthenticator$2(authenticatorName) {
  this.authenticatorName = authenticatorName;
}

util$u.inherits(BaseDseAuthenticator$2, Authenticator$2);

/**
 * Return a Buffer containing the required SASL mechanism.
 * @abstract
 * @returns {Buffer}
 */
BaseDseAuthenticator$2.prototype.getMechanism = function () {
  throw new Error('Not implemented');
};

/**
 * Return a byte array containing the expected successful server challenge.
 * @abstract
 * @returns {Buffer}
 */
BaseDseAuthenticator$2.prototype.getInitialServerChallenge = function () {
  throw new Error('Not implemented');
};

/**
 * @param {Function} callback
 * @override
 */
BaseDseAuthenticator$2.prototype.initialResponse = function (callback) {
  if (!this._isDseAuthenticator()) {
    //fallback
    return this.evaluateChallenge(this.getInitialServerChallenge(), callback);
  }
  //send the mechanism as a first auth message
  callback(null, this.getMechanism());
};

/**
 * Determines if the name of the authenticator matches DSE 5+
 * @protected
 * @ignore
 */
BaseDseAuthenticator$2.prototype._isDseAuthenticator = function () {
  return this.authenticatorName === dseAuthenticatorName;
};

var baseDseAuthenticator = BaseDseAuthenticator$2;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const util$t = require$$0$4;
const utils$E = utils$K;

/**
 * GSSAPI Client interface.
 * @ignore
 */
let GssapiClient$1 = class GssapiClient {
  /**
   * @param {String} [authorizationId]
   * @param {String} [service]
   */
  constructor(authorizationId, service) {
    this.authorizationId = authorizationId;
    this.service = service !== undefined ? service : 'dse';
  }

  /**
   * @abstract
   * @param {String} host Host name or ip
   * @param {Function} callback
   */
  init(host, callback) {
    throw new Error('Not implemented');
  }

  /**
   * @param {Buffer} challenge
   * @param {Function} callback
   * @abstract
   */
  evaluateChallenge(challenge, callback) {
    throw new Error('Not implemented');
  }

  /**
   * @abstract
   * @param {Function} [callback]
   */
  shutdown(callback) {
    throw new Error('Not implemented');
  }

  /**
   * Factory to get the actual implementation of GSSAPI (unix or win)
   * @param {Object} kerberosModule Kerberos client library dependency
   * @param {String} [authorizationId] An identity to act as (for proxy authentication).
   * @param {String} [service] The service to use. (defaults to 'dse')
   * @returns GssapiClient
   */
  static createNew(kerberosModule, authorizationId, service) {
    return new StandardGssClient(kerberosModule, authorizationId, service);
  }
};

/**
 * GSSAPI Client implementation using kerberos module.
 * @ignore
 */
class StandardGssClient extends GssapiClient$1 {
  constructor(kerberosModule, authorizationId, service) {
    if (typeof kerberosModule.initializeClient !== 'function') {
      throw new Error('The driver expects version 1.x of the kerberos library');
    }

    super(authorizationId, service);
    this.kerberos = kerberosModule;
    this.transitionIndex = 0;
  }

  init(host, callback) {
    this.host = host;
    let uri = this.service;
    if (this.host) {
      //For the principal    "dse/cassandra1.datastax.com@DATASTAX.COM"
      //the expected uri is: "dse@cassandra1.datastax.com"
      uri = util$t.format("%s@%s", this.service, this.host);
    }
    const options = {
      gssFlags: this.kerberos.GSS_C_MUTUAL_FLAG //authenticate itself flag
    };
    this.kerberos.initializeClient(uri, options, (err, kerberosClient) => {
      if (err) {
        return callback(err);
      }
      this.kerberosClient = kerberosClient;
      callback();
    });
  }

  /** @override */
  evaluateChallenge(challenge, callback) {
    this['transition' + this.transitionIndex](challenge, (err, response) => {
      if (err) {
        return callback(err);
      }
      this.transitionIndex++;
      callback(null, response ? utils$E.allocBufferFromString(response, 'base64') : utils$E.allocBuffer(0));
    });
  }

  transition0(challenge, callback) {
    this.kerberosClient.step('', callback);
  }

  transition1(challenge, callback) {
    const charPointerChallenge = challenge.toString('base64');
    this.kerberosClient.step(charPointerChallenge, callback);
  }

  transition2(challenge, callback) {
    this.kerberosClient.unwrap(challenge.toString('base64'), (err, response) => {
      if (err) {
        return callback(err, false);
      }
      const cb = function (err, wrapped) {
        if (err) {
          return callback(err);
        }
        callback(null, wrapped);
      };
      if (this.authorizationId !== undefined) {
        this.kerberosClient.wrap(response, { user: this.authorizationId }, cb);
      }
      else {
        this.kerberosClient.wrap(response, null, cb);
      }
    });
  }

  shutdown(callback) {
    this.kerberosClient = null;
    callback();
  }
}

var gssapiClient = GssapiClient$1;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const util$s = require$$0$4;
const { AuthProvider: AuthProvider$3 } = provider$1;
const BaseDseAuthenticator$1 = baseDseAuthenticator;
const GssapiClient = gssapiClient;
const dns$1 = require$$0$7;
const utils$D = utils$K;

const mechanism$1 = utils$D.allocBufferFromString('GSSAPI');
const initialServerChallenge$1 = 'GSSAPI-START';
const emptyBuffer = utils$D.allocBuffer(0);

/**
 * Creates a new instance of <code>DseGssapiAuthProvider</code>.
 * @classdesc
 * AuthProvider that provides GSSAPI authenticator instances for clients to connect
 * to DSE clusters secured with the DseAuthenticator.
 * @param {Object} [gssOptions] GSSAPI authenticator options
 * @param {String} [gssOptions.authorizationId] The optional authorization ID. Providing an authorization ID allows the
 * currently authenticated user to act as a different user (a.k.a. proxy authentication).
 * @param {String} [gssOptions.service] The service to use. Defaults to 'dse'.
 * @param {Function} [gssOptions.hostNameResolver] A method to be used to resolve the name of the Cassandra node based
 * on the IP Address.  Defaults to [lookupServiceResolver]{@link module:auth~DseGssapiAuthProvider.lookupServiceResolver}
 * which resolves the FQDN of the provided IP to generate principals in the format of
 * <code>dse/example.com@MYREALM.COM</code>.
 * Alternatively, you can use [reverseDnsResolver]{@link module:auth~DseGssapiAuthProvider.reverseDnsResolver} to do a
 * reverse DNS lookup or [useIpResolver]{@link module:auth~DseGssapiAuthProvider.useIpResolver} to simply use the IP
 * address provided.
 * @param {String} [gssOptions.user] DEPRECATED, it will be removed in future versions. For proxy authentication, use
 * <code>authorizationId</code> instead.
 * @example
 * const client = new cassandra.Client({
 *   contactPoints: ['h1', 'h2'],
 *   authProvider: new cassandra.auth.DseGssapiAuthProvider()
 * });
 * @alias module:auth~DseGssapiAuthProvider
 * @constructor
 */
function DseGssapiAuthProvider$1(gssOptions) {
  //load the kerberos at construction time
  try {
    // eslint-disable-next-line
    this._kerberos = require('kerberos');
  }
  catch (err) {
    if (err.code === 'MODULE_NOT_FOUND') {
      const newErr = new Error('You must install module "kerberos" to use GSSAPI auth provider: ' +
        'https://www.npmjs.com/package/kerberos');
      newErr.code = err.code;
      throw newErr;
    }
    throw err;
  }
  gssOptions = gssOptions || utils$D.emptyObject;
  this.authorizationId = gssOptions.authorizationId || gssOptions.user;
  this.service = gssOptions.service;
  this.hostNameResolver = gssOptions.hostNameResolver || DseGssapiAuthProvider$1.lookupServiceResolver;
}

util$s.inherits(DseGssapiAuthProvider$1, AuthProvider$3);

/**
 * Returns an Authenticator instance to be used by the driver when connecting to a host.
 * @param {String} endpoint The IP address and port number in the format ip:port.
 * @param {String} name Authenticator name.
 * @override
 * @returns {Authenticator}
 */
DseGssapiAuthProvider$1.prototype.newAuthenticator = function (endpoint, name) {
  let address = endpoint;
  if (endpoint.indexOf(':') > 0) {
    address = endpoint.split(':')[0];
  }
  return new GssapiAuthenticator(
    this._kerberos, address, name, this.authorizationId, this.service, this.hostNameResolver);
};

/**
 * Performs a lookupService query that resolves an IPv4 or IPv6 address to a hostname.  This ultimately makes a
 * <code>getnameinfo()</code> system call which depends on the OS to do hostname resolution.
 * <p/>
 * <b>Note:</b> Depends on <code>dns.lookupService</code> which was added in 0.12.  For older versions falls back on
 * [reverseDnsResolver]{@link module:auth~DseGssapiAuthProvider.reverseDnsResolver}.
 *
 * @param {String} ip IP address to resolve.
 * @param {Function} callback The callback function with <code>err</code> and <code>hostname</code> arguments.
 */
DseGssapiAuthProvider$1.lookupServiceResolver = function (ip, callback) {
  if (!dns$1.lookupService) {
    return DseGssapiAuthProvider$1.reverseDnsResolver(ip, callback);
  }
  dns$1.lookupService(ip, 0, function (err, hostname) {
    if (err) {
      return callback(err);
    }
    if (!hostname) {
      //fallback to ip
      return callback(null, ip);
    }
    callback(null, hostname);
  });
};

/**
 * Performs a reverse DNS query that resolves an IPv4 or IPv6 address to a hostname.
 * @param {String} ip IP address to resolve.
 * @param {Function} callback The callback function with <code>err</code> and <code>hostname</code> arguments.
 */
DseGssapiAuthProvider$1.reverseDnsResolver = function (ip, callback) {
  dns$1.reverse(ip, function (err, names) {
    if (err) {
      return callback(err);
    }
    if (!names || !names.length) {
      //fallback to ip
      return callback(null, ip);
    }
    callback(null, names[0]);
  });
};

/**
 * Effectively a no op operation, returns the IP address provided.
 * @param {String} ip IP address to use.
 * @param {Function} callback The callback function with <code>err</code> and <code>hostname</code> arguments.
 */
DseGssapiAuthProvider$1.useIpResolver = function (ip, callback) {
  callback(null, ip);
};

/**
 * @param {Object} kerberosModule
 * @param {String} address Host address.
 * @param {String} authenticatorName
 * @param {String} authorizationId
 * @param {String} service
 * @param {Function} hostNameResolver
 * @extends Authenticator
 * @private
 */
function GssapiAuthenticator(kerberosModule, address, authenticatorName, authorizationId, service, hostNameResolver) {
  BaseDseAuthenticator$1.call(this, authenticatorName);
  this.authorizationId = authorizationId;
  this.address = address;
  this.client = GssapiClient.createNew(kerberosModule, authorizationId, service);
  this.hostNameResolver = hostNameResolver;
}

//noinspection JSCheckFunctionSignatures
util$s.inherits(GssapiAuthenticator, BaseDseAuthenticator$1);

GssapiAuthenticator.prototype.getMechanism = function () {
  return mechanism$1;
};

GssapiAuthenticator.prototype.getInitialServerChallenge = function () {
  return utils$D.allocBufferFromString(initialServerChallenge$1);
};

//noinspection JSUnusedGlobalSymbols
/**
 * Obtain an initial response token for initializing the SASL handshake.
 * @param {Function} callback
 */
GssapiAuthenticator.prototype.initialResponse = function (callback) {
  const self = this;
  //initialize the GSS client
  let host = this.address;
  utils$D.series([
    function getHostName(next) {
      self.hostNameResolver(self.address, function (err, name) {
        if (!err && name) {
          host = name;
        }
        next();
      });
    },
    function initClient(next) {
      self.client.init(host, function (err) {
        if (err) {
          return next(err);
        }
        if (!self._isDseAuthenticator()) {
          //fallback
          return self.evaluateChallenge(self.getInitialServerChallenge(), next);
        }
        //send the mechanism as a first auth message
        next(null, self.getMechanism());
      });
    }
  ], callback);
};

/**
 * Evaluates a challenge received from the Server. Generally, this method should callback with
 * no error and no additional params when authentication is complete from the client perspective.
 * @param {Buffer} challenge
 * @param {Function} callback
 * @override
 */
GssapiAuthenticator.prototype.evaluateChallenge = function (challenge, callback) {
  if (!challenge || challenge.toString() === initialServerChallenge$1) {
    challenge = emptyBuffer;
  }
  this.client.evaluateChallenge(challenge, callback);
};

/**
 * @override
 */
GssapiAuthenticator.prototype.onAuthenticationSuccess = function (token) {
  this.client.shutdown(function noop() { });
};


var dseGssapiAuthProvider = DseGssapiAuthProvider$1;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const util$r = require$$0$4;
const { AuthProvider: AuthProvider$2 } = provider$1;
const BaseDseAuthenticator = baseDseAuthenticator;
const utils$C = utils$K;

const mechanism = utils$C.allocBufferFromString('PLAIN');
const separatorBuffer = utils$C.allocBufferFromArray([0]);
const initialServerChallenge = 'PLAIN-START';

/**
 * Creates a new instance of <code>DsePlainTextAuthProvider</code>.
 * @classdesc
 * AuthProvider that provides plain text authenticator instances for clients to connect
 * to DSE clusters secured with the DseAuthenticator.
 * @param {String} username The username; cannot be <code>null</code>.
 * @param {String} password The password; cannot be <code>null</code>.
 * @param {String} [authorizationId] The optional authorization ID. Providing an authorization ID allows the currently
 * authenticated user to act as a different user (a.k.a. proxy authentication).
 * @extends AuthProvider
 * @alias module:auth~DsePlainTextAuthProvider
 * @example
 * const client = new cassandra.Client({
 *   contactPoints: ['h1', 'h2'],
 *   authProvider: new cassandra.auth.DsePlainTextAuthProvider('user', 'p@ssword1');
 * });
 * @constructor
 */
function DsePlainTextAuthProvider$2(username, password, authorizationId) {
  if (typeof username !== 'string' || typeof password !== 'string') {
    // Validate for null and undefined
    throw new TypeError('Username and password must be a string');
  }
  this.username = username;
  this.password = password;
  this.authorizationId = authorizationId;
}

util$r.inherits(DsePlainTextAuthProvider$2, AuthProvider$2);

/**
 * Returns an Authenticator instance to be used by the driver when connecting to a host.
 * @param {String} endpoint The IP address and port number in the format ip:port.
 * @param {String} name Authenticator name.
 * @override
 * @returns {Authenticator}
 */
DsePlainTextAuthProvider$2.prototype.newAuthenticator = function (endpoint, name) {
  return new PlainTextAuthenticator$1(name, this.username, this.password, this.authorizationId);
};

/**
 * @param {String} authenticatorName
 * @param {String} authenticatorId
 * @param {String} password
 * @param {String} authorizationId
 * @extends BaseDseAuthenticator
 * @constructor
 * @private
 */
function PlainTextAuthenticator$1(authenticatorName, authenticatorId, password, authorizationId) {
  BaseDseAuthenticator.call(this, authenticatorName);
  this.authenticatorId = utils$C.allocBufferFromString(authenticatorId);
  this.password = utils$C.allocBufferFromString(password);
  this.authorizationId = utils$C.allocBufferFromString(authorizationId || '');
}

util$r.inherits(PlainTextAuthenticator$1, BaseDseAuthenticator);

/** @override */
PlainTextAuthenticator$1.prototype.getMechanism = function () {
  return mechanism;
};

/** @override */
PlainTextAuthenticator$1.prototype.getInitialServerChallenge = function () {
  return utils$C.allocBufferFromString(initialServerChallenge);
};

/** @override */
PlainTextAuthenticator$1.prototype.evaluateChallenge = function (challenge, callback) {
  if (!challenge || challenge.toString() !== initialServerChallenge) {
    return callback(new Error('Incorrect SASL challenge from server'));
  }
  // The SASL plain text format is authorizationId 0 username 0 password
  callback(null, Buffer.concat([
    this.authorizationId,
    separatorBuffer,
    this.authenticatorId,
    separatorBuffer,
    this.password
  ]));
};

var dsePlainTextAuthProvider = DsePlainTextAuthProvider$2;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const { AuthProvider: AuthProvider$1, Authenticator: Authenticator$1 } = provider$1;
const { PlainTextAuthenticator } = plainTextAuthProvider;
const errors$j = errors$n;

const dseAuthenticator = 'com.datastax.bdp.cassandra.auth.DseAuthenticator';

/**
 * Internal authentication provider that is used when no provider has been set by the user.
 * @ignore
 */
let NoAuthProvider$3 = class NoAuthProvider extends AuthProvider$1 {
  newAuthenticator(endpoint, name) {
    if (name === dseAuthenticator) {
      // Try to use transitional mode
      return new TransitionalModePlainTextAuthenticator();
    }

    // Use an authenticator that doesn't allow auth flow
    return new NoAuthAuthenticator(endpoint);
  }
};

/**
 * An authenticator throws an error when authentication flow is started.
 * @ignore
 */
class NoAuthAuthenticator extends Authenticator$1 {
  constructor(endpoint) {
    super();
    this.endpoint = endpoint;
  }

  initialResponse(callback) {
    callback(new errors$j.AuthenticationError(
      `Host ${this.endpoint} requires authentication, but no authenticator found in the options`));
  }
}

/**
 * Authenticator that accounts for DSE authentication configured with transitional mode: normal.
 *
 * In this situation, the client is allowed to connect without authentication, but DSE
 * would still send an AUTHENTICATE response. This Authenticator handles this situation
 * by sending back a dummy credential.
 */
class TransitionalModePlainTextAuthenticator extends PlainTextAuthenticator {
  constructor() {
    super('', '');
  }
}

var noAuthProvider = NoAuthProvider$3;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * DSE Authentication module.
 * <p>
 *   Contains the classes used for connecting to a DSE cluster secured with DseAuthenticator.
 * </p>
 * @module auth
 */

const { Authenticator, AuthProvider } = provider$1;
const { PlainTextAuthProvider } = plainTextAuthProvider;
const DseGssapiAuthProvider = dseGssapiAuthProvider;
const DsePlainTextAuthProvider$1 = dsePlainTextAuthProvider;
const NoAuthProvider$2 = noAuthProvider;

var auth = {
  Authenticator,
  AuthProvider,
  DseGssapiAuthProvider,
  DsePlainTextAuthProvider: DsePlainTextAuthProvider$1,
  NoAuthProvider: NoAuthProvider$2,
  PlainTextAuthProvider
};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var hasRequiredClientOptions;

function requireClientOptions () {
	if (hasRequiredClientOptions) return clientOptions$3;
	hasRequiredClientOptions = 1;

	const util = require$$0$4;
	const policies = requirePolicies();
	const types = requireTypes();
	const utils = utils$K;
	const tracker$1 = tracker;
	const metrics$1 = metrics;
	const auth$1 = auth;

	/** Core connections per host for protocol versions 1 and 2 */
	const coreConnectionsPerHostV2 = {
	  [types.distance.local]: 2,
	  [types.distance.remote]: 1,
	  [types.distance.ignored]: 0
	};

	/** Core connections per host for protocol version 3 and above */
	const coreConnectionsPerHostV3 = {
	  [types.distance.local]: 1,
	  [types.distance.remote]: 1,
	  [types.distance.ignored]: 0
	};

	/** Default maxRequestsPerConnection value for protocol v1 and v2 */
	const maxRequestsPerConnectionV2 = 128;

	/** Default maxRequestsPerConnection value for protocol v3+ */
	const maxRequestsPerConnectionV3 = 2048;

	const continuousPageUnitBytes = 'bytes';
	const continuousPageDefaultSize = 5000;
	const continuousPageDefaultHighWaterMark = 10000;

	/**
	 * @returns {ClientOptions}
	 */
	function defaultOptions () {
	  return ({
	    policies: {
	      addressResolution: policies.defaultAddressTranslator(),
	      loadBalancing: policies.defaultLoadBalancingPolicy(),
	      reconnection: policies.defaultReconnectionPolicy(),
	      retry: policies.defaultRetryPolicy(),
	      speculativeExecution: policies.defaultSpeculativeExecutionPolicy(),
	      timestampGeneration: policies.defaultTimestampGenerator()
	    },
	    queryOptions: {
	      fetchSize: 5000,
	      prepare: false,
	      captureStackTrace: false
	    },
	    protocolOptions: {
	      port: 9042,
	      maxSchemaAgreementWaitSeconds: 10,
	      maxVersion: 0,
	      noCompact: false
	    },
	    pooling: {
	      heartBeatInterval: 30000,
	      warmup: true
	    },
	    socketOptions: {
	      connectTimeout: 5000,
	      defunctReadTimeoutThreshold: 64,
	      keepAlive: true,
	      keepAliveDelay: 0,
	      readTimeout: 12000,
	      tcpNoDelay: true,
	      coalescingThreshold: 65536
	    },
	    authProvider: null,
	    requestTracker: null,
	    metrics: new metrics$1.DefaultMetrics(),
	    maxPrepared: 500,
	    refreshSchemaDelay: 1000,
	    isMetadataSyncEnabled: true,
	    prepareOnAllHosts: true,
	    rePrepareOnUp: true,
	    encoding: {
	      copyBuffer: true,
	      useUndefinedAsUnset: true
	    },
	    monitorReporting: {
	      enabled: true
	    }
	  });
	}

	/**
	 * Extends and validates the user options
	 * @param {Object} [baseOptions] The source object instance that will be overridden
	 * @param {Object} userOptions
	 * @returns {Object}
	 */
	function extend(baseOptions, userOptions) {
	  if (arguments.length === 1) {
	    userOptions = arguments[0];
	    baseOptions = {};
	  }
	  const options = utils.deepExtend(baseOptions, defaultOptions(), userOptions);

	  if (!options.cloud) {
	    if (!Array.isArray(options.contactPoints) || options.contactPoints.length === 0) {
	      throw new TypeError('Contacts points are not defined.');
	    }

	    for (let i = 0; i < options.contactPoints.length; i++) {
	      const hostName = options.contactPoints[i];
	      if (!hostName) {
	        throw new TypeError(util.format('Contact point %s (%s) is not a valid host name, ' +
	          'the following values are valid contact points: ipAddress, hostName or ipAddress:port', i, hostName));
	      }
	    }

	    options.sni = undefined;
	  } else {
	    validateCloudOptions(options);
	  }

	  if (!options.logEmitter) {
	    options.logEmitter = function () {};
	  }
	  if (!options.queryOptions) {
	    throw new TypeError('queryOptions not defined in options');
	  }

	  if (options.requestTracker !== null && !(options.requestTracker instanceof tracker$1.RequestTracker)) {
	    throw new TypeError('requestTracker must be an instance of RequestTracker');
	  }

	  if (!(options.metrics instanceof metrics$1.ClientMetrics)) {
	    throw new TypeError('metrics must be an instance of ClientMetrics');
	  }

	  validatePoliciesOptions(options.policies);

	  validateProtocolOptions(options.protocolOptions);

	  validateSocketOptions(options.socketOptions);

	  validateAuthenticationOptions(options);

	  options.encoding = options.encoding || {};

	  validateEncodingOptions(options.encoding);

	  if (options.profiles && !Array.isArray(options.profiles)) {
	    throw new TypeError('profiles must be an Array of ExecutionProfile instances');
	  }

	  validateApplicationInfo(options);

	  validateMonitorReporting(options);

	  return options;
	}

	/**
	 * Validates the options to connect to a cloud instance.
	 * @private
	 */
	function validateCloudOptions(options) {
	  const bundle = options.cloud.secureConnectBundle;

	  // eslint-disable-next-line no-undef
	  if (!(typeof bundle === 'string' || (typeof URL !== 'undefined' && bundle instanceof URL))) {
	    throw new TypeError('secureConnectBundle in cloud options must be of type string');
	  }

	  if (options.contactPoints) {
	    throw new TypeError('Contact points can not be defined when cloud settings are provided');
	  }

	  if (options.sslOptions) {
	    throw new TypeError('SSL options can not be defined when cloud settings are provided');
	  }
	}

	/**
	 * Validates the policies from the client options.
	 * @param {ClientOptions.policies} policiesOptions
	 * @private
	 */
	function validatePoliciesOptions(policiesOptions) {
	  if (!policiesOptions) {
	    throw new TypeError('policies not defined in options');
	  }
	  if (!(policiesOptions.loadBalancing instanceof policies.loadBalancing.LoadBalancingPolicy)) {
	    throw new TypeError('Load balancing policy must be an instance of LoadBalancingPolicy');
	  }
	  if (!(policiesOptions.reconnection instanceof policies.reconnection.ReconnectionPolicy)) {
	    throw new TypeError('Reconnection policy must be an instance of ReconnectionPolicy');
	  }
	  if (!(policiesOptions.retry instanceof policies.retry.RetryPolicy)) {
	    throw new TypeError('Retry policy must be an instance of RetryPolicy');
	  }
	  if (!(policiesOptions.addressResolution instanceof policies.addressResolution.AddressTranslator)) {
	    throw new TypeError('Address resolution policy must be an instance of AddressTranslator');
	  }
	  if (policiesOptions.timestampGeneration !== null &&
	    !(policiesOptions.timestampGeneration instanceof policies.timestampGeneration.TimestampGenerator)) {
	    throw new TypeError('Timestamp generation policy must be an instance of TimestampGenerator');
	  }
	}

	/**
	 * Validates the protocol options.
	 * @param {ClientOptions.protocolOptions} protocolOptions
	 * @private
	 */
	function validateProtocolOptions(protocolOptions) {
	  if (!protocolOptions) {
	    throw new TypeError('protocolOptions not defined in options');
	  }
	  const version = protocolOptions.maxVersion;
	  if (version && (typeof version !== 'number' || !types.protocolVersion.isSupported(version))) {
	    throw new TypeError(util.format('protocolOptions.maxVersion provided (%s) is invalid', version));
	  }
	}

	/**
	 * Validates the socket options.
	 * @param {ClientOptions.socketOptions} socketOptions
	 * @private
	 */
	function validateSocketOptions(socketOptions) {
	  if (!socketOptions) {
	    throw new TypeError('socketOptions not defined in options');
	  }
	  if (typeof socketOptions.readTimeout !== 'number') {
	    throw new TypeError('socketOptions.readTimeout must be a Number');
	  }
	  if (typeof socketOptions.coalescingThreshold !== 'number' || socketOptions.coalescingThreshold <= 0) {
	    throw new TypeError('socketOptions.coalescingThreshold must be a positive Number');
	  }
	}

	/**
	 * Validates authentication provider and credentials.
	 * @param {ClientOptions} options
	 * @private
	 */
	function validateAuthenticationOptions(options) {
	  if (!options.authProvider) {
	    const credentials = options.credentials;
	    if (credentials) {
	      if (typeof credentials.username !== 'string' || typeof credentials.password !== 'string') {
	        throw new TypeError('credentials username and password must be a string');
	      }

	      options.authProvider = new auth$1.PlainTextAuthProvider(credentials.username, credentials.password);
	    } else {
	      options.authProvider = new auth$1.NoAuthProvider();
	    }
	  } else if (!(options.authProvider instanceof auth$1.AuthProvider)) {
	    throw new TypeError('options.authProvider must be an instance of AuthProvider');
	  }
	}

	/**
	 * Validates the encoding options.
	 * @param {ClientOptions.encoding} encodingOptions
	 * @private
	 */
	function validateEncodingOptions(encodingOptions) {
	  if (encodingOptions.map) {
	    const mapConstructor = encodingOptions.map;
	    if (typeof mapConstructor !== 'function' ||
	      typeof mapConstructor.prototype.forEach !== 'function' ||
	      typeof mapConstructor.prototype.set !== 'function') {
	      throw new TypeError('Map constructor not valid');
	    }
	  }

	  if (encodingOptions.set) {
	    const setConstructor = encodingOptions.set;
	    if (typeof setConstructor !== 'function' ||
	      typeof setConstructor.prototype.forEach !== 'function' ||
	      typeof setConstructor.prototype.add !== 'function') {
	      throw new TypeError('Set constructor not valid');
	    }
	  }

	  if ((encodingOptions.useBigIntAsLong || encodingOptions.useBigIntAsVarint) && typeof BigInt === 'undefined') {
	    throw new TypeError('BigInt is not supported by the JavaScript engine');
	  }
	}

	function validateApplicationInfo(options) {
	  function validateString(key) {
	    const str = options[key];

	    if (str !== null && str !== undefined && typeof str !== 'string') {
	      throw new TypeError(`${key} should be a String`);
	    }
	  }

	  validateString('applicationName');
	  validateString('applicationVersion');

	  if (options.id !== null && options.id !== undefined && !(options.id instanceof types.Uuid)) {
	    throw new TypeError('Client id must be a Uuid');
	  }
	}

	function validateMonitorReporting(options) {
	  const o = options.monitorReporting;
	  if (o === null || typeof o !== 'object') {
	    throw new TypeError(`Monitor reporting must be an object, obtained: ${o}`);
	  }
	}

	/**
	 * Sets the default options that depend on the protocol version and other metadata.
	 * @param {Client} client
	 */
	function setMetadataDependent(client) {
	  const version = client.controlConnection.protocolVersion;
	  let coreConnectionsPerHost = coreConnectionsPerHostV3;
	  let maxRequestsPerConnection = maxRequestsPerConnectionV3;

	  if (!types.protocolVersion.uses2BytesStreamIds(version)) {
	    coreConnectionsPerHost = coreConnectionsPerHostV2;
	    maxRequestsPerConnection = maxRequestsPerConnectionV2;
	  }

	  if (client.options.queryOptions.consistency === undefined) {
	    client.options.queryOptions.consistency =
	      client.metadata.isDbaas() ? types.consistencies.localQuorum : types.consistencies.localOne;
	  }

	  client.options.pooling = utils.deepExtend(
	    {}, { coreConnectionsPerHost, maxRequestsPerConnection }, client.options.pooling);
	}

	clientOptions$3.extend = extend;
	clientOptions$3.defaultOptions = defaultOptions;
	clientOptions$3.coreConnectionsPerHostV2 = coreConnectionsPerHostV2;
	clientOptions$3.coreConnectionsPerHostV3 = coreConnectionsPerHostV3;
	clientOptions$3.maxRequestsPerConnectionV2 = maxRequestsPerConnectionV2;
	clientOptions$3.maxRequestsPerConnectionV3 = maxRequestsPerConnectionV3;
	clientOptions$3.setMetadataDependent = setMetadataDependent;
	clientOptions$3.continuousPageUnitBytes = continuousPageUnitBytes;
	clientOptions$3.continuousPageDefaultSize = continuousPageDefaultSize;
	clientOptions$3.continuousPageDefaultHighWaterMark = continuousPageDefaultHighWaterMark;
	return clientOptions$3;
}

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const utils$B = utils$K;
const types$r = requireTypes();
const promiseUtils$c = promiseUtils$e;

/**
 * Creates a new instance of {@link ExecutionProfile}.
 * @classdesc
 * Represents a set configurations to be used in a statement execution to be used for a single {@link Client} instance.
 * <p>
 *   An {@link ExecutionProfile} instance should not be shared across different {@link Client} instances.
 * </p>
 * @param {String} name Name of the execution profile.
 * <p>
 *   Use <code>'default'</code> to specify that the new instance should be the default {@link ExecutionProfile} if no
 *   profile is specified in the execution.
 * </p>
 * @param {Object} [options] Profile options, when any of the options is not specified the {@link Client} will the use
 * the ones defined in the default profile.
 * @param {Number} [options.consistency] The consistency level to use for this profile.
 * @param {LoadBalancingPolicy} [options.loadBalancing] The load-balancing policy to use for this profile.
 * @param {Number} [options.readTimeout] The client per-host request timeout to use for this profile.
 * @param {RetryPolicy} [options.retry] The retry policy to use for this profile.
 * @param {Number} [options.serialConsistency] The serial consistency level to use for this profile.
 * @param {Object} [options.graphOptions]
 * @param {String} [options.graphOptions.language] The graph language to use for graph queries.
 * <p>
 *   Note that this setting should normally be <code>undefined</code> or set by a utility method and it's not expected
 *   to be defined manually by the user.
 * </p>
 * @param {String} [options.graphOptions.results] The protocol to use for serializing and deserializing graph results.
 * <p>
 *   Note that this setting should normally be <code>undefined</code> or set by a utility method and it's not expected
 *   to be defined manually by the user.
 * </p>
 * @param {String} [options.graphOptions.name] The graph name to use for graph queries.
 * @param {Number} [options.graphOptions.readConsistency] The consistency level to use for graph read queries.
 * @param {String} [options.graphOptions.source] The graph traversal source name to use for graph queries.
 * @param {Number} [options.graphOptions.writeConsistency] The consistency level to use for graph write queries.
 * @param {LoadBalancingPolicy} [options.loadBalancing] The load-balancing policy to use for this profile.
 * @param {Number} [options.readTimeout] The client per-host request timeout to use for this profile.
 * @param {RetryPolicy} [options.retry] The retry policy to use for this profile.
 * @param {Number} [options.serialConsistency] The serial consistency level to use for this profile.
 * @example
 * const { Client, ExecutionProfile } = require('cassandra-driver');
 * const client = new Client({
 *   contactPoints: ['host1', 'host2'],
 *   profiles: [
 *     new ExecutionProfile('metrics-oltp', {
 *       consistency: consistency.localQuorum,
 *       retry: myRetryPolicy
 *     })
 *   ]
 * });
 *
 * client.execute(query, params, { executionProfile: 'metrics-oltp' }, callback);
 * @constructor
 */
function ExecutionProfile(name, options) {
  if (typeof name !== 'string') {
    throw new TypeError('Execution profile name must be a string');
  }
  options = options || utils$B.emptyObject;
  const graphOptions = options.graphOptions || utils$B.emptyObject;
  /**
   * Name of the execution profile.
   * @type {String}
   */
  this.name = name;
  /**
   * Consistency level.
   * @type {Number}
   */
  this.consistency = options.consistency;
  /**
   * Load-balancing policy
   * @type {LoadBalancingPolicy}
   */
  this.loadBalancing = options.loadBalancing;
  /**
   * Client read timeout.
   * @type {Number}
   */
  this.readTimeout = options.readTimeout;
  /**
   * Retry policy.
   * @type {RetryPolicy}
   */
  this.retry = options.retry;
  /**
   * Serial consistency level.
   * @type {Number}
   */
  this.serialConsistency = options.serialConsistency;
  /**
   * The graph options for this profile.
   * @type {Object}
   * @property {String} language The graph language.
   * @property {String} name The graph name.
   * @property {String} readConsistency The consistency to use for graph write queries.
   * @property {String} source The graph traversal source.
   * @property {String} writeConsistency The consistency to use for graph write queries.
   */
  this.graphOptions = {
    language: graphOptions.language,
    results: graphOptions.results,
    name: graphOptions.name,
    readConsistency: graphOptions.readConsistency,
    source: graphOptions.source,
    writeConsistency: graphOptions.writeConsistency
  };
}

/**
 * Contains the logic to handle the different execution profiles of a {@link Client}.
 * @ignore
 */
let ProfileManager$1 = class ProfileManager {

  /**
   * @param {ClientOptions} options
   */
  constructor(options) {
    this._profiles = options.profiles || [];
    this._defaultConfiguredRetryPolicy = undefined;
    this._setDefault(options);
    // A array of unique load balancing policies
    this._loadBalancingPolicies = [];
    // A dictionary of name keys and profile values
    this._profilesMap = {};
    // A dictionary of name keys and custom payload dictionaries as values
    this._customPayloadCache = {};
    // A dictionary of name keys and graph options as values
    this._graphOptionsCache = {};
    this._profiles.forEach(function (p) {
      this._profilesMap[p.name] = p;
      // Set required properties
      p.loadBalancing = p.loadBalancing || this._defaultProfile.loadBalancing;
      // Using array indexOf is not very efficient (O(n)) but the amount of profiles should be limited
      // and a handful of load-balancing policies (no hashcode for load-Balancing policies)
      if (this._loadBalancingPolicies.indexOf(p.loadBalancing) === -1) {
        this._loadBalancingPolicies.push(p.loadBalancing);
      }
      return p;
    }, this);
  }

  /**
   * @param {Client} client
   * @param {HostMap} hosts
   */
  async init(client, hosts) {
    for (const lbp of this._loadBalancingPolicies) {
      await promiseUtils$c.fromCallback(callback => lbp.init(client, hosts, callback));
    }
  }

  /**
   * Uses the load-balancing policies to get the relative distance to the host and return the closest one.
   * @param {Host} host
   */
  getDistance(host) {
    let distance = types$r.distance.ignored;
    // this is performance critical: we can't use any other language features than for-loop :(
    for (let i = 0; i < this._loadBalancingPolicies.length; i++) {
      const d = this._loadBalancingPolicies[i].getDistance(host);
      if (d < distance) {
        distance = d;
        if (distance === types$r.distance.local) {
          break;
        }
      }
    }

    host.setDistance(distance);
    return distance;
  }

  /**
   * @param {String|ExecutionProfile} name
   * @returns {ExecutionProfile|undefined} It returns the execution profile by name or the default profile when name is
   * undefined. It returns undefined when the profile does not exist.
   */
  getProfile(name) {
    if (name instanceof ExecutionProfile) {
      return name;
    }
    return this._profilesMap[name || 'default'];
  }

  /** @returns {ExecutionProfile} */
  getDefault() {
    return this._defaultProfile;
  }

  /** @returns {LoadBalancingPolicy} */
  getDefaultLoadBalancing() {
    return this._defaultProfile.loadBalancing;
  }

  /**
   * Gets the cached default graph options for a given profile. If it doesn't exist, it creates new options using the
   * handler and inserts it into the cache
   * @param {ExecutionProfile} profile
   * @param {Function} createHandler
   */
  getOrCreateGraphOptions(profile, createHandler) {
    let graphOptions = this._graphOptionsCache[profile.name];
    if (!graphOptions) {
      graphOptions = (this._graphOptionsCache[profile.name] = createHandler());
    }
    return graphOptions;
  }

  /**
   * @private
   * @param {ClientOptions} options
   */
  _setDefault(options) {
    this._defaultProfile = this._profiles.filter(function (p) { return p.name === 'default'; })[0];
    if (!this._defaultProfile) {
      this._profiles.push(this._defaultProfile = new ExecutionProfile('default'));
    }

    // Store the default configured retry policy
    this._defaultConfiguredRetryPolicy = this._defaultProfile.retry;

    // Set the required properties
    this._defaultProfile.loadBalancing = this._defaultProfile.loadBalancing || options.policies.loadBalancing;
    this._defaultProfile.retry = this._defaultProfile.retry || options.policies.retry;
  }

  /**
   * Gets all the execution profiles currently defined.
   * @returns {Array.<ExecutionProfile>}
   */
  getAll() {
    return this._profiles;
  }

  getDefaultConfiguredRetryPolicy() {
    return this._defaultConfiguredRetryPolicy;
  }
};

var executionProfile = {
  ProfileManager: ProfileManager$1,
  ExecutionProfile
};

var requests$7 = {};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const events$8 = require$$0;

const types$q = requireTypes();
const utils$A = utils$K;
const FrameHeader$1 = types$q.FrameHeader;

/**
 * Contains the logic to write all the different types to the frame.
 */
let FrameWriter$1 = class FrameWriter {
  /**
   * Creates a new instance of FrameWriter.
   * @param {Number} opcode
   */
  constructor(opcode) {
    if (!opcode) {
      throw new Error('Opcode not provided');
    }
    this.buffers = [];
    this.opcode = opcode;
    this.bodyLength = 0;
  }

  add(buf) {
    this.buffers.push(buf);
    this.bodyLength += buf.length;
  }

  writeShort(num) {
    const buf = utils$A.allocBufferUnsafe(2);
    buf.writeUInt16BE(num, 0);
    this.add(buf);
  }

  writeInt(num) {
    const buf = utils$A.allocBufferUnsafe(4);
    buf.writeInt32BE(num, 0);
    this.add(buf);
  }

  /** @param {Long} num */
  writeLong(num) {
    this.add(types$q.Long.toBuffer(num));
  }

  /**
   * Writes bytes according to Cassandra <int byteLength><bytes>
   * @param {Buffer|null|types.unset} bytes
   */
  writeBytes(bytes) {
    if (bytes === null) {
      //Only the length buffer containing -1
      this.writeInt(-1);
      return;
    }
    if (bytes === types$q.unset) {
      this.writeInt(-2);
      return;
    }
    //Add the length buffer
    this.writeInt(bytes.length);
    //Add the actual buffer
    this.add(bytes);
  }

  /**
   * Writes a buffer according to Cassandra protocol: bytes.length (2) + bytes
   * @param {Buffer} bytes
   */
  writeShortBytes(bytes) {
    if(bytes === null) {
      //Only the length buffer containing -1
      this.writeShort(-1);
      return;
    }
    //Add the length buffer
    this.writeShort(bytes.length);
    //Add the actual buffer
    this.add(bytes);
  }

  /**
   * Writes a single byte
   * @param {Number} num Value of the byte, a number between 0 and 255.
   */
  writeByte(num) {
    this.add(utils$A.allocBufferFromArray([num]));
  }

  writeString(str) {
    if (typeof str === "undefined") {
      throw new Error("can not write undefined");
    }
    const len = Buffer.byteLength(str, 'utf8');
    const buf = utils$A.allocBufferUnsafe(2 + len);
    buf.writeUInt16BE(len, 0);
    buf.write(str, 2, buf.length-2, 'utf8');
    this.add(buf);
  }

  writeLString(str) {
    const len = Buffer.byteLength(str, 'utf8');
    const buf = utils$A.allocBufferUnsafe(4 + len);
    buf.writeInt32BE(len, 0);
    buf.write(str, 4, buf.length-4, 'utf8');
    this.add(buf);
  }

  writeStringList(values) {
    this.writeShort(values.length);
    values.forEach(this.writeString, this);
  }

  writeCustomPayload(payload) {
    const keys = Object.keys(payload);
    this.writeShort(keys.length);
    keys.forEach(k => {
      this.writeString(k);
      this.writeBytes(payload[k]);
    });
  }

  writeStringMap(map) {
    const keys = [];
    for (const k in map) {
      if (map.hasOwnProperty(k)) {
        keys.push(k);
      }
    }

    this.writeShort(keys.length);

    for(let i = 0; i < keys.length; i++) {
      const key = keys[i];
      this.writeString(key);
      this.writeString(map[key]);
    }
  }

  /**
   * @param {Number} version
   * @param {Number} streamId
   * @param {Number} [flags] Header flags
   * @returns {Buffer}
   * @throws {TypeError}
   */
  write(version, streamId, flags) {
    const header = new FrameHeader$1(version, flags || 0, streamId, this.opcode, this.bodyLength);
    const headerBuffer = header.toBuffer();
    this.buffers.unshift(headerBuffer);
    return Buffer.concat(this.buffers, headerBuffer.length + this.bodyLength);
  }
};

/**
 * Represents a queue that process one write at a time (FIFO).
 * @extends {EventEmitter}
 */
let WriteQueue$1 = class WriteQueue extends events$8.EventEmitter {
  /**
   * Creates a new WriteQueue instance.
   * @param {Socket} netClient
   * @param {Encoder} encoder
   * @param {ClientOptions} options
   */
  constructor(netClient, encoder, options) {
    super();
    this.netClient = netClient;
    this.encoder = encoder;
    this.isRunning = false;
    /** @type {Array<{operation: OperationState, callback: Function}>} */
    this.queue = [];
    this.coalescingThreshold = options.socketOptions.coalescingThreshold;
    this.error = null;
    this.canWrite = true;

    // Listen to drain event that is going to be fired once
    // the underlying buffer is empty
    netClient.on('drain', () => {
      this.canWrite = true;
      this.run();
    });
  }

  /**
   * Enqueues a new request
   * @param {OperationState} operation
   * @param {Function} callback The write callback.
   */
  push(operation, callback) {
    const self = this;

    if (this.error) {
      // There was a write error, there is no point in further trying to write to the socket.
      return process.nextTick(function writePushError() {
        callback(self.error);
      });
    }

    this.queue.push({ operation: operation, callback: callback});
    this.run();
  }

  run() {
    if (!this.isRunning && this.canWrite) {
      this.isRunning = true;
      // Use nextTick to allow the queue to build up on the current phase
      process.nextTick(() => this.process());
    }
  }

  process() {
    if (this.error) {
      return;
    }

    const buffers = [];
    const callbacks = [];
    let totalLength = 0;

    while (this.queue.length > 0 && totalLength < this.coalescingThreshold) {
      const writeItem = this.queue.shift();
      if (!writeItem.operation.canBeWritten()) {
        // Invoke the write callback with an error that is not going to be yielded to user
        // as the operation has timed out or was cancelled.
        writeItem.callback(new Error('The operation was already cancelled or timeout elapsed'));
        continue;
      }
      let data;
      try {
        data = writeItem.operation.request.write(this.encoder, writeItem.operation.streamId);
      }
      catch (err) {
        writeItem.callback(err);
        continue;
      }
      totalLength += data.length;
      buffers.push(data);
      callbacks.push(writeItem.callback);
    }

    if (totalLength === 0) {
      this.isRunning = false;
      return;
    }

    // We have to invoke the callbacks to avoid race conditions.
    // There is a performance benefit from executing all of them in a loop
    for (let i = 0; i < callbacks.length; i++) {
      callbacks[i]();
    }

    // Concatenate buffers and write it to the socket
    // Further writes will be throttled until flushed
    this.canWrite = this.netClient.write(Buffer.concat(buffers, totalLength), err => {
      if (err) {
        this.setWriteError(err);
        return;
      }

      if (this.queue.length === 0 || !this.canWrite) {
        // It will start running once we get the next message or has drained
        this.isRunning = false;
        return;
      }

      // Allow IO between writes
      setImmediate(() => this.process());
    });
  }

  /**
   * Emits the 'error' event and callbacks items that haven't been written and clears them from the queue.
   * @param err
   */
  setWriteError(err) {
    err.isSocketError = true;
    this.error = new types$q.DriverError('Socket was closed');
    this.error.isSocketError = true;
    // Use an special flag for items that haven't been written
    this.error.requestNotWritten = true;
    this.error.innerError = err;
    const q = this.queue;
    // Not more items can be added to the queue.
    this.queue = utils$A.emptyArray;
    for (let i = 0; i < q.length; i++) {
      const item = q[i];
      // Use the error marking that it was not written
      item.callback(this.error);
    }
  }
};

var writers = { FrameWriter: FrameWriter$1, WriteQueue: WriteQueue$1 };

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const utils$z = utils$K;
const types$p = requireTypes();
const errors$i = errors$n;

const proxyExecuteKey$1 = 'ProxyExecute';

/**
 * A base class that represents a wrapper around the user provided query options with getter methods and proper
 * default values.
 * <p>
 *   Note that getter methods might return <code>undefined</code> when not set on the query options or default
 *  {@link Client} options.
 * </p>
 */
let ExecutionOptions$4 = class ExecutionOptions {

  /**
   * Creates a new instance of {@link ExecutionOptions}.
   */
  constructor() {
  }

  /**
   * Creates an empty instance, where all methods return undefined, used internally.
   * @ignore
   * @return {ExecutionOptions}
   */
  static empty() {
    return new ExecutionOptions();
  }

  /**
   * Determines if the stack trace before the query execution should be maintained.
   * @abstract
   * @returns {Boolean}
   */
  getCaptureStackTrace() {

  }

  /**
   * Gets the [Consistency level]{@link module:types~consistencies} to be used for the execution.
   * @abstract
   * @returns {Number}
   */
  getConsistency() {

  }

  /**
   * Key-value payload to be passed to the server. On the server side, implementations of QueryHandler can use
   * this data.
   * @abstract
   * @returns {Object}
   */
  getCustomPayload() {

  }

  /**
   * Gets the amount of rows to retrieve per page.
   * @abstract
   * @returns {Number}
   */
  getFetchSize() {

  }

  /**
   * When a fixed host is set on the query options and the query plan for the load-balancing policy is not used, it
   * gets the host that should handle the query.
   * @returns {Host}
   */
  getFixedHost() {

  }

  /**
   * Gets the type hints for parameters given in the query, ordered as for the parameters.
   * @abstract
   * @returns {Array|Array<Array>}
   */
  getHints() {

  }

  /**
   * Determines whether the driver must retrieve the following result pages automatically.
   * <p>
   *   This setting is only considered by the [Client#eachRow()]{@link Client#eachRow} method.
   * </p>
   * @abstract
   * @returns {Boolean}
   */
  isAutoPage() {

  }

  /**
   * Determines whether its a counter batch. Only valid for [Client#batch()]{@link Client#batch}, it will be ignored by
   * other methods.
   * @abstract
   * @returns {Boolean} A <code>Boolean</code> value, it can't be <code>undefined</code>.
   */
  isBatchCounter() {

  }

  /**
   * Determines whether the batch should be written to the batchlog. Only valid for
   * [Client#batch()]{@link Client#batch}, it will be ignored by other methods.
   * @abstract
   * @returns {Boolean} A <code>Boolean</code> value, it can't be <code>undefined</code>.
   */
  isBatchLogged() {

  }

  /**
   * Determines whether the query can be applied multiple times without changing the result beyond the initial
   * application.
   * @abstract
   * @returns {Boolean}
   */
  isIdempotent() {

  }

  /**
   * Determines whether the query must be prepared beforehand.
   * @abstract
   * @returns {Boolean} A <code>Boolean</code> value, it can't be <code>undefined</code>.
   */
  isPrepared() {

  }

  /**
   * Determines whether query tracing is enabled for the execution.
   * @abstract
   * @returns {Boolean}
   */
  isQueryTracing() {

  }

  /**
   * Gets the keyspace for the query when set at query options level.
   * <p>
   *   Note that this method will return <code>undefined</code> when the keyspace is not set at query options level.
   *   It will only return the keyspace name when the user provided a different keyspace than the current
   *   {@link Client} keyspace.
   * </p>
   * @abstract
   * @returns {String}
   */
  getKeyspace() {

  }

  /**
   * Gets the load balancing policy used for this execution.
   * @returns {LoadBalancingPolicy} A <code>LoadBalancingPolicy</code> instance, it can't be <code>undefined</code>.
   */
  getLoadBalancingPolicy() {

  }

  /**
   * Gets the Buffer representing the paging state.
   * @abstract
   * @returns {Buffer}
   */
  getPageState() {

  }

  /**
   * Internal method that gets the preferred host.
   * @abstract
   * @ignore
   */
  getPreferredHost() {

  }

  /**
   * Gets the query options as provided to the execution method without setting the default values.
   * @returns {QueryOptions}
   */
  getRawQueryOptions() {

  }

  /**
   * Gets the timeout in milliseconds to be used for the execution per coordinator.
   * <p>
   *   A value of <code>0</code> disables client side read timeout for the execution. Default: <code>undefined</code>.
   * </p>
   * @abstract
   * @returns {Number}
   */
  getReadTimeout() {

  }

  /**
   * Gets the [retry policy]{@link module:policies/retry} to be used.
   * @abstract
   * @returns {RetryPolicy} A <code>RetryPolicy</code> instance, it can't be <code>undefined</code>.
   */
  getRetryPolicy() {

  }

  /**
   * Internal method to obtain the row callback, for "by row" results.
   * @abstract
   * @ignore
   */
  getRowCallback() {

  }

  /**
   * Internal method to get or generate a timestamp for the request execution.
   * @ignore
   * @returns {Long|null}
   */
  getOrGenerateTimestamp() {

  }

  /**
   * Gets the index of the parameters that are part of the partition key to determine the routing.
   * @abstract
   * @ignore
   * @returns {Array}
   */
  getRoutingIndexes() {

  }

  /**
   * Gets the partition key(s) to determine which coordinator should be used for the query.
   * @abstract
   * @returns {Buffer|Array<Buffer>}
   */
  getRoutingKey() {

  }

  /**
   * Gets the array of the parameters names that are part of the partition key to determine the
   * routing. Only valid for non-prepared requests.
   * @abstract
   * @ignore
   */
  getRoutingNames() {

  }

  /**
   * Gets the the consistency level to be used for the serial phase of conditional updates.
   * @abstract
   * @returns {Number}
   */
  getSerialConsistency() {

  }

  /**
   * Gets the provided timestamp for the execution in microseconds from the unix epoch (00:00:00, January 1st, 1970).
   * <p>When a timestamp generator is used, this method returns <code>undefined</code>.</p>
   * @abstract
   * @returns {Number|Long|undefined|null}
   */
  getTimestamp() {

  }

  /**
   * @param {Array} hints
   * @abstract
   * @ignore
   */
  setHints(hints) {

  }

  /**
   * Sets the keyspace for the execution.
   * @ignore
   * @abstract
   * @param {String} keyspace
   */
  setKeyspace(keyspace) {

  }

  /**
   * @abstract
   * @ignore
   */
  setPageState() {

  }

  /**
   * Internal method that sets the preferred host.
   * @abstract
   * @ignore
   */
  setPreferredHost() {

  }

  /**
   * Sets the index of the parameters that are part of the partition key to determine the routing.
   * @param {Array} routingIndexes
   * @abstract
   * @ignore
   */
  setRoutingIndexes(routingIndexes) {

  }

  /**
   * Sets the routing key.
   * @abstract
   * @ignore
   */
  setRoutingKey(value) {

  }
};

/**
 * Internal implementation of {@link ExecutionOptions} that uses the value from the client options and execution
 * profile into account.
 * @ignore
 */
let DefaultExecutionOptions$2 = class DefaultExecutionOptions extends ExecutionOptions$4 {
  /**
   * Creates a new instance of {@link ExecutionOptions}.
   * @param {QueryOptions} queryOptions
   * @param {Client} client
   * @param {Function|null} rowCallback
   */
  constructor(queryOptions, client, rowCallback) {
    super();

    this._queryOptions = queryOptions;
    this._rowCallback = rowCallback;
    this._routingKey = this._queryOptions.routingKey;
    this._hints = this._queryOptions.hints;
    this._keyspace = this._queryOptions.keyspace;
    this._routingIndexes = this._queryOptions.routingIndexes;
    this._pageState = typeof this._queryOptions.pageState === 'string' ?
      utils$z.allocBufferFromString(this._queryOptions.pageState, 'hex') : this._queryOptions.pageState;
    this._preferredHost = null;

    this._client = client;
    this._defaultQueryOptions = client.options.queryOptions;
    this._profile = client.profileManager.getProfile(this._queryOptions.executionProfile);

    // Build a custom payload object designed for DSE-specific functionality
    this._customPayload = DefaultExecutionOptions.createCustomPayload(this._queryOptions, this._defaultQueryOptions);

    if (!this._profile) {
      throw new errors$i.ArgumentError(`Execution profile "${this._queryOptions.executionProfile}" not found`);
    }
  }

  /**
   * Creates a payload for given user.
   * @param {QueryOptions} userOptions
   * @param {QueryOptions} defaultQueryOptions
   * @private
   */
  static createCustomPayload(userOptions, defaultQueryOptions) {
    let customPayload = userOptions.customPayload || defaultQueryOptions.customPayload;
    const executeAs = userOptions.executeAs || defaultQueryOptions.executeAs;

    if (executeAs) {
      if (!customPayload) {
        customPayload = {};
        customPayload[proxyExecuteKey$1] = utils$z.allocBufferFromString(executeAs);
      } else if (!customPayload[proxyExecuteKey$1]) {
        // Avoid appending to the existing payload object
        customPayload = utils$z.extend({}, customPayload);
        customPayload[proxyExecuteKey$1] = utils$z.allocBufferFromString(executeAs);
      }
    }

    return customPayload;
  }

  /**
   * Creates a new instance {@link ExecutionOptions}, based on the query options.
   * @param {QueryOptions|null} queryOptions
   * @param {Client} client
   * @param {Function|null} [rowCallback]
   * @ignore
   * @return {ExecutionOptions}
   */
  static create(queryOptions, client, rowCallback) {
    if (!queryOptions || typeof queryOptions === 'function') {
      // queryOptions can be null/undefined and could be of type function when is an optional parameter
      queryOptions = utils$z.emptyObject;
    }
    return new DefaultExecutionOptions(queryOptions, client, rowCallback);
  }

  getCaptureStackTrace() {
    return ifUndefined(this._queryOptions.captureStackTrace, this._defaultQueryOptions.captureStackTrace);
  }

  getConsistency() {
    return ifUndefined3(this._queryOptions.consistency, this._profile.consistency,
      this._defaultQueryOptions.consistency);
  }

  getCustomPayload() {
    return this._customPayload;
  }

  getFetchSize() {
    return ifUndefined(this._queryOptions.fetchSize, this._defaultQueryOptions.fetchSize);
  }

  getFixedHost() {
    return this._queryOptions.host;
  }

  getHints() {
    return this._hints;
  }

  isAutoPage() {
    return ifUndefined(this._queryOptions.autoPage, this._defaultQueryOptions.autoPage);
  }

  isBatchCounter() {
    return ifUndefined(this._queryOptions.counter, false);
  }

  isBatchLogged() {
    return ifUndefined3(this._queryOptions.logged, this._defaultQueryOptions.logged, true);
  }

  isIdempotent() {
    return ifUndefined(this._queryOptions.isIdempotent, this._defaultQueryOptions.isIdempotent);
  }

  /**
   * Determines if the query execution must be prepared beforehand.
   * @return {Boolean}
   */
  isPrepared() {
    return ifUndefined(this._queryOptions.prepare, this._defaultQueryOptions.prepare);
  }

  isQueryTracing() {
    return ifUndefined(this._queryOptions.traceQuery, this._defaultQueryOptions.traceQuery);
  }

  getKeyspace() {
    return this._keyspace;
  }

  getLoadBalancingPolicy() {
    return this._profile.loadBalancing;
  }

  getOrGenerateTimestamp() {
    let result = this.getTimestamp();

    if (result === undefined) {
      const generator = this._client.options.policies.timestampGeneration;

      if ( types$p.protocolVersion.supportsTimestamp(this._client.controlConnection.protocolVersion) && generator) {
        result = generator.next(this._client);
      } else {
        result = null;
      }
    }

    return typeof result === 'number' ? types$p.Long.fromNumber(result) : result;
  }

  getPageState() {
    return this._pageState;
  }

  /**
   * Gets the profile defined by the user or the default profile
   * @internal
   * @ignore
   */
  getProfile() {
    return this._profile;
  }

  getRawQueryOptions() {
    return this._queryOptions;
  }

  getReadTimeout() {
    return ifUndefined3(this._queryOptions.readTimeout, this._profile.readTimeout,
      this._client.options.socketOptions.readTimeout);
  }

  getRetryPolicy() {
    return ifUndefined3(this._queryOptions.retry, this._profile.retry, this._client.options.policies.retry);
  }

  getRoutingIndexes() {
    return this._routingIndexes;
  }

  getRoutingKey() {
    return this._routingKey;
  }

  getRoutingNames() {
    return this._queryOptions.routingNames;
  }

  /**
   * Internal method to obtain the row callback, for "by row" results.
   * @ignore
   */
  getRowCallback() {
    return this._rowCallback;
  }

  getSerialConsistency() {
    return ifUndefined3(
      this._queryOptions.serialConsistency, this._profile.serialConsistency, this._defaultQueryOptions.serialConsistency);
  }

  getTimestamp() {
    return this._queryOptions.timestamp;
  }

  /**
   * Internal property to set the custom payload.
   * @ignore
   * @internal
   * @param {Object} payload
   */
  setCustomPayload(payload) {
    this._customPayload = payload;
  }

  /**
   * @param {Array} hints
   */
  setHints(hints) {
    this._hints = hints;
  }

  /**
   * @param {String} keyspace
   */
  setKeyspace(keyspace) {
    this._keyspace = keyspace;
  }

  /**
   * @param {Buffer} pageState
   */
  setPageState(pageState) {
    this._pageState = pageState;
  }

  /**
   * @param {Array} routingIndexes
   */
  setRoutingIndexes(routingIndexes) {
    this._routingIndexes = routingIndexes;
  }

  setRoutingKey(value) {
    this._routingKey = value;
  }
};

function ifUndefined(v1, v2) {
  return v1 !== undefined ? v1 : v2;
}

function ifUndefined3(v1, v2, v3) {
  if (v1 !== undefined) {
    return v1;
  }
  return v2 !== undefined ? v2 : v3;
}

var executionOptions = { ExecutionOptions: ExecutionOptions$4, DefaultExecutionOptions: DefaultExecutionOptions$2, proxyExecuteKey: proxyExecuteKey$1 };

var name = "cassandra-driver";
var version$1 = "4.6.4";
var description$1 = "DataStax Node.js Driver for Apache Cassandra";
var author = "DataStax";
var keywords = [
	"cassandra",
	"cql",
	"cql3",
	"connection",
	"gremlin",
	"datastax",
	"nosql",
	"driver",
	"database",
	"dse",
	"graph",
	"graphdb"
];
var license = "Apache-2.0";
var types$o = "./index.d.ts";
var dependencies = {
	"@types/long": "^4.0.0",
	"@types/node": ">=8",
	"adm-zip": "^0.5.3",
	long: "^2.2.0"
};
var devDependencies = {
	chai: "4.2.0",
	mocha: "~7.1.1",
	proxyquire: "~2.1.3",
	sinon: "~7.5.0",
	temp: ">= 0.8.3"
};
var repository = {
	type: "git",
	url: "https://github.com/datastax/nodejs-driver.git"
};
var bugs = {
	url: "https://groups.google.com/a/lists.datastax.com/forum/#!forum/nodejs-driver-user"
};
var scripts = {
	test: "./node_modules/.bin/mocha test/unit -R spec -t 5000 --recursive",
	unit: "./node_modules/.bin/mocha test/unit -R spec -t 5000 --recursive",
	integration_short: "./node_modules/.bin/mocha test/integration/short -R spec -t 5000 --recursive",
	integration_long: "./node_modules/.bin/mocha test/integration/long -R spec -t 5000 --recursive",
	ci_jenkins: "./node_modules/.bin/mocha test/unit test/integration/short --recursive -R mocha-jenkins-reporter --exit",
	ci_appveyor: "./node_modules/.bin/mocha test/unit test/integration/short --recursive -R mocha-appveyor-reporter --exit",
	ci_unit_appveyor: "./node_modules/.bin/mocha test/unit --recursive -R mocha-appveyor-reporter --exit",
	server_api: "./node_modules/.bin/mocha test/integration/short -g '@SERVER_API' --recursive --exit",
	eslint: "eslint lib test"
};
var engines = {
	node: ">=8"
};
var require$$17 = {
	name: name,
	version: version$1,
	description: description$1,
	author: author,
	keywords: keywords,
	license: license,
	types: types$o,
	dependencies: dependencies,
	devDependencies: devDependencies,
	repository: repository,
	bugs: bugs,
	scripts: scripts,
	engines: engines
};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const util$q = require$$0$4;

const { FrameWriter } = writers;
const types$n = requireTypes();
const utils$y = utils$K;
const { ExecutionOptions: ExecutionOptions$3 } = executionOptions;
const packageInfo$1 = require$$17;

/**
 * Options for the execution of the query / prepared statement
 * @private
 */
const queryFlag = {
  values:                 0x01,
  skipMetadata:           0x02,
  pageSize:               0x04,
  withPagingState:        0x08,
  withSerialConsistency:  0x10,
  withDefaultTimestamp:   0x20,
  withNameForValues:      0x40,
  withKeyspace:           0x80,
  withPageSizeBytes: 0x40000000,
  withContinuousPaging: 0x80000000
};

/**
 * Options for the execution of a batch request from protocol v3 and above
 * @private
 */
const batchFlag = {
  withSerialConsistency:  0x10,
  withDefaultTimestamp:   0x20,
  withNameForValues:      0x40,
  withKeyspace:           0x80
};

/**
 * Options for execution of a prepare request from protocol DSE_V2 and above
 * @private
 */
const prepareFlag = {
  withKeyspace:           0x01
};

const batchType = {
  logged: 0,
  unlogged: 1,
  counter: 2
};

/**
 * Abstract class Request
 */
class Request {
  constructor() {
    this.length = 0;
  }

  /**
   * @abstract
   * @param {Encoder} encoder
   * @param {Number} streamId
   * @throws {TypeError}
   * @returns {Buffer}
   */
  write(encoder, streamId) {
    throw new Error('Method must be implemented');
  }

  /**
   * Creates a new instance using the same constructor as the current instance, copying the properties.
   * @return {Request}
   */
  clone() {
    const newRequest = new (this.constructor)();
    const keysArray = Object.keys(this);
    for (let i = 0; i < keysArray.length; i++) {
      const key = keysArray[i];
      newRequest[key] = this[key];
    }
    return newRequest;
  }
}

/**
 * Writes a execute query (given a prepared queryId)
 * @param {String} query
 * @param {Buffer} queryId
 * @param {Array} params
 * @param options
 */
let ExecuteRequest$1 = class ExecuteRequest extends Request {
  /**
   * @param {String} query
   * @param queryId
   * @param params
   * @param {ExecutionOptions} execOptions
   * @param meta
   */
  constructor(query, queryId, params, execOptions, meta) {
    super();

    this.query = query;
    this.queryId = queryId;
    this.params = params;
    this.meta = meta;
    this.options = execOptions || ExecutionOptions$3.empty();
    this.consistency = this.options.getConsistency() || types$n.consistencies.one;
    // Only QUERY request parameters are encoded as named parameters
    // EXECUTE request parameters are always encoded as positional parameters
    this.namedParameters = false;
  }

  getParamType(index) {
    const columnInfo = this.meta.columns[index];
    return columnInfo ? columnInfo.type : null;
  }

  write(encoder, streamId) {
    //v1: <queryId>
    //      <n><value_1>....<value_n><consistency>
    //v2: <queryId>
    //      <consistency><flags>[<n><value_1>...<value_n>][<result_page_size>][<paging_state>][<serial_consistency>]
    //v3: <queryId>
    //      <consistency><flags>[<n>[name_1]<value_1>...[name_n]<value_n>][<result_page_size>][<paging_state>][<serial_consistency>][<timestamp>]
    const frameWriter = new FrameWriter(types$n.opcodes.execute);
    let headerFlags = this.options.isQueryTracing() ? types$n.frameFlags.tracing : 0;
    if (this.options.getCustomPayload()) {
      //The body may contain the custom payload
      headerFlags |= types$n.frameFlags.customPayload;
      frameWriter.writeCustomPayload(this.options.getCustomPayload());
    }
    frameWriter.writeShortBytes(this.queryId);
    if(types$n.protocolVersion.supportsResultMetadataId(encoder.protocolVersion)) {
      frameWriter.writeShortBytes(this.meta.resultId);
    }
    this.writeQueryParameters(frameWriter, encoder);

    // Record the length of the body of the request before writing it
    this.length = frameWriter.bodyLength;

    return frameWriter.write(encoder.protocolVersion, streamId, headerFlags);
  }

  /**
   * Writes v1 and v2 execute query parameters
   * @param {FrameWriter} frameWriter
   * @param {Encoder} encoder
   * @param {Boolean} [isQuery] True if query, otherwise assumed to be execute request.
   */
  writeQueryParameters(frameWriter, encoder, isQuery) {
    //v1: <n><value_1>....<value_n><consistency>
    //v2: <consistency><flags>[<n><value_1>...<value_n>][<result_page_size>][<paging_state>][<serial_consistency>]
    //v3: <consistency><flags>[<n>[name_1]<value_1>...[name_n]<value_n>][<result_page_size>][<paging_state>][<serial_consistency>][<timestamp>]
    //dse_v1: <consistency><flags>[<n>[name_1]<value_1>...[name_n]<value_n>][<result_page_size>][<paging_state>]
    //          [<serial_consistency>][<timestamp>][continuous_paging_options]
    //dse_v2: <consistency><flags>[<n>[name_1]<value_1>...[name_n]<value_n>][<result_page_size>][<paging_state>]
    //          [<serial_consistency>][<timestamp>][keyspace][continuous_paging_options]
    let flags = 0;

    const timestamp = this.options.getOrGenerateTimestamp();

    if (types$n.protocolVersion.supportsPaging(encoder.protocolVersion)) {
      flags |= (this.params && this.params.length) ? queryFlag.values : 0;
      flags |= (this.options.getFetchSize() > 0) ? queryFlag.pageSize : 0;
      flags |= this.options.getPageState() ? queryFlag.withPagingState : 0;
      flags |= this.options.getSerialConsistency() ? queryFlag.withSerialConsistency : 0;
      flags |= timestamp !== null && timestamp !== undefined ? queryFlag.withDefaultTimestamp : 0;
      flags |= this.namedParameters ? queryFlag.withNameForValues : 0;

      // Don't inject keyspace for EXECUTE requests as inherited from prepared statement.
      const supportsKeyspace = isQuery && types$n.protocolVersion.supportsKeyspaceInRequest(encoder.protocolVersion);
      flags |= supportsKeyspace && this.options.getKeyspace() ? queryFlag.withKeyspace : 0;

      frameWriter.writeShort(this.consistency);
      if (types$n.protocolVersion.uses4BytesQueryFlags(encoder.protocolVersion)) {
        frameWriter.writeInt(flags);
      }
      else {
        frameWriter.writeByte(flags);
      }
    }

    if (this.params && this.params.length) {
      frameWriter.writeShort(this.params.length);
      for (let i = 0; i < this.params.length; i++) {
        let paramValue = this.params[i];
        if (flags & queryFlag.withNameForValues) {
          //parameter is composed by name / value
          frameWriter.writeString(paramValue.name);
          paramValue = paramValue.value;
        }
        frameWriter.writeBytes(encoder.encode(paramValue, this.getParamType(i)));
      }
    }

    if (!types$n.protocolVersion.supportsPaging(encoder.protocolVersion)) {
      if (!this.params || !this.params.length) {
        //zero parameters
        frameWriter.writeShort(0);
      }
      frameWriter.writeShort(this.consistency);
      return;
    }
    if (flags & queryFlag.pageSize) {
      frameWriter.writeInt(this.options.getFetchSize());
    }
    if (flags & queryFlag.withPagingState) {
      frameWriter.writeBytes(this.options.getPageState());
    }
    if (flags & queryFlag.withSerialConsistency) {
      frameWriter.writeShort(this.options.getSerialConsistency());
    }
    if (flags & queryFlag.withDefaultTimestamp) {
      frameWriter.writeLong(timestamp);
    }
    if (flags & queryFlag.withKeyspace) {
      frameWriter.writeString(this.options.getKeyspace());
    }
  }
};

let QueryRequest$1 = class QueryRequest extends ExecuteRequest$1 {
  /**
   * @param {String} query
   * @param params
   * @param {ExecutionOptions} [execOptions]
   * @param {Boolean} [namedParameters]
   */
  constructor(query, params, execOptions, namedParameters) {
    super(query, null, params, execOptions, null);
    this.hints = this.options.getHints() || utils$y.emptyArray;
    this.namedParameters = namedParameters;
  }

  getParamType(index) {
    return this.hints[index];
  }

  write(encoder, streamId) {
    //v1: <query><consistency>
    //v2: <query>
    //      <consistency><flags>[<n><value_1>...<value_n>][<result_page_size>][<paging_state>][<serial_consistency>]
    //v3: <query>
    //      <consistency><flags>[<n>[name_1]<value_1>...[name_n]<value_n>][<result_page_size>][<paging_state>][<serial_consistency>][<timestamp>]
    const frameWriter = new FrameWriter(types$n.opcodes.query);
    let headerFlags = this.options.isQueryTracing() ? types$n.frameFlags.tracing : 0;
    if (this.options.getCustomPayload()) {
      //The body may contain the custom payload
      headerFlags |= types$n.frameFlags.customPayload;
      frameWriter.writeCustomPayload(this.options.getCustomPayload());
    }

    frameWriter.writeLString(this.query);

    if (!types$n.protocolVersion.supportsPaging(encoder.protocolVersion)) {
      frameWriter.writeShort(this.consistency);
    } else {
      //Use the same fields as the execute writer
      this.writeQueryParameters(frameWriter, encoder, true);
    }

    // Record the length of the body of the request before writing it
    this.length = frameWriter.bodyLength;

    return frameWriter.write(encoder.protocolVersion, streamId, headerFlags);
  }
};

class PrepareRequest extends Request {
  constructor(query, keyspace) {
    super();
    this.query = query;
    this.keyspace = keyspace;
  }

  write(encoder, streamId) {
    const frameWriter = new FrameWriter(types$n.opcodes.prepare);
    frameWriter.writeLString(this.query);
    if (types$n.protocolVersion.supportsPrepareFlags(encoder.protocolVersion)) {
      const flags = this.keyspace && types$n.protocolVersion.supportsKeyspaceInRequest(encoder.protocolVersion) ? prepareFlag.withKeyspace : 0;
      frameWriter.writeInt(flags);
      if (flags & prepareFlag.withKeyspace) {
        frameWriter.writeString(this.keyspace);
      }
    }
    return frameWriter.write(encoder.protocolVersion, streamId);
  }
}

class StartupRequest extends Request {

  /**
   * Creates a new instance of {@link StartupRequest}.
   * @param {Object} [options]
   * @param [options.cqlVersion]
   * @param [options.noCompact]
   * @param [options.clientId]
   * @param [options.applicationName]
   * @param [options.applicationVersion]
   */
  constructor(options) {
    super();
    this.options = options || {};
  }

  write(encoder, streamId) {
    const frameWriter = new FrameWriter(types$n.opcodes.startup);

    const startupOptions = {
      CQL_VERSION: this.options.cqlVersion || '3.0.0',
      DRIVER_NAME: packageInfo$1.description,
      DRIVER_VERSION: packageInfo$1.version
    };

    if(this.options.noCompact) {
      startupOptions['NO_COMPACT'] = 'true';
    }

    if (this.options.clientId) {
      startupOptions['CLIENT_ID'] = this.options.clientId.toString();
    }

    if (this.options.applicationName) {
      startupOptions['APPLICATION_NAME'] = this.options.applicationName;
    }

    if (this.options.applicationVersion) {
      startupOptions['APPLICATION_VERSION'] = this.options.applicationVersion;
    }

    frameWriter.writeStringMap(startupOptions);
    return frameWriter.write(encoder.protocolVersion, streamId);
  }
}

class RegisterRequest extends Request {
  constructor(events) {
    super();
    this.events = events;
  }

  write(encoder, streamId) {
    const frameWriter = new FrameWriter(types$n.opcodes.register);
    frameWriter.writeStringList(this.events);
    return frameWriter.write(encoder.protocolVersion, streamId);
  }
}

/**
 * Represents an AUTH_RESPONSE request
 * @param {Buffer} token
 */
class AuthResponseRequest extends Request {
  constructor(token) {
    super();
    this.token = token;
  }

  write(encoder, streamId) {
    const frameWriter = new FrameWriter(types$n.opcodes.authResponse);
    frameWriter.writeBytes(this.token);
    return frameWriter.write(encoder.protocolVersion, streamId);
  }
}

/**
 * Represents a protocol v1 CREDENTIALS request message
 */
class CredentialsRequest extends Request {
  constructor(username, password) {
    super();
    this.username = username;
    this.password = password;
  }

  write(encoder, streamId) {
    const frameWriter = new FrameWriter(types$n.opcodes.credentials);
    frameWriter.writeStringMap({ username:this.username, password:this.password });
    return frameWriter.write(encoder.protocolVersion, streamId);
  }
}

class BatchRequest extends Request {
  /**
   * Creates a new instance of BatchRequest.
   * @param {Array.<{query, params, [info]}>} queries Array of objects with the properties query and params
   * @param {ExecutionOptions} execOptions
   */
  constructor(queries, execOptions) {
    super();
    this.queries = queries;
    this.options = execOptions;
    this.hints = execOptions.getHints() || utils$y.emptyArray;
    this.type = batchType.logged;

    if (execOptions.isBatchCounter()) {
      this.type = batchType.counter;
    } else if (!execOptions.isBatchLogged()) {
      this.type = batchType.unlogged;
    }
  }

  /**
  * Writes a batch request
  */
  write(encoder, streamId) {
    //v2: <type><n><query_1>...<query_n><consistency>
    //v3: <type><n><query_1>...<query_n><consistency><flags>[<serial_consistency>][<timestamp>]
    //dseV1+: similar to v3/v4, flags is an int instead of a byte
    if (!this.queries || !(this.queries.length > 0)) {
      throw new TypeError(util$q.format('Invalid queries provided %s', this.queries));
    }
    const frameWriter = new FrameWriter(types$n.opcodes.batch);
    let headerFlags = this.options.isQueryTracing() ? types$n.frameFlags.tracing : 0;
    if (this.options.getCustomPayload()) {
      //The body may contain the custom payload
      headerFlags |= types$n.frameFlags.customPayload;
      frameWriter.writeCustomPayload(this.options.getCustomPayload());
    }
    frameWriter.writeByte(this.type);
    frameWriter.writeShort(this.queries.length);
    const self = this;
    this.queries.forEach(function eachQuery(item, i) {
      const hints = self.hints[i];
      const params = item.params || utils$y.emptyArray;
      let getParamType;
      if (item.queryId) {
        // Contains prepared queries
        frameWriter.writeByte(1);
        frameWriter.writeShortBytes(item.queryId);
        getParamType = i => item.meta.columns[i].type;
      }
      else {
        // Contains string queries
        frameWriter.writeByte(0);
        frameWriter.writeLString(item.query);
        getParamType = hints ? (i => hints[i]) : (() => null);
      }

      frameWriter.writeShort(params.length);
      params.forEach((param, index) => frameWriter.writeBytes(encoder.encode(param, getParamType(index))));
    }, this);

    frameWriter.writeShort(this.options.getConsistency());

    if (types$n.protocolVersion.supportsTimestamp(encoder.protocolVersion)) {
      // Batch flags
      let flags = this.options.getSerialConsistency() ? batchFlag.withSerialConsistency : 0;
      const timestamp = this.options.getOrGenerateTimestamp();
      flags |= timestamp !== null && timestamp !== undefined ? batchFlag.withDefaultTimestamp : 0;

      flags |= this.options.getKeyspace() && types$n.protocolVersion.supportsKeyspaceInRequest(encoder.protocolVersion)
        ? batchFlag.withKeyspace : 0;

      if (types$n.protocolVersion.uses4BytesQueryFlags(encoder.protocolVersion)) {
        frameWriter.writeInt(flags);
      }
      else {
        frameWriter.writeByte(flags);
      }

      if (flags & batchFlag.withSerialConsistency) {
        frameWriter.writeShort(this.options.getSerialConsistency());
      }

      if (flags & batchFlag.withDefaultTimestamp) {
        frameWriter.writeLong(timestamp);
      }

      if (flags & batchFlag.withKeyspace) {
        frameWriter.writeString(this.options.getKeyspace());
      }
    }

    // Set the length of the body of the request before writing it
    this.length = frameWriter.bodyLength;

    return frameWriter.write(encoder.protocolVersion, streamId, headerFlags);
  }

  clone() {
    return new BatchRequest(this.queries, this.options);
  }
}

function CancelRequest(operationId) {
  this.streamId = null;
  this.operationId = operationId;
}

util$q.inherits(CancelRequest, Request);

CancelRequest.prototype.write = function (encoder, streamId) {
  const frameWriter = new FrameWriter(types$n.opcodes.cancel);
  frameWriter.writeInt(1);
  frameWriter.writeInt(this.operationId);
  return frameWriter.write(encoder.protocolVersion, streamId);
};

class OptionsRequest extends Request {

  write(encoder, streamId) {
    const frameWriter = new FrameWriter(types$n.opcodes.options);
    return frameWriter.write(encoder.protocolVersion, streamId, 0);
  }

  clone() {
    // since options has no unique state, simply return self.
    return this;
  }
}

const options$1 = new OptionsRequest();

requests$7.AuthResponseRequest = AuthResponseRequest;
requests$7.BatchRequest = BatchRequest;
requests$7.CancelRequest = CancelRequest;
requests$7.CredentialsRequest = CredentialsRequest;
requests$7.ExecuteRequest = ExecuteRequest$1;
requests$7.PrepareRequest = PrepareRequest;
requests$7.QueryRequest = QueryRequest$1;
requests$7.Request = Request;
requests$7.RegisterRequest = RegisterRequest;
requests$7.StartupRequest = StartupRequest;
requests$7.options = options$1;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const util$p = require$$0$4;
const errors$h = errors$n;

/**
 * Represents the state of a {@link Client}.
 * <p>
 * Exposes information on the connections maintained by a Client at a specific time.
 * </p>
 * @alias module:metadata~ClientState
 * @constructor
 */
let ClientState$1 = class ClientState {

  /**
   * Creates a new instance of <code>ClientState</code>.
   * @param {Array<Host>} hosts
   * @param {Object.<String, Number>} openConnections
   * @param {Object.<String, Number>} inFlightQueries
   */
  constructor(hosts, openConnections, inFlightQueries) {
    this._hosts = hosts;
    this._openConnections = openConnections;
    this._inFlightQueries = inFlightQueries;
  }

  /**
   * Get an array of hosts to which the client is connected to.
   * @return {Array<Host>}
   */
  getConnectedHosts() {
    return this._hosts;
  }

  /**
   * Gets the amount of open connections to a given host.
   * @param {Host} host
   * @return {Number}
   */
  getOpenConnections(host) {
    if (!host) {
      throw new errors$h.ArgumentError('Host is not defined');
    }

    return this._openConnections[host.address] || 0;
  }

  /**
   * Gets the amount of queries that are currently being executed through a given host.
   * <p>
   * This corresponds to the number of queries that have been sent by the Client to server Host on one of its connections
   * but haven't yet obtained a response.
   * </p>
   * @param {Host} host
   * @return {Number}
   */
  getInFlightQueries(host) {
    if (!host) {
      throw new errors$h.ArgumentError('Host is not defined');
    }

    return this._inFlightQueries[host.address] || 0;
  }

  /**
   * Returns the string representation of the instance.
   */
  toString() {
    return util$p.format('{"hosts": %j, "openConnections": %j, "inFlightQueries": %j}',
      this._hosts.map(function (h) { return h.address; }), this._openConnections, this._inFlightQueries);
  }

  /**
   * Creates a new instance from the provided client.
   * @param {Client} client
   * @internal
   * @ignore
   */
  static from(client) {
    const openConnections = {};
    const inFlightQueries = {};
    const hostArray = [];

    client.hosts.forEach(host => {
      if (host.pool.connections.length === 0) {
        return;
      }

      hostArray.push(host);
      openConnections[host.address] = host.pool.connections.length;
      inFlightQueries[host.address] = host.getInFlight();
    });

    return new ClientState(hostArray, openConnections, inFlightQueries);
  }
};

var clientState = ClientState$1;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const Long$3 = LongExports;

const TWO_PWR_16_DBL = 1 << 16;
const TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

/**
 * Constructs a signed int64 representation.
 * @ignore
 */
let MutableLong$2 = class MutableLong {
  constructor(b00, b16, b32, b48) {
    // Use an array of uint16
    this._arr = [b00 & 0xffff, b16 & 0xffff, b32 & 0xffff, b48 & 0xffff];
  }

  toString() {
    return this.toImmutable().toString();
  }

  /**
   * Compares this value with the provided value.
   * @param {MutableLong} other
   * @return {number}
   */
  compare(other) {
    const thisNeg = this.isNegative();
    const otherNeg = other.isNegative();
    if (thisNeg && !otherNeg) {
      return -1;
    }
    if (!thisNeg && otherNeg) {
      return 1;
    }
    // At this point the sign bits are the same
    return this._compareBits(other);
  }

  _compareBits(other) {
    for (let i = 3; i >= 0; i--) {
      if (this._arr[i] > other._arr[i]) {
        return 1;
      }
      if (this._arr[i] < other._arr[i]) {
        return -1;
      }
    }
    return 0;
  }

  getUint16(index) {
    return this._arr[index];
  }

  getLowBitsUnsigned() {
    return (this._arr[0] | ((this._arr[1] & 0xffff) << 16)) >>> 0;
  }

  getHighBitsUnsigned() {
    return (this._arr[2] | (this._arr[3] << 16)) >>> 0;
  }

  toNumber() {
    return (this._arr[3] << 16 | this._arr[2]) * TWO_PWR_32_DBL + ((this._arr[1] << 16 | this._arr[0]) >>> 0);
  }

  /**
   * Performs the bitwise NOT of this value.
   * @return {MutableLong}
   */
  not() {
    this._arr[0] = ~this._arr[0] & 0xffff;
    this._arr[1] = ~this._arr[1] & 0xffff;
    this._arr[2] = ~this._arr[2] & 0xffff;
    this._arr[3] = ~this._arr[3] & 0xffff;
    return this;
  }

  add(addend) {
    let c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += this._arr[0] + addend._arr[0];
    this._arr[0] = c00 & 0xffff;
    c16 += c00 >>> 16;
    c16 += this._arr[1] + addend._arr[1];
    this._arr[1] = c16 & 0xffff;
    c32 += c16 >>> 16;
    c32 += this._arr[2] + addend._arr[2];
    this._arr[2] = c32 & 0xffff;
    c48 += c32 >>> 16;
    c48 += this._arr[3] + addend._arr[3];
    this._arr[3] = c48 & 0xffff;
    return this;
  }

  shiftLeft(numBits) {
    if (numBits === 0) {
      return this;
    }
    if (numBits >= 64) {
      return this.toZero();
    }
    const remainingBits = numBits % 16;
    const pos = Math.floor(numBits / 16);
    if (pos > 0) {
      this._arr[3] = this._arr[3 - pos];
      this._arr[2] = pos > 2 ? 0 : this._arr[2 - pos];
      this._arr[1] = pos > 1 ? 0 : this._arr[0];
      this._arr[0] = 0;
    }
    if (remainingBits > 0) {
      // shift left within the int16 and the next one
      this._arr[3] = ((this._arr[3] << remainingBits) | (this._arr[2] >>> (16 - remainingBits))) & 0xffff;
      this._arr[2] = ((this._arr[2] << remainingBits) | (this._arr[1] >>> (16 - remainingBits))) & 0xffff;
      this._arr[1] = ((this._arr[1] << remainingBits) | (this._arr[0] >>> (16 - remainingBits))) & 0xffff;
      this._arr[0] = (this._arr[0] << remainingBits) & 0xffff;
    }
    return this;
  }

  shiftRightUnsigned(numBits) {
    if (numBits === 0) {
      return this;
    }
    if (numBits >= 64) {
      return this.toZero();
    }
    const remainingBits = numBits % 16;
    const pos = Math.floor(numBits / 16);
    if (pos > 0) {
      this._arr[0] = this._arr[pos];
      this._arr[1] = pos > 2 ? 0 : this._arr[1 + pos];
      this._arr[2] = pos > 1 ? 0 : this._arr[3];
      this._arr[3] = 0;
    }
    if (remainingBits > 0) {
      this._arr[0] = (this._arr[0] >>> remainingBits) | ((this._arr[1] << (16 - remainingBits)) & 0xffff);
      this._arr[1] = (this._arr[1] >>> remainingBits) | ((this._arr[2] << (16 - remainingBits)) & 0xffff);
      this._arr[2] = (this._arr[2] >>> remainingBits) | ((this._arr[3] << (16 - remainingBits)) & 0xffff);
      this._arr[3] = this._arr[3] >>> remainingBits;
    }
    return this;
  }

  or(other) {
    this._arr[0] |= other._arr[0];
    this._arr[1] |= other._arr[1];
    this._arr[2] |= other._arr[2];
    this._arr[3] |= other._arr[3];
    return this;
  }

  /**
   * Returns the bitwise XOR of this Long and the given one.
   * @param {MutableLong} other
   * @returns {MutableLong} this instance.
   */
  xor(other) {
    this._arr[0] ^= other._arr[0];
    this._arr[1] ^= other._arr[1];
    this._arr[2] ^= other._arr[2];
    this._arr[3] ^= other._arr[3];
    return this;
  }

  clone() {
    return new MutableLong(this._arr[0], this._arr[1], this._arr[2], this._arr[3]);
  }

  /**
   * Performs the product of this and the specified Long.
   * @param {MutableLong} multiplier
   * @returns {MutableLong} this instance.
   */
  multiply(multiplier) {
    let negate = false;
    if (this.isZero() || multiplier.isZero()) {
      return this.toZero();
    }
    if (this.isNegative()) {
      this.negate();
      negate = !negate;
    }
    if (multiplier.isNegative()) {
      multiplier = multiplier.clone().negate();
      negate = !negate;
    }
    // We can skip products that would overflow.
    let c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += this._arr[0] * multiplier._arr[0];
    c16 += c00 >>> 16;
    c16 += this._arr[1] * multiplier._arr[0];
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c16 += this._arr[0] * multiplier._arr[1];
    c32 += c16 >>> 16;
    c32 += this._arr[2] * multiplier._arr[0];
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += this._arr[1] * multiplier._arr[1];
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += this._arr[0] * multiplier._arr[2];
    c48 += c32 >>> 16;
    c48 += this._arr[3] * multiplier._arr[0] + this._arr[2] * multiplier._arr[1] +
      this._arr[1] * multiplier._arr[2] + this._arr[0] * multiplier._arr[3];
    this._arr[0] = c00 & 0xffff;
    this._arr[1] = c16 & 0xffff;
    this._arr[2] = c32 & 0xffff;
    this._arr[3] = c48 & 0xffff;
    if (negate) {
      this.negate();
    }
    return this;
  }

  toZero() {
    this._arr[3] = this._arr[2] = this._arr[1] = this._arr[0] = 0;
    return this;
  }

  isZero() {
    return (this._arr[3] === 0 && this._arr[2] === 0 && this._arr[1] === 0 && this._arr[0] === 0);
  }

  isNegative() {
    // most significant bit turned on
    return (this._arr[3] & 0x8000) > 0;
  }

  /**
   * Negates this value.
   * @return {MutableLong}
   */
  negate() {
    return this.not().add(MutableLong.one);
  }

  equals(other) {
    if (!(other instanceof MutableLong)) {
      return false;
    }
    return (this._arr[0] === other._arr[0] && this._arr[1] === other._arr[1] &&
      this._arr[2] === other._arr[2] && this._arr[3] === other._arr[3]);
  }

  toImmutable() {
    return Long$3.fromBits(this.getLowBitsUnsigned(), this.getHighBitsUnsigned(), false);
  }

  static fromNumber(value) {
    if (isNaN(value) || !isFinite(value)) {
      return new MutableLong();
    }
    if (value < 0) {
      return MutableLong.fromNumber(-value).negate();
    }
    const low32Bits = value % TWO_PWR_32_DBL;
    const high32Bits = value / TWO_PWR_32_DBL;
    return MutableLong.fromBits(low32Bits, high32Bits);
  }

  static fromBits(low32Bits, high32Bits) {
    return new MutableLong(low32Bits, low32Bits >>> 16, high32Bits, high32Bits >>> 16);
  }

  /**
   * Returns a Long representation of the given string, written using the specified radix.
   * @param {String} str
   * @param {Number} [radix]
   * @return {MutableLong}
   */
  static fromString(str, radix) {
    if (typeof str !== 'string') {
      throw new Error('String format is not valid: ' + str);
    }
    if (str.length === 0) {
      throw Error('number format error: empty string');
    }
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity") {
      return new MutableLong();
    }
    radix = radix || 10;
    if (radix < 2 || radix > 36) {
      throw Error('radix out of range: ' + radix);
    }
    let p;
    if ((p = str.indexOf('-')) > 0) {
      throw Error('number format error: interior "-" character: ' + str);
    }
    if (p === 0) {
      return MutableLong.fromString(str.substring(1), radix).negate();
    }
    // Do several (8) digits each time through the loop
    const radixToPower = MutableLong.fromNumber(Math.pow(radix, 8));
    const result = new MutableLong();
    for (let i = 0; i < str.length; i += 8) {
      const size = Math.min(8, str.length - i);
      const value = parseInt(str.substring(i, i + size), radix);
      if (size < 8) {
        const power = MutableLong.fromNumber(Math.pow(radix, size));
        result.multiply(power).add(MutableLong.fromNumber(value));
        break;
      }
      result.multiply(radixToPower);
      result.add(MutableLong.fromNumber(value));
    }
    return result;
  }
};

MutableLong$2.one = new MutableLong$2(1, 0, 0, 0);

var mutableLong = MutableLong$2;

var token$3 = {};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const types$m = requireTypes();
const util$o = require$$0$4;

const _Murmur3TokenType = types$m.dataTypes.getByName('bigint');
const _RandomTokenType = types$m.dataTypes.getByName('varint');
const _OrderedTokenType = types$m.dataTypes.getByName('blob');

/**
 * Represents a token on the Cassandra ring.
 */
class Token {
  constructor(value) {
    this._value = value;
  }

  /**
   * @returns {{code: number, info: *|Object}} The type info for the
   *                                           type of the value of the token.
   */
  getType() {
    throw new Error('You must implement a getType function for this Token instance');
  }

  /**
   * @returns {*} The raw value of the token.
   */
  getValue() {
    return this._value;
  }

  toString() {
    return this._value.toString();
  }

  /**
   * Returns 0 if the values are equal, 1 if greater than other, -1
   * otherwise.
   *
   * @param {Token} other 
   * @returns {Number}
   */
  compare(other) {
    return this._value.compare(other._value);
  }

  equals(other) {
    return this.compare(other) === 0;
  }

  inspect() {
    return this.constructor.name + ' { ' + this.toString() + ' }';
  }
}

/**
 * Represents a token from a Cassandra ring where the partitioner
 * is Murmur3Partitioner.
 * 
 * The raw token type is a varint (represented by MutableLong).
 */
class Murmur3Token extends Token {
  constructor(value) {
    super(value);
  }

  getType() {
    return _Murmur3TokenType;
  }
}

/**
 * Represents a token from a Cassandra ring where the partitioner
 * is RandomPartitioner.
 * 
 * The raw token type is a bigint (represented by Number).
 */
class RandomToken extends Token {
  constructor(value) {
    super(value);
  }

  getType() {
    return _RandomTokenType;
  }
}

/**
 * Represents a token from a Cassandra ring where the partitioner
 * is ByteOrderedPartitioner.
 * 
 * The raw token type is a blob (represented by Buffer or Array).
 */
class ByteOrderedToken extends Token {
  constructor(value) {
    super(value);
  }

  getType() {
    return _OrderedTokenType;
  }

  toString() {
    return this._value.toString('hex').toUpperCase();
  }
}

/** 
 * Represents a range of tokens on a Cassandra ring.
 *
 * A range is start-exclusive and end-inclusive.  It is empty when
 * start and end are the same token, except if that is the minimum
 * token, in which case the range covers the whole ring (this is
 * consistent with the behavior of CQL range queries).
 *
 * Note that CQL does not handle wrapping.  To query all partitions
 * in a range, see {@link unwrap}.
 */
let TokenRange$1 = class TokenRange {
  constructor(start, end, tokenizer) {
    this.start = start;
    this.end = end;
    Object.defineProperty(this, '_tokenizer', { value: tokenizer, enumerable: false});
  }

  /**
   * Splits this range into a number of smaller ranges of equal "size"
   * (referring to the number of tokens, not the actual amount of data).
   *
   * Splitting an empty range is not permitted.  But not that, in edge
   * cases, splitting a range might produce one or more empty ranges.
   *
   * @param {Number} numberOfSplits Number of splits to make.
   * @returns {TokenRange[]} Split ranges.
   * @throws {Error} If splitting an empty range.
   */
  splitEvenly(numberOfSplits) {
    if (numberOfSplits < 1) {
      throw new Error(util$o.format("numberOfSplits (%d) must be greater than 0.", numberOfSplits));
    }
    if (this.isEmpty()) {
      throw new Error("Can't split empty range " + this.toString());
    }

    const tokenRanges = [];
    const splitPoints = this._tokenizer.split(this.start, this.end, numberOfSplits);
    let splitStart = this.start;
    let splitEnd;
    for (let splitIndex = 0; splitIndex < splitPoints.length; splitIndex++) {
      splitEnd = splitPoints[splitIndex];
      tokenRanges.push(new TokenRange(splitStart, splitEnd, this._tokenizer));
      splitStart = splitEnd;
    }
    tokenRanges.push(new TokenRange(splitStart, this.end, this._tokenizer));
    return tokenRanges;
  }

  /**
   * A range is empty when start and end are the same token, except if
   * that is the minimum token, in which case the range covers the
   * whole ring.  This is consistent with the behavior of CQL range
   * queries.
   *
   * @returns {boolean} Whether this range is empty.
   */
  isEmpty() {
    return this.start.equals(this.end) && !this.start.equals(this._tokenizer.minToken());
  }

  /**
   * A range wraps around the end of the ring when the start token
   * is greater than the end token and the end token is not the 
   * minimum token.
   *
   * @returns {boolean} Whether this range wraps around.
   */
  isWrappedAround() {
    return this.start.compare(this.end) > 0 && !this.end.equals(this._tokenizer.minToken());
  }

  /**
   * Splits this range into a list of two non-wrapping ranges.
   *
   * This will return the range itself if it is non-wrapped, or two
   * ranges otherwise.
   *
   * This is useful for CQL range queries, which do not handle
   * wrapping.
   *
   * @returns {TokenRange[]} The list of non-wrapping ranges.
   */
  unwrap() {
    if (this.isWrappedAround()) {
      return [
        new TokenRange(this.start, this._tokenizer.minToken(), this._tokenizer),
        new TokenRange(this._tokenizer.minToken(), this.end, this._tokenizer)
      ];
    }
    return [this];
  }

  /**
   * Whether this range contains a given Token.
   * 
   * @param {*} token Token to check for.
   * @returns {boolean} Whether or not the Token is in this range.
   */
  contains(token) {
    if (this.isEmpty()) {
      return false;
    }
    const minToken = this._tokenizer.minToken();
    if (this.end.equals(minToken)) {
      if (this.start.equals(minToken)) {
        return true; // ]minToken, minToken] === full ring
      } else if (token.equals(minToken)) {
        return true;
      }
      return token.compare(this.start) > 0;
    }

    const isAfterStart = token.compare(this.start) > 0;
    const isBeforeEnd = token.compare(this.end) <= 0;
    // if wrapped around ring, token is in ring if its after start or before end.
    // otherwise, token is in ring if its after start and before end.
    return this.isWrappedAround() 
      ? isAfterStart || isBeforeEnd
      : isAfterStart && isBeforeEnd;
  }

  /**
   * Determines if the input range is equivalent to this one.
   * 
   * @param {TokenRange} other Range to compare with.
   * @returns {boolean} Whether or not the ranges are equal.
   */
  equals(other) {
    if (other === this) {
      return true;
    } else if (other instanceof TokenRange) {
      return this.compare(other) === 0;
    }
    return false;
  }

  /**
   * Returns 0 if the values are equal, otherwise compares against
   * start, if start is equal, compares against end.
   *  
   * @param {TokenRange} other Range to compare with.
   * @returns {Number} 
   */
  compare(other) {
    const compareStart = this.start.compare(other.start);
    return compareStart !== 0 ? compareStart : this.end.compare(other.end);
  }

  toString() {
    return util$o.format(']%s, %s]', 
      this.start.toString(),
      this.end.toString()
    );
  }
};

token$3.Token = Token;
token$3.TokenRange = TokenRange$1;
token$3.ByteOrderedToken = ByteOrderedToken;
token$3.Murmur3Token = Murmur3Token;
token$3.RandomToken = RandomToken;

var search = {};

var dateRange = {};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const utils$x = utils$K;
const Long$2 = LongExports;

/**
 * Regex to parse dates in the following format YYYY-MM-DDThh:mm:ss.mssZ
 * Looks cumbersome but it's straightforward:
 * - "(\d{1,6})": year mandatory 1 to 6 digits
 * - (?:-(\d{1,2}))?(?:-(\d{1,2}))? two non-capturing groups representing the month and day (1 to 2 digits captured).
 * - (?:T(\d{1,2}?)?(?::(\d{1,2}))?(?::(\d{1,2}))?)?Z? A non-capturing group for the time portion
 * @private
 */
const dateRegex =
  /^[-+]?(\d{1,6})(?:-(\d{1,2}))?(?:-(\d{1,2}))?(?:T(\d{1,2}?)?(?::(\d{1,2}))?(?::(\d{1,2})(?:\.(\d{1,3}))?)?)?Z?$/;
const multipleBoundariesRegex = /^\[(.+?) TO (.+)]$/;
const unbounded = Object.freeze(new DateRangeBound(null, -1));

const dateRangeType = {
  // single value as in "2001-01-01"
  singleValue: 0,
  // closed range as in "[2001-01-01 TO 2001-01-31]"
  closedRange: 1,
  // open range high as in "[2001-01-01 TO *]"
  openRangeHigh: 2,
  // - 0x03 - open range low as in "[* TO 2001-01-01]"
  openRangeLow: 3,
  // - 0x04 - both ranges open as in "[* TO *]"
  openBoth: 4,
  // - 0x05 - single open range as in "[*]"
  openSingle: 5
};

/**
 * Defines the possible values of date range precision.
 * @type {Object}
 * @property {Number} year
 * @property {Number} month
 * @property {Number} day
 * @property {Number} hour
 * @property {Number} minute
 * @property {Number} second
 * @property {Number} millisecond
 * @memberof module:search
 */
const dateRangePrecision = {
  year: 0,
  month: 1,
  day: 2,
  hour: 3,
  minute: 4,
  second: 5,
  millisecond: 6
};

/**
 * Creates a new instance of <code>DateRange</code> using a lower bound and an upper bound.
 * <p>Consider using <code>DateRange.fromString()</code> to create instances more easily.</p>
 * @classdesc
 * Represents a range of dates, corresponding to the Apache Solr type
 * <a href="https://cwiki.apache.org/confluence/display/solr/Working+with+Dates"><code>DateRangeField</code></a>.
 * <p>
 *   A date range can have one or two bounds, namely lower bound and upper bound, to represent an interval of time.
 *   Date range bounds are both inclusive. For example:
 * </p>
 * <ul>
 *   <li><code>2015 TO 2016-10</code> represents from the first day of 2015 to the last day of October 2016</li>
 *   <li><code>2015</code> represents during the course of the year 2015.</li>
 *   <li><code>2017 TO *</code> represents any date greater or equals to the first day of the year 2017.</li>
 * </ul>
 * <p>
 *   Note that this JavaScript representation of <code>DateRangeField</code> does not support Dates outside of the range
 *   supported by ECMAScript Date: 100,000,000 days to 100,000,000 days measured relative to midnight at the
 *   beginning of 01 January, 1970 UTC. Being <code>-271821-04-20T00:00:00.000Z</code> the minimum lower boundary
 *   and <code>275760-09-13T00:00:00.000Z</code> the maximum higher boundary.
 * <p>
 * @param {DateRangeBound} lowerBound A value representing the range lower bound, composed by a
 * <code>Date</code> and a precision. Use <code>DateRangeBound.unbounded</code> for an open lower bound.
 * @param {DateRangeBound} [upperBound] A value representing the range upper bound, composed by a
 * <code>Date</code> and a precision. Use <code>DateRangeBound.unbounded</code> for an open upper bound. When it's not
 * defined, the <code>DateRange</code> instance is considered as a single value range.
 * @constructor
 * @memberOf module:datastax/search
 */
function DateRange$1(lowerBound, upperBound) {
  if (!lowerBound) {
    throw new TypeError('The lower boundaries must be defined');
  }
  /**
   * Gets the lower bound of this range (inclusive).
   * @type {DateRangeBound}
   */
  this.lowerBound = lowerBound;
  /**
   * Gets the upper bound of this range (inclusive).
   * @type {DateRangeBound|null}
   */
  this.upperBound = upperBound || null;

  // Define the type
  if (this.upperBound === null) {
    if (this.lowerBound !== unbounded) {
      this._type = dateRangeType.singleValue;
    }
    else {
      this._type = dateRangeType.openSingle;
    }
  }
  else {
    if (this.lowerBound !== unbounded) {
      this._type = this.upperBound !== unbounded ? dateRangeType.closedRange : dateRangeType.openRangeHigh;
    }
    else {
      this._type = this.upperBound !== unbounded ? dateRangeType.openRangeLow : dateRangeType.openBoth;
    }
  }
}

/**
 * Returns true if the value of this DateRange instance and other are the same.
 * @param {DateRange} other
 * @returns {Boolean}
 */
DateRange$1.prototype.equals = function (other) {
  if (!(other instanceof DateRange$1)) {
    return false;
  }
  return (other.lowerBound.equals(this.lowerBound) &&
  (other.upperBound ? other.upperBound.equals(this.upperBound) : !this.upperBound));
};

/**
 * Returns the string representation of the instance.
 * @return {String}
 */
DateRange$1.prototype.toString = function () {
  if (this.upperBound === null) {
    return this.lowerBound.toString();
  }
  return '[' + this.lowerBound.toString() + ' TO ' + this.upperBound.toString() + ']';
};

DateRange$1.prototype.toBuffer = function () {
  // Serializes the value containing:
  // <type>[<time0><precision0><time1><precision1>]
  if (this._type === dateRangeType.openBoth || this._type === dateRangeType.openSingle) {
    return utils$x.allocBufferFromArray([ this._type ]);
  }
  let buffer;
  let offset = 0;
  if (this._type !== dateRangeType.closedRange) {
    // byte + long + byte
    const boundary = this._type !== dateRangeType.openRangeLow ? this.lowerBound : this.upperBound;
    buffer = utils$x.allocBufferUnsafe(10);
    buffer.writeUInt8(this._type, offset++);
    offset = writeDate(boundary.date, buffer, offset);
    buffer.writeUInt8(boundary.precision, offset);
    return buffer;
  }
  // byte + long + byte + long + byte
  buffer = utils$x.allocBufferUnsafe(19);
  buffer.writeUInt8(this._type, offset++);
  offset = writeDate(this.lowerBound.date, buffer, offset);
  buffer.writeUInt8(this.lowerBound.precision, offset++);
  offset = writeDate(this.upperBound.date, buffer, offset);
  buffer.writeUInt8(this.upperBound.precision, offset);
  return buffer;
};

/**
 * Returns the <code>DateRange</code> representation of a given string.
 * <p>String representations of dates are always expressed in Coordinated Universal Time (UTC)</p>
 * @param {String} dateRangeString
 */
DateRange$1.fromString = function (dateRangeString) {
  const matches = multipleBoundariesRegex.exec(dateRangeString);
  if (!matches) {
    return new DateRange$1(DateRangeBound.toLowerBound(DateRangeBound.fromString(dateRangeString)));
  }
  return new DateRange$1(DateRangeBound.toLowerBound(DateRangeBound.fromString(matches[1])), DateRangeBound.toUpperBound(DateRangeBound.fromString(matches[2])));
};

/**
 * Deserializes the buffer into a <code>DateRange</code>
 * @param {Buffer} buffer
 * @return {DateRange}
 */
DateRange$1.fromBuffer = function (buffer) {
  if (buffer.length === 0) {
    throw new TypeError('DateRange serialized value must have at least 1 byte');
  }
  const type = buffer.readUInt8(0);
  if (type === dateRangeType.openBoth) {
    return new DateRange$1(unbounded, unbounded);
  }
  if (type === dateRangeType.openSingle) {
    return new DateRange$1(unbounded);
  }
  let offset = 1;
  let date1;
  let lowerBound;
  let upperBound = null;
  if (type !== dateRangeType.closedRange) {
    date1 = readDate(buffer, offset);
    offset += 8;
    lowerBound = new DateRangeBound(date1, buffer.readUInt8(offset));
    if (type === dateRangeType.openRangeLow) {
      // lower boundary is open, the first serialized boundary is the upperBound
      upperBound = lowerBound;
      lowerBound = unbounded;
    }
    else {
      upperBound = type === dateRangeType.openRangeHigh ? unbounded : null;
    }
    return new DateRange$1(lowerBound, upperBound);
  }
  date1 = readDate(buffer, offset);
  offset += 8;
  lowerBound = new DateRangeBound(date1, buffer.readUInt8(offset++));
  const date2 = readDate(buffer, offset);
  offset += 8;
  upperBound = new DateRangeBound(date2, buffer.readUInt8(offset));
  return new DateRange$1(lowerBound, upperBound);
};

/**
 * Writes a Date, long millis since epoch, to a buffer starting from offset.
 * @param {Date} date
 * @param {Buffer} buffer
 * @param {Number} offset
 * @return {Number} The new offset.
 * @private
 */
function writeDate(date, buffer, offset) {
  const long = Long$2.fromNumber(date.getTime());
  buffer.writeUInt32BE(long.getHighBitsUnsigned(), offset);
  buffer.writeUInt32BE(long.getLowBitsUnsigned(), offset + 4);
  return offset + 8;
}

/**
 * Reads a Date, long millis since epoch, from a buffer starting from offset.
 * @param {Buffer} buffer
 * @param {Number} offset
 * @return {Date}
 * @private
 */
function readDate(buffer, offset) {
  const long = new Long$2(buffer.readInt32BE(offset+4), buffer.readInt32BE(offset));
  return new Date(long.toNumber());
}

/**
 * @classdesc
 * Represents a date range boundary, composed by a <code>Date</code> and a precision.
 * @param {Date} date The timestamp portion, representing a single moment in time. Consider using
 * <code>Date.UTC()</code> method to build the <code>Date</code> instance.
 * @param {Number} precision The precision portion. Valid values for <code>DateRangeBound</code> precision are
 * defined in the [dateRangePrecision]{@link module:datastax/search~dateRangePrecision} member.
 * @constructor
 * @memberOf module:datastax/search
 */
function DateRangeBound(date, precision) {
  /**
   * The timestamp portion of the boundary.
   * @type {Date}
   */
  this.date = date;
  /**
   * The precision portion of the boundary. Valid values are defined in the
   * [dateRangePrecision]{@link module:datastax/search~dateRangePrecision} member.
   * @type {Number}
   */
  this.precision = precision;
}

/**
 * Returns the string representation of the instance.
 * @return {String}
 */
DateRangeBound.prototype.toString = function () {
  if (this.precision === -1) {
    return '*';
  }
  let precision = 0;
  const isoString = this.date.toISOString();
  let i;
  let char;
  // The years take at least the first 4 characters
  for (i = 4; i < isoString.length && precision <= this.precision; i++) {
    char = isoString.charAt(i);
    if (precision === dateRangePrecision.day && char === 'T') {
      precision = dateRangePrecision.hour;
      continue;
    }
    if (precision >= dateRangePrecision.hour && char === ':' || char === '.') {
      precision++;
      continue;
    }
    if (precision < dateRangePrecision.day && char === '-') {
      precision++;
    }
  }
  let start = 0;
  const firstChar = isoString.charAt(0);
  let sign = '';
  let toRemoveIndex = 4;
  if (firstChar === '+' || firstChar === '-') {
    sign = firstChar;
    if (firstChar === '-') {
      // since we are retaining the -, don't remove as many zeros.
      toRemoveIndex = 3;
    }
    // Remove additional zeros
    for (start = 1; start < toRemoveIndex; start++) {
      if (isoString.charAt(start) !== '0') {
        break;
      }
    }
  }
  if (this.precision !== dateRangePrecision.millisecond) {
    // i holds the position of the first char that marks the end of a precision (ie: '-', 'T', ...),
    // we should not include it in the result, except its the 'Z' char for the complete representation
    i--;
  }
  return sign + isoString.substring(start, i);
};

/**
 * Returns true if the value of this DateRange instance and other are the same.
 * @param {DateRangeBound} other
 * @return {boolean}
 */
DateRangeBound.prototype.equals = function (other) {
  if (!(other instanceof DateRangeBound)) {
    return false;
  }
  if (other.precision !== this.precision) {
    return false;
  }
  return datesEqual(other.date, this.date);
};

function datesEqual(d1, d2) {
  const t1 = d1 ? d1.getTime() : null;
  const t2 = d2 ? d2.getTime() : null;
  return t1 === t2;
}

DateRangeBound.prototype.isUnbounded = function () {
  return (this.precision === -1);
};

/**
 * Parses a date string and returns a DateRangeBound.
 * @param {String} boundaryString
 * @return {DateRangeBound}
 */
DateRangeBound.fromString = function(boundaryString) {
  if (!boundaryString) {
    return null;
  }
  if (boundaryString === '*') {
    return unbounded;
  }
  const matches = dateRegex.exec(boundaryString);
  if (!matches) {
    throw TypeError('String provided is not a valid date ' + boundaryString);
  }
  if (matches[7] !== undefined && matches[5] === undefined) {
    // Due to a limitation in the regex, its possible to match dates like 2015T03:02.001, without the seconds
    // portion but with the milliseconds specified.
    throw new TypeError('String representation of the date contains the milliseconds portion but not the seconds: ' +
      boundaryString);
  }
  const builder = new BoundaryBuilder(boundaryString.charAt(0) === '-');
  for (let i = 1; i < matches.length; i++) {
    builder.set(i-1, matches[i], boundaryString);
  }
  return builder.build();
};

/**
 * The unbounded {@link DateRangeBound} instance. Unbounded bounds are syntactically represented by a <code>*</code>
 * (star) sign.
 * @type {DateRangeBound}
 */
DateRangeBound.unbounded = unbounded;

/**
 * Converts a {DateRangeBound} into a lower-bounded bound by rounding down its date
 * based on its precision.
 *
 * @param {DateRangeBound} bound The bound to round down.
 * @returns {DateRangeBound} with the date rounded down to the given precision.
 */
DateRangeBound.toLowerBound = function (bound) {
  if(bound === unbounded) {
    return bound;
  }
  const rounded = new Date(bound.date.getTime());
  // in this case we want to fallthrough
  /* eslint-disable no-fallthrough */
  switch (bound.precision) {
    case dateRangePrecision.year:
      rounded.setUTCMonth(0);
    case dateRangePrecision.month:
      rounded.setUTCDate(1);
    case dateRangePrecision.day:
      rounded.setUTCHours(0);
    case dateRangePrecision.hour:
      rounded.setUTCMinutes(0);
    case dateRangePrecision.minute:
      rounded.setUTCSeconds(0);
    case dateRangePrecision.second:
      rounded.setUTCMilliseconds(0);
  }
  /* eslint-enable no-fallthrough */
  return new DateRangeBound(rounded, bound.precision);
};

/**
 * Converts a {DateRangeBound} into a upper-bounded bound by rounding up its date
 * based on its precision.
 *
 * @param {DateRangeBound} bound The bound to round up.
 * @returns {DateRangeBound} with the date rounded up to the given precision.
 */
DateRangeBound.toUpperBound = function (bound) {
  if (bound === unbounded) {
    return bound;
  }
  const rounded = new Date(bound.date.getTime());
  // in this case we want to fallthrough
  /* eslint-disable no-fallthrough */
  switch (bound.precision) {
    case dateRangePrecision.year:
      rounded.setUTCMonth(11);
    case dateRangePrecision.month:
      // Advance to the beginning of next month and set day of month to 0
      // which sets the date to the last day of the previous month.
      // This gives us the effect of YYYY-MM-LastDayOfThatMonth
      rounded.setUTCMonth(rounded.getUTCMonth() + 1, 0);
    case dateRangePrecision.day:
      rounded.setUTCHours(23);
    case dateRangePrecision.hour:
      rounded.setUTCMinutes(59);
    case dateRangePrecision.minute:
      rounded.setUTCSeconds(59);
    case dateRangePrecision.second:
      rounded.setUTCMilliseconds(999);
  }
  /* eslint-enable no-fallthrough */
  return new DateRangeBound(rounded, bound.precision);
};

/** @private */
function BoundaryBuilder(isNegative) {
  this._sign = isNegative ? -1 : 1;
  this._index = 0;
  this._values = new Int32Array(7);
}

BoundaryBuilder.prototype.set = function (index, value, stringDate) {
  if (value === undefined) {
    return;
  }
  if (index > 6) {
    throw new TypeError('Index out of bounds: ' + index);
  }
  if (index > this._index) {
    this._index = index;
  }
  const numValue = +value;
  switch (index) {
    case dateRangePrecision.month:
      if (numValue < 1 || numValue > 12) {
        throw new TypeError('Month portion is not valid for date: ' + stringDate);
      }
      break;
    case dateRangePrecision.day:
      if (numValue < 1 || numValue > 31) {
        throw new TypeError('Day portion is not valid for date: ' + stringDate);
      }
      break;
    case dateRangePrecision.hour:
      if (numValue > 23) {
        throw new TypeError('Hour portion is not valid for date: ' + stringDate);
      }
      break;
    case dateRangePrecision.minute:
    case dateRangePrecision.second:
      if (numValue > 59) {
        throw new TypeError('Minute/second portion is not valid for date: ' + stringDate);
      }
      break;
    case dateRangePrecision.millisecond:
      if (numValue > 999) {
        throw new TypeError('Millisecond portion is not valid for date: ' + stringDate);
      }
      break;
  }
  this._values[index] = numValue;
};

/** @return {DateRangeBound} */
BoundaryBuilder.prototype.build = function () {
  const date = new Date(0);
  let month = this._values[1];
  if (month) {
    // ES Date months are represented from 0 to 11
    month--;
  }
  date.setUTCFullYear(this._sign * this._values[0], month, this._values[2] || 1);
  date.setUTCHours(this._values[3], this._values[4], this._values[5], this._values[6]);
  return new DateRangeBound(date, this._index);
};

dateRange.unbounded = unbounded;
dateRange.dateRangePrecision = dateRangePrecision;
dateRange.DateRange = DateRange$1;
dateRange.DateRangeBound = DateRangeBound;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const dateRangeModule = dateRange;

/**
 * Search module.
 * <p>
 *   Contains the classes to represent the set of  types for search data that come with DSE 5.1+
 * </p>
 * @module datastax/search
 */

search.DateRange = dateRangeModule.DateRange;
search.DateRangeBound = dateRangeModule.DateRangeBound;
search.dateRangePrecision = dateRangeModule.dateRangePrecision;

var geometry$1 = {};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const endianness = {
  '0': 'BE',
  '1': 'LE'
};

function Geometry$4() {

}

Geometry$4.types = {
  Point2D: 1,
  LineString: 2,
  Polygon: 3
};

/**
 * @protected
 * @param {Number} code
 * @returns {String}
 * @ignore
 */
Geometry$4.getEndianness = function (code) {
  const value = endianness[code.toString()];
  if (typeof value === 'undefined') {
    throw new TypeError('Invalid endianness with code ' + code);
  }
  return value;
};

/**
 * Reads an int32 from binary representation based on endianness.
 * @protected
 * @param {Buffer} buffer
 * @param {String} endianness
 * @param {Number} offset
 * @returns Number
 * @ignore
 */
Geometry$4.readInt32 = function (buffer, endianness, offset) {
  if (endianness === 'BE') {
    return buffer.readInt32BE(offset, true);
  }
  return buffer.readInt32LE(offset, true);
};

/**
 * Reads an 64-bit double from binary representation based on endianness.
 * @protected
 * @param {Buffer} buffer
 * @param {String} endianness
 * @param {Number} offset
 * @returns Number
 * @ignore
 */
Geometry$4.readDouble = function (buffer, endianness, offset) {
  if (endianness === 'BE') {
    return buffer.readDoubleBE(offset, true);
  }
  return buffer.readDoubleLE(offset, true);
};

/**
 * Writes an 32-bit integer to binary representation based on OS endianness.
 * @protected
 * @param {Number} val
 * @param {Buffer} buffer
 * @param {Number} offset
 * @ignore
 */
Geometry$4.prototype.writeInt32 = function (val, buffer, offset) {
  if (this.useBESerialization()) {
    return buffer.writeInt32BE(val, offset, true);
  }
  return buffer.writeInt32LE(val, offset, true);
};

/**
 * Writes an 64-bit double to binary representation based on OS endianness.
 * @protected
 * @param {Number} val
 * @param {Buffer} buffer
 * @param {Number} offset
 * @ignore
 */
Geometry$4.prototype.writeDouble = function (val, buffer, offset) {
  if (this.useBESerialization()) {
    return buffer.writeDoubleBE(val, offset, true);
  }
  return buffer.writeDoubleLE(val, offset, true);
};

/**
 * Writes an 8-bit int that represents the OS endianness.
 * @protected
 * @param {Buffer} buffer
 * @param {Number} offset
 * @ignore
 */
Geometry$4.prototype.writeEndianness = function (buffer, offset) {
  if (this.useBESerialization()) {
    return buffer.writeInt8(0, offset, true);
  }
  return buffer.writeInt8(1, offset, true);
};

/**
 * Returns true if the serialization must be done in big-endian format.
 * Designed to allow injection of OS endianness.
 * @abstract
 * @ignore
 */
Geometry$4.prototype.useBESerialization = function () {
  throw new Error('Not Implemented');
};

var geometry = Geometry$4;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const util$n = require$$0$4;
const utils$w = utils$K;
const Geometry$3 = geometry;

/**
 * Creates a new {@link Point} instance.
 * @classdesc
 * A Point is a zero-dimensional object that represents a specific (X,Y)
 * location in a two-dimensional XY-Plane. In case of Geographic Coordinate
 * Systems, the X coordinate is the longitude and the Y is the latitude.
 * @param {Number} x The X coordinate.
 * @param {Number} y The Y coordinate.
 * @extends {Geometry}
 * @alias module:geometry~Point
 * @constructor
 */
function Point$4(x, y) {
  if (typeof x !== 'number' || typeof y !== 'number') {
    throw new TypeError('X and Y must be numbers');
  }
  if (isNaN(x) || isNaN(y)) {
    throw new TypeError('X and Y must be numbers');
  }
  /**
   * Returns the X coordinate of this 2D point.
   * @type {Number}
   */
  this.x = x;
  /**
   * Returns the Y coordinate of this 2D point.
   * @type {Number}
   */
  this.y = y;
}

//noinspection JSCheckFunctionSignatures
util$n.inherits(Point$4, Geometry$3);

/**
 * Creates a {@link Point} instance from
 * a <a href="https://en.wikipedia.org/wiki/Well-known_text">Well-known Text (WKT)</a>
 * representation of a 2D point.
 * @param {Buffer} buffer
 * @returns {Point}
 */
Point$4.fromBuffer = function (buffer) {
  if (!buffer || buffer.length !== 21) {
    throw new TypeError('2D Point buffer should contain 21 bytes');
  }
  const endianness = Geometry$3.getEndianness(buffer.readInt8(0, true));
  if (Geometry$3.readInt32(buffer, endianness, 1) !== Geometry$3.types.Point2D) {
    throw new TypeError('Binary representation was not a point');
  }
  return new Point$4(Geometry$3.readDouble(buffer, endianness, 5), Geometry$3.readDouble(buffer, endianness, 13));
};

/**
 * Creates a {@link Point} instance from
 * a <a href="https://en.wikipedia.org/wiki/Well-known_text">Well-known Text (WKT)</a>
 * representation of a 2D point.
 * @param {String} textValue
 * @returns {Point}
 */
Point$4.fromString = function (textValue) {
  const wktRegex = /^POINT\s?\(([-0-9.]+) ([-0-9.]+)\)$/g;
  const matches = wktRegex.exec(textValue);
  if (!matches || matches.length !== 3) {
    throw new TypeError('2D Point WTK should contain 2 coordinates');
  }
  return new Point$4(parseFloat(matches[1]), parseFloat(matches[2]));
};

/**
 * Returns a <a href="https://en.wikipedia.org/wiki/Well-known_text#Well-known_binary">Well-known Binary</a> (WKB)
 * representation of this instance.
 * @returns {Buffer}
 */
Point$4.prototype.toBuffer = function () {
  const buffer = utils$w.allocBufferUnsafe(21);
  this.writeEndianness(buffer, 0);
  this.writeInt32(Geometry$3.types.Point2D, buffer, 1);
  this.writeDouble(this.x, buffer, 5);
  this.writeDouble(this.y, buffer, 13);
  return buffer;
};

/**
 * Returns true if the values of the point are the same, otherwise it returns false.
 * @param {Point} other
 * @returns {Boolean}
 */
Point$4.prototype.equals = function (other) {
  if (!(other instanceof Point$4)) {
    return false;
  }
  return (this.x === other.x && this.y === other.y);
};

/**
 * Returns Well-known text (WKT) representation of the geometry object.
 * @returns {String}
 */
Point$4.prototype.toString = function () {
  return util$n.format('POINT (%d %d)', this.x, this.y);
};

Point$4.prototype.useBESerialization = function () {
  return false;
};

/**
 * Returns a JSON representation of this geo-spatial type.
 */
Point$4.prototype.toJSON = function () {
  return { type: 'Point', coordinates: [ this.x, this.y ]};
};

var point = Point$4;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const util$m = require$$0$4;
const utils$v = utils$K;
const Geometry$2 = geometry;
const Point$3 = point;

/**
 * Creates a new {@link LineString} instance.
 * @classdesc
 * A LineString is a one-dimensional object representing a sequence of points and the line segments connecting them.
 * @param {...Point}[point] A sequence of [Point]{@link module:geometry~Point} items as arguments.
 * @example
 * new LineString(new Point(10.99, 20.02), new Point(14, 26), new Point(34, 1.2));
 * @constructor
 * @alias module:geometry~LineString
 * @extends {Geometry}
 */
function LineString$3(point) {
  let points = Array.prototype.slice.call(arguments);
  if (points.length === 1 && Array.isArray(points) && Array.isArray(points[0])) {
    //The first argument is an array of the points
    points = points[0];
  }
  if (points.length === 1) {
    throw new TypeError('LineString can be either empty or contain 2 or more points');
  }
  /**
   * Returns a frozen Array of points that represent the line.
   * @type {Array.<Point>}
   */
  this.points = Object.freeze(points);
}

//noinspection JSCheckFunctionSignatures
util$m.inherits(LineString$3, Geometry$2);

/**
 * Creates a {@link LineString} instance from
 * a <a href="https://en.wikipedia.org/wiki/Well-known_text">Well-known Text (WKT)</a>
 * representation of a line.
 * @param {Buffer} buffer
 * @returns {LineString}
 */
LineString$3.fromBuffer = function (buffer) {
  if (!buffer || buffer.length < 9) {
    throw new TypeError('A linestring buffer should contain at least 9 bytes');
  }
  const endianness = Geometry$2.getEndianness(buffer.readInt8(0, true));
  let offset = 1;
  if (Geometry$2.readInt32(buffer, endianness, offset) !== Geometry$2.types.LineString) {
    throw new TypeError('Binary representation was not a LineString');
  }
  offset += 4;
  const length = Geometry$2.readInt32(buffer, endianness, offset);
  offset += 4;
  if (buffer.length !== offset + length * 16) {
    throw new TypeError(util$m.format('Length of the buffer does not match %d !== %d', buffer.length, offset + length * 8));
  }
  const points = new Array(length);
  for (let i = 0; i < length; i++) {
    points[i] = new Point$3(
      Geometry$2.readDouble(buffer, endianness, offset),
      Geometry$2.readDouble(buffer, endianness, offset + 8));
    offset += 16;
  }
  //noinspection JSCheckFunctionSignatures
  return new LineString$3(points);
};

/**
 * Creates a {@link LineString} instance from
 * a <a href="https://en.wikipedia.org/wiki/Well-known_text">Well-known Text (WKT)</a>
 * representation of a line.
 * @param {String} textValue
 * @returns {LineString}
 */
LineString$3.fromString = function (textValue) {
  const wktRegex = /^LINESTRING ?\(([-0-9. ,]+)\)+$/g;
  const matches = wktRegex.exec(textValue);
  if (!matches || matches.length !== 2) {
    throw new TypeError('Invalid WKT: ' + textValue);
  }
  const points = LineString$3.parseSegments(matches[1]);
  return new LineString$3(points);
};

/**
 * Internal method that parses a series of WKT points.
 * @param {String} textValue
 * @returns {Array<Point>}
 * @internal
 * @ignore
 */
LineString$3.parseSegments = function (textValue) {
  const points = [];
  const pointParts = textValue.split(',');
  for (let i = 0; i < pointParts.length; i++) {
    const p = pointParts[i].trim();
    if (p.length === 0) {
      throw new TypeError('Invalid WKT segment: ' + textValue);
    }
    const xyText = p.split(' ').filter(function (element) {
      return (element.trim().length > 0);
    });
    if (xyText.length !== 2) {
      throw new TypeError('Invalid WKT segment: ' + textValue);
    }
    points.push(new Point$3(parseFloat(xyText[0]), parseFloat(xyText[1])));
  }
  return points;
};

/**
 * Returns a <a href="https://en.wikipedia.org/wiki/Well-known_text#Well-known_binary">Well-known Binary</a> (WKB)
 * representation of this instance.
 * @returns {Buffer}
 */
LineString$3.prototype.toBuffer = function () {
  const buffer = utils$v.allocBufferUnsafe(9 + this.points.length * 16);
  this.writeEndianness(buffer, 0);
  let offset = 1;
  this.writeInt32(Geometry$2.types.LineString, buffer, offset);
  offset += 4;
  this.writeInt32(this.points.length, buffer, offset);
  offset += 4;
  this.points.forEach(function (p) {
    this.writeDouble(p.x, buffer, offset);
    this.writeDouble(p.y, buffer, offset + 8);
    offset += 16;
  }, this);
  return buffer;
};

/**
 * Returns true if the values of the linestrings are the same, otherwise it returns false.
 * @param {LineString} other
 * @returns {Boolean}
 */
LineString$3.prototype.equals = function (other) {
  if (!(other instanceof LineString$3)) {
    return false;
  }
  if (this.points.length !== other.points.length) {
    return false;
  }
  for (let i = 0; i < this.points.length; i++) {
    if (!this.points[i].equals(other.points[i])) {
      return false;
    }
  }
  return true;
};

/**
 * Returns Well-known text (WKT) representation of the geometry object.
 * @returns {String}
 */
LineString$3.prototype.toString = function () {
  if (this.points.length === 0) {
    return 'LINESTRING EMPTY';
  }
  return 'LINESTRING ('
    + this.points.map(function (p) {
      return p.x + ' ' + p.y;
    }).join(', ')
    + ')';
};

LineString$3.prototype.useBESerialization = function () {
  return false;
};

/**
 * Returns a JSON representation of this geo-spatial type.
 */
LineString$3.prototype.toJSON = function () {
  return { type: 'LineString', coordinates: this.points.map(function (p) {
    return [p.x, p.y];
  })};
};

var lineString = LineString$3;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const util$l = require$$0$4;
const utils$u = utils$K;
const Geometry$1 = geometry;
const Point$2 = point;
const LineString$2 = lineString;

/**
 * Creates a new {@link Polygon} instance.
 * @classdesc
 * Represents is a plane geometry figure that is bounded by a finite chain of straight line segments closing in a loop
 * to form a closed chain or circuit.
 * @param {...Array.<Point>}[ringPoints] A sequence of Array of [Point]{@link module:geometry~Point} items as arguments
 * representing the rings of the polygon.
 * @example
 * new Polygon([ new Point(30, 10), new Point(40, 40), new Point(10, 20), new Point(30, 10) ]);
 * @example
 * //polygon with a hole
 * new Polygon(
 *  [ new Point(30, 10), new Point(40, 40), new Point(10, 20), new Point(30, 10) ],
 *  [ new Point(25, 20), new Point(30, 30), new Point(20, 20), new Point(25, 20) ]
 * );
 * @alias module:geometry~Polygon
 * @constructor
 */
function Polygon$2(ringPoints) {
  const rings = Array.prototype.slice.call(arguments);
  /**
   * Returns a frozen Array of array of points that represent the different rings in the polygon.
   * @type {Array}
   */
  this.rings = Object.freeze(rings);
}

//noinspection JSCheckFunctionSignatures
util$l.inherits(Polygon$2, Geometry$1);

/**
 * Creates a {@link Polygon} instance from
 * a <a href="https://en.wikipedia.org/wiki/Well-known_text">Well-known Text (WKT)</a>
 * representation of a polygon.
 * @param {Buffer} buffer
 * @returns {Polygon}
 */
Polygon$2.fromBuffer = function (buffer) {
  if (!buffer || buffer.length < 9) {
    throw new TypeError('A Polygon buffer should contain at least 9 bytes');
  }
  const endianness = Geometry$1.getEndianness(buffer.readInt8(0, true));
  let offset = 1;
  if (Geometry$1.readInt32(buffer, endianness, offset) !== Geometry$1.types.Polygon) {
    throw new TypeError('Binary representation was not a Polygon');
  }
  offset += 4;
  const ringsLength = Geometry$1.readInt32(buffer, endianness, offset);
  offset += 4;
  const ringsArray = new Array(ringsLength);
  for (let ringIndex = 0; ringIndex < ringsLength; ringIndex++) {
    const pointsLength = Geometry$1.readInt32(buffer, endianness, offset);
    offset += 4;
    if (buffer.length < offset + pointsLength * 16) {
      throw new TypeError(util$l.format('Length of the buffer does not match'));
    }
    const ring = new Array(pointsLength);
    for (let i = 0; i < pointsLength; i++) {
      ring[i] = new Point$2(
        Geometry$1.readDouble(buffer, endianness, offset),
        Geometry$1.readDouble(buffer, endianness, offset + 8));
      offset += 16;
    }
    ringsArray[ringIndex] = ring;
  }
  //Invoke the constructor with each ring as a parameter
  //ringsArray.unshift(null);
  //return new (Function.prototype.bind.apply(Polygon, ringsArray));
  return construct(ringsArray);
};

/**
 * Creates a {@link Polygon} instance from
 * a <a href="https://en.wikipedia.org/wiki/Well-known_text">Well-known Text (WKT)</a>
 * representation of a shape.
 * @param {String} textValue
 * @returns {Polygon}
 */
Polygon$2.fromString = function (textValue) {
  const wktRegex = /^POLYGON ?\((\(.*\))\)$/g;
  const matches = wktRegex.exec(textValue);
  function validateWkt(condition) {
    if (condition) {
      throw new TypeError('Invalid WKT: ' + textValue);
    }
  }
  validateWkt(!matches || matches.length !== 2);

  const ringsText = matches[1];
  const ringsArray = [];
  let ringStart = null;
  for (let i = 0; i < ringsText.length; i++) {
    const c = ringsText[i];
    if (c === '(') {
      validateWkt(ringStart !== null);
      ringStart = i+1;
      continue;
    }
    if (c === ')') {
      validateWkt(ringStart === null);
      ringsArray.push(ringsText.substring(ringStart, i));
      ringStart = null;
      continue;
    }
    validateWkt(ringStart === null && c !== ' ' && c !== ',');
  }
  return construct(ringsArray.map(LineString$2.parseSegments));
};

/**
 * Creates a new instance of Polygon with each array item as a parameter
 * @private
 * @param {Array<Array<Point>>} argsArray
 * @returns {Polygon}
 */
function construct(argsArray) {
  function F() {
    return Polygon$2.apply(this, argsArray);
  }
  F.prototype = Polygon$2.prototype;
  return new F();
}

/**
 * Returns a <a href="https://en.wikipedia.org/wiki/Well-known_text#Well-known_binary">Well-known Binary</a> (WKB)
 * representation of this instance.
 * @returns {Buffer}
 */
Polygon$2.prototype.toBuffer = function () {
  let totalRingsLength = 0;
  this.rings.forEach(function (ring) {
    totalRingsLength += 4 + ring.length * 16;
  }, this);
  const buffer = utils$u.allocBufferUnsafe(9 + totalRingsLength);
  this.writeEndianness(buffer, 0);
  let offset = 1;
  this.writeInt32(Geometry$1.types.Polygon, buffer, offset);
  offset += 4;
  this.writeInt32(this.rings.length, buffer, offset);
  offset += 4;
  this.rings.forEach(function (ring) {
    this.writeInt32(ring.length, buffer, offset);
    offset += 4;
    ring.forEach(function (p) {
      this.writeDouble(p.x, buffer, offset);
      this.writeDouble(p.y, buffer, offset + 8);
      offset += 16;
    }, this);
  }, this);
  return buffer;
};

/**
 * Returns true if the values of the polygons are the same, otherwise it returns false.
 * @param {Polygon} other
 * @returns {Boolean}
 */
Polygon$2.prototype.equals = function (other) {
  if (!(other instanceof Polygon$2)) {
    return false;
  }
  if (this.rings.length !== other.rings.length) {
    return false;
  }
  for (let i = 0; i < this.rings.length; i++) {
    const r1 = this.rings[i];
    const r2 = other.rings[i];
    if (r1.length !== r2.length) {
      return false;
    }
    for (let j = 0; j < r1.length; j++) {
      if (!r1[i].equals(r2[i])) {
        return false;
      }
    }
  }
  return true;
};

Polygon$2.prototype.useBESerialization = function () {
  return false;
};

/**
 * Returns Well-known text (WKT) representation of the geometry object.
 * @returns {String}
 */
Polygon$2.prototype.toString = function () {
  if (this.rings.length === 0) {
    return 'POLYGON EMPTY';
  }
  let ringStrings = '';
  this.rings.forEach(function (r, i) {
    if (i > 0) {
      ringStrings += ', ';
    }
    ringStrings += '(' +
      r.map(function (p) {
        return p.x + ' ' + p.y;
      }).join(', ')
      + ')';
  });
  return 'POLYGON (' + ringStrings + ')';
};

/**
 * Returns a JSON representation of this geo-spatial type.
 */
Polygon$2.prototype.toJSON = function () {
  return { type: 'Polygon', coordinates: this.rings.map(function (r) {
    return r.map(function (p) {
      return [ p.x, p.y ];
    });
  })};
};

var polygon = Polygon$2;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Geometry module.
 * <p>
 *   Contains the classes to represent the set of additional CQL types for geospatial data that come with
 *   DSE 5.0.
 * </p>
 * @module geometry
 */

geometry$1.Geometry = geometry;
geometry$1.LineString = lineString;
geometry$1.Point = point;
geometry$1.Polygon = polygon;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const util$k = require$$0$4;

const types$l = requireTypes();
const dataTypes$4 = types$l.dataTypes;
const Long$1 = types$l.Long;
const Integer$1 = types$l.Integer;
const BigDecimal = types$l.BigDecimal;
const MutableLong$1 = mutableLong;
const utils$t = utils$K;
const token$2 = token$3;
const { DateRange } = search;
const geo = geometry$1;
const Geometry = geo.Geometry;
const LineString$1 = geo.LineString;
const Point$1 = geo.Point;
const Polygon$1 = geo.Polygon;

const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;

const buffers = {
  int16Zero: utils$t.allocBufferFromArray([0, 0]),
  int32Zero: utils$t.allocBufferFromArray([0, 0, 0, 0]),
  int8Zero: utils$t.allocBufferFromArray([0]),
  int8One: utils$t.allocBufferFromArray([1]),
  int8MaxValue: utils$t.allocBufferFromArray([0xff])
};

// BigInt: Avoid using literals (e.g., 32n) as we must be able to compile with older engines
const isBigIntSupported = typeof BigInt !== 'undefined';
const bigInt32 = isBigIntSupported ? BigInt(32) : null;
const bigInt8 = isBigIntSupported ? BigInt(8) : null;
const bigInt0 = isBigIntSupported ? BigInt(0) : null;
const bigIntMinus1 = isBigIntSupported ? BigInt(-1) : null;
const bigInt32BitsOn = isBigIntSupported ? BigInt(0xffffffff) : null;
const bigInt8BitsOn = isBigIntSupported ? BigInt(0xff) : null;

const complexTypeNames = Object.freeze({
  list      : 'org.apache.cassandra.db.marshal.ListType',
  set       : 'org.apache.cassandra.db.marshal.SetType',
  map       : 'org.apache.cassandra.db.marshal.MapType',
  udt       : 'org.apache.cassandra.db.marshal.UserType',
  tuple     : 'org.apache.cassandra.db.marshal.TupleType',
  frozen    : 'org.apache.cassandra.db.marshal.FrozenType',
  reversed  : 'org.apache.cassandra.db.marshal.ReversedType',
  composite : 'org.apache.cassandra.db.marshal.CompositeType',
  empty     : 'org.apache.cassandra.db.marshal.EmptyType',
  collection: 'org.apache.cassandra.db.marshal.ColumnToCollectionType'
});
const cqlNames = Object.freeze({
  frozen: 'frozen',
  list: 'list',
  'set': 'set',
  map: 'map',
  tuple: 'tuple',
  empty: 'empty',
  duration: 'duration'
});
const singleTypeNames = Object.freeze({
  'org.apache.cassandra.db.marshal.UTF8Type':           dataTypes$4.varchar,
  'org.apache.cassandra.db.marshal.AsciiType':          dataTypes$4.ascii,
  'org.apache.cassandra.db.marshal.UUIDType':           dataTypes$4.uuid,
  'org.apache.cassandra.db.marshal.TimeUUIDType':       dataTypes$4.timeuuid,
  'org.apache.cassandra.db.marshal.Int32Type':          dataTypes$4.int,
  'org.apache.cassandra.db.marshal.BytesType':          dataTypes$4.blob,
  'org.apache.cassandra.db.marshal.FloatType':          dataTypes$4.float,
  'org.apache.cassandra.db.marshal.DoubleType':         dataTypes$4.double,
  'org.apache.cassandra.db.marshal.BooleanType':        dataTypes$4.boolean,
  'org.apache.cassandra.db.marshal.InetAddressType':    dataTypes$4.inet,
  'org.apache.cassandra.db.marshal.SimpleDateType':     dataTypes$4.date,
  'org.apache.cassandra.db.marshal.TimeType':           dataTypes$4.time,
  'org.apache.cassandra.db.marshal.ShortType':          dataTypes$4.smallint,
  'org.apache.cassandra.db.marshal.ByteType':           dataTypes$4.tinyint,
  'org.apache.cassandra.db.marshal.DateType':           dataTypes$4.timestamp,
  'org.apache.cassandra.db.marshal.TimestampType':      dataTypes$4.timestamp,
  'org.apache.cassandra.db.marshal.LongType':           dataTypes$4.bigint,
  'org.apache.cassandra.db.marshal.DecimalType':        dataTypes$4.decimal,
  'org.apache.cassandra.db.marshal.IntegerType':        dataTypes$4.varint,
  'org.apache.cassandra.db.marshal.CounterColumnType':  dataTypes$4.counter
});
const singleFqTypeNamesLength = Object.keys(singleTypeNames).reduce(function (previous, current) {
  return current.length > previous ? current.length : previous;
}, 0);

const customTypeNames = Object.freeze({
  duration: 'org.apache.cassandra.db.marshal.DurationType',
  lineString: 'org.apache.cassandra.db.marshal.LineStringType',
  point: 'org.apache.cassandra.db.marshal.PointType',
  polygon: 'org.apache.cassandra.db.marshal.PolygonType',
  dateRange: 'org.apache.cassandra.db.marshal.DateRangeType'
});

const nullValueBuffer = utils$t.allocBufferFromArray([255, 255, 255, 255]);
const unsetValueBuffer = utils$t.allocBufferFromArray([255, 255, 255, 254]);

/**
 * For backwards compatibility, empty buffers as text/blob/custom values are supported.
 * In the case of other types, they are going to be decoded as a <code>null</code> value.
 * @private
 * @type {Set}
 */
const zeroLengthTypesSupported = new Set([
  dataTypes$4.text,
  dataTypes$4.ascii,
  dataTypes$4.varchar,
  dataTypes$4.custom,
  dataTypes$4.blob
]);

/**
 * Serializes and deserializes to and from a CQL type and a Javascript Type.
 * @param {Number} protocolVersion
 * @param {ClientOptions} options
 * @constructor
 */
function Encoder$2(protocolVersion, options) {
  this.encodingOptions = options.encoding || utils$t.emptyObject;
  defineInstanceMembers.call(this);
  this.setProtocolVersion(protocolVersion);
  setEncoders.call(this);
  if (this.encodingOptions.copyBuffer) {
    this.handleBuffer = handleBufferCopy;
  }
  else {
    this.handleBuffer = handleBufferRef;
  }
}

/**
 * Declares the privileged instance members.
 * @private
 */
function defineInstanceMembers() {
  /**
   * Sets the protocol version and the encoding/decoding methods depending on the protocol version
   * @param {Number} value
   * @ignore
   * @internal
   */
  this.setProtocolVersion = function (value) {
    this.protocolVersion = value;
    //Set the collection serialization based on the protocol version
    this.decodeCollectionLength = decodeCollectionLengthV3;
    this.getLengthBuffer = getLengthBufferV3;
    this.collectionLengthSize = 4;
    if (!types$l.protocolVersion.uses4BytesCollectionLength(this.protocolVersion)) {
      this.decodeCollectionLength = decodeCollectionLengthV2;
      this.getLengthBuffer = getLengthBufferV2;
      this.collectionLengthSize = 2;
    }
  };

  const customDecoders = {
    [customTypeNames.duration]: decodeDuration,
    [customTypeNames.lineString]: decodeLineString,
    [customTypeNames.point]: decodePoint,
    [customTypeNames.polygon]: decodePolygon,
    [customTypeNames.dateRange]: decodeDateRange
  };

  const customEncoders = {
    [customTypeNames.duration]: encodeDuration,
    [customTypeNames.lineString]: encodeLineString,
    [customTypeNames.point]: encodePoint,
    [customTypeNames.polygon]: encodePolygon,
    [customTypeNames.dateRange]: encodeDateRange
  };

  // Decoding methods
  this.decodeBlob = function (bytes) {
    return this.handleBuffer(bytes);
  };
  this.decodeCustom = function (bytes, typeName) {
    const handler = customDecoders[typeName];
    if (handler) {
      return handler.call(this, bytes);
    }
    return this.handleBuffer(bytes);
  };
  this.decodeUtf8String = function (bytes) {
    return bytes.toString('utf8');
  };
  this.decodeAsciiString = function (bytes) {
    return bytes.toString('ascii');
  };
  this.decodeBoolean = function (bytes) {
    return !!bytes.readUInt8(0);
  };
  this.decodeDouble = function (bytes) {
    return bytes.readDoubleBE(0);
  };
  this.decodeFloat = function (bytes) {
    return bytes.readFloatBE(0);
  };
  this.decodeInt = function (bytes) {
    return bytes.readInt32BE(0);
  };
  this.decodeSmallint = function (bytes) {
    return bytes.readInt16BE(0);
  };
  this.decodeTinyint = function (bytes) {
    return bytes.readInt8(0);
  };

  this._decodeCqlLongAsLong = function (bytes) {
    return Long$1.fromBuffer(bytes);
  };

  this._decodeCqlLongAsBigInt = function (bytes) {
    return BigInt.asIntN(64, (BigInt(bytes.readUInt32BE(0)) << bigInt32) | BigInt(bytes.readUInt32BE(4)));
  };

  this.decodeLong = this.encodingOptions.useBigIntAsLong
    ? this._decodeCqlLongAsBigInt
    : this._decodeCqlLongAsLong;

  this._decodeVarintAsInteger = function (bytes) {
    return Integer$1.fromBuffer(bytes);
  };

  this._decodeVarintAsBigInt = function decodeVarintAsBigInt(bytes) {
    let result = bigInt0;
    if (bytes[0] <= 0x7f) {
      for (let i = 0; i < bytes.length; i++) {
        const b = BigInt(bytes[bytes.length - 1 - i]);
        result = result | (b << BigInt(i * 8));
      }
    } else {
      for (let i = 0; i < bytes.length; i++) {
        const b = BigInt(bytes[bytes.length - 1 - i]);
        result = result | ((~b & bigInt8BitsOn) << BigInt(i * 8));
      }
      result = ~result;
    }

    return result;
  };

  this.decodeVarint = this.encodingOptions.useBigIntAsVarint
    ? this._decodeVarintAsBigInt
    : this._decodeVarintAsInteger;

  this.decodeDecimal = function(bytes) {
    return BigDecimal.fromBuffer(bytes);
  };
  this.decodeTimestamp = function(bytes) {
    return new Date(this._decodeCqlLongAsLong(bytes).toNumber());
  };
  this.decodeDate = function (bytes) {
    return types$l.LocalDate.fromBuffer(bytes);
  };
  this.decodeTime = function (bytes) {
    return types$l.LocalTime.fromBuffer(bytes);
  };
  /*
   * Reads a list from bytes
   */
  this.decodeList = function (bytes, subtype) {
    const totalItems = this.decodeCollectionLength(bytes, 0);
    let offset = this.collectionLengthSize;
    const list = new Array(totalItems);
    for (let i = 0; i < totalItems; i++) {
      //bytes length of the item
      const length = this.decodeCollectionLength(bytes, offset);
      offset += this.collectionLengthSize;
      //slice it
      list[i] = this.decode(bytes.slice(offset, offset+length), subtype);
      offset += length;
    }
    return list;
  };
  /*
   * Reads a Set from bytes
   */
  this.decodeSet = function (bytes, subtype) {
    const arr = this.decodeList(bytes, subtype);
    if (this.encodingOptions.set) {
      const setConstructor = this.encodingOptions.set;
      return new setConstructor(arr);
    }
    return arr;
  };
  /*
   * Reads a map (key / value) from bytes
   */
  this.decodeMap = function (bytes, subtypes) {
    let map;
    const totalItems = this.decodeCollectionLength(bytes, 0);
    let offset = this.collectionLengthSize;
    const self = this;
    function readValues(callback, thisArg) {
      for (let i = 0; i < totalItems; i++) {
        const keyLength = self.decodeCollectionLength(bytes, offset);
        offset += self.collectionLengthSize;
        const key = self.decode(bytes.slice(offset, offset + keyLength), subtypes[0]);
        offset += keyLength;
        const valueLength = self.decodeCollectionLength(bytes, offset);
        offset += self.collectionLengthSize;
        if (valueLength < 0) {
          callback.call(thisArg, key, null);
          continue;
        }
        const value = self.decode(bytes.slice(offset, offset + valueLength), subtypes[1]);
        offset += valueLength;
        callback.call(thisArg, key, value);
      }
    }
    if (this.encodingOptions.map) {
      const mapConstructor = this.encodingOptions.map;
      map = new mapConstructor();
      readValues(map.set, map);
    }
    else {
      map = {};
      readValues(function (key, value) {
        map[key] = value;
      });
    }
    return map;
  };
  this.decodeUuid = function (bytes) {
    return new types$l.Uuid(this.handleBuffer(bytes));
  };
  this.decodeTimeUuid = function (bytes) {
    return new types$l.TimeUuid(this.handleBuffer(bytes));
  };
  this.decodeInet = function (bytes) {
    return new types$l.InetAddress(this.handleBuffer(bytes));
  };
  /**
   * Decodes a user defined type into an object
   * @param {Buffer} bytes
   * @param {{fields: Array}} udtInfo
   * @private
   */
  this.decodeUdt = function (bytes, udtInfo) {
    const result = {};
    let offset = 0;
    for (let i = 0; i < udtInfo.fields.length && offset < bytes.length; i++) {
      //bytes length of the field value
      const length = bytes.readInt32BE(offset);
      offset += 4;
      //slice it
      const field = udtInfo.fields[i];
      if (length < 0) {
        result[field.name] = null;
        continue;
      }
      result[field.name] = this.decode(bytes.slice(offset, offset+length), field.type);
      offset += length;
    }
    return result;
  };

  this.decodeTuple = function (bytes, tupleInfo) {
    const elements = new Array(tupleInfo.length);
    let offset = 0;

    for (let i = 0; i < tupleInfo.length && offset < bytes.length; i++) {
      const length = bytes.readInt32BE(offset);
      offset += 4;

      if (length < 0) {
        elements[i] = null;
        continue;
      }

      elements[i] = this.decode(bytes.slice(offset, offset+length), tupleInfo[i]);
      offset += length;
    }

    return types$l.Tuple.fromArray(elements);
  };

  //Encoding methods
  this.encodeFloat = function (value) {
    if (typeof value === 'string') {
      // All numeric types are supported as strings for historical reasons
      value = parseFloat(value);

      if (Number.isNaN(value)) {
        throw new TypeError(`Expected string representation of a number, obtained ${util$k.inspect(value)}`);
      }
    }

    if (typeof value !== 'number') {
      throw new TypeError('Expected Number, obtained ' + util$k.inspect(value));
    }

    const buf = utils$t.allocBufferUnsafe(4);
    buf.writeFloatBE(value, 0);
    return buf;
  };

  this.encodeDouble = function (value) {
    if (typeof value === 'string') {
      // All numeric types are supported as strings for historical reasons
      value = parseFloat(value);

      if (Number.isNaN(value)) {
        throw new TypeError(`Expected string representation of a number, obtained ${util$k.inspect(value)}`);
      }
    }

    if (typeof value !== 'number') {
      throw new TypeError('Expected Number, obtained ' + util$k.inspect(value));
    }

    const buf = utils$t.allocBufferUnsafe(8);
    buf.writeDoubleBE(value, 0);
    return buf;
  };

  /**
   * @param {Date|String|Long|Number} value
   * @private
   */
  this.encodeTimestamp = function (value) {
    const originalValue = value;
    if (typeof value === 'string') {
      value = new Date(value);
    }
    if (value instanceof Date) {
      //milliseconds since epoch
      value = value.getTime();
      if (isNaN(value)) {
        throw new TypeError('Invalid date: ' + originalValue);
      }
    }
    if (this.encodingOptions.useBigIntAsLong) {
      value = BigInt(value);
    }
    return this.encodeLong(value);
  };
  /**
   * @param {Date|String|LocalDate} value
   * @returns {Buffer}
   * @throws {TypeError}
   * @private
   */
  this.encodeDate = function (value) {
    const originalValue = value;
    try {
      if (typeof value === 'string') {
        value = types$l.LocalDate.fromString(value);
      }
      if (value instanceof Date) {
        value = types$l.LocalDate.fromDate(value);
      }
    }
    catch (err) {
      //Wrap into a TypeError
      throw new TypeError('LocalDate could not be parsed ' + err);
    }
    if (!(value instanceof types$l.LocalDate)) {
      throw new TypeError('Expected Date/String/LocalDate, obtained ' + util$k.inspect(originalValue));
    }
    return value.toBuffer();
  };
  /**
   * @param {String|LocalDate} value
   * @returns {Buffer}
   * @throws {TypeError}
   * @private
   */
  this.encodeTime = function (value) {
    const originalValue = value;
    try {
      if (typeof value === 'string') {
        value = types$l.LocalTime.fromString(value);
      }
    }
    catch (err) {
      //Wrap into a TypeError
      throw new TypeError('LocalTime could not be parsed ' + err);
    }
    if (!(value instanceof types$l.LocalTime)) {
      throw new TypeError('Expected String/LocalTime, obtained ' + util$k.inspect(originalValue));
    }
    return value.toBuffer();
  };
  /**
   * @param {Uuid|String|Buffer} value
   * @private
   */
  this.encodeUuid = function (value) {
    if (typeof value === 'string') {
      try {
        value = types$l.Uuid.fromString(value).getBuffer();
      }
      catch (err) {
        throw new TypeError(err.message);
      }
    } else if (value instanceof types$l.Uuid) {
      value = value.getBuffer();
    } else {
      throw new TypeError('Not a valid Uuid, expected Uuid/String/Buffer, obtained ' + util$k.inspect(value));
    }

    return value;
  };
  /**
   * @param {String|InetAddress|Buffer} value
   * @returns {Buffer}
   * @private
   */
  this.encodeInet = function (value) {
    if (typeof value === 'string') {
      value = types$l.InetAddress.fromString(value);
    }
    if (value instanceof types$l.InetAddress) {
      value = value.getBuffer();
    }
    if (!(value instanceof Buffer)) {
      throw new TypeError('Not a valid Inet, expected InetAddress/Buffer, obtained ' + util$k.inspect(value));
    }
    return value;
  };

  /**
   * @param {Long|Buffer|String|Number} value
   * @private
   */
  this._encodeBigIntFromLong = function (value) {
    if (typeof value === 'number') {
      value = Long$1.fromNumber(value);
    } else if (typeof value === 'string') {
      value = Long$1.fromString(value);
    }

    let buf = null;

    if (value instanceof Long$1) {
      buf = Long$1.toBuffer(value);
    } else if (value instanceof MutableLong$1) {
      buf = Long$1.toBuffer(value.toImmutable());
    }

    if (buf === null) {
      throw new TypeError('Not a valid bigint, expected Long/Number/String/Buffer, obtained ' + util$k.inspect(value));
    }

    return buf;
  };

  this._encodeBigIntFromBigInt = function (value) {
    if (typeof value === 'string') {
      // All numeric types are supported as strings for historical reasons
      value = BigInt(value);
    }

    // eslint-disable-next-line valid-typeof
    if (typeof value !== 'bigint') {
      // Only BigInt values are supported
      throw new TypeError('Not a valid BigInt value, obtained ' + util$k.inspect(value));
    }

    const buffer = utils$t.allocBufferUnsafe(8);
    buffer.writeUInt32BE(Number(value >> bigInt32) >>> 0, 0);
    buffer.writeUInt32BE(Number(value & bigInt32BitsOn), 4);
    return buffer;
  };

  this.encodeLong = this.encodingOptions.useBigIntAsLong
    ? this._encodeBigIntFromBigInt
    : this._encodeBigIntFromLong;

  /**
   * @param {Integer|Buffer|String|Number} value
   * @returns {Buffer}
   * @private
   */
  this._encodeVarintFromInteger = function (value) {
    if (typeof value === 'number') {
      value = Integer$1.fromNumber(value);
    }
    if (typeof value === 'string') {
      value = Integer$1.fromString(value);
    }
    let buf = null;
    if (value instanceof Buffer) {
      buf = value;
    }
    if (value instanceof Integer$1) {
      buf = Integer$1.toBuffer(value);
    }
    if (buf === null) {
      throw new TypeError('Not a valid varint, expected Integer/Number/String/Buffer, obtained ' + util$k.inspect(value));
    }
    return buf;
  };

  this._encodeVarintFromBigInt = function (value) {
    if (typeof value === 'string') {
      // All numeric types are supported as strings for historical reasons
      value = BigInt(value);
    }

    // eslint-disable-next-line valid-typeof
    if (typeof value !== 'bigint') {
      throw new TypeError('Not a valid varint, expected BigInt, obtained ' + util$k.inspect(value));
    }

    if (value === bigInt0) {
      return buffers.int8Zero;

    }
    else if (value === bigIntMinus1) {
      return buffers.int8MaxValue;
    }

    const parts = [];

    if (value > bigInt0){
      while (value !== bigInt0) {
        parts.unshift(Number(value & bigInt8BitsOn));
        value = value >> bigInt8;
      }

      if (parts[0] > 0x7f) {
        // Positive value needs a padding
        parts.unshift(0);
      }
    } else {
      while (value !== bigIntMinus1) {
        parts.unshift(Number(value & bigInt8BitsOn));
        value = value >> bigInt8;
      }

      if (parts[0] <= 0x7f) {
        // Negative value needs a padding
        parts.unshift(0xff);
      }
    }

    return utils$t.allocBufferFromArray(parts);
  };

  this.encodeVarint = this.encodingOptions.useBigIntAsVarint
    ? this._encodeVarintFromBigInt
    : this._encodeVarintFromInteger;

  /**
   * @param {BigDecimal|Buffer|String|Number} value
   * @returns {Buffer}
   * @private
   */
  this.encodeDecimal = function (value) {
    if (typeof value === 'number') {
      value = BigDecimal.fromNumber(value);
    } else if (typeof value === 'string') {
      value = BigDecimal.fromString(value);
    }

    let buf = null;

    if (value instanceof BigDecimal) {
      buf = BigDecimal.toBuffer(value);
    } else {
      throw new TypeError('Not a valid varint, expected BigDecimal/Number/String/Buffer, obtained ' + util$k.inspect(value));
    }

    return buf;
  };
  this.encodeString = function (value, encoding) {
    if (typeof value !== 'string') {
      throw new TypeError('Not a valid text value, expected String obtained ' + util$k.inspect(value));
    }
    return utils$t.allocBufferFromString(value, encoding);
  };
  this.encodeUtf8String = function (value) {
    return this.encodeString(value, 'utf8');
  };
  this.encodeAsciiString = function (value) {
    return this.encodeString(value, 'ascii');
  };
  this.encodeBlob = function (value) {
    if (!(value instanceof Buffer)) {
      throw new TypeError('Not a valid blob, expected Buffer obtained ' + util$k.inspect(value));
    }
    return value;
  };
  this.encodeCustom = function (value, name) {
    const handler = customEncoders[name];
    if (handler) {
      return handler.call(this, value);
    }
    throw new TypeError('No encoding handler found for type ' + name);
  };
  /**
   * @param {Boolean} value
   * @returns {Buffer}
   * @private
   */
  this.encodeBoolean = function (value) {
    return value ? buffers.int8One : buffers.int8Zero;
  };
  /**
   * @param {Number|String} value
   * @private
   */
  this.encodeInt = function (value) {
    if (isNaN(value)) {
      throw new TypeError('Expected Number, obtained ' + util$k.inspect(value));
    }
    const buf = utils$t.allocBufferUnsafe(4);
    buf.writeInt32BE(value, 0);
    return buf;
  };
  /**
   * @param {Number|String} value
   * @private
   */
  this.encodeSmallint = function (value) {
    if (isNaN(value)) {
      throw new TypeError('Expected Number, obtained ' + util$k.inspect(value));
    }
    const buf = utils$t.allocBufferUnsafe(2);
    buf.writeInt16BE(value, 0);
    return buf;
  };
  /**
   * @param {Number|String} value
   * @private
   */
  this.encodeTinyint = function (value) {
    if (isNaN(value)) {
      throw new TypeError('Expected Number, obtained ' + util$k.inspect(value));
    }
    const buf = utils$t.allocBufferUnsafe(1);
    buf.writeInt8(value, 0);
    return buf;
  };
  this.encodeList = function (value, subtype) {
    if (!Array.isArray(value)) {
      throw new TypeError('Not a valid list value, expected Array obtained ' + util$k.inspect(value));
    }
    if (value.length === 0) {
      return null;
    }
    const parts = [];
    parts.push(this.getLengthBuffer(value));
    for (let i = 0;i < value.length;i++) {
      const val = value[i];
      if (val === null || typeof val === 'undefined' || val === types$l.unset) {
        throw new TypeError('A collection can\'t contain null or unset values');
      }
      const bytes = this.encode(val, subtype);
      //include item byte length
      parts.push(this.getLengthBuffer(bytes));
      //include item
      parts.push(bytes);
    }
    return Buffer.concat(parts);
  };
  this.encodeSet = function (value, subtype) {
    if (this.encodingOptions.set && value instanceof this.encodingOptions.set) {
      const arr = [];
      value.forEach(function (x) {
        arr.push(x);
      });
      return this.encodeList(arr, subtype);
    }
    return this.encodeList(value, subtype);
  };
  /**
   * Serializes a map into a Buffer
   * @param value
   * @param {Array} [subtypes]
   * @returns {Buffer}
   * @private
   */
  this.encodeMap = function (value, subtypes) {
    const parts = [];
    let propCounter = 0;
    let keySubtype = null;
    let valueSubtype = null;
    const self = this;
    if (subtypes) {
      keySubtype = subtypes[0];
      valueSubtype = subtypes[1];
    }
    function addItem(val, key) {
      if (key === null || typeof key === 'undefined' || key === types$l.unset) {
        throw new TypeError('A map can\'t contain null or unset keys');
      }
      if (val === null || typeof val === 'undefined' || val === types$l.unset) {
        throw new TypeError('A map can\'t contain null or unset values');
      }
      const keyBuffer = self.encode(key, keySubtype);
      //include item byte length
      parts.push(self.getLengthBuffer(keyBuffer));
      //include item
      parts.push(keyBuffer);
      //value
      const valueBuffer = self.encode(val, valueSubtype);
      //include item byte length
      parts.push(self.getLengthBuffer(valueBuffer));
      //include item
      if (valueBuffer !== null) {
        parts.push(valueBuffer);
      }
      propCounter++;
    }
    if (this.encodingOptions.map && value instanceof this.encodingOptions.map) {
      //Use Map#forEach() method to iterate
      value.forEach(addItem);
    }
    else {
      //Use object
      for (const key in value) {
        if (!value.hasOwnProperty(key)) {
          continue;
        }
        const val = value[key];
        addItem(val, key);
      }
    }

    parts.unshift(this.getLengthBuffer(propCounter));
    return Buffer.concat(parts);
  };
  this.encodeUdt = function (value, udtInfo) {
    const parts = [];
    let totalLength = 0;
    for (let i = 0; i < udtInfo.fields.length; i++) {
      const field = udtInfo.fields[i];
      const item = this.encode(value[field.name], field.type);
      if (!item) {
        parts.push(nullValueBuffer);
        totalLength += 4;
        continue;
      }
      if (item === types$l.unset) {
        parts.push(unsetValueBuffer);
        totalLength += 4;
        continue;
      }
      const lengthBuffer = utils$t.allocBufferUnsafe(4);
      lengthBuffer.writeInt32BE(item.length, 0);
      parts.push(lengthBuffer);
      parts.push(item);
      totalLength += item.length + 4;
    }
    return Buffer.concat(parts, totalLength);
  };
  this.encodeTuple = function (value, tupleInfo) {
    const parts = [];
    let totalLength = 0;
    const length = Math.min(tupleInfo.length, value.length);

    for (let i = 0; i < length; i++) {
      const type = tupleInfo[i];
      const item = this.encode(value.get(i), type);

      if (!item) {
        parts.push(nullValueBuffer);
        totalLength += 4;
        continue;
      }

      if (item === types$l.unset) {
        parts.push(unsetValueBuffer);
        totalLength += 4;
        continue;
      }

      const lengthBuffer = utils$t.allocBufferUnsafe(4);
      lengthBuffer.writeInt32BE(item.length, 0);
      parts.push(lengthBuffer);
      parts.push(item);
      totalLength += item.length + 4;
    }

    return Buffer.concat(parts, totalLength);
  };

  /**
   * If not provided, it uses the array of buffers or the parameters and hints to build the routingKey
   * @param {Array} params
   * @param {ExecutionOptions} execOptions
   * @param [keys] parameter keys and positions in the params array
   * @throws TypeError
   * @internal
   * @ignore
   */
  this.setRoutingKeyFromUser = function (params, execOptions, keys) {
    let totalLength = 0;
    const userRoutingKey = execOptions.getRoutingKey();
    if (Array.isArray(userRoutingKey)) {
      if (userRoutingKey.length === 1) {
        execOptions.setRoutingKey(userRoutingKey[0]);
        return;
      }

      // Its a composite routing key
      totalLength = 0;
      for (let i = 0; i < userRoutingKey.length; i++) {
        const item = userRoutingKey[i];
        if (!item) {
          // Invalid routing key part provided by the user, clear the value
          execOptions.setRoutingKey(null);
          return;
        }
        totalLength += item.length + 3;
      }

      execOptions.setRoutingKey(concatRoutingKey(userRoutingKey, totalLength));
      return;
    }
    // If routingKey is present, ensure it is a Buffer, Token, or TokenRange.  Otherwise throw an error.
    if (userRoutingKey) {
      if (userRoutingKey instanceof Buffer || userRoutingKey instanceof token$2.Token
        || userRoutingKey instanceof token$2.TokenRange) {
        return;
      }

      throw new TypeError(`Unexpected routingKey '${util$k.inspect(userRoutingKey)}' provided. ` +
        `Expected Buffer, Array<Buffer>, Token, or TokenRange.`);
    }

    // If no params are present, return as routing key cannot be determined.
    if (!params || params.length === 0) {
      return;
    }

    let routingIndexes = execOptions.getRoutingIndexes();
    if (execOptions.getRoutingNames()) {
      routingIndexes = execOptions.getRoutingNames().map(k => keys[k]);
    }
    if (!routingIndexes) {
      return;
    }

    const parts = [];
    const hints = execOptions.getHints() || utils$t.emptyArray;

    const encodeParam = !keys ?
      (i => this.encode(params[i], hints[i])) :
      (i => this.encode(params[i].value, hints[i]));

    try {
      totalLength = this._encodeRoutingKeyParts(parts, routingIndexes, encodeParam);
    } catch (e) {
      // There was an error encoding a parameter that is part of the routing key,
      // ignore now to fail afterwards
    }

    if (totalLength === 0) {
      return;
    }

    execOptions.setRoutingKey(concatRoutingKey(parts, totalLength));
  };

  /**
   * Sets the routing key in the options based on the prepared statement metadata.
   * @param {Object} meta Prepared metadata
   * @param {Array} params Array of parameters
   * @param {ExecutionOptions} execOptions
   * @throws TypeError
   * @internal
   * @ignore
   */
  this.setRoutingKeyFromMeta = function (meta, params, execOptions) {
    const routingIndexes = execOptions.getRoutingIndexes();
    if (!routingIndexes) {
      return;
    }
    const parts = new Array(routingIndexes.length);
    const encodeParam = i => {
      const columnInfo = meta.columns[i];
      return this.encode(params[i], columnInfo ? columnInfo.type : null);
    };

    let totalLength = 0;

    try {
      totalLength = this._encodeRoutingKeyParts(parts, routingIndexes, encodeParam);
    } catch (e) {
      // There was an error encoding a parameter that is part of the routing key,
      // ignore now to fail afterwards
    }

    if (totalLength === 0) {
      return;
    }

    execOptions.setRoutingKey(concatRoutingKey(parts, totalLength));
  };

  /**
   * @param {Array} parts
   * @param {Array} routingIndexes
   * @param {Function} encodeParam
   * @returns {Number} The total length
   * @private
   */
  this._encodeRoutingKeyParts = function (parts, routingIndexes, encodeParam) {
    let totalLength = 0;
    for (let i = 0; i < routingIndexes.length; i++) {
      const paramIndex = routingIndexes[i];
      if (paramIndex === undefined) {
        // Bad input from the user, ignore
        return 0;
      }

      const item = encodeParam(paramIndex);
      if (item === null || item === undefined || item === types$l.unset) {
        // The encoded partition key should an instance of Buffer
        // Let it fail later in the pipeline for null/undefined parameter values
        return 0;
      }

      // Per each part of the routing key, 3 extra bytes are needed
      totalLength += item.length + 3;
      parts[i] = item;
    }
    return totalLength;
  };

  /**
   * Parses a CQL name string into data type information
   * @param {String} keyspace
   * @param {String} typeName
   * @param {Number} startIndex
   * @param {Number|null} length
   * @param {Function} udtResolver
   * @returns {Promise<{err, info, options}>} callback Callback invoked with err and  {{code: number, info: Object|Array|null, options: {frozen: Boolean}}}
   * @internal
   * @ignore
   */
  this.parseTypeName = async function (keyspace, typeName, startIndex, length, udtResolver) {
    startIndex = startIndex || 0;
    if (!length) {
      length = typeName.length;
    }

    const dataType = {
      code: 0,
      info: null,
      options: {
        frozen: false
      }
    };

    let innerTypes;

    if (typeName.indexOf("'", startIndex) === startIndex) {
      //If quoted, this is a custom type.
      dataType.info = typeName.substr(startIndex+1, length-2);
      return dataType;
    }

    if (!length) {
      length = typeName.length;
    }

    if (typeName.indexOf(cqlNames.frozen, startIndex) === startIndex) {
      //Remove the frozen token
      startIndex += cqlNames.frozen.length + 1;
      length -= cqlNames.frozen.length + 2;
      dataType.options.frozen = true;
    }

    if (typeName.indexOf(cqlNames.list, startIndex) === startIndex) {
      //move cursor across the name and bypass the angle brackets
      startIndex += cqlNames.list.length + 1;
      length -= cqlNames.list.length + 2;
      innerTypes = parseParams(typeName, startIndex, length, '<', '>');

      if (innerTypes.length !== 1) {
        throw new TypeError('Not a valid type ' + typeName);
      }

      dataType.code = dataTypes$4.list;
      dataType.info = await this.parseTypeName(keyspace, innerTypes[0], 0, null, udtResolver);
      return dataType;
    }

    if (typeName.indexOf(cqlNames.set, startIndex) === startIndex) {
      //move cursor across the name and bypass the angle brackets
      startIndex += cqlNames.set.length + 1;
      length -= cqlNames.set.length + 2;
      innerTypes = parseParams(typeName, startIndex, length, '<', '>');

      if (innerTypes.length !== 1) {
        throw new TypeError('Not a valid type ' + typeName);
      }

      dataType.code = dataTypes$4.set;
      dataType.info = await this.parseTypeName(keyspace, innerTypes[0], 0, null, udtResolver);
      return dataType;
    }

    if (typeName.indexOf(cqlNames.map, startIndex) === startIndex) {
      //move cursor across the name and bypass the angle brackets
      startIndex += cqlNames.map.length + 1;
      length -= cqlNames.map.length + 2;
      innerTypes = parseParams(typeName, startIndex, length, '<', '>');

      //It should contain the key and value types
      if (innerTypes.length !== 2) {
        throw new TypeError('Not a valid type ' + typeName);
      }

      dataType.code = dataTypes$4.map;
      dataType.info = await this._parseChildTypes(keyspace, innerTypes, udtResolver);
      return dataType;
    }

    if (typeName.indexOf(cqlNames.tuple, startIndex) === startIndex) {
      //move cursor across the name and bypass the angle brackets
      startIndex += cqlNames.tuple.length + 1;
      length -= cqlNames.tuple.length + 2;
      innerTypes = parseParams(typeName, startIndex, length, '<', '>');

      if (innerTypes.length < 1) {
        throw new TypeError('Not a valid type ' + typeName);
      }

      dataType.code = dataTypes$4.tuple;
      dataType.info = await this._parseChildTypes(keyspace, innerTypes, udtResolver);
      return dataType;
    }

    const quoted = typeName.indexOf('"', startIndex) === startIndex;
    if (quoted) {
      // Remove quotes
      startIndex++;
      length -= 2;
    }

    // Quick check if its a single type
    if (startIndex > 0) {
      typeName = typeName.substr(startIndex, length);
    }

    // Un-escape double quotes if quoted.
    if (quoted) {
      typeName = typeName.replace('""', '"');
    }

    const typeCode = dataTypes$4[typeName];
    if (typeof typeCode === 'number') {
      dataType.code = typeCode;
      return dataType;
    }

    if (typeName === cqlNames.duration) {
      dataType.info = customTypeNames.duration;
      return dataType;
    }

    if (typeName === cqlNames.empty) {
      // Set as custom
      dataType.info = 'empty';
      return dataType;
    }

    const udtInfo = await udtResolver(keyspace, typeName);
    if (udtInfo) {
      dataType.code = dataTypes$4.udt;
      dataType.info = udtInfo;
      return dataType;
    }

    throw new TypeError('Not a valid type "' + typeName + '"');
  };

  /**
   * @param {String} keyspace
   * @param {Array} typeNames
   * @param {Function} udtResolver
   * @returns {Promise}
   * @private
   */
  this._parseChildTypes = function (keyspace, typeNames, udtResolver) {
    return Promise.all(typeNames.map(name => this.parseTypeName(keyspace, name.trim(), 0, null, udtResolver)));
  };

  /**
   * Parses a Cassandra fully-qualified class name string into data type information
   * @param {String} typeName
   * @param {Number} [startIndex]
   * @param {Number} [length]
   * @throws TypeError
   * @returns {{code: number, info: Object|Array|null, options: {frozen: Boolean, reversed: Boolean}}}
   * @internal
   * @ignore
   */
  this.parseFqTypeName = function (typeName, startIndex, length) {
    const dataType = {
      code: 0,
      info: null,
      options: {
        reversed: false,
        frozen: false
      }
    };
    startIndex = startIndex || 0;
    let innerTypes;
    if (!length) {
      length = typeName.length;
    }
    if (length > complexTypeNames.reversed.length && typeName.indexOf(complexTypeNames.reversed) === startIndex) {
      //Remove the reversed token
      startIndex += complexTypeNames.reversed.length + 1;
      length -= complexTypeNames.reversed.length + 2;
      dataType.options.reversed = true;
    }
    if (length > complexTypeNames.frozen.length &&
        typeName.indexOf(complexTypeNames.frozen, startIndex) === startIndex) {
      //Remove the frozen token
      startIndex += complexTypeNames.frozen.length + 1;
      length -= complexTypeNames.frozen.length + 2;
      dataType.options.frozen = true;
    }
    if (typeName === complexTypeNames.empty) {
      //set as custom
      dataType.info = 'empty';
      return dataType;
    }
    //Quick check if its a single type
    if (length <= singleFqTypeNamesLength) {
      if (startIndex > 0) {
        typeName = typeName.substr(startIndex, length);
      }
      const typeCode = singleTypeNames[typeName];
      if (typeof typeCode === 'number') {
        dataType.code = typeCode;
        return dataType;
      }
      throw new TypeError('Not a valid type "' + typeName + '"');
    }
    if (typeName.indexOf(complexTypeNames.list, startIndex) === startIndex) {
      //Its a list
      //org.apache.cassandra.db.marshal.ListType(innerType)
      //move cursor across the name and bypass the parenthesis
      startIndex += complexTypeNames.list.length + 1;
      length -= complexTypeNames.list.length + 2;
      innerTypes = parseParams(typeName, startIndex, length);
      if (innerTypes.length !== 1) {
        throw new TypeError('Not a valid type ' + typeName);
      }
      dataType.code = dataTypes$4.list;
      dataType.info = this.parseFqTypeName(innerTypes[0]);
      return dataType;
    }
    if (typeName.indexOf(complexTypeNames.set, startIndex) === startIndex) {
      //Its a set
      //org.apache.cassandra.db.marshal.SetType(innerType)
      //move cursor across the name and bypass the parenthesis
      startIndex += complexTypeNames.set.length + 1;
      length -= complexTypeNames.set.length + 2;
      innerTypes = parseParams(typeName, startIndex, length);
      if (innerTypes.length !== 1)
      {
        throw new TypeError('Not a valid type ' + typeName);
      }
      dataType.code = dataTypes$4.set;
      dataType.info = this.parseFqTypeName(innerTypes[0]);
      return dataType;
    }
    if (typeName.indexOf(complexTypeNames.map, startIndex) === startIndex) {
      //org.apache.cassandra.db.marshal.MapType(keyType,valueType)
      //move cursor across the name and bypass the parenthesis
      startIndex += complexTypeNames.map.length + 1;
      length -= complexTypeNames.map.length + 2;
      innerTypes = parseParams(typeName, startIndex, length);
      //It should contain the key and value types
      if (innerTypes.length !== 2) {
        throw new TypeError('Not a valid type ' + typeName);
      }
      dataType.code = dataTypes$4.map;
      dataType.info = [this.parseFqTypeName(innerTypes[0]), this.parseFqTypeName(innerTypes[1])];
      return dataType;
    }
    if (typeName.indexOf(complexTypeNames.udt, startIndex) === startIndex) {
      //move cursor across the name and bypass the parenthesis
      startIndex += complexTypeNames.udt.length + 1;
      length -= complexTypeNames.udt.length + 2;
      return this._parseUdtName(typeName, startIndex, length);
    }
    if (typeName.indexOf(complexTypeNames.tuple, startIndex) === startIndex) {
      //move cursor across the name and bypass the parenthesis
      startIndex += complexTypeNames.tuple.length + 1;
      length -= complexTypeNames.tuple.length + 2;
      innerTypes = parseParams(typeName, startIndex, length);
      if (innerTypes.length < 1) {
        throw new TypeError('Not a valid type ' + typeName);
      }
      dataType.code = dataTypes$4.tuple;
      dataType.info = innerTypes.map(x => this.parseFqTypeName(x));
      return dataType;
    }

    // Assume custom type if cannot be parsed up to this point.
    dataType.info = typeName.substr(startIndex, length);
    return dataType;
  };
  /**
   * Parses type names with composites
   * @param {String} typesString
   * @returns {{types: Array, isComposite: Boolean, hasCollections: Boolean}}
   * @internal
   * @ignore
   */
  this.parseKeyTypes = function (typesString) {
    let i = 0;
    let length = typesString.length;
    const isComposite = typesString.indexOf(complexTypeNames.composite) === 0;
    if (isComposite) {
      i = complexTypeNames.composite.length + 1;
      length--;
    }
    const types = [];
    let startIndex = i;
    let nested = 0;
    let inCollectionType = false;
    let hasCollections = false;
    //as collection types are not allowed, it is safe to split by ,
    while (++i < length) {
      switch (typesString[i]) {
        case ',':
          if (nested > 0) {
            break;
          }
          if (inCollectionType) {
            //remove type id
            startIndex = typesString.indexOf(':', startIndex) + 1;
          }
          types.push(typesString.substring(startIndex, i));
          startIndex = i + 1;
          break;
        case '(':
          if (nested === 0 && typesString.indexOf(complexTypeNames.collection, startIndex) === startIndex) {
            inCollectionType = true;
            hasCollections = true;
            //skip collection type
            i++;
            startIndex = i;
            break;
          }
          nested++;
          break;
        case ')':
          if (inCollectionType && nested === 0){
            types.push(typesString.substring(typesString.indexOf(':', startIndex) + 1, i));
            startIndex = i + 1;
            break;
          }
          nested--;
          break;
      }
    }
    if (startIndex < length) {
      types.push(typesString.substring(startIndex, length));
    }
    return {
      types: types.map(name => this.parseFqTypeName(name)),
      hasCollections: hasCollections,
      isComposite: isComposite
    };
  };
  this._parseUdtName = function (typeName, startIndex, length) {
    const udtParams = parseParams(typeName, startIndex, length);
    if (udtParams.length < 2) {
      //It should contain at least the keyspace, name of the udt and a type
      throw new TypeError('Not a valid type ' + typeName);
    }
    const dataType = {
      code: dataTypes$4.udt,
      info: null
    };
    const udtInfo = {
      keyspace: udtParams[0],
      name: utils$t.allocBufferFromString(udtParams[1], 'hex').toString(),
      fields: []
    };
    for (let i = 2; i < udtParams.length; i++) {
      const p = udtParams[i];
      const separatorIndex = p.indexOf(':');
      const fieldType = this.parseFqTypeName(p, separatorIndex + 1, p.length - (separatorIndex + 1));
      udtInfo.fields.push({
        name: utils$t.allocBufferFromString(p.substr(0, separatorIndex), 'hex').toString(),
        type: fieldType
      });
    }
    dataType.info = udtInfo;
    return dataType;
  };
}

/**
 * Sets the encoder and decoder methods for this instance
 * @private
 */
function setEncoders() {
  this.decoders = {
    [dataTypes$4.custom]: this.decodeCustom,
    [dataTypes$4.ascii]: this.decodeAsciiString,
    [dataTypes$4.bigint]: this.decodeLong,
    [dataTypes$4.blob]: this.decodeBlob,
    [dataTypes$4.boolean]: this.decodeBoolean,
    [dataTypes$4.counter]: this.decodeLong,
    [dataTypes$4.decimal]: this.decodeDecimal,
    [dataTypes$4.double]: this.decodeDouble,
    [dataTypes$4.float]: this.decodeFloat,
    [dataTypes$4.int]: this.decodeInt,
    [dataTypes$4.text]: this.decodeUtf8String,
    [dataTypes$4.timestamp]: this.decodeTimestamp,
    [dataTypes$4.uuid]: this.decodeUuid,
    [dataTypes$4.varchar]: this.decodeUtf8String,
    [dataTypes$4.varint]: this.decodeVarint,
    [dataTypes$4.timeuuid]: this.decodeTimeUuid,
    [dataTypes$4.inet]: this.decodeInet,
    [dataTypes$4.date]: this.decodeDate,
    [dataTypes$4.time]: this.decodeTime,
    [dataTypes$4.smallint]: this.decodeSmallint,
    [dataTypes$4.tinyint]: this.decodeTinyint,
    [dataTypes$4.duration]: decodeDuration,
    [dataTypes$4.list]: this.decodeList,
    [dataTypes$4.map]: this.decodeMap,
    [dataTypes$4.set]: this.decodeSet,
    [dataTypes$4.udt]: this.decodeUdt,
    [dataTypes$4.tuple]: this.decodeTuple
  };

  this.encoders = {
    [dataTypes$4.custom]: this.encodeCustom,
    [dataTypes$4.ascii]: this.encodeAsciiString,
    [dataTypes$4.bigint]: this.encodeLong,
    [dataTypes$4.blob]: this.encodeBlob,
    [dataTypes$4.boolean]: this.encodeBoolean,
    [dataTypes$4.counter]: this.encodeLong,
    [dataTypes$4.decimal]: this.encodeDecimal,
    [dataTypes$4.double]: this.encodeDouble,
    [dataTypes$4.float]: this.encodeFloat,
    [dataTypes$4.int]: this.encodeInt,
    [dataTypes$4.text]: this.encodeUtf8String,
    [dataTypes$4.timestamp]: this.encodeTimestamp,
    [dataTypes$4.uuid]: this.encodeUuid,
    [dataTypes$4.varchar]: this.encodeUtf8String,
    [dataTypes$4.varint]: this.encodeVarint,
    [dataTypes$4.timeuuid]: this.encodeUuid,
    [dataTypes$4.inet]: this.encodeInet,
    [dataTypes$4.date]: this.encodeDate,
    [dataTypes$4.time]: this.encodeTime,
    [dataTypes$4.smallint]: this.encodeSmallint,
    [dataTypes$4.tinyint]: this.encodeTinyint,
    [dataTypes$4.duration]: encodeDuration,
    [dataTypes$4.list]: this.encodeList,
    [dataTypes$4.map]: this.encodeMap,
    [dataTypes$4.set]: this.encodeSet,
    [dataTypes$4.udt]: this.encodeUdt,
    [dataTypes$4.tuple]: this.encodeTuple
  };
}

/**
 * Decodes Cassandra bytes into Javascript values.
 * <p>
 * This is part of an <b>experimental</b> API, this can be changed future releases.
 * </p>
 * @param {Buffer} buffer Raw buffer to be decoded.
 * @param {Object} type An object containing the data type <code>code</code> and <code>info</code>.
 * @param {Number} type.code Type code.
 * @param {Object} [type.info] Additional information on the type for complex / nested types.
 */
Encoder$2.prototype.decode = function (buffer, type) {
  if (buffer === null || (buffer.length === 0 && !zeroLengthTypesSupported.has(type.code))) {
    return null;
  }

  const decoder = this.decoders[type.code];

  if (!decoder) {
    throw new Error('Unknown data type: ' + type.code);
  }

  return decoder.call(this, buffer, type.info);
};

/**
 * Encodes Javascript types into Buffer according to the Cassandra protocol.
 * <p>
 * This is part of an <b>experimental</b> API, this can be changed future releases.
 * </p>
 * @param {*} value The value to be converted.
 * @param {{code: number, info: *|Object}|String|Number} [typeInfo] The type information.
 * <p>It can be either a:</p>
 * <ul>
 *   <li>A <code>String</code> representing the data type.</li>
 *   <li>A <code>Number</code> with one of the values of {@link module:types~dataTypes dataTypes}.</li>
 *   <li>An <code>Object</code> containing the <code>type.code</code> as one of the values of
 *   {@link module:types~dataTypes dataTypes} and <code>type.info</code>.
 *   </li>
 * </ul>
 * @returns {Buffer}
 * @throws {TypeError} When there is an encoding error
 */
Encoder$2.prototype.encode = function (value, typeInfo) {
  if (value === undefined) {
    value = this.encodingOptions.useUndefinedAsUnset && this.protocolVersion >= 4 ? types$l.unset : null;
  }

  if (value === types$l.unset) {
    if (!types$l.protocolVersion.supportsUnset(this.protocolVersion)) {
      throw new TypeError('Unset value can not be used for this version of Cassandra, protocol version: ' +
        this.protocolVersion);
    }

    return value;
  }

  if (value === null || value instanceof Buffer) {
    return value;
  }

  /** @type {{code: Number, info: object}} */
  let type = {
    code: null,
    info: null
  };

  if (typeInfo) {
    if (typeof typeInfo === 'number') {
      type.code = typeInfo;
    }
    else if (typeof typeInfo === 'string') {
      type = dataTypes$4.getByName(typeInfo);
    }
    if (typeof typeInfo.code === 'number') {
      type.code = typeInfo.code;
      type.info = typeInfo.info;
    }
    if (typeof type.code !== 'number') {
      throw new TypeError('Type information not valid, only String and Number values are valid hints');
    }
  }
  else {
    //Lets guess
    type = Encoder$2.guessDataType(value);
    if (!type) {
      throw new TypeError('Target data type could not be guessed, you should use prepared statements for accurate type mapping. Value: ' + util$k.inspect(value));
    }
  }

  const encoder = this.encoders[type.code];

  if (!encoder) {
    throw new Error('Type not supported ' + type.code);
  }

  return encoder.call(this, value, type.info);
};

/**
 * Try to guess the Cassandra type to be stored, based on the javascript value type
 * @param value
 * @returns {{code: number, info: object}|null}
 * @ignore
 * @internal
 */
Encoder$2.guessDataType = function (value) {
  let code = null;
  let info = null;
  const esTypeName = (typeof value);
  if (esTypeName === 'number') {
    code = dataTypes$4.double;
  }
  else if (esTypeName === 'string') {
    code = dataTypes$4.text;
    if (value.length === 36 && uuidRegex.test(value)){
      code = dataTypes$4.uuid;
    }
  }
  else if (esTypeName === 'boolean') {
    code = dataTypes$4.boolean;
  }
  else if (value instanceof Buffer) {
    code = dataTypes$4.blob;
  }
  else if (value instanceof Date) {
    code = dataTypes$4.timestamp;
  }
  else if (value instanceof Long$1) {
    code = dataTypes$4.bigint;
  }
  else if (value instanceof Integer$1) {
    code = dataTypes$4.varint;
  }
  else if (value instanceof BigDecimal) {
    code = dataTypes$4.decimal;
  }
  else if (value instanceof types$l.Uuid) {
    code = dataTypes$4.uuid;
  }
  else if (value instanceof types$l.InetAddress) {
    code = dataTypes$4.inet;
  }
  else if (value instanceof types$l.Tuple) {
    code = dataTypes$4.tuple;
  }
  else if (value instanceof types$l.LocalDate) {
    code = dataTypes$4.date;
  }
  else if (value instanceof types$l.LocalTime) {
    code = dataTypes$4.time;
  }
  else if (value instanceof types$l.Duration) {
    code = dataTypes$4.custom;
    info = customTypeNames.duration;
  }
  else if (Array.isArray(value)) {
    code = dataTypes$4.list;
  }
  else if (value instanceof Geometry) {
    code = dataTypes$4.custom;
    if (value instanceof LineString$1) {
      info = customTypeNames.lineString;
    } else if (value instanceof Point$1) {
      info = customTypeNames.point;
    } else if (value instanceof Polygon$1) {
      info = customTypeNames.polygon;
    }
  }
  else if (value instanceof DateRange) {
    code = dataTypes$4.custom;
    info = customTypeNames.dateRange;
  }

  if (code === null) {
    return null;
  }
  return { code: code, info: info };
};

/**
 * Gets a buffer containing with the bytes (BE) representing the collection length for protocol v2 and below
 * @param {Buffer|Number} value
 * @returns {Buffer}
 * @private
 */
function getLengthBufferV2(value) {
  if (!value) {
    return buffers.int16Zero;
  }
  const lengthBuffer = utils$t.allocBufferUnsafe(2);
  if (typeof value === 'number') {
    lengthBuffer.writeUInt16BE(value, 0);
  }
  else {
    lengthBuffer.writeUInt16BE(value.length, 0);
  }
  return lengthBuffer;
}

/**
 * Gets a buffer containing with the bytes (BE) representing the collection length for protocol v3 and above
 * @param {Buffer|Number} value
 * @returns {Buffer}
 * @private
 */
function getLengthBufferV3(value) {
  if (!value) {
    return buffers.int32Zero;
  }
  const lengthBuffer = utils$t.allocBufferUnsafe(4);
  if (typeof value === 'number') {
    lengthBuffer.writeInt32BE(value, 0);
  }
  else {
    lengthBuffer.writeInt32BE(value.length, 0);
  }
  return lengthBuffer;
}

/**
 * @param {Buffer} buffer
 * @private
 */
function handleBufferCopy(buffer) {
  if (buffer === null) {
    return null;
  }
  return utils$t.copyBuffer(buffer);
}

/**
 * @param {Buffer} buffer
 * @private
 */
function handleBufferRef(buffer) {
  return buffer;
}
/**
 * Decodes collection length for protocol v3 and above
 * @param bytes
 * @param offset
 * @returns {Number}
 * @private
 */
function decodeCollectionLengthV3(bytes, offset) {
  return bytes.readInt32BE(offset);
}
/**
 * Decodes collection length for protocol v2 and below
 * @param bytes
 * @param offset
 * @returns {Number}
 * @private
 */
function decodeCollectionLengthV2(bytes, offset) {
  return bytes.readUInt16BE(offset);
}

function decodeDuration(bytes) {
  return types$l.Duration.fromBuffer(bytes);
}

function encodeDuration(value) {
  if (!(value instanceof types$l.Duration)) {
    throw new TypeError('Not a valid duration, expected Duration/Buffer obtained ' + util$k.inspect(value));
  }
  return value.toBuffer();
}

/**
 * @private
 * @param {Buffer} buffer
 */
function decodeLineString(buffer) {
  return LineString$1.fromBuffer(buffer);
}

/**
 * @private
 * @param {LineString} value
 */
function encodeLineString(value) {
  return value.toBuffer();
}

/**
 * @private
 * @param {Buffer} buffer
 */
function decodePoint(buffer) {
  return Point$1.fromBuffer(buffer);
}

/**
 * @private
 * @param {LineString} value
 */
function encodePoint(value) {
  return value.toBuffer();
}

/**
 * @private
 * @param {Buffer} buffer
 */
function decodePolygon(buffer) {
  return Polygon$1.fromBuffer(buffer);
}

/**
 * @private
 * @param {Polygon} value
 */
function encodePolygon(value) {
  return value.toBuffer();
}

function decodeDateRange(buffer) {
  return DateRange.fromBuffer(buffer);
}

/**
 * @private
 * @param {DateRange} value
 */
function encodeDateRange(value) {
  return value.toBuffer();
}

/**
 * @param {String} value
 * @param {Number} startIndex
 * @param {Number} length
 * @param {String} [open]
 * @param {String} [close]
 * @returns {Array}
 * @private
 */
function parseParams(value, startIndex, length, open, close) {
  open = open || '(';
  close = close || ')';
  const types = [];
  let paramStart = startIndex;
  let level = 0;
  for (let i = startIndex; i < startIndex + length; i++) {
    const c = value[i];
    if (c === open) {
      level++;
    }
    if (c === close) {
      level--;
    }
    if (level === 0 && c === ',') {
      types.push(value.substr(paramStart, i - paramStart));
      paramStart = i + 1;
    }
  }
  //Add the last one
  types.push(value.substr(paramStart, length - (paramStart - startIndex)));
  return types;
}

/**
 * @param {Array.<Buffer>} parts
 * @param {Number} totalLength
 * @returns {Buffer}
 * @private
 */
function concatRoutingKey(parts, totalLength) {
  if (totalLength === 0) {
    return null;
  }
  if (parts.length === 1) {
    return parts[0];
  }
  const routingKey = utils$t.allocBufferUnsafe(totalLength);
  let offset = 0;
  for (let i = 0; i < parts.length; i++) {
    const item = parts[i];
    routingKey.writeUInt16BE(item.length, offset);
    offset += 2;
    item.copy(routingKey, offset);
    offset += item.length;
    routingKey[offset] = 0;
    offset++;
  }
  return routingKey;
}

var encoder = Encoder$2;

var streams$1 = {};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const util$j = require$$0$4;
const utils$s = utils$K;
const types$k = requireTypes();
const errors$g = errors$n;

/**
 * Information on the formatting of the returned rows
 */
const resultFlag = {
  globalTablesSpec:   0x0001,
  hasMorePages:       0x0002,
  noMetadata:         0x0004,
  metadataChanged:    0x0008,
  continuousPaging: 0x40000000,
  lastContinuousPage: 0x80000000,
};

// templates for derived error messages.
const _writeTimeoutQueryMessage = 'Server timeout during write query at consistency %s (%d peer(s) acknowledged the write over %d required)';
const _writeTimeoutBatchLogMessage = 'Server timeout during batchlog write at consistency %s (%d peer(s) acknowledged the write over %d required)';
const _writeFailureMessage = 'Server failure during write query at consistency %s (%d responses were required but only %d replicas responded, %d failed)';
const _unavailableMessage = 'Not enough replicas available for query at consistency %s (%d required but only %d alive)';
const _readTimeoutMessage = 'Server timeout during read query at consistency %s (%s)';
const _readFailureMessage = 'Server failure during read query at consistency %s (%d responses were required but only %d replicas responded, %d failed)';

/**
 * Buffer forward reader of CQL binary frames
 * @param {FrameHeader} header
 * @param {Buffer} body
 * @param {Number} [offset]
 */
let FrameReader$1 = class FrameReader {

  /**
   * Creates a new instance of the reader
   * @param {FrameHeader} header
   * @param {Buffer} body
   * @param {Number} [offset]
   */
  constructor(header, body, offset) {
    this.header = header;
    this.opcode = header.opcode;
    this.offset = offset || 0;
    this.buf = body;
  }

  remainingLength() {
    return this.buf.length - this.offset;
  }

  getBuffer() {
    return this.buf;
  }

  /**
   * Slices the underlining buffer
   * @param {Number} begin
   * @param {Number} [end]
   * @returns {Buffer}
   */
  slice(begin, end) {
    if (typeof end === 'undefined') {
      end = this.buf.length;
    }
    return this.buf.slice(begin, end);
  }

  /**
   * Modifies the underlying buffer, it concatenates the given buffer with the original (internalBuffer = concat(bytes, internalBuffer)
   */
  unshift(bytes) {
    if (this.offset > 0) {
      throw new Error('Can not modify the underlying buffer if already read');
    }
    this.buf = Buffer.concat([bytes, this.buf], bytes.length + this.buf.length);
  }

  /**
   * Reads any number of bytes and moves the offset.
   * if length not provided or it's larger than the remaining bytes, reads to end.
   * @param length
   * @returns {Buffer}
   */
  read(length) {
    let end = this.buf.length;
    if (typeof length !== 'undefined' && this.offset + length < this.buf.length) {
      end = this.offset + length;
    }
    const bytes = this.slice(this.offset, end);
    this.offset = end;
    return bytes;
  }

  /**
   * Moves the reader cursor to the end
   */
  toEnd() {
    this.offset = this.buf.length;
  }

  /**
   * Reads a BE Int and moves the offset
   * @returns {Number}
   */
  readInt() {
    const result = this.buf.readInt32BE(this.offset);
    this.offset += 4;
    return result;
  }

  /** @returns {Number} */
  readShort() {
    const result = this.buf.readUInt16BE(this.offset);
    this.offset += 2;
    return result;
  }

  readByte() {
    const result = this.buf.readUInt8(this.offset);
    this.offset += 1;
    return result;
  }

  readString() {
    const length = this.readShort();
    this.checkOffset(length);
    const result = this.buf.toString('utf8', this.offset, this.offset + length);
    this.offset += length;
    return result;
  }

  /**
   * Checks that the new length to read is within the range of the buffer length. Throws a RangeError if not.
   * @param {Number} newLength
   */
  checkOffset(newLength) {
    if (this.offset + newLength > this.buf.length) {
      const err = new RangeError('Trying to access beyond buffer length');
      err.expectedLength = newLength;
      throw err;
    }
  }

  /**
   * Reads a protocol string list
   * @returns {Array}
   */
  readStringList() {
    const length = this.readShort();
    const list = new Array(length);
    for (let i = 0; i < length; i++) {
      list[i] = this.readString();
    }
    return list;
  }

  /**
   * Reads the amount of bytes that the field has and returns them (slicing them).
   * @returns {Buffer}
   */
  readBytes() {
    const length = this.readInt();
    if (length < 0) {
      return null;
    }
    this.checkOffset(length);
    return this.read(length);
  }

  readShortBytes() {
    const length = this.readShort();
    if (length < 0) {
      return null;
    }
    this.checkOffset(length);
    return this.read(length);
  }

  /**
   * Reads an associative array of strings as keys and bytes as values
   * @param {Number} length
   * @param {Function} keyFn
   * @param {Function} valueFn
   * @returns {Object}
   */
  readMap(length, keyFn, valueFn) {
    if (length < 0) {
      return null;
    }
    const map = {};
    for (let i = 0; i < length; i++) {
      map[keyFn.call(this)] = valueFn.call(this);
    }
    return map;
  }

  /**
   * Reads an associative array of strings as keys and string lists as values
   * @returns {Object}
   */
  readStringMultiMap() {
    //A [short] n, followed by n pair <k><v> where <k> is a
    //[string] and <v> is a [string[]].
    const length = this.readShort();
    if (length < 0) {
      return null;
    }
    const map = {};
    for (let i = 0; i < length; i++) {
      map[this.readString()] = this.readStringList();
    }
    return map;
  }

  /**
   * Reads a data type definition
   * @returns {{code: Number, info: Object|null}} An array of 2 elements
   */
  readType() {
    let i;
    const type = {
      code: this.readShort(),
      type: null
    };
    switch (type.code) {
      case types$k.dataTypes.custom:
        type.info = this.readString();
        break;
      case types$k.dataTypes.list:
      case types$k.dataTypes.set:
        type.info = this.readType();
        break;
      case types$k.dataTypes.map:
        type.info = [this.readType(), this.readType()];
        break;
      case types$k.dataTypes.udt:
        type.info = {
          keyspace: this.readString(),
          name: this.readString(),
          fields: new Array(this.readShort())
        };
        for (i = 0; i < type.info.fields.length; i++) {
          type.info.fields[i] = {
            name: this.readString(),
            type: this.readType()
          };
        }
        break;
      case types$k.dataTypes.tuple:
        type.info = new Array(this.readShort());
        for (i = 0; i < type.info.length; i++) {
          type.info[i] = this.readType();
        }
        break;
    }
    return type;
  }

  /**
   * Reads an Ip address and port
   * @returns {{address: exports.InetAddress, port: Number}}
   */
  readInet() {
    const length = this.readByte();
    const address = this.read(length);
    return { address: new types$k.InetAddress(address), port: this.readInt() };
  }

  /**
   * Reads an Ip address
   * @returns {InetAddress}
   */
  readInetAddress() {
    const length = this.readByte();
    return new types$k.InetAddress(this.read(length));
  }

  /**
   * Reads the body bytes corresponding to the flags
   * @returns {{traceId: Uuid, warnings: Array, customPayload}}
   * @throws {RangeError}
   */
  readFlagsInfo() {
    if (this.header.flags === 0) {
      return utils$s.emptyObject;
    }
    const result = {};
    if (this.header.flags & types$k.frameFlags.tracing) {
      this.checkOffset(16);
      result.traceId = new types$k.Uuid(utils$s.copyBuffer(this.read(16)));
    }
    if (this.header.flags & types$k.frameFlags.warning) {
      result.warnings = this.readStringList();
    }
    if (this.header.flags & types$k.frameFlags.customPayload) {
      // Custom payload is a Map<string, Buffer>
      result.customPayload = this.readMap(this.readShort(), this.readString, this.readBytes);
    }
    return result;
  }

  /**
   * Reads the metadata from a row or a prepared result response
   * @param {Number} kind
   * @returns {Object}
   * @throws {RangeError}
   */
  readMetadata(kind) {
    let i;
    //Determines if its a prepared metadata
    const isPrepared = (kind === types$k.resultKind.prepared);
    const meta = {};
    if (types$k.protocolVersion.supportsResultMetadataId(this.header.version) && isPrepared) {
      meta.resultId = utils$s.copyBuffer(this.readShortBytes());
    }
    //as used in Rows and Prepared responses
    const flags = this.readInt();
    const columnLength = this.readInt();
    if (types$k.protocolVersion.supportsPreparedPartitionKey(this.header.version) && isPrepared) {
      //read the pk columns
      meta.partitionKeys = new Array(this.readInt());
      for (i = 0; i < meta.partitionKeys.length; i++) {
        meta.partitionKeys[i] = this.readShort();
      }
    }
    if (flags & resultFlag.hasMorePages) {
      meta.pageState = utils$s.copyBuffer(this.readBytes());
    }
    if (flags & resultFlag.metadataChanged) {
      meta.newResultId = utils$s.copyBuffer(this.readShortBytes());
    }
    if (flags & resultFlag.continuousPaging) {
      meta.continuousPageIndex = this.readInt();
      meta.lastContinuousPage = !!(flags & resultFlag.lastContinuousPage);
    }
    if (flags & resultFlag.globalTablesSpec) {
      meta.global_tables_spec = true;
      meta.keyspace = this.readString();
      meta.table = this.readString();
    }
    meta.columns = new Array(columnLength);
    meta.columnsByName = utils$s.emptyObject;
    if (isPrepared) {
      //for prepared metadata, we will need a index of the columns (param) by name
      meta.columnsByName = {};
    }
    for (i = 0; i < columnLength; i++) {
      const col = {};
      if (!meta.global_tables_spec) {
        col.ksname = this.readString();
        col.tablename = this.readString();
      }
      col.name = this.readString();
      col.type = this.readType();
      meta.columns[i] = col;
      if (isPrepared) {
        meta.columnsByName[col.name] = i;
      }
    }
    return meta;
  }

  /**
   * Reads the error from the frame
   * @throws {RangeError}
   * @returns {ResponseError}
   */
  readError() {
    const code = this.readInt();
    const message = this.readString();
    const err = new errors$g.ResponseError(code, message);
    //read extra info
    switch (code) {
      case types$k.responseErrorCodes.unavailableException:
        err.consistencies = this.readShort();
        err.required = this.readInt();
        err.alive = this.readInt();
        err.message = util$j.format(_unavailableMessage, types$k.consistencyToString[err.consistencies], err.required, err.alive);
        break;
      case types$k.responseErrorCodes.readTimeout:
      case types$k.responseErrorCodes.readFailure:
        err.consistencies = this.readShort();
        err.received = this.readInt();
        err.blockFor = this.readInt();
        if (code === types$k.responseErrorCodes.readFailure) {
          if (types$k.protocolVersion.supportsFailureReasonMap(this.header.version)) {
            err.failures = this.readInt();
            err.reasons = this.readMap(err.failures, this.readInetAddress, this.readShort);
          }
          else {
            err.failures = this.readInt();
          }
        }
        err.isDataPresent = this.readByte();
        if (code === types$k.responseErrorCodes.readTimeout) {
          let details;
          if (err.received < err.blockFor) {
            details = util$j.format('%d replica(s) responded over %d required', err.received, err.blockFor);
          }
          else if (!err.isDataPresent) {
            details = 'the replica queried for the data didn\'t respond';
          }
          else {
            details = 'timeout while waiting for repair of inconsistent replica';
          }
          err.message = util$j.format(_readTimeoutMessage, types$k.consistencyToString[err.consistencies], details);
        }
        else {
          err.message = util$j.format(_readFailureMessage, types$k.consistencyToString[err.consistencies], err.blockFor, err.received, err.failures);
        }
        break;
      case types$k.responseErrorCodes.writeTimeout:
      case types$k.responseErrorCodes.writeFailure:
        err.consistencies = this.readShort();
        err.received = this.readInt();
        err.blockFor = this.readInt();
        if (code === types$k.responseErrorCodes.writeFailure) {
          if (types$k.protocolVersion.supportsFailureReasonMap(this.header.version)) {
            err.failures = this.readInt();
            err.reasons = this.readMap(err.failures, this.readInetAddress, this.readShort);
          }
          else {
            err.failures = this.readInt();
          }
        }
        err.writeType = this.readString();
        if (code === types$k.responseErrorCodes.writeTimeout) {
          const template = err.writeType === 'BATCH_LOG' ? _writeTimeoutBatchLogMessage : _writeTimeoutQueryMessage;
          err.message = util$j.format(template, types$k.consistencyToString[err.consistencies], err.received, err.blockFor);
        }
        else {
          err.message = util$j.format(_writeFailureMessage, types$k.consistencyToString[err.consistencies], err.blockFor, err.received, err.failures);
        }
        break;
      case types$k.responseErrorCodes.unprepared:
        err.queryId = utils$s.copyBuffer(this.readShortBytes());
        break;
      case types$k.responseErrorCodes.functionFailure:
        err.keyspace = this.readString();
        err.functionName = this.readString();
        err.argTypes = this.readStringList();
        break;
      case types$k.responseErrorCodes.alreadyExists: {
        err.keyspace = this.readString();
        const table = this.readString();
        if (table.length > 0) {
          err.table = table;
        }
        break;
      }
    }
    return err;
  }

  /**
   * Reads an event from Cassandra and returns the detail
   * @returns {{eventType: String, inet: {address: Buffer, port: Number}}, *}
   */
  readEvent() {
    const eventType = this.readString();
    switch (eventType) {
      case types$k.protocolEvents.topologyChange:
        return {
          added: this.readString() === 'NEW_NODE',
          inet: this.readInet(),
          eventType: eventType
        };
      case types$k.protocolEvents.statusChange:
        return {
          up: this.readString() === 'UP',
          inet: this.readInet(),
          eventType: eventType
        };
      case types$k.protocolEvents.schemaChange:
        return this.parseSchemaChange();
    }
    //Forward compatibility
    return { eventType: eventType };
  }

  parseSchemaChange() {
    let result;
    if (!types$k.protocolVersion.supportsSchemaChangeFullMetadata(this.header.version)) {
      //v1/v2: 3 strings, the table value can be empty
      result = {
        eventType: types$k.protocolEvents.schemaChange,
        schemaChangeType: this.readString(),
        keyspace: this.readString(),
        table: this.readString()
      };
      result.isKeyspace = !result.table;
      return result;
    }
    //v3+: 3 or 4 strings: change_type, target, keyspace and (table, type, functionName or aggregate)
    result = {
      eventType: types$k.protocolEvents.schemaChange,
      schemaChangeType: this.readString(),
      target: this.readString(),
      keyspace: this.readString(),
      table: null,
      udt: null,
      signature: null
    };
    result.isKeyspace = result.target === 'KEYSPACE';
    switch (result.target) {
      case 'TABLE':
        result.table = this.readString();
        break;
      case 'TYPE':
        result.udt = this.readString();
        break;
      case 'FUNCTION':
        result.functionName = this.readString();
        result.signature = this.readStringList();
        break;
      case 'AGGREGATE':
        result.aggregate = this.readString();
        result.signature = this.readStringList();
    }
    return result;
  }
};

var readers = { FrameReader: FrameReader$1 };

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const util$i = require$$0$4;
const { Transform, Writable } = require$$0$1;

const types$j = requireTypes();
const utils$r = utils$K;
const errors$f = errors$n;
const { FrameHeader } = types$j;
const { FrameReader } = readers;

/**
 * Transforms chunks, emits data objects {header, chunk}
 * @param options Stream options
 * @extends Transform
 */
function Protocol (options) {
  Transform.call(this, options);
  this.header = null;
  this.bodyLength = 0;
  this.clearHeaderChunks();
  this.version = 0;
  this.headerSize = 0;
}

util$i.inherits(Protocol, Transform);

Protocol.prototype._transform = function (chunk, encoding, callback) {
  let error = null;
  try {
    this.readItems(chunk);
  }
  catch (err) {
    error = err;
  }
  callback(error);
};

/**
 * Parses the chunk into frames (header and body).
 * Emits (push) complete frames or frames with incomplete bodies. Following chunks containing the rest of the body will
 * be emitted using the same frame.
 * It buffers incomplete headers.
 * @param {Buffer} chunk
 */
Protocol.prototype.readItems = function (chunk) {
  if (!chunk || chunk.length === 0) {
    return;
  }
  if (this.version === 0) {
    //The server replies the first message with the max protocol version supported
    this.version = FrameHeader.getProtocolVersion(chunk);
    this.headerSize = FrameHeader.size(this.version);
  }
  let offset = 0;
  let currentHeader = this.header;
  this.header = null;
  if (this.headerChunks.byteLength !== 0) {
    //incomplete header was buffered try to read the header from the buffered chunks
    this.headerChunks.parts.push(chunk);
    if (this.headerChunks.byteLength + chunk.length < this.headerSize) {
      this.headerChunks.byteLength += chunk.length;
      return;
    }
    currentHeader = FrameHeader.fromBuffer(Buffer.concat(this.headerChunks.parts, this.headerSize));
    offset = this.headerSize - this.headerChunks.byteLength;
    this.clearHeaderChunks();
  }
  const items = [];
  while (true) {
    if (!currentHeader) {
      if (this.headerSize > chunk.length - offset) {
        if (chunk.length - offset <= 0) {
          break;
        }
        //the header is incomplete, buffer it until the next chunk
        const headerPart = chunk.slice(offset, chunk.length);
        this.headerChunks.parts.push(headerPart);
        this.headerChunks.byteLength = headerPart.length;
        break;
      }
      //read header
      currentHeader = FrameHeader.fromBuffer(chunk, offset);
      offset += this.headerSize;
    }
    //parse body
    const remaining = chunk.length - offset;
    if (currentHeader.bodyLength <= remaining + this.bodyLength) {
      items.push({ header: currentHeader, chunk: chunk, offset: offset, frameEnded: true });
      offset += currentHeader.bodyLength - this.bodyLength;
      //reset the body length
      this.bodyLength = 0;
    }
    else if (remaining >= 0) {
      //the body is not fully contained in this chunk
      //will continue later
      this.header = currentHeader;
      this.bodyLength += remaining;
      if (remaining > 0) {
        //emit if there is at least a byte to emit
        items.push({ header: currentHeader, chunk: chunk, offset: offset, frameEnded: false });
      }
      break;
    }
    currentHeader = null;
  }
  for (let i = 0; i < items.length; i++) {
    this.push(items[i]);
  }
};

Protocol.prototype.clearHeaderChunks = function () {
  this.headerChunks = { byteLength: 0, parts: [] };
};

/**
 * A stream that gets reads header + body chunks and transforms them into header + (row | error)
 * @param {Object} streamOptions Node.js Stream options
 * @param {Encoder} encoder Encoder instance for the parser to use
 * @extends Transform
 */
function Parser (streamOptions, encoder) {
  Transform.call(this, streamOptions);
  //frames that are streaming, indexed by id
  this.frames = {};
  this.encoder = encoder;
}

util$i.inherits(Parser, Transform);

Parser.prototype._transform = function (item, encoding, callback) {
  const frameInfo = this.frameState(item);

  let error = null;
  try {
    this.parseBody(frameInfo, item);
  }
  catch (err) {
    error = err;
  }
  callback(error);

  if (item.frameEnded) {
    if (frameInfo.cellBuffer) {
      //Frame was being streamed but an error force it to buffer the result
      this.push({
        header: frameInfo.header,
        error: new errors$f.DriverInternalError('There was an problem while parsing streaming frame, opcode ' +
          frameInfo.header.opcode)
      });
    }
    //all the parsing finished and it was streamed down
    //emit an item that signals it
    this.push({ header: frameInfo.header, frameEnded: true});
  }
};

/**
 * @param frameInfo
 * @param {{header: FrameHeader, chunk: Buffer, offset: Number}} item
 */
Parser.prototype.parseBody = function (frameInfo, item) {
  frameInfo.isStreaming = frameInfo.byRow && item.header.opcode === types$j.opcodes.result;
  if (!this.handleFrameBuffers(frameInfo, item)) {
    // Frame isn't complete and we are not streaming the frame
    return;
  }
  const reader = new FrameReader(item.header, item.chunk, item.offset);
  // Check that flags have not been parsed yet for this frame
  if (frameInfo.flagsInfo === undefined) {
    const originalOffset = reader.offset;
    try {
      frameInfo.flagsInfo = reader.readFlagsInfo();
    }
    catch (e) {
      return this.handleParsingError(e, frameInfo, reader, originalOffset);
    }
  }

  //All the body for most operations is already buffered at this stage
  //Except for RESULT
  switch (item.header.opcode) {
    case types$j.opcodes.result:
      return this.parseResult(frameInfo, reader);
    case types$j.opcodes.ready:
    case types$j.opcodes.authSuccess:
      return this.push({ header: frameInfo.header, ready: true });
    case types$j.opcodes.authChallenge:
      return this.push({ header: frameInfo.header, authChallenge: true, token: reader.readBytes()});
    case types$j.opcodes.authenticate:
      return this.push({ header: frameInfo.header, mustAuthenticate: true, authenticatorName: reader.readString()});
    case types$j.opcodes.error:
      return this.push({ header: frameInfo.header, error: reader.readError()});
    case types$j.opcodes.supported:
      return this.push({ header: frameInfo.header, supported: reader.readStringMultiMap()});
    case types$j.opcodes.event:
      return this.push({ header: frameInfo.header, event: reader.readEvent()});
    default:
      return this.push({ header: frameInfo.header, error: new Error('Received invalid opcode: ' + item.header.opcode) });
  }
};

/**
 * Buffers if needed and returns true if it has all the necessary data to continue parsing the frame.
 * @param frameInfo
 * @param {{header: FrameHeader, chunk: Buffer, offset: Number}} item
 * @returns {Boolean}
 */
Parser.prototype.handleFrameBuffers = function (frameInfo, item) {
  if (!frameInfo.isStreaming) {
    // Handle buffering for complete frame bodies
    const currentLength = (frameInfo.bufferLength || 0) + item.chunk.length - item.offset;
    if (currentLength < item.header.bodyLength) {
      //buffer until the frame is completed
      this.addFrameBuffer(frameInfo, item);
      return false;
    }
    //We have received the full frame body
    if (frameInfo.buffers) {
      item.chunk = this.getFrameBuffer(frameInfo, item);
      item.offset = 0;
    }
    return true;
  }
  if (frameInfo.cellBuffer) {
    // Handle buffering for frame cells (row cells or metadata cells)
    if (item.offset !== 0) {
      throw new errors$f.DriverInternalError('Following chunks can not have an offset greater than zero');
    }
    frameInfo.cellBuffer.parts.push(item.chunk);
    if (!frameInfo.cellBuffer.expectedLength) {
      //Its a buffer outside a row cell (metadata or other)
      if (frameInfo.cellBuffer.parts.length !== 2) {
        throw new errors$f.DriverInternalError('Buffer for streaming frame can not contain more than 1 item');
      }
      item.chunk = Buffer.concat(frameInfo.cellBuffer.parts, frameInfo.cellBuffer.byteLength + item.chunk.length);
      frameInfo.cellBuffer = null;
      return true;
    }
    if (frameInfo.cellBuffer.expectedLength > frameInfo.cellBuffer.byteLength + item.chunk.length) {
      //We still haven't got the cell data
      frameInfo.cellBuffer.byteLength += item.chunk.length;
      return false;
    }
    item.chunk = Buffer.concat(frameInfo.cellBuffer.parts, frameInfo.cellBuffer.byteLength + item.chunk.length);
    frameInfo.cellBuffer = null;
  }
  return true;
};

/**
 * Adds this chunk to the frame buffers.
 * @param frameInfo
 * @param {{header: FrameHeader, chunk: Buffer, offset: Number}} item
 */
Parser.prototype.addFrameBuffer = function (frameInfo, item) {
  if (!frameInfo.buffers) {
    frameInfo.buffers = [ item.chunk.slice(item.offset) ];
    frameInfo.bufferLength = item.chunk.length - item.offset;
    return;
  }
  if (item.offset > 0) {
    throw new errors$f.DriverInternalError('Following chunks can not have an offset greater than zero');
  }
  frameInfo.buffers.push(item.chunk);
  frameInfo.bufferLength += item.chunk.length;
};

/**
 * Adds the last chunk and concatenates the frame buffers
 * @param frameInfo
 * @param {{header: FrameHeader, chunk: Buffer, offset: Number}} item
 */
Parser.prototype.getFrameBuffer = function (frameInfo, item) {
  frameInfo.buffers.push(item.chunk);
  const result = Buffer.concat(frameInfo.buffers, frameInfo.bodyLength);
  frameInfo.buffers = null;
  return result;
};

/**
 * Tries to read the result in the body of a message
 * @param frameInfo Frame information, header / metadata
 * @param {FrameReader} reader
 */
Parser.prototype.parseResult = function (frameInfo, reader) {
  let result;
  // As we might be streaming and the frame buffer might not be complete,
  // read the metadata and different types of result values in a try-catch.
  // Store the reader position
  const originalOffset = reader.offset;
  try {
    if (!frameInfo.meta) {
      frameInfo.kind = reader.readInt();
      // Spec 4.2.5
      switch (frameInfo.kind) {
        case types$j.resultKind.voidResult:
          result = { header: frameInfo.header, flags: frameInfo.flagsInfo };
          break;
        case types$j.resultKind.rows:
          // Parse the rows metadata, the rest of the response is going to be parsed afterwards
          frameInfo.meta = reader.readMetadata(frameInfo.kind);
          break;
        case types$j.resultKind.setKeyspace:
          result = { header: frameInfo.header, keyspaceSet: reader.readString(), flags: frameInfo.flagsInfo };
          break;
        case types$j.resultKind.prepared:
        {
          const preparedId = utils$r.copyBuffer(reader.readShortBytes());
          frameInfo.meta = reader.readMetadata(frameInfo.kind);
          result = { header: frameInfo.header, id: preparedId, meta: frameInfo.meta, flags: frameInfo.flagsInfo };
          break;
        }
        case types$j.resultKind.schemaChange:
          result = { header: frameInfo.header, schemaChange: reader.parseSchemaChange(), flags: frameInfo.flagsInfo };
          break;
        default:
          throw errors$f.DriverInternalError('Unexpected result kind: ' + frameInfo.kind);
      }
    }
  }
  catch (e) {
    return this.handleParsingError(e, frameInfo, reader, originalOffset);
  }
  if (result) {
    if (frameInfo.emitted) {
      // It may contain additional metadata and info that it's not being parsed
      return;
    }
    frameInfo.emitted = true;
    return this.push(result);
  }
  if (reader.remainingLength() > 0) {
    this.parseRows(frameInfo, reader);
  }
};

/**
 * @param frameInfo
 * @param {FrameReader} reader
 */
Parser.prototype.parseRows = function (frameInfo, reader) {
  if (frameInfo.parsingError) {
    //No more processing on this frame
    return;
  }
  if (frameInfo.rowLength === undefined) {
    try {
      frameInfo.rowLength = reader.readInt();
    }
    catch (e) {
      return this.handleParsingError(e, frameInfo, reader);
    }
  }
  if (frameInfo.rowLength === 0) {
    return this.push({
      header: frameInfo.header,
      result: { rows: utils$r.emptyArray, meta: frameInfo.meta, flags: frameInfo.flagsInfo }
    });
  }
  const meta = frameInfo.meta;
  frameInfo.rowIndex = frameInfo.rowIndex || 0;
  for (let i = frameInfo.rowIndex; i < frameInfo.rowLength; i++) {
    const rowOffset = reader.offset;
    const row = new types$j.Row(meta.columns);
    let cellBuffer;
    for (let j = 0; j < meta.columns.length; j++ ) {
      const c = meta.columns[j];
      try {
        cellBuffer = reader.readBytes();
      }
      catch (e) {
        return this.handleParsingError(e, frameInfo, reader, rowOffset, i);
      }
      try {
        row[c.name] = this.encoder.decode(cellBuffer, c.type);
      }
      catch (e) {
        //Something went wrong while decoding, we are not going to be able to recover
        return this.handleParsingError(e, frameInfo, null);
      }
    }
    this.push({
      header: frameInfo.header,
      row: row,
      meta: frameInfo.meta,
      byRow: frameInfo.byRow,
      length: frameInfo.rowLength,
      flags: frameInfo.flagsInfo
    });
  }
  if (frameInfo.byRow) {
    // Use an event item to identify that all the streaming rows have finished processing
    this.push({
      header: frameInfo.header,
      byRowCompleted: true,
      meta: frameInfo.meta,
      length: frameInfo.rowLength,
      flags: frameInfo.flagsInfo
    });
  }
};

/**
 * Sets parser options (ie: how to yield the results as they are parsed)
 * @param {Number} id Id of the stream
 * @param options
 */
Parser.prototype.setOptions = function (id, options) {
  if (this.frames[id.toString()]) {
    throw new types$j.DriverError('There was already state for this frame');
  }
  this.frames[id.toString()] = options;
};

/**
 * Manually clears the frame options.
 * This class already clears the provided options when the frame ends, so it's usually not required to invoke this
 * method.
 * When manually setting the options for continuous paging, it's possible that the frame options are set while
 * it's being cancelled.
 * @param {Number} id The streamId
 */
Parser.prototype.clearOptions = function (id) {
  delete this.frames[id.toString()];
};

/**
 * Gets the frame info from the internal state.
 * In case it is not there, it creates it.
 * In case the frame ended
 */
Parser.prototype.frameState = function (item) {
  let frameInfo = this.frames[item.header.streamId];
  if (!frameInfo) {
    frameInfo = {};
    if (!item.frameEnded) {
      //store it in the frames
      this.frames[item.header.streamId] = frameInfo;
    }
  }
  else if (item.frameEnded) {
    //if it was already stored, remove it
    delete this.frames[item.header.streamId];
  }
  frameInfo.header = item.header;
  return frameInfo;
};

/**
 * Handles parsing error: pushing an error if its unexpected or buffer the cell if its streaming
 * @param {Error} e
 * @param frameInfo
 * @param {FrameReader} reader
 * @param {Number} [originalOffset]
 * @param {Number} [rowIndex]
 */
Parser.prototype.handleParsingError = function (e, frameInfo, reader, originalOffset, rowIndex) {
  if (reader && frameInfo.isStreaming && (e instanceof RangeError)) {
    //A controlled error, buffer from offset and move on
    return this.bufferResultCell(frameInfo, reader, originalOffset, rowIndex, e.expectedLength);
  }
  frameInfo.parsingError = true;
  frameInfo.cellBuffer = null;
  this.push({ header: frameInfo.header, error: e });
};

/**
 * When streaming, it buffers data since originalOffset.
 * @param frameInfo
 * @param {FrameReader} reader
 * @param {Number} [originalOffset]
 * @param {Number} [rowIndex]
 * @param {Number} [expectedLength]
 */
Parser.prototype.bufferResultCell = function (frameInfo, reader, originalOffset, rowIndex, expectedLength) {
  if (!originalOffset && originalOffset !== 0) {
    originalOffset = reader.offset;
  }
  frameInfo.rowIndex = rowIndex;
  const buffer = reader.slice(originalOffset);
  frameInfo.cellBuffer = {
    parts: [ buffer ],
    byteLength: buffer.length,
    expectedLength: expectedLength
  };
};

/**
 * Represents a writable streams that emits results
 */
function ResultEmitter(options) {
  Writable.call(this, options);
  /**
   * Stores the rows for frames that needs to be yielded as one result with many rows
   */
  this.rowBuffer = {};
}

util$i.inherits(ResultEmitter, Writable);

ResultEmitter.prototype._write = function (item, encoding, callback) {
  let error = null;
  try {
    this.each(item);
  }
  catch (err) {
    error = err;
  }
  callback(error);
};


/**
 * Analyzes the item and emit the corresponding event
 */
ResultEmitter.prototype.each = function (item) {
  if (item.error || item.result) {
    //Its either an error or an empty array rows
    //no transformation needs to be made
    return this.emit('result', item.header, item.error, item.result);
  }
  if (item.frameEnded) {
    return this.emit('frameEnded', item.header);
  }
  if (item.lastContinuousPage) {
    return this.emit('lastContinuousPage', item.header);
  }
  if (item.byRowCompleted) {
    return this.emit('byRowCompleted', item.header, item.row, item.meta, item.flags);
  }
  if (item.byRow) {
    //it should be yielded by row
    return this.emit('row', item.header, item.row, item.meta, item.length, item.flags);
  }
  if (item.row) {
    //it should be yielded as a result
    //it needs to be buffered to an array of rows
    return this.bufferAndEmit(item);
  }
  if (item.event) {
    //its an event from Cassandra
    return this.emit('nodeEvent', item.header, item.event);
  }
  //its a raw response (object with flags)
  return this.emit('result', item.header, null, item);
};

/**
 * Buffers the rows until the result set is completed and emits the result event.
 */
ResultEmitter.prototype.bufferAndEmit = function (item) {
  let rows = this.rowBuffer[item.header.streamId];
  if (!rows) {
    rows = this.rowBuffer[item.header.streamId] = [];
  }
  rows.push(item.row);
  if (rows.length === item.length) {
    this.emit('result', item.header, null, { rows: rows, meta: item.meta, flags: item.flags});
    delete this.rowBuffer[item.header.streamId];
  }
};

streams$1.Protocol = Protocol;
streams$1.Parser = Parser;
streams$1.ResultEmitter = ResultEmitter;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const types$i = requireTypes();

/**
 * Group size
 * @type {number}
 */
const groupSize = 128;

/**
 * Number used to right shift ids to allocate them into groups
 * @const
 * @type {number}
 */
const shiftToGroup = 7;

/**
 * Amount of groups that can be released per time
 * If it grows larger than 4 groups (128 * 4), groups can be released
 * @const
 * @type {number}
 */
const releasableSize = 4;

/**
 * 32K possible stream ids depending for protocol v3 and above
 * @const
 * @type {number}
 */
const maxGroupsFor2Bytes = 256;

/**
 * Delay used to check if groups can be released
 * @const
 * @type {number}
 */
const defaultReleaseDelay = 5000;

/**
 * Represents a queue of ids from 0 to maximum stream id supported by the protocol version.
 * Clients can dequeue a stream id using {@link StreamIdStack#shift()} and enqueue (release) using
 * {@link StreamIdStack#push()}
 */
let StreamIdStack$1 = class StreamIdStack {
  /**
   * Creates a new instance of StreamIdStack.
   * @param {number} version Protocol version
   * @constructor
   */
  constructor(version) {
    //Ecmascript Number is 64-bit double, it can be optimized by the engine into a 32-bit int, but nothing below that.
    //We try to allocate as few as possible in arrays of 128
    this.currentGroup = generateGroup(0);
    this.groupIndex = 0;
    this.groups = [this.currentGroup];
    this.releaseTimeout = null;
    this.setVersion(version);
    /**
     * Returns the amount of ids currently in use
     * @member {number}
     */
    this.inUse = 0;
    this.releaseDelay = defaultReleaseDelay;
  }

  /**
   * Sets the protocol version
   * @param {Number} version
   */
  setVersion(version) {
    //128 or 32K stream ids depending on the protocol version
    this.maxGroups = types$i.protocolVersion.uses2BytesStreamIds(version) ? maxGroupsFor2Bytes : 1;
  }

  /**
   * Dequeues an id.
   * Similar to {@link Array#pop()}.
   * @returns {Number} Returns an id or null
   */
  pop() {
    let id = this.currentGroup.pop();
    if (typeof id !== 'undefined') {
      this.inUse++;
      return id;
    }
    //try to use the following groups
    while (this.groupIndex < this.groups.length - 1) {
      //move to the following group
      this.currentGroup = this.groups[++this.groupIndex];
      //try dequeue
      id = this.currentGroup.pop();
      if (typeof id !== 'undefined') {
        this.inUse++;
        return id;
      }
    }
    return this._tryCreateGroup();
  }

  /**
   * Enqueue an id for future use.
   * Similar to {@link Array#push()}.
   * @param {Number} id
   */
  push(id) {
    this.inUse--;
    const groupIndex = id >> shiftToGroup;
    const group = this.groups[groupIndex];
    group.push(id);
    if (groupIndex < this.groupIndex) {
      //Set the lower group to be used to dequeue from
      this.groupIndex = groupIndex;
      this.currentGroup = group;
    }
    this._tryIssueRelease();
  }

  /**
   * Clears all timers
   */
  clear() {
    if (this.releaseTimeout) {
      clearTimeout(this.releaseTimeout);
      this.releaseTimeout = null;
    }
  }

  /**
   * Tries to create an additional group and returns a new id
   * @returns {Number} Returns a new id or null if it's not possible to create a new group
   * @private
   */
  _tryCreateGroup() {
    if (this.groups.length === this.maxGroups) {
      //we can have an additional group
      return null;
    }
    //Add a new group at the last position
    this.groupIndex = this.groups.length;
    //Using 128 * groupIndex as initial value
    this.currentGroup = generateGroup(this.groupIndex << shiftToGroup);
    this.groups.push(this.currentGroup);
    this.inUse++;
    return this.currentGroup.pop();
  }

  _tryIssueRelease() {
    if (this.releaseTimeout || this.groups.length <= releasableSize) {
      //Nothing to release or a release delay has been issued
      return;
    }

    this.releaseTimeout = setTimeout(() => this._releaseGroups(), this.releaseDelay);
  }

  _releaseGroups() {
    let counter = 0;
    let index = this.groups.length - 1;
    //only release up to n groups (n = releasable size)
    //shrink back up to n groups not all the way up to 1
    while (counter++ < releasableSize && this.groups.length > releasableSize && index > this.groupIndex) {
      if (this.groups[index].length !== groupSize) {
        //the group is being used
        break;
      }
      this.groups.pop();
      index--;
    }
    this.releaseTimeout = null;
    //Issue next release if applies
    this._tryIssueRelease();
  }
};

function generateGroup(initialValue) {
  const arr = new Array(groupSize);
  const upperBound = initialValue + groupSize - 1;
  for (let i = 0; i < groupSize; i++) {
    arr[i] = upperBound - i;
  }
  return arr;
}

var streamIdStack = StreamIdStack$1;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const util$h = require$$0$4;
const utils$q = utils$K;
const errors$e = errors$n;
const requests$6 = requests$7;
const ExecuteRequest = requests$6.ExecuteRequest;
const QueryRequest = requests$6.QueryRequest;

const state$1 = {
  init: 0,
  completed: 1,
  timedOut: 2,
  cancelled: 3
};

/**
 * Maintains the state information of a request inside a Connection.
 */
let OperationState$1 = class OperationState {
  /**
   * Creates a new instance of OperationState.
   * @param {Request} request
   * @param {Function} rowCallback
   * @param {Function} callback
   */
  constructor(request, rowCallback, callback) {
    this.request = request;
    this._rowCallback = rowCallback;
    this._callback = callback;
    this._timeout = null;
    this._state = state$1.init;
    this._rowIndex = 0;
    /**
     * Stream id that is set right before being written.
     * @type {number}
     */
    this.streamId = -1;
  }

  /**
   * Marks the operation as cancelled, clearing all callbacks and timeouts.
   */
  cancel() {
    if (this._state !== state$1.init) {
      return;
    }
    if (this._timeout !== null) {
      clearTimeout(this._timeout);
    }
    this._state = state$1.cancelled;
    this._callback = utils$q.noop;
  }

  /**
   * Determines if the operation can be written to the wire (when it hasn't been cancelled or it hasn't timed out).
   */
  canBeWritten() {
    return this._state === state$1.init;
  }

  /**
   * Determines if the response is going to be yielded by row.
   * @return {boolean}
   */
  isByRow() {
    return this._rowCallback && (this.request instanceof ExecuteRequest || this.request instanceof QueryRequest);
  }

  /**
   * Creates the timeout for the request.
   * @param {ExecutionOptions} execOptions
   * @param {Number} defaultReadTimeout
   * @param {String} address
   * @param {Function} onTimeout The callback to be invoked when it times out.
   * @param {Function} onResponse The callback to be invoked if a response is obtained after it timed out.
   */
  setRequestTimeout(execOptions, defaultReadTimeout, address, onTimeout, onResponse) {
    if (this._state !== state$1.init) {
      // No need to set the timeout
      return;
    }
    const millis = execOptions.getReadTimeout() !== undefined ? execOptions.getReadTimeout() : defaultReadTimeout;
    if (!(millis > 0)) {
      // Read timeout disabled
      return;
    }
    const self = this;
    this._timeout = setTimeout(function requestTimedOut() {
      onTimeout();
      const message = util$h.format('The host %s did not reply before timeout %d ms', address, millis);
      self._markAsTimedOut(new errors$e.OperationTimedOutError(message, address), onResponse);
    }, millis);
  }

  setResultRow(row, meta, rowLength, flags, header) {
    this._markAsCompleted();
    if (!this._rowCallback) {
      return this.setResult(new errors$e.DriverInternalError('RowCallback not found for streaming frame handler'));
    }
    this._rowCallback(this._rowIndex++, row, rowLength);
    if (this._rowIndex === rowLength) {
      this._swapCallbackAndInvoke(null, { rowLength: rowLength, meta: meta, flags: flags }, header.bodyLength);
    }
  }

  /**
   * Marks the current operation as timed out.
   * @param {Error} err
   * @param {Function} onResponse
   * @private
   */
  _markAsTimedOut(err, onResponse) {
    if (this._state !== state$1.init) {
      return;
    }
    this._state = state$1.timedOut;
    this._swapCallbackAndInvoke(err, null, null, onResponse);
  }

  _markAsCompleted() {
    if (this._state !== state$1.init) {
      return;
    }
    if (this._timeout !== null) {
      clearTimeout(this._timeout);
    }
    this._state = state$1.completed;
  }

  /**
   * Sets the result of this operation, declaring that no further input will be processed for this operation.
   * @param {Error} err
   * @param {Object} [result]
   * @param {Number} [length]
   */
  setResult(err, result, length) {
    this._markAsCompleted();
    this._swapCallbackAndInvoke(err, result, length);
  }

  _swapCallbackAndInvoke(err, result, length, newCallback) {
    const callback = this._callback;
    this._callback = newCallback || utils$q.noop;
    callback(err, result, length);
  }
};

var operationState = OperationState$1;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const events$7 = require$$0;
const util$g = require$$0$4;
const tls = require$$2;
const net$1 = require$$1$2;

const Encoder$1 = encoder;
const { WriteQueue } = writers;
const requests$5 = requests$7;
const streams = streams$1;
const utils$p = utils$K;
const types$h = requireTypes();
const errors$d = errors$n;
const StreamIdStack = streamIdStack;
const OperationState = operationState;
const promiseUtils$b = promiseUtils$e;
const { ExecutionOptions: ExecutionOptions$2 } = executionOptions;

/**
 * Represents a connection to a Cassandra node
 */
let Connection$2 = class Connection extends events$7.EventEmitter {

  /**
   * Creates a new instance of Connection.
   * @param {String} endpoint An string containing ip address and port of the host
   * @param {Number|null} protocolVersion
   * @param {ClientOptions} options
   */
  constructor(endpoint, protocolVersion, options) {
    super();

    this.setMaxListeners(0);

    if (!options) {
      throw new Error('options is not defined');
    }

    /**
     * Gets the ip and port of the server endpoint.
     * @type {String}
     */
    this.endpoint = endpoint;

    /**
     * Gets the friendly name of the host, used to identify the connection in log messages.
     * With direct connect, this is the address and port.
     * With SNI, this will be the address and port of the proxy, plus the server name.
     * @type {String}
     */
    this.endpointFriendlyName = this.endpoint;

    if (options.sni) {
      this._serverName = endpoint;
      this.endpoint = `${options.sni.addressResolver.getIp()}:${options.sni.port}`;
      this.endpointFriendlyName = `${this.endpoint} (${this._serverName})`;
    }

    if (!this.endpoint || this.endpoint.indexOf(':') < 0) {
      throw new Error('EndPoint must contain the ip address and port separated by : symbol');
    }

    const portSeparatorIndex = this.endpoint.lastIndexOf(':');
    this.address = this.endpoint.substr(0, portSeparatorIndex);
    this.port = this.endpoint.substr(portSeparatorIndex + 1);

    Object.defineProperty(this, "options", { value: options, enumerable: false, writable: false});

    if (protocolVersion === null) {
      // Set initial protocol version
      protocolVersion = types$h.protocolVersion.maxSupported;
      if (options.protocolOptions.maxVersion) {
        // User provided the protocol version
        protocolVersion = options.protocolOptions.maxVersion;
      }
      // Allow to check version using this connection instance
      this._checkingVersion = true;
    }

    this.log = utils$p.log;
    this.protocolVersion = protocolVersion;
    this._operations = new Map();
    this._pendingWrites = [];
    this._preparing = new Map();

    /**
     * The timeout state for the idle request (heartbeat)
     */
    this._idleTimeout = null;
    this.timedOutOperations = 0;
    this._streamIds = new StreamIdStack(this.protocolVersion);
    this._metrics = options.metrics;

    this.encoder = new Encoder$1(protocolVersion, options);
    this.keyspace = null;
    this.emitDrain = false;
    /**
     * Determines if the socket is open and startup succeeded, whether the connection can be used to send requests /
     * receive events
     */
    this.connected = false;
    /**
     * Determines if the socket can be considered as open
     */
    this.isSocketOpen = false;

    this.send = util$g.promisify(this.sendStream);
    this.closeAsync = util$g.promisify(this.close);
    this.openAsync = util$g.promisify(this.open);
    this.prepareOnceAsync = util$g.promisify(this.prepareOnce);
  }

  /**
   * Binds the necessary event listeners for the socket
   */
  bindSocketListeners() {
    //Remove listeners that were used for connecting
    this.netClient.removeAllListeners('connect');
    this.netClient.removeAllListeners('timeout');
    // The socket is expected to be open at this point
    this.isSocketOpen = true;
    this.netClient.on('close', () => {
      this.log('info', `Connection to ${this.endpointFriendlyName} closed`);
      this.isSocketOpen = false;
      const wasConnected = this.connected;
      this.close();
      if (wasConnected) {
        // Emit only when it was closed unexpectedly
        this.emit('socketClose');
      }
    });

    this.protocol = new streams.Protocol({ objectMode: true });
    this.parser = new streams.Parser({ objectMode: true }, this.encoder);
    const resultEmitter = new streams.ResultEmitter({objectMode: true});
    resultEmitter.on('result', this.handleResult.bind(this));
    resultEmitter.on('row', this.handleRow.bind(this));
    resultEmitter.on('frameEnded', this.freeStreamId.bind(this));
    resultEmitter.on('nodeEvent', this.handleNodeEvent.bind(this));

    this.netClient
      .pipe(this.protocol)
      .pipe(this.parser)
      .pipe(resultEmitter);

    this.writeQueue = new WriteQueue(this.netClient, this.encoder, this.options);
  }

  /**
   * Connects a socket and sends the startup protocol messages.
   * Note that when open() callbacks in error, the caller should immediately call {@link Connection#close}.
   */
  open(callback) {
    const self = this;
    this.log('info', `Connecting to ${this.endpointFriendlyName}`);

    if (!this.options.sslOptions) {
      this.netClient = new net$1.Socket({ highWaterMark: this.options.socketOptions.coalescingThreshold });
      this.netClient.connect(this.port, this.address, function connectCallback() {
        self.log('verbose', `Socket connected to ${self.endpointFriendlyName}`);
        self.bindSocketListeners();
        self.startup(callback);
      });
    }
    else {
      // Use TLS
      const sslOptions = utils$p.extend({ rejectUnauthorized: false }, this.options.sslOptions);

      if (this.options.sni) {
        sslOptions.servername = this._serverName;
      }

      this.netClient = tls.connect(this.port, this.address, sslOptions, function tlsConnectCallback() {
        self.log('verbose', `Secure socket connected to ${self.endpointFriendlyName} with protocol ${self.netClient.getProtocol()}`);
        self.bindSocketListeners();
        self.startup(callback);
      });

      // TLSSocket will validate for values from 512 to 16K (depending on the SSL protocol version)
      this.netClient.setMaxSendFragment(this.options.socketOptions.coalescingThreshold);
    }

    this.netClient.once('error', function socketError(err) {
      self.errorConnecting(err, false, callback);
    });

    this.netClient.once('timeout', function connectTimedOut() {
      const err = new types$h.DriverError('Connection timeout');
      self.errorConnecting(err, true, callback);
    });

    this.netClient.setTimeout(this.options.socketOptions.connectTimeout);

    // Improve failure detection with TCP keep-alives
    if (this.options.socketOptions.keepAlive) {
      this.netClient.setKeepAlive(true, this.options.socketOptions.keepAliveDelay);
    }

    this.netClient.setNoDelay(!!this.options.socketOptions.tcpNoDelay);
  }

  /**
   * Determines the protocol version to use and sends the STARTUP request
   * @param {Function} callback
   */
  startup(callback) {
    if (this._checkingVersion) {
      this.log('info', 'Trying to use protocol version 0x' + this.protocolVersion.toString(16));
    }

    const self = this;
    const request = new requests$5.StartupRequest({
      noCompact: this.options.protocolOptions.noCompact,
      clientId: this.options.id,
      applicationName: this.options.applicationName,
      applicationVersion: this.options.applicationVersion
    });

    this.sendStream(request, null, function responseCallback(err, response) {
      if (err && self._checkingVersion) {
        let invalidProtocol = (err instanceof errors$d.ResponseError &&
          err.code === types$h.responseErrorCodes.protocolError &&
          err.message.indexOf('Invalid or unsupported protocol version') >= 0);

        if (!invalidProtocol && types$h.protocolVersion.canStartupResponseErrorBeWrapped(self.protocolVersion)) {
          //For some versions of Cassandra, the error is wrapped into a server error
          //See CASSANDRA-9451
          invalidProtocol = (err instanceof errors$d.ResponseError &&
            err.code === types$h.responseErrorCodes.serverError &&
            err.message.indexOf('ProtocolException: Invalid or unsupported protocol version') > 0);
        }

        if (invalidProtocol) {
          // The server can respond with a message using the lower protocol version supported
          // or using the same version as the one provided
          let lowerVersion = self.protocol.version;

          if (lowerVersion === self.protocolVersion) {
            lowerVersion = types$h.protocolVersion.getLowerSupported(self.protocolVersion);
          } else if (!types$h.protocolVersion.isSupported(self.protocol.version)) {
            // If we have an unsupported protocol version or a beta version we need to switch
            // to something we can support.  Note that dseV1 and dseV2 are excluded from this
            // logic as they are supported.  Also note that any v5 and greater beta protocols
            // are included here since the beta flag was introduced in v5.
            self.log('info',`Protocol version ${self.protocol.version} not supported by this driver, downgrading`);
            lowerVersion = types$h.protocolVersion.getLowerSupported(self.protocol.version);
          }

          if (!lowerVersion) {
            return startupCallback(
              new Error('Connection was unable to STARTUP using protocol version ' + self.protocolVersion));
          }

          self.log('info', 'Protocol 0x' + self.protocolVersion.toString(16) + ' not supported, using 0x' + lowerVersion.toString(16));
          self.decreaseVersion(lowerVersion);

          // The host closed the connection, close the socket and start the connection flow again
          setImmediate(function decreasingVersionClosing() {
            self.close(function decreasingVersionOpening() {
              // Attempt to open with the correct protocol version
              self.open(callback);
            });
          });

          return;
        }
      }

      if (response && response.mustAuthenticate) {
        return self.startAuthenticating(response.authenticatorName, startupCallback);
      }

      startupCallback(err);
    });

    function startupCallback(err) {
      if (err) {
        return self.errorConnecting(err, false, callback);
      }
      //The socket is connected and the connection is authenticated
      return self.connectionReady(callback);
    }
  }

  errorConnecting(err, destroy, callback) {
    this.log('warning', `There was an error when trying to connect to the host ${this.endpointFriendlyName}`, err);
    if (destroy) {
      //there is a TCP connection that should be killed.
      this.netClient.destroy();
    }

    this._metrics.onConnectionError(err);

    callback(err);
  }

  /**
   * Sets the connection to ready/connected status
   */
  connectionReady(callback) {
    this.emit('connected');
    this.connected = true;
    // Remove existing error handlers as the connection is now ready.
    this.netClient.removeAllListeners('error');
    this.netClient.on('error', this.handleSocketError.bind(this));
    callback();
  }

  /** @param {Number} lowerVersion */
  decreaseVersion(lowerVersion) {
    // The response already has the max protocol version supported by the Cassandra host.
    this.protocolVersion = lowerVersion;
    this.encoder.setProtocolVersion(lowerVersion);
    this._streamIds.setVersion(lowerVersion);
  }

  /**
   * Handle socket errors, if the socket is not readable invoke all pending callbacks
   */
  handleSocketError(err) {
    this._metrics.onConnectionError(err);
    this.clearAndInvokePending(err);
  }

  /**
   * Cleans all internal state and invokes all pending callbacks of sent streams
   */
  clearAndInvokePending(innerError) {
    if (this._idleTimeout) {
      //Remove the idle request
      clearTimeout(this._idleTimeout);
      this._idleTimeout = null;
    }
    this._streamIds.clear();
    if (this.emitDrain) {
      this.emit('drain');
    }
    const err = new types$h.DriverError('Socket was closed');
    err.isSocketError = true;
    if (innerError) {
      err.innerError = innerError;
    }

    // Get all handlers
    const operations = Array.from(this._operations.values());
    // Clear pending operation map
    this._operations = new Map();

    if (operations.length > 0) {
      this.log('info', 'Invoking ' + operations.length + ' pending callbacks');
    }

    // Invoke all handlers
    utils$p.each(operations, function (operation, next) {
      operation.setResult(err);
      next();
    });

    const pendingWritesCopy = this._pendingWrites;
    this._pendingWrites = [];
    utils$p.each(pendingWritesCopy, function (operation, next) {
      operation.setResult(err);
      next();
    });
  }

  /**
   * Starts the SASL flow
   * @param {String} authenticatorName
   * @param {Function} callback
   */
  startAuthenticating(authenticatorName, callback) {
    if (!this.options.authProvider) {
      return callback(new errors$d.AuthenticationError('Authentication provider not set'));
    }
    const authenticator = this.options.authProvider.newAuthenticator(this.endpoint, authenticatorName);
    const self = this;
    authenticator.initialResponse(function initialResponseCallback(err, token) {
      // Start the flow with the initial token
      if (err) {
        return self.onAuthenticationError(callback, err);
      }
      self.authenticate(authenticator, token, callback);
    });
  }

  /**
   * Handles authentication requests and responses.
   * @param {Authenticator} authenticator
   * @param {Buffer} token
   * @param {Function} callback
   */
  authenticate(authenticator, token, callback) {
    const self = this;
    let request = new requests$5.AuthResponseRequest(token);
    if (this.protocolVersion === 1) {
      //No Sasl support, use CREDENTIALS
      if (!authenticator.username) {
        return self.onAuthenticationError(
          callback, new errors$d.AuthenticationError('Only plain text authenticator providers allowed under protocol v1'));
      }

      request = new requests$5.CredentialsRequest(authenticator.username, authenticator.password);
    }

    this.sendStream(request, null, function authResponseCallback(err, result) {
      if (err) {
        if (err instanceof errors$d.ResponseError && err.code === types$h.responseErrorCodes.badCredentials) {
          const authError = new errors$d.AuthenticationError(err.message);
          authError.additionalInfo = err;
          err = authError;
        }
        return self.onAuthenticationError(callback, err);
      }

      if (result.ready) {
        authenticator.onAuthenticationSuccess();
        return callback();
      }

      if (result.authChallenge) {
        return authenticator.evaluateChallenge(result.token, function evaluateCallback(err, t) {
          if (err) {
            return self.onAuthenticationError(callback, err);
          }
          //here we go again
          self.authenticate(authenticator, t, callback);
        });
      }

      callback(new errors$d.DriverInternalError('Unexpected response from Cassandra: ' + util$g.inspect(result)));
    });
  }

  onAuthenticationError(callback, err) {
    this._metrics.onAuthenticationError(err);
    callback(err);
  }

  /**
   * Executes a 'USE ' query, if keyspace is provided and it is different from the current keyspace
   * @param {?String} keyspace
   */
  async changeKeyspace(keyspace) {
    if (!keyspace || this.keyspace === keyspace) {
      return;
    }

    if (this.toBeKeyspace === keyspace) {
      // It will be invoked once the keyspace is changed
      return promiseUtils$b.fromEvent(this, 'keyspaceChanged');
    }

    this.toBeKeyspace = keyspace;

    const query = `USE "${keyspace}"`;

    try {
      await this.send(new requests$5.QueryRequest(query, null, null), null);
      this.keyspace = keyspace;
      this.emit('keyspaceChanged', null, keyspace);
    } catch (err) {
      this.log('error', `Connection to ${this.endpointFriendlyName} could not switch active keyspace: ${err}`, err);
      this.emit('keyspaceChanged', err);
      throw err;
    } finally {
      this.toBeKeyspace = null;
    }
  }

  /**
   * Prepares a query on a given connection. If its already being prepared, it queues the callback.
   * @param {String} query
   * @param {String} keyspace
   * @param {function} callback
   */
  prepareOnce(query, keyspace, callback) {
    const name = ( keyspace || '' ) + query;
    let info = this._preparing.get(name);

    if (info) {
      // Its being already prepared
      return info.once('prepared', callback);
    }

    info = new events$7.EventEmitter();
    info.setMaxListeners(0);
    info.once('prepared', callback);
    this._preparing.set(name, info);

    this.sendStream(new requests$5.PrepareRequest(query, keyspace), null, (err, response) => {
      info.emit('prepared', err, response);
      this._preparing.delete(name);
    });
  }

  /**
   * Queues the operation to be written to the wire and invokes the callback once the response was obtained or with an
   * error (socket error or OperationTimedOutError or serialization-related error).
   * @param {Request} request
   * @param {ExecutionOptions|null} execOptions
   * @param {function} callback Function to be called once the response has been received
   * @return {OperationState}
   */
  sendStream(request, execOptions, callback) {
    execOptions = execOptions || ExecutionOptions$2.empty();

    // Create a new operation that will contain the request, callback and timeouts
    const operation = new OperationState(request, execOptions.getRowCallback(), (err, response, length) => {
      if (!err || !err.isSocketError) {
        // Emit that a response was obtained when there is a valid response
        // or when the error is not a socket error
        this.emit('responseDequeued');
      }
      callback(err, response, length);
    });

    const streamId = this._getStreamId();

    // Start the request timeout without waiting for the request to be written
    operation.setRequestTimeout(execOptions, this.options.socketOptions.readTimeout, this.endpoint,
      () => this.timedOutOperations++,
      () => this.timedOutOperations--);

    if (streamId === null) {
      this.log('info',
        'Enqueuing ' +
        this._pendingWrites.length +
        ', if this message is recurrent consider configuring more connections per host or lowering the pressure');
      this._pendingWrites.push(operation);
      return operation;
    }
    this._write(operation, streamId);
    return operation;
  }

  /**
   * Pushes the item into the queue.
   * @param {OperationState} operation
   * @param {Number} streamId
   * @private
   */
  _write(operation, streamId) {
    operation.streamId = streamId;
    const self = this;
    this.writeQueue.push(operation, function writeCallback (err) {
      if (err) {
        // The request was not written.
        // There was a serialization error or the operation has already timed out or was cancelled
        self._streamIds.push(streamId);
        return operation.setResult(err);
      }
      self.log('verbose', 'Sent stream #' + streamId + ' to ' + self.endpointFriendlyName);
      if (operation.isByRow()) {
        self.parser.setOptions(streamId, { byRow: true });
      }
      self._setIdleTimeout();
      self._operations.set(streamId, operation);
    });
  }

  _setIdleTimeout() {
    if (!this.options.pooling.heartBeatInterval) {
      return;
    }
    const self = this;
    // Scheduling the new timeout before de-scheduling the previous performs significantly better
    // than de-scheduling first, see nodejs implementation: https://github.com/nodejs/node/blob/master/lib/timers.js
    const previousTimeout = this._idleTimeout;
    self._idleTimeout = setTimeout(() => self._idleTimeoutHandler(), self.options.pooling.heartBeatInterval);
    if (previousTimeout) {
      //remove the previous timeout for the idle request
      clearTimeout(previousTimeout);
    }
  }

  /**
   * Function that gets executed once the idle timeout has passed to issue a request to keep the connection alive
   */
  _idleTimeoutHandler() {
    if (this.sendingIdleQuery) {
      //don't issue another
      //schedule for next time
      this._idleTimeout = setTimeout(() => this._idleTimeoutHandler(), this.options.pooling.heartBeatInterval);
      return;
    }

    this.log('verbose', `Connection to ${this.endpointFriendlyName} idling, issuing a request to prevent disconnects`);
    this.sendingIdleQuery = true;
    this.sendStream(requests$5.options, null, (err) => {
      this.sendingIdleQuery = false;
      if (!err) {
        //The sending succeeded
        //There is a valid response but we don't care about the response
        return;
      }
      this.log('warning', 'Received heartbeat request error', err);
      this.emit('idleRequestError', err, this);
    });
  }

  /**
   * Returns an available streamId or null if there isn't any available
   * @returns {Number}
   */
  _getStreamId() {
    return this._streamIds.pop();
  }

  freeStreamId(header) {
    const streamId = header.streamId;

    if (streamId < 0) {
      // Event ids don't have a matching request operation
      return;
    }

    this._operations.delete(streamId);
    this._streamIds.push(streamId);

    if (this.emitDrain && this._streamIds.inUse === 0 && this._pendingWrites.length === 0) {
      this.emit('drain');
    }

    this._writeNext();
  }

  _writeNext() {
    if (this._pendingWrites.length === 0) {
      return;
    }
    const streamId = this._getStreamId();
    if (streamId === null) {
      // No streamId available
      return;
    }
    const self = this;
    let operation;
    while ((operation = this._pendingWrites.shift()) && !operation.canBeWritten()) {
      // Trying to obtain an pending operation that can be written
    }

    if (!operation) {
      // There isn't a pending operation that can be written
      this._streamIds.push(streamId);
      return;
    }

    // Schedule after current I/O callbacks have been executed
    setImmediate(function writeNextPending() {
      self._write(operation, streamId);
    });
  }

  /**
   * Returns the number of requests waiting for response
   * @returns {Number}
   */
  getInFlight() {
    return this._streamIds.inUse;
  }

  /**
   * Handles a result and error response
   */
  handleResult(header, err, result) {
    const streamId = header.streamId;
    if(streamId < 0) {
      return this.log('verbose', 'event received', header);
    }
    const operation = this._operations.get(streamId);
    if (!operation) {
      return this.log('error', 'The server replied with a wrong streamId #' + streamId);
    }
    this.log('verbose', 'Received frame #' + streamId + ' from ' + this.endpointFriendlyName);
    operation.setResult(err, result, header.bodyLength);
  }

  handleNodeEvent(header, event) {
    switch (event.eventType) {
      case types$h.protocolEvents.schemaChange:
        this.emit('nodeSchemaChange', event);
        break;
      case types$h.protocolEvents.topologyChange:
        this.emit('nodeTopologyChange', event);
        break;
      case types$h.protocolEvents.statusChange:
        this.emit('nodeStatusChange', event);
        break;
    }
  }

  /**
   * Handles a row response
   */
  handleRow(header, row, meta, rowLength, flags) {
    const streamId = header.streamId;
    if(streamId < 0) {
      return this.log('verbose', 'Event received', header);
    }
    const operation = this._operations.get(streamId);
    if (!operation) {
      return this.log('error', 'The server replied with a wrong streamId #' + streamId);
    }
    operation.setResultRow(row, meta, rowLength, flags, header);
  }

  /**
   * Closes the socket (if not already closed) and cancels all in-flight requests.
   * Multiple calls to this method have no additional side-effects.
   * @param {Function} [callback]
   */
  close(callback) {
    callback = callback || utils$p.noop;

    if (!this.connected && !this.isSocketOpen) {
      return callback();
    }

    this.connected = false;
    // Drain is never going to be emitted, once it is set to closed
    this.removeAllListeners('drain');
    this.clearAndInvokePending();

    if (!this.isSocketOpen) {
      return callback();
    }

    // Set the socket as closed now (before socket.end() is called) to avoid being invoked more than once
    this.isSocketOpen = false;
    this.log('verbose', `Closing connection to ${this.endpointFriendlyName}`);
    const self = this;

    // If server doesn't acknowledge the half-close within connection timeout, destroy the socket.
    const endTimeout = setTimeout(() => {
      this.log('info', `${this.endpointFriendlyName} did not respond to connection close within ` +
        `${this.options.socketOptions.connectTimeout}ms, destroying connection`);
      this.netClient.destroy();
    }, this.options.socketOptions.connectTimeout);

    this.netClient.once('close', function (hadError) {
      clearTimeout(endTimeout);
      if (hadError) {
        self.log('info', 'The socket closed with a transmission error');
      }
      setImmediate(callback);
    });

    // At this point, the error event can be triggered because:
    // - It's connected and writes haven't completed yet
    // - The server abruptly closed its end of the connection (ECONNRESET) as a result of protocol error / auth error
    // We need to remove any listeners and make sure we callback are pending writes
    this.netClient.removeAllListeners('error');
    this.netClient.on('error', err => this.clearAndInvokePending(err));

    // Half-close the socket, it will result in 'close' event being fired
    this.netClient.end();
  }

  /**
   * Gets the local IP address to which this connection socket is bound to.
   * @returns {String|undefined}
   */
  getLocalAddress() {
    if (!this.netClient) {
      return undefined;
    }

    return this.netClient.localAddress;
  }
};

var connection = Connection$2;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const util$f = require$$0$4;
const events$6 = require$$0;

const Connection$1 = connection;
const utils$o = utils$K;
const promiseUtils$a = promiseUtils$e;
const errors$c = errors$n;
const clientOptions$2 = requireClientOptions();

// Used to get the index of the connection with less in-flight requests
let connectionIndex = 0;
const connectionIndexOverflow = Math.pow(2, 15);

let defaultOptions$1;

/**
 * Represents the possible states of the pool.
 * Possible state transitions:
 *  - From initial to closing: The pool must be closed because the host is ignored.
 *  - From initial to shuttingDown: The pool is being shutdown as a result of a client shutdown.
 *  - From closing to initial state: The pool finished closing connections (is now ignored) and it resets to
 *    initial state in case the host is marked as local/remote in the future.
 *  - From closing to shuttingDown (rare): It was marked as ignored, now the client is being shutdown.
 *  - From shuttingDown to shutdown: Finished shutting down, the pool should not be reused.
 * @private
 */
const state = {
  // Initial state: open / opening / ready to be opened
  initial: 0,
  // When the pool is being closed as part of a distance change
  closing: 1,
  // When the pool is being shutdown for good
  shuttingDown: 2,
  // When the pool has being shutdown
  shutDown: 4
};

/**
 * Represents a pool of connections to a host
 */
let HostConnectionPool$1 = class HostConnectionPool extends events$6.EventEmitter {
  /**
   * Creates a new instance of HostConnectionPool.
   * @param {Host} host
   * @param {Number} protocolVersion Initial protocol version
   * @extends EventEmitter
   */
  constructor(host, protocolVersion) {
    super();
    this._address = host.address;
    this._newConnectionTimeout = null;
    this._state = state.initial;
    this._opening = false;
    this._host = host;
    this.responseCounter = 0;
    this.options = host.options;
    this.protocolVersion = protocolVersion;
    this.coreConnectionsLength = 1;
    /**
     * An immutable array of connections
     * @type {Array.<Connection>}
     */
    this.connections = utils$o.emptyArray;
    this.setMaxListeners(0);
    this.log = utils$o.log;
  }

  getInFlight() {
    const length = this.connections.length;
    if (length === 1) {
      return this.connections[0].getInFlight();
    }

    let sum = 0;
    for (let i = 0; i < length; i++) {
      sum += this.connections[i].getInFlight();
    }
    return sum;
  }

  /**
   * Gets the least busy connection from the pool.
   * @param {Connection} [previousConnection] When provided, the pool should attempt to obtain a different connection.
   * @returns {Connection!}
   * @throws {Error}
   * @throws {BusyConnectionError}
   */
  borrowConnection(previousConnection) {
    if (this.connections.length === 0) {
      throw new Error('No connection available');
    }

    const maxRequests = this.options.pooling.maxRequestsPerConnection;
    const c = HostConnectionPool.minInFlight(this.connections, maxRequests, previousConnection);

    if (c.getInFlight() >= maxRequests) {
      throw new errors$c.BusyConnectionError(this._address, maxRequests, this.connections.length);
    }

    return c;
  }

  /**
   * Gets the connection with the minimum number of in-flight requests.
   * Only checks for 2 connections (round-robin) and gets the one with minimum in-flight requests, as long as
   * the amount of in-flight requests is lower than maxRequests.
   * @param {Array.<Connection>} connections
   * @param {Number} maxRequests
   * @param {Connection} previousConnection When provided, it will attempt to obtain a different connection.
   * @returns {Connection!}
   */
  static minInFlight(connections, maxRequests, previousConnection) {
    const length = connections.length;
    if (length === 1) {
      return connections[0];
    }

    // Use a single index for all hosts as a simplified way to balance the load between connections
    connectionIndex++;
    if (connectionIndex >= connectionIndexOverflow) {
      connectionIndex = 0;
    }

    let current;
    for (let index = connectionIndex; index < connectionIndex + length; index++) {
      current = connections[index % length];
      if (current === previousConnection) {
        // Increment the index and skip
        current = connections[(++index) % length];
      }

      let next = connections[(index + 1) % length];
      if (next === previousConnection) {
        // Skip
        next = connections[(index + 2) % length];
      }

      if (next.getInFlight() < current.getInFlight()) {
        current = next;
      }

      if (current.getInFlight() < maxRequests) {
        // Check as few connections as possible, as long as the amount of in-flight
        // requests is lower than maxRequests
        break;
      }
    }
    return current;
  }

  /**
   * Creates all the connections in the pool and switches the keyspace of each connection if needed.
   * @param {string} keyspace
   */
  async warmup(keyspace) {
    if (this.connections.length < this.coreConnectionsLength) {
      while (this.connections.length < this.coreConnectionsLength) {
        await this._attemptNewConnection();
      }

      this.log('info',
        `Connection pool to host ${this._address} created with ${this.connections.length} connection(s)`);
    } else {
      this.log('info', `Connection pool to host ${this._address} contains ${this.connections.length} connection(s)`);
    }

    if (keyspace) {
      try {
        for (const connection of this.connections) {
          await connection.changeKeyspace(keyspace);
        }
      } catch (err) {
        // Log it and move on, it could be a momentary schema mismatch failure
        this.log('warning', `Connection(s) to host ${this._address} could not be switched to keyspace ${keyspace}`);
      }
    }
  }

  /** @returns {Connection} */
  _createConnection() {
    const endpointOrServerName = !this.options.sni
      ? this._address : this._host.hostId.toString();

    const c = new Connection$1(endpointOrServerName, this.protocolVersion, this.options);
    this._addListeners(c);
    return c;
  }

  /** @param {Connection} c */
  _addListeners(c) {
    c.on('responseDequeued', () => this.responseCounter++);

    const self = this;
    function connectionErrorCallback() {
      // The socket is not fully open / can not send heartbeat
      self.remove(c);
    }
    c.on('idleRequestError', connectionErrorCallback);
    c.on('socketClose', connectionErrorCallback);
  }

  addExistingConnection(c) {
    this._addListeners(c);
    // Use a copy of the connections array
    this.connections = this.connections.slice(0);
    this.connections.push(c);
  }

  /**
   * Prevents reconnection timeout from triggering
   */
  clearNewConnectionAttempt() {
    if (!this._newConnectionTimeout) {
      return;
    }
    clearTimeout(this._newConnectionTimeout);
    this._newConnectionTimeout = null;
  }

  /**
   * Tries to open a new connection.
   * If a connection is being opened, it will resolve when the existing open task completes.
   * @returns {Promise<void>}
   */
  async _attemptNewConnection() {
    if (this._opening) {
      // Wait for the event to fire
      return await promiseUtils$a.fromEvent(this, 'open');
    }

    this._opening = true;

    const c = this._createConnection();
    let err;

    try {
      await c.openAsync();
    } catch (e) {
      err = e;
      this.log('warning', `Connection to ${this._address} could not be created: ${err}`, err);
    }

    if (this.isClosing()) {
      this.log('info', `Connection to ${this._address} opened successfully but pool was being closed`);
      err = new Error('Connection closed');
    }

    if (!err) {
      // Append the connection to the pool.
      // Use a copy of the connections array.
      const newConnections = this.connections.slice(0);
      newConnections.push(c);
      this.connections = newConnections;
      this.log('info', `Connection to ${this._address} opened successfully`);
    } else {
      promiseUtils$a.toBackground(c.closeAsync());
    }

    // Notify that creation finished by setting the flag and emitting the event
    this._opening = false;
    this.emit('open', err, c);

    if (err) {
      // Opening failed
      throw err;
    }
  }

  attemptNewConnectionImmediate() {
    const self = this;
    function openConnection() {
      self.clearNewConnectionAttempt();
      self.scheduleNewConnectionAttempt(0);
    }

    if (this._state === state.initial) {
      return openConnection();
    }

    if (this._state === state.closing) {
      return this.once('close', openConnection);
    }
    // In the case the pool its being / has been shutdown for good
    // Do not attempt to create a new connection.
  }

  /**
   * Closes the connection and removes a connection from the pool.
   * @param {Connection} connection
   */
  remove(connection) {
    // locating an object by position in the array is O(n), but normally there should be between 1 to 8 connections.
    const index = this.connections.indexOf(connection);
    if (index < 0) {
      // it was already removed from the connections and it's closing
      return;
    }
    // remove the connection from the pool, using an pool copy
    const newConnections = this.connections.slice(0);
    newConnections.splice(index, 1);
    this.connections = newConnections;
    // close the connection
    setImmediate(function removeClose() {
      connection.close();
    });
    this.emit('remove');
  }

  /**
   * @param {Number} delay
   */
  scheduleNewConnectionAttempt(delay) {
    if (this.isClosing()) {
      return;
    }

    const self = this;

    this._newConnectionTimeout = setTimeout(function newConnectionTimeoutExpired() {
      self._newConnectionTimeout = null;
      if (self.connections.length >= self.coreConnectionsLength) {
        // new connection can be scheduled while a new connection is being opened
        // the pool has the appropriate size
        return;
      }

      if (delay > 0 && self.options.sni) {
        // We use delay > 0 as an indication that it's a reconnection.
        // A reconnection schedule can use delay = 0 as well, but it's a good enough signal.
        promiseUtils$a.toBackground(self.options.sni.addressResolver.refresh().then(() => self._attemptNewConnection()));
        return;
      }

      promiseUtils$a.toBackground(self._attemptNewConnection());
    }, delay);
  }

  hasScheduledNewConnection() {
    return !!this._newConnectionTimeout || this._opening;
  }

  /**
   * Increases the size of the connection pool in the background, if needed.
   */
  increaseSize() {
    if (this.connections.length < this.coreConnectionsLength && !this.hasScheduledNewConnection()) {
      // schedule the next connection in the background
      this.scheduleNewConnectionAttempt(0);
    }
  }

  /**
   * Gets the amount of responses and resets the internal counter.
   * @returns {number}
   */
  getAndResetResponseCounter() {
    const temp = this.responseCounter;
    this.responseCounter = 0;
    return temp;
  }

  /**
   * Gets a boolean indicating if the pool is being closed / shutting down or has been shutdown.
   */
  isClosing() {
    return this._state !== state.initial;
  }

  /**
   * Gracefully waits for all in-flight requests to finish and closes the pool.
   */
  drainAndShutdown() {
    if (this.isClosing()) {
      // Its already closing / shutting down
      return;
    }

    this._state = state.closing;
    this.clearNewConnectionAttempt();

    if (this.connections.length === 0) {
      return this._afterClosing();
    }

    const self = this;
    const connections = this.connections;
    this.connections = utils$o.emptyArray;
    let closedConnections = 0;
    this.log('info', util$f.format('Draining and closing %d connections to %s', connections.length, this._address));
    let wasClosed = false;
    // eslint-disable-next-line prefer-const
    let checkShutdownTimeout;

    for (let i = 0; i < connections.length; i++) {
      const c = connections[i];
      if (c.getInFlight() === 0) {
        getDelayedClose(c)();
        continue;
      }
      c.emitDrain = true;
      c.once('drain', getDelayedClose(c));
    }

    function getDelayedClose(connection) {
      return (function delayedClose() {
        connection.close();
        if (++closedConnections < connections.length) {
          return;
        }
        if (wasClosed) {
          return;
        }
        wasClosed = true;
        if (checkShutdownTimeout) {
          clearTimeout(checkShutdownTimeout);
        }
        self._afterClosing();
      });
    }

    // Check that after sometime (readTimeout + 100ms) the connections have been drained
    const delay = (this.options.socketOptions.readTimeout || getDefaultOptions().socketOptions.readTimeout) + 100;
    checkShutdownTimeout = setTimeout(function checkShutdown() {
      wasClosed = true;
      connections.forEach(function connectionEach(c) {
        c.close();
      });
      self._afterClosing();
    }, delay);
  }

  _afterClosing() {
    const self = this;

    function resetState() {
      if (self._state === state.shuttingDown) {
        self._state = state.shutDown;
      } else {
        self._state = state.initial;
      }

      self.emit('close');

      if (self._state === state.shutDown) {
        self.emit('shutdown');
      }
    }

    if (this._opening) {
      // The pool is growing, reset the state back to init once the open finished (without any new connection)
      return this.once('open', resetState);
    }

    resetState();
  }

  /**
   * @returns {Promise<void>}
   */
  async shutdown() {
    this.clearNewConnectionAttempt();

    if (!this.connections.length) {
      this._state = state.shutDown;
      return;
    }

    const previousState = this._state;
    this._state = state.shuttingDown;

    if (previousState === state.closing || previousState === state.shuttingDown) {
      // When previous state was closing, it will drain all connections and close them
      // When previous state was "shuttingDown", it will close all the connections
      // Once it's completed, shutdown event will be emitted
      return promiseUtils$a.fromEvent(this, 'shutdown');
    }

    await this._closeAllConnections();

    this._state = state.shutDown;
    this.emit('shutdown');
  }

  async _closeAllConnections() {
    const connections = this.connections;
    // point to an empty array
    this.connections = utils$o.emptyArray;
    if (connections.length === 0) {
      return;
    }

    this.log('info', util$f.format('Closing %d connections to %s', connections.length, this._address));

    await Promise.all(connections.map(c => c.closeAsync()));
  }
};

/** Lazily loads the default options */
function getDefaultOptions() {
  if (defaultOptions$1 === undefined) {
    defaultOptions$1 = clientOptions$2.defaultOptions();
  }
  return defaultOptions$1;
}

var hostConnectionPool = HostConnectionPool$1;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const errors$b = errors$n;
const utils$n = utils$K;
const types$g = requireTypes();
const promiseUtils$9 = promiseUtils$e;

/**
 * Encapsulates the logic for dealing with the different prepare request and response flows, including failover when
 * trying to prepare a query.
 */
let PrepareHandler$2 = class PrepareHandler {
  /**
   * Creates a new instance of PrepareHandler
   * @param {Client} client
   * @param {LoadBalancingPolicy} loadBalancing
   */
  constructor(client, loadBalancing) {
    this._client = client;
    this._loadBalancing = loadBalancing;
    this.logEmitter = client.options.logEmitter;
    this.log = utils$n.log;
  }

  /**
   * Gets the query id and metadata for a prepared statement, preparing it on
   * single host or on all hosts depending on the options.
   * @param {Client} client
   * @param {LoadBalancingPolicy} loadBalancing
   * @param {String} query
   * @param {String} keyspace
   * @returns {Promise<{queryId, meta}>}
   * @static
   */
  static async getPrepared(client, loadBalancing, query, keyspace) {
    const info = client.metadata.getPreparedInfo(keyspace, query);
    if (info.queryId) {
      return info;
    }

    if (info.preparing) {
      // It's already being prepared
      return await promiseUtils$9.fromEvent(info, 'prepared');
    }

    const instance = new PrepareHandler(client, loadBalancing);
    return await instance._prepare(info, query, keyspace);
  }

  /**
   * @param {Client} client
   * @param {LoadBalancingPolicy} loadBalancing
   * @param {Array} queries
   * @param {String} keyspace
   * @static
   */
  static async getPreparedMultiple(client, loadBalancing, queries, keyspace) {
    const result = [];

    for (const item of queries) {
      let query;

      if (item) {
        query = typeof item === 'string' ? item : item.query;
      }

      if (typeof query !== 'string') {
        throw new errors$b.ArgumentError('Query item should be a string');
      }

      const { queryId, meta } = await PrepareHandler.getPrepared(client, loadBalancing, query, keyspace);
      result.push({ query, params: utils$n.adaptNamedParamsPrepared(item.params, meta.columns), queryId, meta });
    }

    return result;
  }

  /**
   * Prepares the query on a single host or on all hosts depending on the options.
   * Uses the info 'prepared' event to emit the result.
   * @param {Object} info
   * @param {String} query
   * @param {String} keyspace
   * @returns {Promise<{queryId, meta}>}
   */
  async _prepare(info, query, keyspace) {
    info.preparing = true;
    let iterator;

    try {
      iterator = await promiseUtils$9.newQueryPlan(this._loadBalancing, keyspace, null);
      return await this._prepareWithQueryPlan(info, iterator, query, keyspace);
    } catch (err) {
      info.preparing = false;
      err.query = query;
      info.emit('prepared', err);

      throw err;
    }
  }

  /**
   * Uses the query plan to prepare the query on the first host and optionally on the rest of the hosts.
   * @param {Object} info
   * @param {Iterator} iterator
   * @param {String} query
   * @param {String} keyspace
   * @returns {Promise<{queryId, meta}>}
   * @private
   */
  async _prepareWithQueryPlan(info, iterator, query, keyspace) {
    const triedHosts = {};

    while (true) {
      const host = PrepareHandler.getNextHost(iterator, this._client.profileManager, triedHosts);

      if (host === null) {
        throw new errors$b.NoHostAvailableError(triedHosts);
      }

      try {
        const connection = await PrepareHandler._borrowWithKeyspace(host, keyspace);
        const response = await connection.prepareOnceAsync(query, keyspace);

        if (this._client.options.prepareOnAllHosts) {
          await this._prepareOnAllHosts(iterator, query, keyspace);
        }

        // Set the prepared metadata
        info.preparing = false;
        info.queryId = response.id;
        info.meta = response.meta;
        this._client.metadata.setPreparedById(info);
        info.emit('prepared', null, info);

        return info;

      } catch (err) {
        triedHosts[host.address] = err;

        if (!err.isSocketError && !(err instanceof errors$b.OperationTimedOutError)) {
          // There's no point in retrying syntax errors and other response errors
          throw err;
        }
      }
    }
  }

  /**
   * Gets the next host from the query plan.
   * @param {Iterator} iterator
   * @param {ProfileManager} profileManager
   * @param {Object} [triedHosts]
   * @return {Host|null}
   */
  static getNextHost(iterator, profileManager, triedHosts) {
    let host;
    // Get a host that is UP in a sync loop
    while (true) {
      const item = iterator.next();
      if (item.done) {
        return null;
      }

      host = item.value;

      // set the distance relative to the client first
      const distance = profileManager.getDistance(host);
      if (distance === types$g.distance.ignored) {
        //If its marked as ignore by the load balancing policy, move on.
        continue;
      }

      if (host.isUp()) {
        break;
      }

      if (triedHosts) {
        triedHosts[host.address] = 'Host considered as DOWN';
      }
    }

    return host;
  }

  /**
   * Prepares all queries on a single host.
   * @param {Host} host
   * @param {Array} allPrepared
   */
  static async prepareAllQueries(host, allPrepared) {
    const anyKeyspaceQueries = [];

    const queriesByKeyspace = new Map();
    allPrepared.forEach(info => {
      let arr;
      if (info.keyspace) {
        arr = queriesByKeyspace.get(info.keyspace);

        if (!arr) {
          arr = [];
          queriesByKeyspace.set(info.keyspace, arr);
        }
      } else {
        arr = anyKeyspaceQueries;
      }

      arr.push(info.query);
    });

    for (const [keyspace, queries] of queriesByKeyspace) {
      await PrepareHandler._borrowAndPrepare(host, keyspace, queries);
    }

    await PrepareHandler._borrowAndPrepare(host, null, anyKeyspaceQueries);
  }

  /**
   * Borrows a connection from the host and prepares the queries provided.
   * @param {Host} host
   * @param {String} keyspace
   * @param {Array} queries
   * @returns {Promise<void>}
   * @private
   */
  static async _borrowAndPrepare(host, keyspace, queries) {
    if (queries.length === 0) {
      return;
    }

    const connection = await PrepareHandler._borrowWithKeyspace(host, keyspace);

    for (const query of queries) {
      await connection.prepareOnceAsync(query, keyspace);
    }
  }

  /**
   * Borrows a connection and changes the active keyspace on the connection, if needed.
   * It does not perform any retry or error handling.
   * @param {Host!} host
   * @param {string} keyspace
   * @returns {Promise<Connection>}
   * @throws {errors.BusyConnectionError} When the connection is busy.
   * @throws {errors.ResponseError} For invalid keyspaces.
   * @throws {Error} For socket errors.
   * @private
   */
  static async _borrowWithKeyspace(host, keyspace) {
    const connection = host.borrowConnection();

    if (keyspace && connection.keyspace !== keyspace) {
      await connection.changeKeyspace(keyspace);
    }

    return connection;
  }

  /**
   * Prepares the provided query on all hosts, except the host provided.
   * @param {Iterator} iterator
   * @param {String} query
   * @param {String} keyspace
   * @private
   */
  _prepareOnAllHosts(iterator, query, keyspace) {
    const queries = [ query ];
    let h;
    const hosts = [];

    while ((h = PrepareHandler.getNextHost(iterator, this._client.profileManager)) !== null) {
      hosts.push(h);
    }

    return Promise.all(hosts.map(h =>
      PrepareHandler
        ._borrowAndPrepare(h, keyspace, queries)
        .catch(err => this.log('verbose', `Unexpected error while preparing query (${query}) on ${h.address}`, err))));
  }
};

var prepareHandler = PrepareHandler$2;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const events$5 = require$$0;

const utils$m = utils$K;
const types$f = requireTypes();
const HostConnectionPool = hostConnectionPool;
const PrepareHandler$1 = prepareHandler;
const promiseUtils$8 = promiseUtils$e;

const healthResponseCountInterval = 200;

/**
 * Represents a Cassandra node.
 * @extends EventEmitter
 */
let Host$1 = class Host extends events$5.EventEmitter {

  /**
   * Creates a new Host instance.
   */
  constructor(address, protocolVersion, options, metadata) {
    super();
    /**
     * Gets ip address and port number of the node separated by `:`.
     * @type {String}
     */
    this.address = address;
    this.setDownAt = 0;
    this.log = utils$m.log;

    /**
     * Gets the timestamp of the moment when the Host was marked as UP.
     * @type {Number|null}
     * @ignore
     * @internal
     */
    this.isUpSince = null;
    Object.defineProperty(this, 'options', { value: options, enumerable: false, writable: false });

    /**
     * The host pool.
     * @internal
     * @ignore
     * @type {HostConnectionPool}
     */
    Object.defineProperty(this, 'pool', { value: new HostConnectionPool(this, protocolVersion), enumerable: false });

    this.pool.on('open', err => promiseUtils$8.toBackground(this._onNewConnectionOpen(err)));
    this.pool.on('remove', () => this._checkPoolState());

    /**
     * Gets string containing the Cassandra version.
     * @type {String}
     */
    this.cassandraVersion = null;

    /**
     * Gets data center name of the node.
     * @type {String}
     */
    this.datacenter = null;

    /**
     * Gets rack name of the node.
     * @type {String}
     */
    this.rack = null;

    /**
     * Gets the tokens assigned to the node.
     * @type {Array}
     */
    this.tokens = null;

    /**
     * Gets the id of the host.
     * <p>This identifier is used by the server for internal communication / gossip.</p>
     * @type {Uuid}
     */
    this.hostId = null;

    /**
     * Gets string containing the DSE version or null if not set.
     * @type {String}
     */
    this.dseVersion = null;

    /**
     * Gets the DSE Workloads the host is running.
     * <p>
     *   This is based on the "workload" or "workloads" columns in {@code system.local} and {@code system.peers}.
     * <p/>
     * <p>
     *   Workload labels may vary depending on the DSE version in use;e.g. DSE 5.1 may report two distinct workloads:
     *   <code>Search</code> and <code>Analytics</code>, while DSE 5.0 would report a single
     *   <code>SearchAnalytics</code> workload instead. The driver simply returns the workload labels as reported by
     *   DSE, without any form of pre-processing.
     * <p/>
     * <p>When the information is unavailable, this property returns an empty array.</p>
     * @type {Array<string>}
     */
    this.workloads = utils$m.emptyArray;

    // the distance as last set using the load balancing policy
    this._distance = types$f.distance.ignored;
    this._healthResponseCounter = 0;

    // Make some of the private instance variables not enumerable to prevent from showing when inspecting
    Object.defineProperty(this, '_metadata', { value: metadata, enumerable: false });
    Object.defineProperty(this, '_healthResponseCountTimer', { value: null, enumerable: false, writable: true });

    this.reconnectionSchedule = this.options.policies.reconnection.newSchedule();
    this.reconnectionDelay = 0;
  }

  /**
   * Marks this host as not available for query coordination, when the host was previously marked as UP, otherwise its
   * a no-op.
   * @internal
   * @ignore
   */
  setDown() {
    // Multiple events signaling that a host is failing could cause multiple calls to this method
    if (this.setDownAt !== 0) {
      // the host is already marked as Down
      return;
    }
    if (this.pool.isClosing()) {
      // the pool is being closed/shutdown, don't mind
      return;
    }
    this.setDownAt = Date.now();
    if (this.pool.coreConnectionsLength > 0) {
      // According to the distance, there should be connections open to it => issue a warning
      this.log('warning', `Host ${this.address} considered as DOWN. Reconnection delay ${this.reconnectionDelay}ms.`);
    }
    else {
      this.log('info', `Host ${this.address} considered as DOWN.`);
    }
    this.emit('down');
    this._checkPoolState();
  }

  /**
   * Marks this host as available for querying.
   * @param {Boolean} [clearReconnection]
   * @internal
   * @ignore
   */
  setUp(clearReconnection) {
    if (!this.setDownAt) {
      //The host is already marked as UP
      return;
    }
    this.log('info', `Setting host ${this.address} as UP`);
    this.setDownAt = 0;
    this.isUpSince = Date.now();
    //if it was unhealthy and now it is not, lets reset the reconnection schedule.
    this.reconnectionSchedule = this.options.policies.reconnection.newSchedule();
    if (clearReconnection) {
      this.pool.clearNewConnectionAttempt();
    }
    this.emit('up');
  }

  /**
   * Resets the reconnectionSchedule and tries to issue a reconnection immediately.
   * @internal
   * @ignore
   */
  checkIsUp() {
    if (this.isUp()) {
      return;
    }
    this.reconnectionSchedule = this.options.policies.reconnection.newSchedule();
    this.reconnectionDelay = 0;
    this.pool.attemptNewConnectionImmediate();
  }

  /**
   * @param {Boolean} [waitForPending] When true, it waits for in-flight operations to be finish before closing the
   * connections.
   * @returns {Promise<void>}
   * @internal
   * @ignore
   */
  shutdown(waitForPending) {
    if (this._healthResponseCountTimer) {
      clearInterval(this._healthResponseCountTimer);
    }
    if (waitForPending) {
      this.pool.drainAndShutdown();
      // Gracefully draining and shutting down the pool is being done in the background
      return Promise.resolve();
    }
    return this.pool.shutdown();
  }

  /**
   * Determines if the node is UP now (seen as UP by the driver).
   * @returns {boolean}
   */
  isUp() {
    return !this.setDownAt;
  }

  /**
   * Determines if the host can be considered as UP.
   * Deprecated: Use {@link Host#isUp()} instead.
   * @returns {boolean}
   */
  canBeConsideredAsUp() {
    const self = this;
    function hasTimePassed() {
      return new Date().getTime() - self.setDownAt >= self.reconnectionDelay;
    }
    return !this.setDownAt || hasTimePassed();
  }

  /**
   * Sets the distance of the host relative to the client using the load balancing policy.
   * @param {Number} distance
   * @internal
   * @ignore
   */
  setDistance(distance) {
    const previousDistance = this._distance;
    this._distance = distance || types$f.distance.local;
    if (this.options.pooling.coreConnectionsPerHost) {
      this.pool.coreConnectionsLength = this.options.pooling.coreConnectionsPerHost[this._distance] || 0;
    }
    else {
      this.pool.coreConnectionsLength = 1;
    }
    if (this._distance === previousDistance) {
      return this._distance;
    }
    if (this._healthResponseCountTimer) {
      clearInterval(this._healthResponseCountTimer);
    }
    if (this._distance === types$f.distance.ignored) {
      // this host was local/remote and now must be ignored
      this.emit('ignore');
      this.pool.drainAndShutdown();
    }
    else {
      if (!this.isUp()) {
        this.checkIsUp();
      }
      // Reset the health check timer
      this._healthResponseCountTimer = setInterval(() => {
        this._healthResponseCounter = this.pool.getAndResetResponseCounter();
      }, healthResponseCountInterval);
    }
    return this._distance;
  }

  /**
   * Changes the protocol version of a given host
   * @param {Number} value
   * @internal
   * @ignore
   */
  setProtocolVersion(value) {
    this.pool.protocolVersion = value;
  }

  /**
   * Gets the least busy connection from the pool.
   * @param {Connection} [previousConnection] When provided, the pool should attempt to obtain a different connection.
   * @returns {Connection!}
   * @throws {Error}
   * @throws {BusyConnectionError}
   * @internal
   * @ignore
   */
  borrowConnection(previousConnection) {
    return this.pool.borrowConnection(previousConnection);
  }

  /**
   * Creates all the connection in the pool.
   * @param {string} keyspace
   * @internal
   * @ignore
   */
  warmupPool(keyspace) {
    return this.pool.warmup(keyspace);
  }

  /**
   * Starts creating the pool in the background.
   * @internal
   * @ignore
   */
  initializePool() {
    this.pool.increaseSize();
  }
  /**
   * Gets any connection that is already opened or null if not found.
   * @returns {Connection}
   * @internal
   * @ignore
   */
  getActiveConnection() {
    if (!this.isUp() || !this.pool.connections.length) {
      return null;
    }
    return this.pool.connections[0];
  }

  /**
   * Internal method to get the amount of responses dequeued in the last interval (between 200ms and 400ms) on all
   * connections to the host.
   * @returns {Number}
   * @internal
   * @ignore
   */
  getResponseCount() {
    // Last interval plus the current count
    return this._healthResponseCounter + this.pool.responseCounter;
  }

  /**
   * Checks the health of a connection in the pool
   * @param {Connection} connection
   * @internal
   * @ignore
   */
  checkHealth(connection) {
    if (connection.timedOutOperations <= this.options.socketOptions.defunctReadTimeoutThreshold) {
      return;
    }
    this.removeFromPool(connection);
  }

  /**
   * @param {Connection} connection
   * @internal
   * @ignore
   */
  removeFromPool(connection) {
    this.pool.remove(connection);
    this._checkPoolState();
  }

  /**
   * Internal method that gets the amount of in-flight requests on all connections to the host.
   * @internal
   * @ignore
   */
  getInFlight() {
    return this.pool.getInFlight();
  }

  /**
   * Validates that the internal state of the connection pool.
   * If the pool size is smaller than expected, schedule a new connection attempt.
   * If the amount of connections is 0 for not ignored hosts, the host must be down.
   * @private
   */
  _checkPoolState() {
    if (this.pool.isClosing()) {
      return;
    }
    if (this.pool.connections.length < this.pool.coreConnectionsLength) {
      // the pool needs to grow / reconnect
      if (!this.pool.hasScheduledNewConnection()) {
        this.reconnectionDelay = this.reconnectionSchedule.next().value;
        this.pool.scheduleNewConnectionAttempt(this.reconnectionDelay);
      }
    }
    const shouldHaveConnections = this._distance !== types$f.distance.ignored && this.pool.coreConnectionsLength > 0;
    if (shouldHaveConnections && this.pool.connections.length === 0) {
      // Mark as DOWN, if its UP
      this.setDown();
    }
  }

  /**
   * Executed after an scheduled new connection attempt finished
   * @private
   */
  async _onNewConnectionOpen(err) {
    if (err) {
      this._checkPoolState();
      return;
    }
    if (!this.isUp() && this.options.rePrepareOnUp) {
      this.log('info', `Re-preparing all queries on host ${this.address} before setting it as UP`);
      const allPrepared = this._metadata.getAllPrepared();
      try {
        await PrepareHandler$1.prepareAllQueries(this, allPrepared);
      }
      catch (err) {
        this.log('warning', `Failed re-preparing on host ${this.address}: ${err}`, err);
      }
    }
    this.setUp();
    this.pool.increaseSize();
  }

  /**
   * Returns an array containing the Cassandra Version as an Array of Numbers having the major version in the first
   * position.
   * @returns {Array.<Number>}
   */
  getCassandraVersion() {
    if (!this.cassandraVersion) {
      return utils$m.emptyArray;
    }
    return this.cassandraVersion.split('-')[0].split('.').map(x => parseInt(x, 10));
  }

  /**
   * Gets the DSE version of the host as an Array, containing the major version in the first position.
   * In case the cluster is not a DSE cluster, it returns an empty Array.
   * @returns {Array}
   */
  getDseVersion() {
    if (!this.dseVersion) {
      return utils$m.emptyArray;
    }
    return this.dseVersion.split('-')[0].split('.').map(x => parseInt(x, 10));
  }
};

/**
 * Represents an associative-array of {@link Host hosts} that can be iterated.
 * It creates an internal copy when adding or removing, making it safe to iterate using the values()
 * method within async operations.
 * @extends events.EventEmitter
 * @constructor
 */
let HostMap$1 = class HostMap extends events$5.EventEmitter{
  constructor() {
    super();

    this._items = new Map();
    this._values = null;

    Object.defineProperty(this, 'length', { get: () => this.values().length, enumerable: true });

    /**
     * Emitted when a host is added to the map
     * @event HostMap#add
     */
    /**
     * Emitted when a host is removed from the map
     * @event HostMap#remove
     */
  }

  /**
   * Executes a provided function once per map element.
   * @param callback
   */
  forEach(callback) {
    const items = this._items;
    for (const [ key, value ] of items) {
      callback(value, key);
    }
  }

  /**
   * Gets a {@link Host host} by key or undefined if not found.
   * @param {String} key
   * @returns {Host}
   */
  get(key) {
    return this._items.get(key);
  }

  /**
   * Returns an array of host addresses.
   * @returns {Array.<String>}
   */
  keys() {
    return Array.from(this._items.keys());
  }

  /**
   * Removes an item from the map.
   * @param {String} key The key of the host
   * @fires HostMap#remove
   */
  remove(key) {
    const value = this._items.get(key);
    if (value === undefined) {
      return;
    }

    // Clear cache
    this._values = null;

    // Copy the values
    const copy = new Map(this._items);
    copy.delete(key);

    this._items = copy;
    this.emit('remove', value);
  }

  /**
   * Removes multiple hosts from the map.
   * @param {Array.<String>} keys
   * @fires HostMap#remove
   */
  removeMultiple(keys) {
    // Clear value cache
    this._values = null;

    // Copy the values
    const copy = new Map(this._items);
    const removedHosts = [];

    for (const key of keys) {
      const h = copy.get(key);

      if (!h) {
        continue;
      }

      removedHosts.push(h);
      copy.delete(key);
    }

    this._items = copy;
    removedHosts.forEach(h => this.emit('remove', h));
  }

  /**
   * Adds a new item to the map.
   * @param {String} key The key of the host
   * @param {Host} value The host to be added
   * @fires HostMap#remove
   * @fires HostMap#add
   */
  set(key, value) {
    // Clear values cache
    this._values = null;

    const originalValue = this._items.get(key);
    if (originalValue) {
      //The internal structure does not change
      this._items.set(key, value);
      //emit a remove followed by a add
      this.emit('remove', originalValue);
      this.emit('add', value);
      return;
    }

    // Copy the values
    const copy = new Map(this._items);
    copy.set(key, value);
    this._items = copy;
    this.emit('add', value);
    return value;
  }

  /**
   * Returns a shallow copy of a portion of the items into a new array object.
   * Backward-compatibility.
   * @param {Number} [begin]
   * @param {Number} [end]
   * @returns {Array}
   * @ignore
   */
  slice(begin, end) {
    if (!begin && !end) {
      // Avoid making a copy of the copy
      return this.values();
    }

    return this.values().slice(begin || 0, end);
  }

  /**
   * Deprecated: Use set() instead.
   * @ignore
   * @deprecated
   */
  push(k, v) {
    this.set(k, v);
  }

  /**
   * Returns a shallow copy of the values of the map.
   * @returns {Array.<Host>}
   */
  values() {
    if (!this._values) {
      // Cache the values
      this._values = Object.freeze(Array.from(this._items.values()));
    }

    return this._values;
  }

  /**
   * Removes all items from the map.
   * @returns {Array.<Host>} The previous items
   */
  clear() {
    const previousItems = this.values();

    // Clear cache
    this._values = null;

    // Clear items
    this._items = new Map();

    // Emit events
    previousItems.forEach(h => this.emit('remove', h));

    return previousItems;
  }

  inspect() {
    return this._items;
  }

  toJSON() {
    // Node.js 10 and below don't support Object.fromEntries()
    if (Object.fromEntries) {
      return Object.fromEntries(this._items);
    }

    const obj = {};
    for (const [ key, value ] of this._items) {
      obj[key] = value;
    }

    return obj;
  }
};

var host = {
  Host: Host$1,
  HostMap: HostMap$1
};

var tokenizer = {};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const types$e = requireTypes();
const token$1 = token$3;
const utils$l = utils$K;
const MutableLong = mutableLong;
const { Integer } = types$e;

// Murmur3 constants
//-0x783C846EEEBDAC2B
const mconst1 = new MutableLong(0x53d5, 0x1142, 0x7b91, 0x87c3);
//0x4cf5ad432745937f
const mconst2 = new MutableLong(0x937f, 0x2745, 0xad43, 0x4cf5);
const mlongFive = MutableLong.fromNumber(5);
//0xff51afd7ed558ccd
const mconst3 = new MutableLong(0x8ccd, 0xed55, 0xafd7, 0xff51);
//0xc4ceb9fe1a85ec53
const mconst4 = new MutableLong(0xec53, 0x1a85, 0xb9fe, 0xc4ce);
const mconst5 = MutableLong.fromNumber(0x52dce729);
const mconst6 = MutableLong.fromNumber(0x38495ab5);

/**
 * Represents a set of methods that are able to generate and parse tokens for the C* partitioner.
 * @abstract
 */
class Tokenizer {
  constructor() {

  }

  /**
   * Creates a token based on the Buffer value provided
   * @abstract
   * @param {Buffer|Array} value
   * @returns {Token} Computed token
   */
  hash(value) {
    throw new Error('You must implement a hash function for the tokenizer');
  }

  /**
   * Parses a token string and returns a representation of the token
   * @abstract
   * @param {String} value
   */
  parse(value) {
    throw new Error('You must implement a parse function for the tokenizer');
  }

  minToken() {
    throw new Error('You must implement a minToken function for the tokenizer');
  }

  /**
   * Splits the range specified by start and end into numberOfSplits equal parts.
   * @param {Token} start Starting token
   * @param {Token} end  End token
   * @param {Number} numberOfSplits Number of splits to make.
   */
  split(start, end, numberOfSplits) {
    throw new Error('You must implement a split function for the tokenizer');
  }

  /**
   * Common implementation for splitting token ranges when start is in
   * a shared Integer format.
   *
   * @param {Integer} start Starting token
   * @param {Integer} range How large the range of the split is
   * @param {Integer} ringEnd The end point of the ring so we know where to wrap
   * @param {Integer} ringLength The total size of the ring
   * @param {Number} numberOfSplits The number of splits to make
   * @returns {Array<Integer>} The evenly-split points on the range
   */
  splitBase(start, range, ringEnd, ringLength, numberOfSplits) {
    const numberOfSplitsInt = Integer.fromInt(numberOfSplits);
    const divider = range.divide(numberOfSplitsInt);
    let remainder = range.modulo(numberOfSplitsInt);

    const results = [];
    let current = start;
    const dividerPlusOne = divider.add(Integer.ONE);

    for(let i = 1; i < numberOfSplits; i++) {
      if (remainder.greaterThan(Integer.ZERO)) {
        current = current.add(dividerPlusOne);
      } else {
        current = current.add(divider);
      }
      if (ringLength && current.greaterThan(ringEnd)) {
        current = current.subtract(ringLength);
      }
      results.push(current);
      remainder = remainder.subtract(Integer.ONE);
    }
    return results;
  }

  /**
   * Return internal string based representation of a Token.
   * @param {Token} token 
   */
  stringify(token) {
    return token.getValue().toString();
  }
}

/**
 * Uniformly distributes data across the cluster based on Cassandra flavored Murmur3 hashed values.
 */
class Murmur3Tokenizer extends Tokenizer {

  constructor() {
    super();
  }

  /**
   * @param {Buffer} value
   * @return {Murmur3Token}
   */
  hash(value) {
    // This is an adapted version of the MurmurHash.hash3_x64_128 from Cassandra used
    // for M3P. Compared to that methods, there's a few inlining of arguments and we
    // only return the first 64-bits of the result since that's all M3 partitioner uses.

    const data = value;
    let offset = 0;
    const length = data.length;

    const nblocks = length >> 4; // Process as 128-bit blocks.

    const h1 = new MutableLong();
    const h2 = new MutableLong();
    let k1 = new MutableLong();
    let k2 = new MutableLong();

    for (let i = 0; i < nblocks; i++) {
      k1 = this.getBlock(data, offset, i * 2);
      k2 = this.getBlock(data, offset, i * 2 + 1);

      k1.multiply(mconst1);
      this.rotl64(k1, 31);
      k1.multiply(mconst2);

      h1.xor(k1);
      this.rotl64(h1, 27);
      h1.add(h2);
      h1.multiply(mlongFive).add(mconst5);

      k2.multiply(mconst2);
      this.rotl64(k2, 33);
      k2.multiply(mconst1);
      h2.xor(k2);
      this.rotl64(h2, 31);
      h2.add(h1);
      h2.multiply(mlongFive).add(mconst6);
    }
    //----------
    // tail

    // Advance offset to the unprocessed tail of the data.
    offset += nblocks * 16;

    k1 = new MutableLong();
    k2 = new MutableLong();

    /* eslint-disable no-fallthrough */
    switch(length & 15) {
      case 15:
        k2.xor(fromSignedByte(data[offset+14]).shiftLeft(48));
      case 14:
        k2.xor(fromSignedByte(data[offset+13]).shiftLeft(40));
      case 13:
        k2.xor(fromSignedByte(data[offset+12]).shiftLeft(32));
      case 12:
        k2.xor(fromSignedByte(data[offset+11]).shiftLeft(24));
      case 11:
        k2.xor(fromSignedByte(data[offset+10]).shiftLeft(16));
      case 10:
        k2.xor(fromSignedByte(data[offset+9]).shiftLeft(8));
      case 9:
        k2.xor(fromSignedByte(data[offset+8]));
        k2.multiply(mconst2);
        this.rotl64(k2, 33);
        k2.multiply(mconst1);
        h2.xor(k2);
      case 8:
        k1.xor(fromSignedByte(data[offset+7]).shiftLeft(56));
      case 7:
        k1.xor(fromSignedByte(data[offset+6]).shiftLeft(48));
      case 6:
        k1.xor(fromSignedByte(data[offset+5]).shiftLeft(40));
      case 5:
        k1.xor(fromSignedByte(data[offset+4]).shiftLeft(32));
      case 4:
        k1.xor(fromSignedByte(data[offset+3]).shiftLeft(24));
      case 3:
        k1.xor(fromSignedByte(data[offset+2]).shiftLeft(16));
      case 2:
        k1.xor(fromSignedByte(data[offset+1]).shiftLeft(8));
      case 1:
        k1.xor(fromSignedByte(data[offset]));
        k1.multiply(mconst1);
        this.rotl64(k1,31);
        k1.multiply(mconst2);
        h1.xor(k1);
    }
    /* eslint-enable no-fallthrough */

    h1.xor(MutableLong.fromNumber(length));
    h2.xor(MutableLong.fromNumber(length));

    h1.add(h2);
    h2.add(h1);


    this.fmix(h1);
    this.fmix(h2);

    h1.add(h2);

    return new token$1.Murmur3Token(h1);
  }

  /**
   *
   * @param {Array<Number>} key
   * @param {Number} offset
   * @param {Number} index
   * @return {MutableLong}
   */
  getBlock(key, offset, index) {
    const i8 = index << 3;
    const blockOffset = offset + i8;
    return new MutableLong(
      (key[blockOffset]) | (key[blockOffset + 1] << 8),
      (key[blockOffset + 2]) | (key[blockOffset + 3] << 8),
      (key[blockOffset + 4]) | (key[blockOffset + 5] << 8),
      (key[blockOffset + 6]) | (key[blockOffset + 7] << 8)
    );
  }

  /**
   * @param {MutableLong} v
   * @param {Number} n
   */
  rotl64(v, n) {
    const left = v.clone().shiftLeft(n);
    v.shiftRightUnsigned(64 - n).or(left);
  }

  /** @param {MutableLong} k */
  fmix(k) {
    k.xor(new MutableLong(k.getUint16(2) >>> 1 | ((k.getUint16(3) << 15) & 0xffff), k.getUint16(3) >>> 1, 0, 0));
    k.multiply(mconst3);
    const other = new MutableLong(
      (k.getUint16(2) >>> 1) | ((k.getUint16(3) << 15) & 0xffff),
      k.getUint16(3) >>> 1,
      0,
      0
    );
    k.xor(other);
    k.multiply(mconst4);
    k.xor(new MutableLong(k.getUint16(2) >>> 1 | (k.getUint16(3) << 15 & 0xffff), k.getUint16(3) >>> 1, 0, 0));
  }

  /**
   * Parses a int64 decimal string representation into a MutableLong.
   * @param {String} value
   * @returns {Murmur3Token}
   */
  parse(value) {
    return new token$1.Murmur3Token(MutableLong.fromString(value));
  }

  minToken() {
    if (!this._minToken) {
      // minimum long value.
      this._minToken = this.parse('-9223372036854775808');
    }
    return this._minToken;
  }

  maxToken() {
    if (!this._maxToken) {
      this._maxToken = this.parse('9223372036854775807');
    }
    return this._maxToken;
  }

  maxValue() {
    if (!this._maxValue) {
      this._maxValue = Integer.fromString('9223372036854775807');
    }
    return this._maxValue;
  }

  minValue() {
    if (!this._minValue) {
      this._minValue = Integer.fromString('-9223372036854775808');
    }
    return this._minValue;
  }

  ringLength() {
    if (!this._ringLength) {
      this._ringLength = this.maxValue().subtract(this.minValue());
    }
    return this._ringLength;
  }

  split(start, end, numberOfSplits) {
    // ]min, min] means the whole ring.
    if (start.equals(end) && start.equals(this.minToken())) {
      end = this.maxToken();
    }

    const startVal = Integer.fromString(start.getValue().toString());
    const endVal = Integer.fromString(end.getValue().toString());

    let range = endVal.subtract(startVal);
    if (range.isNegative()) {
      range = range.add(this.ringLength());
    }

    const values = this.splitBase(startVal, range, this.maxValue(), this.ringLength(), numberOfSplits);
    return values.map(v => this.parse(v.toString()));
  }

  stringify(token) {
    // Get the underlying MutableLong
    const value = token.getValue();
    // We need a way to uniquely represent a token, it doesn't have to be the decimal string representation
    // Using the uint16 avoids divisions and other expensive operations on the longs
    return value.getUint16(0) + ',' + value.getUint16(1) + ',' + value.getUint16(2) + ',' + value.getUint16(3);
  }
}

/**
 * Uniformly distributes data across the cluster based on MD5 hash values.
 */
class RandomTokenizer extends Tokenizer {
  constructor() {
    super();
    // eslint-disable-next-line
    this._crypto = require$$0$8;
  }

  /**
   * @param {Buffer|Array} value
   * @returns {RandomToken}
   */
  hash(value) {
    if (Array.isArray(value)) {
      value = utils$l.allocBufferFromArray(value);
    }
    const hashedValue = this._crypto.createHash('md5').update(value).digest();
    return new token$1.RandomToken(Integer.fromBuffer(hashedValue).abs());
  }

  /**
   * @returns {Token}
   */
  parse(value) {
    return new token$1.RandomToken(Integer.fromString(value));
  }

  minToken() {
    if (!this._minToken) {
      this._minToken = this.parse('-1');
    }
    return this._minToken;
  }

  maxValue() {
    if (!this._maxValue) {
      this._maxValue = Integer.fromNumber(Math.pow(2, 127));
    }
    return this._maxValue;
  }

  maxToken() {
    if (!this._maxToken) {
      this._maxToken = new token$1.RandomToken(this.maxValue());
    }
    return this._maxToken;
  }

  ringLength() {
    if (!this._ringLength) {
      this._ringLength = this.maxValue().add(Integer.ONE);
    }
    return this._ringLength;
  }

  split(start, end, numberOfSplits) {
    // ]min, min] means the whole ring.
    if (start.equals(end) && start.equals(this.minToken())) {
      end = this.maxToken();
    }

    const startVal = start.getValue();
    const endVal = end.getValue();

    let range = endVal.subtract(startVal);
    if (range.lessThan(Integer.ZERO)) {
      range = range.add(this.ringLength());
    }

    const values = this.splitBase(startVal, range, this.maxValue(), this.ringLength(), numberOfSplits);
    return values.map(v => new token$1.RandomToken(v));
  }
}

class ByteOrderedTokenizer extends Tokenizer {
  constructor() {
    super();
  }

  /**
   * @param {Buffer} value
   * @returns {ByteOrderedToken}
   */
  hash(value) {
    // strip any trailing zeros as tokens with trailing zeros are equivalent
    // to those who don't have them.
    if (Array.isArray(value)) {
      value = utils$l.allocBufferFromArray(value);
    }
    let zeroIndex = value.length;
    for(let i = value.length - 1; i > 0; i--) {
      if(value[i] === 0) {
        zeroIndex = i;
      } else {
        break;
      }
    }
    return new token$1.ByteOrderedToken(value.slice(0, zeroIndex));
  }

  stringify(token) {
    return token.getValue().toString('hex');
  }

  parse(value) {
    return this.hash(utils$l.allocBufferFromString(value, 'hex'));
  }

  minToken() {
    if (!this._minToken) {
      this._minToken = this.hash([]);
    }
    return this._minToken;
  }

  _toNumber(buffer, significantBytes) {
    // Convert a token's byte array to a number in order to perform computations.
    // This depends on the number of significant bytes that is used to normalize all tokens
    // to the same size.  For example if the token is 0x01 but significant bytes is 2, the
    // result is 0x0100.
    let target = buffer;
    if(buffer.length !== significantBytes) {
      target = Buffer.alloc(significantBytes);
      buffer.copy(target);
    }

    // similar to Integer.fromBuffer except we force the sign to 0.
    const bits = new Array(Math.ceil(target.length / 4));
    for (let i = 0; i < bits.length; i++) {
      let offset = target.length - ((i + 1) * 4);
      let value;
      if (offset < 0) {
        //The buffer length is not multiple of 4
        offset = offset + 4;
        value = 0;
        for (let j = 0; j < offset; j++) {
          const byte = target[j];
          value = value | (byte << (offset - j - 1) * 8);
        }
      }
      else {
        value = target.readInt32BE(offset);
      }
      bits[i] = value;
    }
    return new Integer(bits, 0);
  }

  _toBuffer(number, significantBytes) {
    // Convert numeric representation back to a buffer.
    const buffer = Integer.toBuffer(number);
    if (buffer.length === significantBytes) {
      return buffer;
    }

    // if first byte is a sign byte, skip it.
    let start, length;
    if (buffer[0] === 0) {
      start = 1;
      length = buffer.length - 1;
    } else {
      start = 0;
      length = buffer.length;
    }

    const target = Buffer.alloc(significantBytes);
    buffer.copy(target, significantBytes - length, start, length + start);
    return target;
  }

  split(start, end, numberOfSplits) {
    const tokenOrder = start.compare(end);

    if (tokenOrder === 0 && start.equals(this.minToken())) {
      throw new Error("Cannot split whole ring with ordered partitioner");
    }

    let startVal, endVal, range, ringLength, ringEnd;
    const intNumberOfSplits = Integer.fromNumber(numberOfSplits);
    // Since tokens are compared lexicographically, convert to numbers using the
    // largest length (i.e. given 0x0A and 0x0BCD, switch to 0x0A00 and 0x0BCD)
    let significantBytes = Math.max(start.getValue().length, end.getValue().length);
    if (tokenOrder < 0) {
      let addedBytes = 0;
      while (true) {
        startVal = this._toNumber(start.getValue(), significantBytes);
        endVal = this._toNumber(end.getValue(), significantBytes);
        range = endVal.subtract(startVal);
        if (addedBytes === 4 || range.compare(intNumberOfSplits) >= 0) {
          break;
        }
        significantBytes += 1;
        addedBytes += 1;
      }
    } else {
      let addedBytes = 0;
      while (true) {
        startVal = this._toNumber(start.getValue(), significantBytes);
        endVal = this._toNumber(end.getValue(), significantBytes);
        ringLength = Integer.fromNumber(Math.pow(2, significantBytes * 8));
        ringEnd = ringLength.subtract(Integer.ONE);
        range = endVal.subtract(startVal).add(ringLength);
        if (addedBytes === 4 || range.compare(intNumberOfSplits) >= 0) {
          break;
        }
        significantBytes += 1;
        addedBytes += 1;
      }
    }

    const values = this.splitBase(startVal, range, ringEnd, ringLength, numberOfSplits);
    return values.map(v => new token$1.ByteOrderedToken(this._toBuffer(v, significantBytes)));
  }
}

/**
 * @param {Number} value
 * @return {MutableLong}
 */
function fromSignedByte(value) {
  if (value < 128) {
    return new MutableLong(value, 0, 0, 0);
  }
  return new MutableLong((value - 256) & 0xffff, 0xffff, 0xffff, 0xffff);
}

tokenizer.Murmur3Tokenizer = Murmur3Tokenizer;
tokenizer.RandomTokenizer = RandomTokenizer;
tokenizer.ByteOrderedTokenizer = ByteOrderedTokenizer;

var schemaParser = {};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const util$e = require$$0$4;
const events$4 = require$$0;
/**
 * Creates a new instance of DataCollection
 * @param {String} name Name of the data object.
 * @classdesc Describes a table or a view
 * @alias module:metadata~DataCollection
 * @constructor
 * @abstract
 */
function DataCollection$2(name) {
  events$4.EventEmitter.call(this);
  this.setMaxListeners(0);
  //private
  Object.defineProperty(this, 'loading', { value: false, enumerable: false, writable: true });
  Object.defineProperty(this, 'loaded', { value: false, enumerable: false, writable: true });
  /**
   * Name of the object
   * @type {String}
   */
  this.name = name;
  /**
   * False-positive probability for SSTable Bloom filters.
   * @type {number}
   */
  this.bloomFilterFalsePositiveChance = 0;
  /**
   * Level of caching: all, keys_only, rows_only, none
   * @type {String}
   */
  this.caching = null;
  /**
   * A human readable comment describing the table.
   * @type {String}
   */
  this.comment = null;
  /**
   * Specifies the time to wait before garbage collecting tombstones (deletion markers)
   * @type {number}
   */
  this.gcGraceSeconds = 0;
  /**
   * Compaction strategy class used for the table.
   * @type {String}
   */
  this.compactionClass = null;
  /**
   * Associative-array containing the compaction options keys and values.
   * @type {Object}
   */
  this.compactionOptions = null;
  /**
   * Associative-array containing the compression options.
   * @type {Object}
   */
  this.compression = null;
  /**
   * Specifies the probability of read repairs being invoked over all replicas in the current data center.
   * @type {number}
   */
  this.localReadRepairChance = 0;
  /**
   * Specifies the probability with which read repairs should be invoked on non-quorum reads. The value must be
   * between 0 and 1.
   * @type {number}
   */
  this.readRepairChance = 0;
  /**
   * An associative Array containing extra metadata for the table.
   * <p>
   * For Apache Cassandra versions prior to 3.0.0, this method always returns <code>null</code>.
   * </p>
   * @type {Object}
   */
  this.extensions = null;
  /**
   * When compression is enabled, this option defines the probability
   * with which checksums for compressed blocks are checked during reads.
   * The default value for this options is 1.0 (always check).
   * <p>
   *   For Apache Cassandra versions prior to 3.0.0, this method always returns <code>null</code>.
   * </p>
   * @type {Number|null}
   */
  this.crcCheckChance = null;
  /**
   * Whether the populate I/O cache on flush is set on this table.
   * @type {Boolean}
   */
  this.populateCacheOnFlush = false;
  /**
   * Returns the default TTL for this table.
   * @type {Number}
   */
  this.defaultTtl = 0;
  /**
   * * Returns the speculative retry option for this table.
   * @type {String}
   */
  this.speculativeRetry = 'NONE';
  /**
   * Returns the minimum index interval option for this table.
   * <p>
   *   Note: this option is available in Apache Cassandra 2.1 and above, and will return <code>null</code> for
   *   earlier versions.
   * </p>
   * @type {Number|null}
   */
  this.minIndexInterval = 128;
  /**
   * Returns the maximum index interval option for this table.
   * <p>
   * Note: this option is available in Apache Cassandra 2.1 and above, and will return <code>null</code> for
   * earlier versions.
   * </p>
   * @type {Number|null}
   */
  this.maxIndexInterval = 2048;
  /**
   * Array describing the table columns.
   * @type {Array}
   */
  this.columns = null;
  /**
   * An associative Array of columns by name.
   * @type {Object}
   */
  this.columnsByName = null;
  /**
   * Array describing the columns that are part of the partition key.
   * @type {Array}
   */
  this.partitionKeys = [];
  /**
   * Array describing the columns that form the clustering key.
   * @type {Array}
   */
  this.clusteringKeys = [];
  /**
   * Array describing the clustering order of the columns in the same order as the clusteringKeys.
   * @type {Array}
   */
  this.clusteringOrder = [];
  /**
   * An associative Array containing nodesync options for this table.
   * <p>
   * For DSE versions prior to 6.0.0, this method always returns {@code null}.  If nodesync
   * was not explicitly configured for this table this method will also return {@code null}.
   * </p>
   * @type {Object}
   */
  this.nodesync = null;
}

util$e.inherits(DataCollection$2, events$4.EventEmitter);

var dataCollection = DataCollection$2;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const util$d = require$$0$4;
const DataCollection$1 = dataCollection;
/**
 * Creates a new instance of TableMetadata
 * @classdesc Describes a table
 * @param {String} name Name of the Table
 * @augments {module:metadata~DataCollection}
 * @alias module:metadata~TableMetadata
 * @constructor
 */
function TableMetadata$1(name) {
  DataCollection$1.call(this, name);
  /**
   * Applies only to counter tables.
   * When set to true, replicates writes to all affected replicas regardless of the consistency level specified by
   * the client for a write request. For counter tables, this should always be set to true.
   * @type {Boolean}
   */
  this.replicateOnWrite = true;
  /**
   * Returns the memtable flush period (in milliseconds) option for this table.
   * @type {Number}
   */
  this.memtableFlushPeriod = 0;
  /**
   * Returns the index interval option for this table.
   * <p>
   * Note: this option is only available in Apache Cassandra 2.0. It is deprecated in Apache Cassandra 2.1 and
   * above, and will therefore return <code>null</code> for 2.1 nodes.
   * </p>
   * @type {Number|null}
   */
  this.indexInterval = null;
  /**
   * Determines  whether the table uses the COMPACT STORAGE option.
   * @type {Boolean}
   */
  this.isCompact = false;
  /**
   *
   * @type {Array.<Index>}
   */
  this.indexes = null;

  /**
   * Determines whether the Change Data Capture (CDC) flag is set for the table.
   * @type {Boolean|null}
   */
  this.cdc = null;

  /**
   * Determines whether the table is a virtual table or not.
   * @type {Boolean}
   */
  this.virtual = false;
}

util$d.inherits(TableMetadata$1, DataCollection$1);

var tableMetadata = TableMetadata$1;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Creates a new Aggregate.
 * @classdesc Describes a CQL aggregate.
 * @alias module:metadata~Aggregate
 * @constructor
 */
function Aggregate$1() {
  /**
   * Name of the aggregate.
   * @type {String}
   */
  this.name = null;
  /**
   * Name of the keyspace where the aggregate is declared.
   */
  this.keyspaceName = null;
  /**
   * Signature of the aggregate.
   * @type {Array.<String>}
   */
  this.signature = null;
  /**
   * List of the CQL aggregate argument types.
   * @type {Array.<{code, info}>}
   */
  this.argumentTypes = null;
  /**
   * State Function.
   * @type {String}
   */
  this.stateFunction = null;
  /**
   * State Type.
   * @type {{code, info}}
   */
  this.stateType = null;
  /**
   * Final Function.
   * @type {String}
   */
  this.finalFunction = null;
  this.initConditionRaw = null;
  /**
   * Initial state value of this aggregate.
   * @type {String}
   */
  this.initCondition = null;
  /**
   * Type of the return value.
   * @type {{code: number, info: (Object|Array|null)}}
   */
  this.returnType = null;
  /**
   * Indicates whether or not this aggregate is deterministic.  This means that
   * given a particular input, the aggregate will always produce the same output.
   * @type {Boolean}
   */
  this.deterministic = null;
}

var aggregate = Aggregate$1;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Creates a new SchemaFunction.
 * @classdesc Describes a CQL function.
 * @alias module:metadata~SchemaFunction
 * @constructor
 */
function SchemaFunction$1() {
  /**
   * Name of the cql function.
   * @type {String}
   */
  this.name = null;
  /**
   * Name of the keyspace where the cql function is declared.
   */
  this.keyspaceName = null;
  /**
   * Signature of the function.
   * @type {Array.<String>}
   */
  this.signature = null;
  /**
   * List of the function argument names.
   * @type {Array.<String>}
   */
  this.argumentNames = null;
  /**
   * List of the function argument types.
   * @type {Array.<{code, info}>}
   */
  this.argumentTypes = null;
  /**
   * Body of the function.
   * @type {String}
   */
  this.body = null;
  /**
   * Determines if the function is called when the input is null.
   * @type {Boolean}
   */
  this.calledOnNullInput = null;
  /**
   * Name of the programming language, for example: java, javascript, ...
   * @type {String}
   */
  this.language = null;
  /**
   * Type of the return value.
   * @type {{code: number, info: (Object|Array|null)}}
   */
  this.returnType = null;
  /**
   * Indicates whether or not this function is deterministic.  This means that
   * given a particular input, the function will always produce the same output.
   * @type {Boolean}
   */
  this.deterministic = null;
  /**
   * Indicates whether or not this function is monotonic on all of its
   * arguments.  This means that it is either entirely non-increasing or
   * non-decreasing.  Even if the function is not monotonic on all of its
   * arguments, it's possible to specify that it is monotonic on one of
   * its arguments, meaning that partial applications of the function over
   * that argument will be monotonic.
   * 
   * Monotonicity is required to use the function in a GROUP BY clause.
   * @type {Boolean}
   */
  this.monotonic = null;
  /**
   * The argument names that the function is monotonic on.
   * 
   * If {@link monotonic} is true, this will return all argument names.
   * Otherwise, this will return either one argument or an empty array.
   * @type {Array.<String>}
   */
  this.monotonicOn = null;
}

var schemaFunction = SchemaFunction$1;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const util$c = require$$0$4;
const utils$k = utils$K;
const types$d = requireTypes();

/** @private */
const kind = {
  custom: 0,
  keys: 1,
  composites: 2
};
/**
 * Creates a new Index instance.
 * @classdesc Describes a CQL index.
 * @param {String} name
 * @param {String} target
 * @param {Number|String} kind
 * @param {Object} options
 * @alias module:metadata~Index
 * @constructor
 */
function Index$1(name, target, kind, options) {
  /**
   * Name of the index.
   * @type {String}
   */
  this.name = name;
  /**
   * Target of the index.
   * @type {String}
   */
  this.target = target;
  /**
   * A numeric value representing index kind (0: custom, 1: keys, 2: composite);
   * @type {Number}
   */
  this.kind = typeof kind === 'string' ? getKindByName(kind) : kind;
  /**
   * An associative array containing the index options
   * @type {Object}
   */
  this.options = options;
}

/**
 * Determines if the index is of composites kind
 * @returns {Boolean}
 */
Index$1.prototype.isCompositesKind = function () {
  return this.kind === kind.composites;
};

/**
 * Determines if the index is of keys kind
 * @returns {Boolean}
 */
Index$1.prototype.isKeysKind = function () {
  return this.kind === kind.keys;
};

/**
 * Determines if the index is of custom kind
 * @returns {Boolean}
 */
Index$1.prototype.isCustomKind = function () {
  return this.kind === kind.custom;
};

/**
 * Parses Index information from rows in the 'system_schema.indexes' table
 * @deprecated It will be removed in the next major version.
 * @param {Array.<Row>} indexRows
 * @returns {Array.<Index>}
 */
Index$1.fromRows = function (indexRows) {
  if (!indexRows || indexRows.length === 0) {
    return utils$k.emptyArray;
  }
  return indexRows.map(function (row) {
    const options = row['options'];
    return new Index$1(row['index_name'], options['target'], getKindByName(row['kind']), options);
  });
};

/**
 * Parses Index information from rows in the legacy 'system.schema_columns' table.
 * @deprecated It will be removed in the next major version.
 * @param {Array.<Row>} columnRows
 * @param {Object.<String, {name, type}>} columnsByName
 * @returns {Array.<Index>}
 */
Index$1.fromColumnRows = function (columnRows, columnsByName) {
  const result = [];
  for (let i = 0; i < columnRows.length; i++) {
    const row = columnRows[i];
    const indexName = row['index_name'];
    if (!indexName) {
      continue;
    }
    const c = columnsByName[row['column_name']];
    let target;
    const options = JSON.parse(row['index_options']);
    if (options !== null && options['index_keys'] !== undefined) {
      target = util$c.format("keys(%s)", c.name);
    }
    else if (options !== null && options['index_keys_and_values'] !== undefined) {
      target = util$c.format("entries(%s)", c.name);
    }
    else if (c.type.options.frozen && (c.type.code === types$d.dataTypes.map || c.type.code === types$d.dataTypes.list ||
      c.type.code === types$d.dataTypes.set)) {
      target = util$c.format("full(%s)", c.name);
    }
    else {
      target = c.name;
    }
    result.push(new Index$1(indexName, target, getKindByName(row['index_type']), options));
  }
  return result;
};

/**
 * Gets the number representing the kind based on the name
 * @param {String} name
 * @returns {Number}
 * @private
 */
function getKindByName(name) {
  if (!name) {
    return kind.custom;
  }
  return kind[name.toLowerCase()];
}

var schemaIndex = Index$1;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const util$b = require$$0$4;
const DataCollection = dataCollection;
/**
 * Creates a new MaterializedView.
 * @param {String} name Name of the View.
 * @classdesc Describes a CQL materialized view.
 * @alias module:metadata~MaterializedView
 * @augments {module:metadata~DataCollection}
 * @constructor
 */
function MaterializedView$1(name) {
  DataCollection.call(this, name);
  /**
   * Name of the table.
   * @type {String}
   */
  this.tableName = null;
  /**
   * View where clause.
   * @type {String}
   */
  this.whereClause = null;
  /**
   * Determines if all the table columns where are included in the view.
   * @type {boolean}
   */
  this.includeAllColumns = false;
}

util$b.inherits(MaterializedView$1, DataCollection);

var materializedView = MaterializedView$1;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const util$a = require$$0$4;
const events$3 = require$$0;
const types$c = requireTypes();
const utils$j = utils$K;
const errors$a = errors$n;
const promiseUtils$7 = promiseUtils$e;
const TableMetadata = tableMetadata;
const Aggregate = aggregate;
const SchemaFunction = schemaFunction;
const Index = schemaIndex;
const MaterializedView = materializedView;
const { format } = util$a;

/**
 * @module metadata/schemaParser
 * @ignore
 */

const _selectAllKeyspacesV1 = "SELECT * FROM system.schema_keyspaces";
const _selectSingleKeyspaceV1 = "SELECT * FROM system.schema_keyspaces where keyspace_name = '%s'";
const _selectAllKeyspacesV2 = "SELECT * FROM system_schema.keyspaces";
const _selectSingleKeyspaceV2 = "SELECT * FROM system_schema.keyspaces where keyspace_name = '%s'";
const _selectTableV1 = "SELECT * FROM system.schema_columnfamilies WHERE keyspace_name='%s' AND columnfamily_name='%s'";
const _selectTableV2 = "SELECT * FROM system_schema.tables WHERE keyspace_name='%s' AND table_name='%s'";
const _selectColumnsV1 = "SELECT * FROM system.schema_columns WHERE keyspace_name='%s' AND columnfamily_name='%s'";
const _selectColumnsV2 = "SELECT * FROM system_schema.columns WHERE keyspace_name='%s' AND table_name='%s'";
const _selectIndexesV2 = "SELECT * FROM system_schema.indexes WHERE keyspace_name='%s' AND table_name='%s'";
const _selectUdtV1 = "SELECT * FROM system.schema_usertypes WHERE keyspace_name='%s' AND type_name='%s'";
const _selectUdtV2 = "SELECT * FROM system_schema.types WHERE keyspace_name='%s' AND type_name='%s'";
const _selectFunctionsV1 = "SELECT * FROM system.schema_functions WHERE keyspace_name = '%s' AND function_name = '%s'";
const _selectFunctionsV2 = "SELECT * FROM system_schema.functions WHERE keyspace_name = '%s' AND function_name = '%s'";
const _selectAggregatesV1 = "SELECT * FROM system.schema_aggregates WHERE keyspace_name = '%s' AND aggregate_name = '%s'";
const _selectAggregatesV2 = "SELECT * FROM system_schema.aggregates WHERE keyspace_name = '%s' AND aggregate_name = '%s'";
const _selectMaterializedViewV2 = "SELECT * FROM system_schema.views WHERE keyspace_name = '%s' AND view_name = '%s'";

const _selectAllVirtualKeyspaces = "SELECT * FROM system_virtual_schema.keyspaces";
const _selectSingleVirtualKeyspace = "SELECT * FROM system_virtual_schema.keyspaces where keyspace_name = '%s'";
const _selectVirtualTable = "SELECT * FROM system_virtual_schema.tables where keyspace_name = '%s' and table_name='%s'";
const _selectVirtualColumns = "SELECT * FROM system_virtual_schema.columns where keyspace_name = '%s' and table_name='%s'";


/**
 * @abstract
 * @param {ClientOptions} options The client options
 * @param {ControlConnection} cc
 * @constructor
 * @ignore
 */
class SchemaParser {
  constructor(options, cc) {
    this.cc = cc;
    this.encodingOptions = options.encoding;
    this.selectTable = null;
    this.selectColumns = null;
    this.selectIndexes = null;
    this.selectUdt = null;
    this.selectAggregates = null;
    this.selectFunctions = null;
    this.supportsVirtual = false;
  }

  /**
   * @param name
   * @param durableWrites
   * @param strategy
   * @param strategyOptions
   * @param virtual
   * @returns {{name, durableWrites, strategy, strategyOptions, tokenToReplica, udts, tables, functions, aggregates}}
   * @protected
   */
  _createKeyspace(name, durableWrites, strategy, strategyOptions, virtual) {
    return {
      name,
      durableWrites,
      strategy,
      strategyOptions,
      virtual: virtual === true,
      udts: {},
      tables: {},
      functions: {},
      aggregates: {},
      views: {},
      tokenToReplica: getTokenToReplicaMapper(strategy, strategyOptions),
      graphEngine: undefined
    };
  }

  /**
   * @abstract
   * @param {String} name
   * @returns {Promise<Object>}
   */
  getKeyspace(name) {
  }

  /**
   * @abstract
   * @param {Boolean} waitReconnect
   * @returns {Promise<Object<string, Object>>}
   */
  getKeyspaces(waitReconnect) {
  }

  /**
   * @param {String} keyspaceName
   * @param {String} name
   * @param {Object} cache
   * @param {Boolean} virtual
   * @returns {Promise<TableMetadata|null>}
   */
  async getTable(keyspaceName, name, cache, virtual) {
    let tableInfo = cache && cache[name];
    if (!tableInfo) {
      tableInfo = new TableMetadata(name);
      if (cache) {
        cache[name] = tableInfo;
      }
    }
    if (tableInfo.loaded) {
      return tableInfo;
    }
    if (tableInfo.loading) {
      // Wait for it to emit
      return promiseUtils$7.fromEvent(tableInfo, 'load');
    }
    try {
      // its not cached and not being retrieved
      tableInfo.loading = true;
      let indexRows;
      let virtualTable = virtual;
      const selectTable = virtualTable ? _selectVirtualTable : this.selectTable;
      const query = util$a.format(selectTable, keyspaceName, name);
      let tableRow = await this._getFirstRow(query);
      // if we weren't sure if table was virtual or not, query virtual schema.
      if (!tableRow && this.supportsVirtual && virtualTable === undefined) {
        const query = util$a.format(_selectVirtualTable, keyspaceName, name);
        try {
          tableRow = await this._getFirstRow(query);
        }
        catch (err) {
          // we can't error here as we can't be sure if the node
          // supports virtual tables, in this case it is adequate
          // to act as if there was no matching table.
        }
        if (tableRow) {
          // We are fetching a virtual table
          virtualTable = true;
        }
      }
      if (!tableRow) {
        tableInfo.loading = false;
        tableInfo.emit('load', null, null);
        return null;
      }
      const selectColumns = virtualTable ? _selectVirtualColumns : this.selectColumns;
      const columnRows = await this._getRows(util$a.format(selectColumns, keyspaceName, name));
      if (this.selectIndexes && !virtualTable) {
        indexRows = await this._getRows(util$a.format(this.selectIndexes, keyspaceName, name));
      }
      await this._parseTableOrView(tableInfo, tableRow, columnRows, indexRows, virtualTable);
      tableInfo.loaded = true;
      tableInfo.emit('load', null, tableInfo);
      return tableInfo;
    }
    catch (err) {
      tableInfo.emit('load', err, null);
      throw err;
    }
    finally {
      tableInfo.loading = false;
    }
  }

  async _getFirstRow(query) {
    const rows = await this._getRows(query);
    return rows[0];
  }

  async _getRows(query) {
    const response = await this.cc.query(query);
    return response.rows;
  }

  /**
   * @param {String} keyspaceName
   * @param {String} name
   * @param {Object} cache
   * @returns {Promise<Object|null>}
   */
  async getUdt(keyspaceName, name, cache) {
    let udtInfo = cache && cache[name];
    if (!udtInfo) {
      udtInfo = new events$3.EventEmitter();
      if (cache) {
        cache[name] = udtInfo;
      }
      udtInfo.setMaxListeners(0);
      udtInfo.loading = false;
      udtInfo.name = name;
      udtInfo.keyspace = keyspaceName;
      udtInfo.fields = null;
    }
    if (udtInfo.fields) {
      return udtInfo;
    }
    if (udtInfo.loading) {
      return promiseUtils$7.fromEvent(udtInfo, 'load');
    }
    udtInfo.loading = true;
    const query = format(this.selectUdt, keyspaceName, name);
    try {
      const row = await this._getFirstRow(query);
      if (!row) {
        udtInfo.loading = false;
        udtInfo.emit('load', null, null);
        return null;
      }
      await this._parseUdt(udtInfo, row);
      udtInfo.emit('load', null, udtInfo);
      return udtInfo;
    }
    catch (err) {
      udtInfo.emit('load', err);
      throw err;
    }
    finally {
      udtInfo.loading = false;
    }
  }

  /**
   * Parses the udt information from the row
   * @param udtInfo
   * @param {Row} row
   * @returns {Promise<void>}
   * @abstract
   */
  _parseUdt(udtInfo, row) {
  }

  /**
   * Builds the metadata based on the table and column rows
   * @abstract
   * @param {module:metadata~TableMetadata} tableInfo
   * @param {Row} tableRow
   * @param {Array.<Row>} columnRows
   * @param {Array.<Row>} indexRows
   * @param {Boolean} virtual
   * @returns {Promise<void>}
   * @throws {Error}
   */
  async _parseTableOrView(tableInfo, tableRow, columnRows, indexRows, virtual) {
  }

  /**
   * @abstract
   * @param {String} keyspaceName
   * @param {String} name
   * @param {Object} cache
   * @returns {Promise<MaterializedView|null>}
   */
  getMaterializedView(keyspaceName, name, cache) {
  }

  /**
   * @param {String} keyspaceName
   * @param {String} name
   * @param {Boolean} aggregate
   * @param {Object} cache
   * @returns {Promise<Map>}
   */
  async getFunctions(keyspaceName, name, aggregate, cache) {
    /** @type {String} */
    let query = this.selectFunctions;
    let parser = row => this._parseFunction(row);
    if (aggregate) {
      query = this.selectAggregates;
      parser = row => this._parseAggregate(row);
    }
    // if it's not already loaded, get all functions with that name
    // cache it by name and, within name, by signature
    let functionsInfo = cache && cache[name];
    if (!functionsInfo) {
      functionsInfo = new events$3.EventEmitter();
      if (cache) {
        cache[name] = functionsInfo;
      }
      functionsInfo.setMaxListeners(0);
    }
    if (functionsInfo.values) {
      return functionsInfo.values;
    }
    if (functionsInfo.loading) {
      return promiseUtils$7.fromEvent(functionsInfo, 'load');
    }
    functionsInfo.loading = true;
    try {
      const rows = await this._getRows(format(query, keyspaceName, name));
      const funcs = await Promise.all(rows.map(parser));
      const result = new Map();
      if (rows.length > 0) {
        // Cache positive hits
        functionsInfo.values = result;
      }

      funcs.forEach(f => functionsInfo.values.set(f.signature.join(','), f));
      functionsInfo.emit('load', null, result);
      return result;
    }
    catch (err) {
      functionsInfo.emit('load', err);
      throw err;
    }
    finally {
      functionsInfo.loading = false;
    }
  }

  /**
   * @abstract
   * @param {Row} row
   * @returns {Promise}
   */
  _parseAggregate(row) {
  }

  /**
   * @abstract
   * @param {Row} row
   * @returns {Promise}
   */
  _parseFunction(row) {
  }

  /** @returns {Map} */
  _asMap(obj) {
    if (!obj) {
      return new Map();
    }
    if (this.encodingOptions.map && obj instanceof this.encodingOptions.map) {
      // Its already a Map or a polyfill of a Map
      return obj;
    }
    return new Map(Object.keys(obj).map(k => [k, obj[k]]));
  }

  _mapAsObject(map) {
    if (!map) {
      return map;
    }
    if (this.encodingOptions.map && map instanceof this.encodingOptions.map) {
      const result = {};
      map.forEach((value, key) => result[key] = value);
      return result;
    }
    return map;
  }
}

/**
 * Used to parse schema information for Cassandra versions 1.2.x, and 2.x
 * @ignore
 */
class SchemaParserV1 extends SchemaParser {

  /**
   * @param {ClientOptions} options
   * @param {ControlConnection} cc
   */
  constructor(options, cc) {
    super(options, cc);
    this.selectTable = _selectTableV1;
    this.selectColumns = _selectColumnsV1;
    this.selectUdt = _selectUdtV1;
    this.selectAggregates = _selectAggregatesV1;
    this.selectFunctions = _selectFunctionsV1;
  }

  async getKeyspaces(waitReconnect) {
    const keyspaces = {};
    const result = await this.cc.query(_selectAllKeyspacesV1, waitReconnect);
    for (let i = 0; i < result.rows.length; i++) {
      const row = result.rows[i];
      const ksInfo = this._createKeyspace(row['keyspace_name'], row['durable_writes'], row['strategy_class'], JSON.parse(row['strategy_options'] || null));
      keyspaces[ksInfo.name] = ksInfo;
    }
    return keyspaces;
  }

  async getKeyspace(name) {
    const row = await this._getFirstRow(format(_selectSingleKeyspaceV1, name));
    if (!row) {
      return null;
    }
    return this._createKeyspace(row['keyspace_name'], row['durable_writes'], row['strategy_class'], JSON.parse(row['strategy_options']));
  }

  // eslint-disable-next-line require-await
  async _parseTableOrView(tableInfo, tableRow, columnRows, indexRows, virtual) {
    // All the tableInfo parsing in V1 is sync, it uses a async function because the super class defines one
    // to support other versions.
    let c, name, types;
    const encoder = this.cc.getEncoder();
    const columnsKeyed = {};
    let partitionKeys = [];
    let clusteringKeys = [];
    tableInfo.bloomFilterFalsePositiveChance = tableRow['bloom_filter_fp_chance'];
    tableInfo.caching = tableRow['caching'];
    tableInfo.comment = tableRow['comment'];
    tableInfo.compactionClass = tableRow['compaction_strategy_class'];
    tableInfo.compactionOptions = JSON.parse(tableRow['compaction_strategy_options']);
    tableInfo.compression = JSON.parse(tableRow['compression_parameters']);
    tableInfo.gcGraceSeconds = tableRow['gc_grace_seconds'];
    tableInfo.localReadRepairChance = tableRow['local_read_repair_chance'];
    tableInfo.readRepairChance = tableRow['read_repair_chance'];
    tableInfo.populateCacheOnFlush = tableRow['populate_io_cache_on_flush'] || tableInfo.populateCacheOnFlush;
    tableInfo.memtableFlushPeriod = tableRow['memtable_flush_period_in_ms'] || tableInfo.memtableFlushPeriod;
    tableInfo.defaultTtl = tableRow['default_time_to_live'] || tableInfo.defaultTtl;
    tableInfo.speculativeRetry = tableRow['speculative_retry'] || tableInfo.speculativeRetry;
    tableInfo.indexInterval = tableRow['index_interval'] || tableInfo.indexInterval;
    if (typeof tableRow['min_index_interval'] !== 'undefined') {
      //Cassandra 2.1+
      tableInfo.minIndexInterval = tableRow['min_index_interval'] || tableInfo.minIndexInterval;
      tableInfo.maxIndexInterval = tableRow['max_index_interval'] || tableInfo.maxIndexInterval;
    }
    else {
      //set to null
      tableInfo.minIndexInterval = null;
      tableInfo.maxIndexInterval = null;
    }
    if (typeof tableRow['replicate_on_write'] !== 'undefined') {
      //leave the default otherwise
      tableInfo.replicateOnWrite = tableRow['replicate_on_write'];
    }
    tableInfo.columns = [];
    for (let i = 0; i < columnRows.length; i++) {
      const row = columnRows[i];
      const type = encoder.parseFqTypeName(row['validator']);
      c = {
        name: row['column_name'],
        type: type,
        isStatic: false
      };
      tableInfo.columns.push(c);
      columnsKeyed[c.name] = c;
      switch (row['type']) {
        case 'partition_key':
          partitionKeys.push({ c: c, index: (row['component_index'] || 0) });
          break;
        case 'clustering_key':
          clusteringKeys.push({
            c: c,
            index: (row['component_index'] || 0),
            order: c.type.options.reversed ? 'DESC' : 'ASC'
          });
          break;
        case 'static':
          // C* 2.0.6+ supports static columns
          c.isStatic = true;
          break;
      }
    }
    if (partitionKeys.length > 0) {
      tableInfo.partitionKeys = partitionKeys.sort(utils$j.propCompare('index')).map(item => item.c);
      clusteringKeys.sort(utils$j.propCompare('index'));
      tableInfo.clusteringKeys = clusteringKeys.map(item => item.c);
      tableInfo.clusteringOrder = clusteringKeys.map(item => item.order);
    }
    // In C* 1.2, keys are not stored on the schema_columns table
    const keysStoredInTableRow = (tableInfo.partitionKeys.length === 0);
    if (keysStoredInTableRow && tableRow['key_aliases']) {
      //In C* 1.2, keys are not stored on the schema_columns table
      partitionKeys = JSON.parse(tableRow['key_aliases']);
      types = encoder.parseKeyTypes(tableRow['key_validator']).types;
      for (let i = 0; i < partitionKeys.length; i++) {
        name = partitionKeys[i];
        c = columnsKeyed[name];
        if (!c) {
          c = {
            name: name,
            type: types[i]
          };
          tableInfo.columns.push(c);
        }
        tableInfo.partitionKeys.push(c);
      }
    }
    const comparator = encoder.parseKeyTypes(tableRow['comparator']);
    if (keysStoredInTableRow && tableRow['column_aliases']) {
      clusteringKeys = JSON.parse(tableRow['column_aliases']);
      for (let i = 0; i < clusteringKeys.length; i++) {
        name = clusteringKeys[i];
        c = columnsKeyed[name];
        if (!c) {
          c = {
            name: name,
            type: comparator.types[i]
          };
          tableInfo.columns.push(c);
        }
        tableInfo.clusteringKeys.push(c);
        tableInfo.clusteringOrder.push(c.type.options.reversed ? 'DESC' : 'ASC');
      }
    }
    tableInfo.isCompact = !!tableRow['is_dense'];
    if (!tableInfo.isCompact) {
      //is_dense column does not exist in previous versions of Cassandra
      //also, compact pk, ck and val appear as is_dense false
      // clusteringKeys != comparator types - 1
      // or not composite (comparator)
      tableInfo.isCompact = (
        //clustering keys are not marked as composite
        !comparator.isComposite ||
        //only 1 column not part of the partition or clustering keys
        (!comparator.hasCollections && tableInfo.clusteringKeys.length !== comparator.types.length - 1));
    }
    name = tableRow['value_alias'];
    if (tableInfo.isCompact && name && !columnsKeyed[name]) {
      //additional column in C* 1.2 as value_alias
      c = {
        name: name,
        type: encoder.parseFqTypeName(tableRow['default_validator'])
      };
      tableInfo.columns.push(c);
      columnsKeyed[name] = c;
    }
    tableInfo.columnsByName = columnsKeyed;
    tableInfo.indexes = Index.fromColumnRows(columnRows, tableInfo.columnsByName);
  }

  getMaterializedView(keyspaceName, name, cache) {
    return Promise.reject(new errors$a.NotSupportedError('Materialized views are not supported on Cassandra versions below 3.0'));
  }

  // eslint-disable-next-line require-await
  async _parseAggregate(row) {
    const encoder = this.cc.getEncoder();
    const aggregate = new Aggregate();
    aggregate.name = row['aggregate_name'];
    aggregate.keyspaceName = row['keyspace_name'];
    aggregate.signature = row['signature'] || utils$j.emptyArray;
    aggregate.stateFunction = row['state_func'];
    aggregate.finalFunction = row['final_func'];
    aggregate.initConditionRaw = row['initcond'];
    aggregate.argumentTypes = (row['argument_types'] || utils$j.emptyArray).map(name => encoder.parseFqTypeName(name));
    aggregate.stateType = encoder.parseFqTypeName(row['state_type']);
    const initConditionValue = encoder.decode(aggregate.initConditionRaw, aggregate.stateType);
    if (initConditionValue !== null && typeof initConditionValue !== 'undefined') {
      aggregate.initCondition = initConditionValue.toString();
    }
    aggregate.returnType = encoder.parseFqTypeName(row['return_type']);
    return aggregate;
  }

  // eslint-disable-next-line require-await
  async _parseFunction(row) {
    const encoder = this.cc.getEncoder();
    const func = new SchemaFunction();
    func.name = row['function_name'];
    func.keyspaceName = row['keyspace_name'];
    func.signature = row['signature'] || utils$j.emptyArray;
    func.argumentNames = row['argument_names'] || utils$j.emptyArray;
    func.body = row['body'];
    func.calledOnNullInput = row['called_on_null_input'];
    func.language = row['language'];
    func.argumentTypes = (row['argument_types'] || utils$j.emptyArray).map(name => encoder.parseFqTypeName(name));
    func.returnType = encoder.parseFqTypeName(row['return_type']);
    return func;
  }

  // eslint-disable-next-line require-await
  async _parseUdt(udtInfo, row) {
    const encoder = this.cc.getEncoder();
    const fieldNames = row['field_names'];
    const fieldTypes = row['field_types'];
    const fields = new Array(fieldNames.length);
    for (let i = 0; i < fieldNames.length; i++) {
      fields[i] = {
        name: fieldNames[i],
        type: encoder.parseFqTypeName(fieldTypes[i])
      };
    }
    udtInfo.fields = fields;
    return udtInfo;
  }
}


/**
 * Used to parse schema information for Cassandra versions 3.x and above
 * @param {ClientOptions} options The client options
 * @param {ControlConnection} cc The control connection to be used
 * @param {Function} udtResolver The function to be used to retrieve the udts.
 * @ignore
 */
class SchemaParserV2 extends SchemaParser {

  /**
   * @param {ClientOptions} options The client options
   * @param {ControlConnection} cc The control connection to be used
   * @param {Function} udtResolver The function to be used to retrieve the udts.
   */
  constructor(options, cc, udtResolver) {
    super(options, cc);
    this.udtResolver = udtResolver;
    this.selectTable = _selectTableV2;
    this.selectColumns = _selectColumnsV2;
    this.selectUdt = _selectUdtV2;
    this.selectAggregates = _selectAggregatesV2;
    this.selectFunctions = _selectFunctionsV2;
    this.selectIndexes = _selectIndexesV2;
  }

  async getKeyspaces(waitReconnect) {
    const keyspaces = {};
    const result = await this.cc.query(_selectAllKeyspacesV2, waitReconnect);
    for (let i = 0; i < result.rows.length; i++) {
      const ksInfo = this._parseKeyspace(result.rows[i]);
      keyspaces[ksInfo.name] = ksInfo;
    }
    return keyspaces;
  }

  async getKeyspace(name) {
    const row = await this._getFirstRow(format(_selectSingleKeyspaceV2, name));
    if (!row) {
      return null;
    }
    return this._parseKeyspace(row);
  }

  async getMaterializedView(keyspaceName, name, cache) {
    let viewInfo = cache && cache[name];
    if (!viewInfo) {
      viewInfo = new MaterializedView(name);
      if (cache) {
        cache[name] = viewInfo;
      }
    }
    if (viewInfo.loaded) {
      return viewInfo;
    }
    if (viewInfo.loading) {
      return promiseUtils$7.fromEvent(viewInfo, 'load');
    }
    viewInfo.loading = true;
    try {
      const tableRow = await this._getFirstRow(format(_selectMaterializedViewV2, keyspaceName, name));
      if (!tableRow) {
        viewInfo.emit('load', null, null);
        viewInfo.loading = false;
        return null;
      }
      const columnRows = await this._getRows(format(this.selectColumns, keyspaceName, name));
      await this._parseTableOrView(viewInfo, tableRow, columnRows, null, false);
      viewInfo.loaded = true;
      viewInfo.emit('load', null, viewInfo);
      return viewInfo;
    }
    catch (err) {
      viewInfo.emit('load', err);
      throw err;
    }
    finally {
      viewInfo.loading = false;
    }
  }

  _parseKeyspace(row, virtual) {
    const replication = row['replication'];
    let strategy;
    let strategyOptions;
    if (replication) {
      strategy = replication['class'];
      strategyOptions = {};
      for (const key in replication) {
        if (!replication.hasOwnProperty(key) || key === 'class') {
          continue;
        }
        strategyOptions[key] = replication[key];
      }
    }

    const ks = this._createKeyspace(row['keyspace_name'], row['durable_writes'], strategy, strategyOptions, virtual);
    ks.graphEngine = row['graph_engine'];
    return ks;
  }

  async _parseTableOrView(tableInfo, tableRow, columnRows, indexRows, virtual) {
    const encoder = this.cc.getEncoder();
    const columnsKeyed = {};
    const partitionKeys = [];
    const clusteringKeys = [];
    tableInfo.columns = await Promise.all(columnRows.map(async (row) => {
      const type = await encoder.parseTypeName(tableRow['keyspace_name'], row['type'], 0, null, this.udtResolver);
      const c = {
        name: row['column_name'],
        type: type,
        isStatic: false
      };
      columnsKeyed[c.name] = c;
      switch (row['kind']) {
        case 'partition_key':
          partitionKeys.push({ c, index: (row['position'] || 0) });
          break;
        case 'clustering':
          clusteringKeys.push({
            c, index: (row['position'] || 0), order: row['clustering_order'] === 'desc' ? 'DESC' : 'ASC'
          });
          break;
        case 'static':
          c.isStatic = true;
          break;
      }
      return c;
    }));
    tableInfo.columnsByName = columnsKeyed;
    tableInfo.partitionKeys = partitionKeys.sort(utils$j.propCompare('index')).map(item => item.c);
    clusteringKeys.sort(utils$j.propCompare('index'));
    tableInfo.clusteringKeys = clusteringKeys.map(item => item.c);
    tableInfo.clusteringOrder = clusteringKeys.map(item => item.order);
    if (virtual) {
      // When table is virtual, the only relevant information to parse are the columns
      // as the table itself has no configuration
      tableInfo.virtual = true;
      return;
    }
    const isView = tableInfo instanceof MaterializedView;
    tableInfo.bloomFilterFalsePositiveChance = tableRow['bloom_filter_fp_chance'];
    tableInfo.caching = JSON.stringify(tableRow['caching']);
    tableInfo.comment = tableRow['comment'];
    // Regardless of the encoding options, use always an Object to represent an associative Array
    const compaction = this._asMap(tableRow['compaction']);
    if (compaction) {
      // compactionOptions as an Object<String, String>
      tableInfo.compactionOptions = {};
      tableInfo.compactionClass = compaction.get('class');
      compaction.forEach((value, key) => {
        if (key === 'class') {
          return;
        }
        tableInfo.compactionOptions[key] = compaction.get(key);
      });
    }
    // Convert compression to an Object<String, String>
    tableInfo.compression = this._mapAsObject(tableRow['compression']);
    tableInfo.gcGraceSeconds = tableRow['gc_grace_seconds'];
    tableInfo.localReadRepairChance = tableRow['dclocal_read_repair_chance'];
    tableInfo.readRepairChance = tableRow['read_repair_chance'];
    tableInfo.extensions = this._mapAsObject(tableRow['extensions']);
    tableInfo.crcCheckChance = tableRow['crc_check_chance'];
    tableInfo.memtableFlushPeriod = tableRow['memtable_flush_period_in_ms'] || tableInfo.memtableFlushPeriod;
    tableInfo.defaultTtl = tableRow['default_time_to_live'] || tableInfo.defaultTtl;
    tableInfo.speculativeRetry = tableRow['speculative_retry'] || tableInfo.speculativeRetry;
    tableInfo.minIndexInterval = tableRow['min_index_interval'] || tableInfo.minIndexInterval;
    tableInfo.maxIndexInterval = tableRow['max_index_interval'] || tableInfo.maxIndexInterval;
    tableInfo.nodesync = tableRow['nodesync'] || tableInfo.nodesync;
    if (!isView) {
      const cdc = tableRow['cdc'];
      if (cdc !== undefined) {
        tableInfo.cdc = cdc;
      }
    }
    if (isView) {
      tableInfo.tableName = tableRow['base_table_name'];
      tableInfo.whereClause = tableRow['where_clause'];
      tableInfo.includeAllColumns = tableRow['include_all_columns'];
      return;
    }
    tableInfo.indexes = this._getIndexes(indexRows);
    // flags can be an instance of Array or Set (real or polyfill)
    let flags = tableRow['flags'];
    if (Array.isArray(flags)) {
      flags = new Set(flags);
    }
    const isDense = flags.has('dense');
    const isSuper = flags.has('super');
    const isCompound = flags.has('compound');
    tableInfo.isCompact = isSuper || isDense || !isCompound;
    // Remove the columns related to Thrift
    const isStaticCompact = !isSuper && !isDense && !isCompound;
    if (isStaticCompact) {
      pruneStaticCompactTableColumns(tableInfo);
    }
    else if (isDense) {
      pruneDenseTableColumns(tableInfo);
    }
  }

  _getIndexes(indexRows) {
    if (!indexRows || indexRows.length === 0) {
      return utils$j.emptyArray;
    }
    return indexRows.map((row) => {
      const options = this._mapAsObject(row['options']);
      return new Index(row['index_name'], options['target'], row['kind'], options);
    });
  }

  async _parseAggregate(row) {
    const encoder = this.cc.getEncoder();
    const aggregate = new Aggregate();
    aggregate.name = row['aggregate_name'];
    aggregate.keyspaceName = row['keyspace_name'];
    aggregate.signature = row['argument_types'] || utils$j.emptyArray;
    aggregate.stateFunction = row['state_func'];
    aggregate.finalFunction = row['final_func'];
    aggregate.initConditionRaw = row['initcond'];
    aggregate.initCondition = aggregate.initConditionRaw;
    aggregate.deterministic = row['deterministic'] || false;
    aggregate.argumentTypes = await Promise.all(aggregate.signature.map(name => encoder.parseTypeName(row['keyspace_name'], name, 0, null, this.udtResolver)));
    aggregate.stateType = await encoder.parseTypeName(row['keyspace_name'], row['state_type'], 0, null, this.udtResolver);
    aggregate.returnType = await encoder.parseTypeName(row['keyspace_name'], row['return_type'], 0, null, this.udtResolver);
    return aggregate;
  }

  async _parseFunction(row) {
    const encoder = this.cc.getEncoder();
    const func = new SchemaFunction();
    func.name = row['function_name'];
    func.keyspaceName = row['keyspace_name'];
    func.signature = row['argument_types'] || utils$j.emptyArray;
    func.argumentNames = row['argument_names'] || utils$j.emptyArray;
    func.body = row['body'];
    func.calledOnNullInput = row['called_on_null_input'];
    func.language = row['language'];
    func.deterministic = row['deterministic'] || false;
    func.monotonic = row['monotonic'] || false;
    func.monotonicOn = row['monotonic_on'] || utils$j.emptyArray;
    func.argumentTypes = await Promise.all(func.signature.map(name => encoder.parseTypeName(row['keyspace_name'], name, 0, null, this.udtResolver)));
    func.returnType = await encoder.parseTypeName(row['keyspace_name'], row['return_type'], 0, null, this.udtResolver);
    return func;
  }

  async _parseUdt(udtInfo, row) {
    const encoder = this.cc.getEncoder();
    const fieldTypes = row['field_types'];
    const keyspace = row['keyspace_name'];
    udtInfo.fields = await Promise.all(row['field_names'].map(async (name, i) => {
      const type = await encoder.parseTypeName(keyspace, fieldTypes[i], 0, null, this.udtResolver);
      return { name, type };
    }));
    return udtInfo;
  }
}

/**
 * Used to parse schema information for Cassandra versions 4.x and above.
 *
 * This parser similar to [SchemaParserV2] expect it also parses virtual
 * keyspaces.
 * @ignore
 */
class SchemaParserV3 extends SchemaParserV2 {
  /**
   * @param {ClientOptions} options The client options
   * @param {ControlConnection} cc The control connection to be used
   * @param {Function} udtResolver The function to be used to retrieve the udts.
   */
  constructor(options, cc, udtResolver) {
    super(options, cc, udtResolver);
    this.supportsVirtual = true;
  }

  async getKeyspaces(waitReconnect) {
    const keyspaces = {};
    const queries = [
      { query: _selectAllKeyspacesV2, virtual: false },
      { query: _selectAllVirtualKeyspaces, virtual: true }
    ];

    await Promise.all(queries.map(async (q) => {
      let result = null;
      try {
        result = await this.cc.query(q.query, waitReconnect);
      }
      catch (err) {
        if (q.virtual) {
          // Only throw error for non-virtual query as
          // server reporting C* 4.0 may not actually implement
          // virtual tables.
          return;
        }
        throw err;
      }
      for (let i = 0; i < result.rows.length; i++) {
        const ksInfo = this._parseKeyspace(result.rows[i], q.virtual);
        keyspaces[ksInfo.name] = ksInfo;
      }
    }));
    return keyspaces;
  }

  async getKeyspace(name) {
    const ks = await this._getKeyspace(_selectSingleKeyspaceV2, name, false);
    if (!ks) {
      // if not found, attempt to retrieve as virtual keyspace.
      return this._getKeyspace(_selectSingleVirtualKeyspace, name, true);
    }
    return ks;
  }

  async _getKeyspace(query, name, virtual) {
    try {
      const row = await this._getFirstRow(format(query, name));

      if (!row) {
        return null;
      }

      return this._parseKeyspace(row, virtual);
    }
    catch (err) {
      if (virtual) {
        // only throw error for non-virtual query as
        // server reporting C* 4.0 may not actually implement
        // virtual tables.
        return null;
      }
      throw err;
    }
  }
}

/**
 * Upon migration from thrift to CQL, we internally create a pair of surrogate clustering/regular columns
 * for compact static tables. These columns shouldn't be exposed to the user but are currently returned by C*.
 * We also need to remove the static keyword for all other columns in the table.
 * @param {module:metadata~TableMetadata} tableInfo
*/
function pruneStaticCompactTableColumns(tableInfo) {
  let i;
  let c;
  //remove "column1 text" clustering column
  for (i = 0; i < tableInfo.clusteringKeys.length; i++) {
    c = tableInfo.clusteringKeys[i];
    const index = tableInfo.columns.indexOf(c);
    tableInfo.columns.splice(index, 1);
    delete tableInfo.columnsByName[c.name];
  }
  tableInfo.clusteringKeys = utils$j.emptyArray;
  tableInfo.clusteringOrder = utils$j.emptyArray;
  //remove regular columns and set the static columns to non-static
  i = tableInfo.columns.length;
  while (i--) {
    c = tableInfo.columns[i];
    if (!c.isStatic && tableInfo.partitionKeys.indexOf(c) === -1) {
      // remove "value blob" regular column
      tableInfo.columns.splice(i, 1);
      delete tableInfo.columnsByName[c.name];
      continue;
    }
    c.isStatic = false;
  }
}

/**
 * Upon migration from thrift to CQL, we internally create a surrogate column "value" of type custom.
 * This column shouldn't be exposed to the user but is currently returned by C*.
 * @param {module:metadata~TableMetadata} tableInfo
 */
function pruneDenseTableColumns(tableInfo) {
  let i = tableInfo.columns.length;
  while (i--) {
    const c = tableInfo.columns[i];
    if (!c.isStatic && c.type.code === types$c.dataTypes.custom && c.type.info === 'empty') {
      // remove "value blob" regular column
      tableInfo.columns.splice(i, 1);
      delete tableInfo.columnsByName[c.name];
      continue;
    }
    c.isStatic = false;
  }
}

function getTokenToReplicaMapper(strategy, strategyOptions) {
  if (/SimpleStrategy$/.test(strategy)) {
    const rf = parseInt(strategyOptions['replication_factor'], 10);
    if (rf > 1) {
      return getTokenToReplicaSimpleMapper(rf);
    }
  }
  if (/NetworkTopologyStrategy$/.test(strategy)) {
    return getTokenToReplicaNetworkMapper(strategyOptions);
  }
  //default, wrap in an Array
  return (function noStrategy(tokenizer, ring, primaryReplicas) {
    const replicas = {};
    for (const key in primaryReplicas) {
      if (!primaryReplicas.hasOwnProperty(key)) {
        continue;
      }
      replicas[key] = [primaryReplicas[key]];
    }
    return replicas;
  });
}

/**
 * @param {Number} replicationFactor
 * @returns {function}
 */
function getTokenToReplicaSimpleMapper(replicationFactor) {
  return (function tokenSimpleStrategy(tokenizer, ringTokensAsStrings, primaryReplicas) {
    const ringLength = ringTokensAsStrings.length;
    const rf = Math.min(replicationFactor, ringLength);
    const replicas = {};
    for (let i = 0; i < ringLength; i++) {
      const key = ringTokensAsStrings[i];
      const tokenReplicas = [primaryReplicas[key]];
      for (let j = 1; j < ringLength && tokenReplicas.length < rf; j++) {
        let nextReplicaIndex = i + j;
        if (nextReplicaIndex >= ringLength) {
          //circle back
          nextReplicaIndex = nextReplicaIndex % ringLength;
        }
        const nextReplica = primaryReplicas[ringTokensAsStrings[nextReplicaIndex]];
        // In the case of vnodes, consecutive sections of the ring can be assigned to the same host.
        if (tokenReplicas.indexOf(nextReplica) === -1) {
          tokenReplicas.push(nextReplica);
        }
      }
      replicas[key] = tokenReplicas;
    }
    return replicas;
  });
}

/**
 * @param {Object} replicationFactors
 * @returns {Function}
 * @private
 */
function getTokenToReplicaNetworkMapper(replicationFactors) {
  //                A(DC1)
  //
  //           H         B(DC2)
  //                |
  //      G       --+--       C(DC1)
  //                |
  //           F         D(DC2)
  //
  //                E(DC1)
  return (function tokenNetworkStrategy(tokenizer, ringTokensAsStrings, primaryReplicas, datacenters) {
    const replicas = {};
    const ringLength = ringTokensAsStrings.length;

    for (let i = 0; i < ringLength; i++) {
      const key = ringTokensAsStrings[i];
      const tokenReplicas = [];
      const replicasByDc = {};
      const racksPlaced = {};
      const skippedHosts = [];
      for (let j = 0; j < ringLength; j++) {
        let nextReplicaIndex = i + j;
        if (nextReplicaIndex >= ringLength) {
          //circle back
          nextReplicaIndex = nextReplicaIndex % ringLength;
        }
        const h = primaryReplicas[ringTokensAsStrings[nextReplicaIndex]];
        // In the case of vnodes, consecutive sections of the ring can be assigned to the same host.
        if (tokenReplicas.indexOf(h) !== -1) {
          continue;
        }
        const dc = h.datacenter;
        //Check if the next replica belongs to one of the targeted dcs
        let dcRf = parseInt(replicationFactors[dc], 10);
        if (!dcRf) {
          continue;
        }
        dcRf = Math.min(dcRf, datacenters[dc].hostLength);
        let dcReplicas = replicasByDc[dc] || 0;
        //Amount of replicas per dc is greater than rf or the amount of host in the datacenter
        if (dcReplicas >= dcRf) {
          continue;
        }
        let racksPlacedInDc = racksPlaced[dc];
        if (!racksPlacedInDc) {
          racksPlacedInDc = racksPlaced[dc] = new utils$j.HashSet();
        }
        if (h.rack &&
            racksPlacedInDc.contains(h.rack) &&
            racksPlacedInDc.length < datacenters[dc].racks.length) {
          // We already selected a replica for this rack
          // Skip until replicas in other racks are added
          if (skippedHosts.length < dcRf - dcReplicas) {
            skippedHosts.push(h);
          }
          continue;
        }
        replicasByDc[h.datacenter] = ++dcReplicas;
        tokenReplicas.push(h);
        if (h.rack && racksPlacedInDc.add(h.rack) && racksPlacedInDc.length === datacenters[dc].racks.length) {
          // We finished placing all replicas for all racks in this dc
          // Add the skipped hosts
          replicasByDc[dc] += addSkippedHosts(dcRf, dcReplicas, tokenReplicas, skippedHosts);
        }
        if (isDoneForToken(replicationFactors, datacenters, replicasByDc)) {
          break;
        }
      }
      replicas[key] = tokenReplicas;
    }
    return replicas;
  });
}

/**
 * @returns {Number} The number of skipped hosts added.
 */
function addSkippedHosts(dcRf, dcReplicas, tokenReplicas, skippedHosts) {
  let i;
  for (i = 0; i < dcRf - dcReplicas && i < skippedHosts.length; i++) {
    tokenReplicas.push(skippedHosts[i]);
  }
  return i;
}

function isDoneForToken(replicationFactors, datacenters, replicasByDc) {
  const keys = Object.keys(replicationFactors);
  for (let i = 0; i < keys.length; i++) {
    const dcName = keys[i];
    const dc = datacenters[dcName];
    if (!dc) {
      // A DC is included in the RF but the DC does not exist in the topology
      continue;
    }
    const rf = Math.min(parseInt(replicationFactors[dcName], 10), dc.hostLength);
    if (rf > 0 && (!replicasByDc[dcName] || replicasByDc[dcName] < rf)) {
      return false;
    }
  }
  return true;
}

/**
 * Creates a new instance if the currentInstance is not valid for the
 * provided Cassandra version
 * @param {ClientOptions} options The client options
 * @param {ControlConnection} cc The control connection to be used
 * @param {Function} udtResolver The function to be used to retrieve the udts.
 * @param {Array.<Number>} [version] The cassandra version
 * @param {SchemaParser} [currentInstance] The current instance
 * @returns {SchemaParser}
 */
function getByVersion(options, cc, udtResolver, version, currentInstance) {
  let parserConstructor = SchemaParserV1;
  if (version && version[0] === 3) {
    parserConstructor = SchemaParserV2;
  } else if (version && version[0] >= 4) {
    parserConstructor = SchemaParserV3;
  }
  if (!currentInstance || !(currentInstance instanceof parserConstructor)){
    return new parserConstructor(options, cc, udtResolver);
  }
  return currentInstance;
}

schemaParser.getByVersion = getByVersion;
schemaParser.isDoneForToken = isDoneForToken;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const events$2 = require$$0;
const util$9 = require$$0$4;

/**
 * Module containing classes and fields related to metadata.
 * @module metadata
 */

const t$2 = tokenizer;
const utils$i = utils$K;
const errors$9 = errors$n;
const types$b = requireTypes();
const requests$4 = requests$7;
const schemaParserFactory = schemaParser;
const promiseUtils$6 = promiseUtils$e;
const { TokenRange } = token$3;
const { ExecutionOptions: ExecutionOptions$1 } = executionOptions;

/**
 * @const
 * @private
 */
const _selectTraceSession = "SELECT * FROM system_traces.sessions WHERE session_id=%s";
/**
 * @const
 * @private
 */
const _selectTraceEvents = "SELECT * FROM system_traces.events WHERE session_id=%s";
/**
 * @const
 * @private
 */
const _selectSchemaVersionPeers = "SELECT schema_version FROM system.peers";
/**
 * @const
 * @private
 */
const _selectSchemaVersionLocal = "SELECT schema_version FROM system.local";
/**
 * @const
 * @private
 */
const _traceMaxAttemps = 5;
/**
 * @const
 * @private
 */
const _traceAttemptDelay = 400;

/**
 * Represents cluster and schema information.
 * The metadata class acts as a internal state of the driver.
 */
let Metadata$2 = class Metadata {

  /**
   * Creates a new instance of {@link Metadata}.
   * @param {ClientOptions} options
   * @param {ControlConnection} controlConnection Control connection used to retrieve information.
   */
  constructor(options, controlConnection) {
    if (!options) {
      throw new errors$9.ArgumentError('Options are not defined');
    }

    Object.defineProperty(this, 'options', { value: options, enumerable: false, writable: false });
    Object.defineProperty(this, 'controlConnection', { value: controlConnection, enumerable: false, writable: false });
    this.keyspaces = {};
    this.initialized = false;
    this._isDbaas = false;
    this._schemaParser = schemaParserFactory.getByVersion(options, controlConnection, this.getUdt.bind(this));
    this.log = utils$i.log;
    this._preparedQueries = new PreparedQueries(options.maxPrepared, (...args) => this.log(...args));
  }

  /**
   * Sets the cassandra version
   * @internal
   * @ignore
   * @param {Array.<Number>} version
   */
  setCassandraVersion(version) {
    this._schemaParser = schemaParserFactory.getByVersion(
      this.options, this.controlConnection, this.getUdt.bind(this), version, this._schemaParser);
  }

  /**
   * Determines whether the cluster is provided as a service.
   * @returns {boolean} true when the cluster is provided as a service (DataStax Astra), <code>false<code> when it's a
   * different deployment (on-prem).
   */
  isDbaas() {
    return this._isDbaas;
  }

  /**
   * Sets the product type as DBaaS.
   * @internal
   * @ignore
   */
  setProductTypeAsDbaas() {
    this._isDbaas = true;
  }

  /**
   * @ignore
   * @param {String} partitionerName
   */
  setPartitioner(partitionerName) {
    if (/RandomPartitioner$/.test(partitionerName)) {
      return this.tokenizer = new t$2.RandomTokenizer();
    }
    if (/ByteOrderedPartitioner$/.test(partitionerName)) {
      return this.tokenizer = new t$2.ByteOrderedTokenizer();
    }
    return this.tokenizer = new t$2.Murmur3Tokenizer();
  }

  /**
   * Populates the information regarding primary replica per token, datacenters (+ racks) and sorted token ring.
   * @ignore
   * @param {HostMap} hosts
   */
  buildTokens(hosts) {
    if (!this.tokenizer) {
      return this.log('error', 'Tokenizer could not be determined');
    }
    //Get a sorted array of tokens
    const allSorted = [];
    //Get a map of <token, primaryHost>
    const primaryReplicas = {};
    //Depending on the amount of tokens, this could be an expensive operation
    const hostArray = hosts.values();
    const stringify = this.tokenizer.stringify;
    const datacenters = {};
    hostArray.forEach((h) => {
      if (!h.tokens) {
        return;
      }
      h.tokens.forEach((tokenString) => {
        const token = this.tokenizer.parse(tokenString);
        utils$i.insertSorted(allSorted, token, (t1, t2) => t1.compare(t2));
        primaryReplicas[stringify(token)] = h;
      });
      let dc = datacenters[h.datacenter];
      if (!dc) {
        dc = datacenters[h.datacenter] = {
          hostLength: 0,
          racks: new utils$i.HashSet()
        };
      }
      dc.hostLength++;
      dc.racks.add(h.rack);
    });
    //Primary replica for given token
    this.primaryReplicas = primaryReplicas;
    //All the tokens in ring order
    this.ring = allSorted;
    // Build TokenRanges.
    const tokenRanges = new Set();
    if (this.ring.length === 1) {
      // If there is only one token, return the range ]minToken, minToken]
      const min = this.tokenizer.minToken();
      tokenRanges.add(new TokenRange(min, min, this.tokenizer));
    }
    else {
      for (let i = 0; i < this.ring.length; i++) {
        const start = this.ring[i];
        const end = this.ring[(i + 1) % this.ring.length];
        tokenRanges.add(new TokenRange(start, end, this.tokenizer));
      }
    }
    this.tokenRanges = tokenRanges;
    //Compute string versions as it's potentially expensive and frequently reused later
    this.ringTokensAsStrings = new Array(allSorted.length);
    for (let i = 0; i < allSorted.length; i++) {
      this.ringTokensAsStrings[i] = stringify(allSorted[i]);
    }
    //Datacenter metadata (host length and racks)
    this.datacenters = datacenters;
  }

  /**
   * Gets the keyspace metadata information and updates the internal state of the driver.
   * <p>
   *   If a <code>callback</code> is provided, the callback is invoked when the keyspaces metadata refresh completes.
   *   Otherwise, it returns a <code>Promise</code>.
   * </p>
   * @param {String} name Name of the keyspace.
   * @param {Function} [callback] Optional callback.
   */
  refreshKeyspace(name, callback) {
    return promiseUtils$6.optionalCallback(this._refreshKeyspace(name), callback);
  }

  /**
   * @param {String} name
   * @private
   */
  async _refreshKeyspace(name) {
    if (!this.initialized) {
      throw this._uninitializedError();
    }
    this.log('info', util$9.format('Retrieving keyspace %s metadata', name));
    try {
      const ksInfo = await this._schemaParser.getKeyspace(name);
      if (!ksInfo) {
        // the keyspace was dropped
        delete this.keyspaces[name];
        return null;
      }
      // Tokens are lazily init on the keyspace, once a replica from that keyspace is retrieved.
      this.keyspaces[ksInfo.name] = ksInfo;
      return ksInfo;
    }
    catch (err) {
      this.log('error', 'There was an error while trying to retrieve keyspace information', err);
      throw err;
    }
  }

  /**
   * Gets the metadata information of all the keyspaces and updates the internal state of the driver.
   * <p>
   *   If a <code>callback</code> is provided, the callback is invoked when the keyspace metadata refresh completes.
   *   Otherwise, it returns a <code>Promise</code>.
   * </p>
   * @param {Boolean|Function} [waitReconnect] Determines if it should wait for reconnection in case the control connection is not
   * connected at the moment. Default: true.
   * @param {Function} [callback] Optional callback.
   */
  refreshKeyspaces(waitReconnect, callback) {
    if (typeof waitReconnect === 'function' || typeof waitReconnect === 'undefined') {
      callback = waitReconnect;
      waitReconnect = true;
    }
    if (!this.initialized) {
      const err = this._uninitializedError();
      if (callback) {
        return callback(err);
      }
      return Promise.reject(err);
    }
    return promiseUtils$6.optionalCallback(this.refreshKeyspacesInternal(waitReconnect), callback);
  }

  /**
   * @param {Boolean} waitReconnect
   * @returns {Promise<Object<string, Object>>}
   * @ignore
   * @internal
   */
  async refreshKeyspacesInternal(waitReconnect) {
    this.log('info', 'Retrieving keyspaces metadata');
    try {
      this.keyspaces = await this._schemaParser.getKeyspaces(waitReconnect);
      return this.keyspaces;
    }
    catch (err) {
      this.log('error', 'There was an error while trying to retrieve keyspaces information', err);
      throw err;
    }
  }

  _getKeyspaceReplicas(keyspace) {
    if (!keyspace.replicas) {
      //Calculate replicas the first time for the keyspace
      keyspace.replicas =
        keyspace.tokenToReplica(this.tokenizer, this.ringTokensAsStrings, this.primaryReplicas, this.datacenters);
    }
    return keyspace.replicas;
  }

  /**
   * Gets the host list representing the replicas that contain the given partition key, token or token range.
   * <p>
   *   It uses the pre-loaded keyspace metadata to retrieve the replicas for a token for a given keyspace.
   *   When the keyspace metadata has not been loaded, it returns null.
   * </p>
   * @param {String} keyspaceName
   * @param {Buffer|Token|TokenRange} token Can be Buffer (serialized partition key), Token or TokenRange
   * @returns {Array}
   */
  getReplicas(keyspaceName, token) {
    if (!this.ring) {
      return null;
    }
    if (Buffer.isBuffer(token)) {
      token = this.tokenizer.hash(token);
    }
    if (token instanceof TokenRange) {
      token = token.end;
    }
    let keyspace;
    if (keyspaceName) {
      keyspace = this.keyspaces[keyspaceName];
      if (!keyspace) {
        // the keyspace was not found, the metadata should be loaded beforehand
        return null;
      }
    }
    let i = utils$i.binarySearch(this.ring, token, (t1, t2) => t1.compare(t2));
    if (i < 0) {
      i = ~i;
    }
    if (i >= this.ring.length) {
      //it circled back
      i = i % this.ring.length;
    }
    const closestToken = this.ringTokensAsStrings[i];
    if (!keyspaceName) {
      return [this.primaryReplicas[closestToken]];
    }
    const replicas = this._getKeyspaceReplicas(keyspace);
    return replicas[closestToken];
  }

  /**
   * Gets the token ranges that define data distribution in the ring.
   *
   * @returns {Set<TokenRange>} The ranges of the ring or empty set if schema metadata is not enabled.
   */
  getTokenRanges() {
    return this.tokenRanges;
  }

  /**
   * Gets the token ranges that are replicated on the given host, for
   * the given keyspace.
   *
   * @param {String} keyspaceName The name of the keyspace to get ranges for.
   * @param {Host} host The host.
   * @returns {Set<TokenRange>|null} Ranges for the keyspace on this host or null if keyspace isn't found or hasn't been loaded.
   */
  getTokenRangesForHost(keyspaceName, host) {
    if (!this.ring) {
      return null;
    }
    let keyspace;
    if (keyspaceName) {
      keyspace = this.keyspaces[keyspaceName];
      if (!keyspace) {
        // the keyspace was not found, the metadata should be loaded beforehand
        return null;
      }
    }
    // If the ring has only 1 token, just return the ranges as we should only have a single node cluster.
    if (this.ring.length === 1) {
      return this.getTokenRanges();
    }
    const replicas = this._getKeyspaceReplicas(keyspace);
    const ranges = new Set();
    // for each range, find replicas for end token, if replicas include host, add range.
    this.tokenRanges.forEach((tokenRange) => {
      const replicasForToken = replicas[this.tokenizer.stringify(tokenRange.end)];
      if (replicasForToken.indexOf(host) !== -1) {
        ranges.add(tokenRange);
      }
    });
    return ranges;
  }

  /**
   * Constructs a Token from the input buffer(s) or string input.  If a string is passed in
   * it is assumed this matches the token representation reported by cassandra.
   * @param {Array<Buffer>|Buffer|String} components
   * @returns {Token} constructed token from the input buffer.
   */
  newToken(components) {
    if (!this.tokenizer) {
      throw new Error('Partitioner not established.  This should only happen if metadata was disabled or you have not connected yet.');
    }
    if (Array.isArray(components)) {
      return this.tokenizer.hash(Buffer.concat(components));
    }
    else if (util$9.isString(components)) {
      return this.tokenizer.parse(components);
    }
    return this.tokenizer.hash(components);
  }

  /**
   * Constructs a TokenRange from the given start and end tokens.
   * @param {Token} start
   * @param {Token} end
   * @returns TokenRange build range spanning from start (exclusive) to end (inclusive).
   */
  newTokenRange(start, end) {
    if (!this.tokenizer) {
      throw new Error('Partitioner not established.  This should only happen if metadata was disabled or you have not connected yet.');
    }
    return new TokenRange(start, end, this.tokenizer);
  }

  /**
   * Gets the metadata information already stored associated to a prepared statement
   * @param {String} keyspaceName
   * @param {String} query
   * @internal
   * @ignore
   */
  getPreparedInfo(keyspaceName, query) {
    return this._preparedQueries.getOrAdd(keyspaceName, query);
  }

  /**
   * Clears the internal state related to the prepared statements.
   * Following calls to the Client using the prepare flag will re-prepare the statements.
   */
  clearPrepared() {
    this._preparedQueries.clear();
  }

  /** @ignore */
  getPreparedById(id) {
    return this._preparedQueries.getById(id);
  }

  /** @ignore */
  setPreparedById(info) {
    return this._preparedQueries.setById(info);
  }

  /** @ignore */
  getAllPrepared() {
    return this._preparedQueries.getAll();
  }

  /** @ignore */
  _uninitializedError() {
    return new Error('Metadata has not been initialized.  This could only happen if you have not connected yet.');
  }

  /**
   * Gets the definition of an user-defined type.
   * <p>
   *   If a <code>callback</code> is provided, the callback is invoked when the metadata retrieval completes.
   *   Otherwise, it returns a <code>Promise</code>.
   * </p>
   * <p>
   * When trying to retrieve the same UDT definition concurrently, it will query once and invoke all callbacks
   * with the retrieved information.
   * </p>
   * @param {String} keyspaceName Name of the keyspace.
   * @param {String} name Name of the UDT.
   * @param {Function} [callback] The callback to invoke when retrieval completes.
   */
  getUdt(keyspaceName, name, callback) {
    return promiseUtils$6.optionalCallback(this._getUdt(keyspaceName, name), callback);
  }

  /**
   * @param {String} keyspaceName
   * @param {String} name
   * @returns {Promise<Object|null>}
   * @private
   */
  async _getUdt(keyspaceName, name) {
    if (!this.initialized) {
      throw this._uninitializedError();
    }
    let cache;
    if (this.options.isMetadataSyncEnabled) {
      const keyspace = this.keyspaces[keyspaceName];
      if (!keyspace) {
        return null;
      }
      cache = keyspace.udts;
    }
    return await this._schemaParser.getUdt(keyspaceName, name, cache);
  }

  /**
   * Gets the definition of a table.
   * <p>
   *   If a <code>callback</code> is provided, the callback is invoked when the metadata retrieval completes.
   *   Otherwise, it returns a <code>Promise</code>.
   * </p>
   * <p>
   * When trying to retrieve the same table definition concurrently, it will query once and invoke all callbacks
   * with the retrieved information.
   * </p>
   * @param {String} keyspaceName Name of the keyspace.
   * @param {String} name Name of the Table.
   * @param {Function} [callback] The callback with the err as a first parameter and the {@link TableMetadata} as
   * second parameter.
   */
  getTable(keyspaceName, name, callback) {
    return promiseUtils$6.optionalCallback(this._getTable(keyspaceName, name), callback);
  }

  /**
   * @param {String} keyspaceName
   * @param {String} name
   * @private
   */
  async _getTable(keyspaceName, name) {
    if (!this.initialized) {
      throw this._uninitializedError();
    }
    let cache;
    let virtual;
    if (this.options.isMetadataSyncEnabled) {
      const keyspace = this.keyspaces[keyspaceName];
      if (!keyspace) {
        return null;
      }
      cache = keyspace.tables;
      virtual = keyspace.virtual;
    }
    return await this._schemaParser.getTable(keyspaceName, name, cache, virtual);
  }

  /**
   * Gets the definition of CQL functions for a given name.
   * <p>
   *   If a <code>callback</code> is provided, the callback is invoked when the metadata retrieval completes.
   *   Otherwise, it returns a <code>Promise</code>.
   * </p>
   * <p>
   * When trying to retrieve the same function definition concurrently, it will query once and invoke all callbacks
   * with the retrieved information.
   * </p>
   * @param {String} keyspaceName Name of the keyspace.
   * @param {String} name Name of the Function.
   * @param {Function} [callback] The callback with the err as a first parameter and the array of {@link SchemaFunction}
   * as second parameter.
   */
  getFunctions(keyspaceName, name, callback) {
    return promiseUtils$6.optionalCallback(this._getFunctionsWrapper(keyspaceName, name), callback);
  }

  /**
   * @param {String} keyspaceName
   * @param {String} name
   * @private
   */
  async _getFunctionsWrapper(keyspaceName, name) {
    if (!keyspaceName || !name) {
      throw new errors$9.ArgumentError('You must provide the keyspace name and cql function name to retrieve the metadata');
    }
    const functionsMap = await this._getFunctions(keyspaceName, name, false);
    return Array.from(functionsMap.values());
  }

  /**
   * Gets a definition of CQL function for a given name and signature.
   * <p>
   *   If a <code>callback</code> is provided, the callback is invoked when the metadata retrieval completes.
   *   Otherwise, it returns a <code>Promise</code>.
   * </p>
   * <p>
   * When trying to retrieve the same function definition concurrently, it will query once and invoke all callbacks
   * with the retrieved information.
   * </p>
   * @param {String} keyspaceName Name of the keyspace
   * @param {String} name Name of the Function
   * @param {Array.<String>|Array.<{code, info}>} signature Array of types of the parameters.
   * @param {Function} [callback] The callback with the err as a first parameter and the {@link SchemaFunction} as second
   * parameter.
   */
  getFunction(keyspaceName, name, signature, callback) {
    return promiseUtils$6.optionalCallback(this._getSingleFunction(keyspaceName, name, signature, false), callback);
  }

  /**
   * Gets the definition of CQL aggregate for a given name.
   * <p>
   *   If a <code>callback</code> is provided, the callback is invoked when the metadata retrieval completes.
   *   Otherwise, it returns a <code>Promise</code>.
   * </p>
   * <p>
   * When trying to retrieve the same aggregates definition concurrently, it will query once and invoke all callbacks
   * with the retrieved information.
   * </p>
   * @param {String} keyspaceName Name of the keyspace
   * @param {String} name Name of the Function
   * @param {Function} [callback] The callback with the err as a first parameter and the array of {@link Aggregate} as
   * second parameter.
   */
  getAggregates(keyspaceName, name, callback) {
    return promiseUtils$6.optionalCallback(this._getAggregates(keyspaceName, name), callback);
  }

  /**
   * @param {String} keyspaceName
   * @param {String} name
   * @private
   */
  async _getAggregates(keyspaceName, name) {
    if (!keyspaceName || !name) {
      throw new errors$9.ArgumentError('You must provide the keyspace name and cql aggregate name to retrieve the metadata');
    }
    const functionsMap = await this._getFunctions(keyspaceName, name, true);
    return Array.from(functionsMap.values());
  }

  /**
   * Gets a definition of CQL aggregate for a given name and signature.
   * <p>
   *   If a <code>callback</code> is provided, the callback is invoked when the metadata retrieval completes.
   *   Otherwise, it returns a <code>Promise</code>.
   * </p>
   * <p>
   * When trying to retrieve the same aggregate definition concurrently, it will query once and invoke all callbacks
   * with the retrieved information.
   * </p>
   * @param {String} keyspaceName Name of the keyspace
   * @param {String} name Name of the aggregate
   * @param {Array.<String>|Array.<{code, info}>} signature Array of types of the parameters.
   * @param {Function} [callback] The callback with the err as a first parameter and the {@link Aggregate} as second parameter.
   */
  getAggregate(keyspaceName, name, signature, callback) {
    return promiseUtils$6.optionalCallback(this._getSingleFunction(keyspaceName, name, signature, true), callback);
  }

  /**
   * Gets the definition of a CQL materialized view for a given name.
   * <p>
   *   If a <code>callback</code> is provided, the callback is invoked when the metadata retrieval completes.
   *   Otherwise, it returns a <code>Promise</code>.
   * </p>
   * <p>
   *   Note that, unlike the rest of the {@link Metadata} methods, this method does not cache the result for following
   *   calls, as the current version of the Cassandra native protocol does not support schema change events for
   *   materialized views. Each call to this method will produce one or more queries to the cluster.
   * </p>
   * @param {String} keyspaceName Name of the keyspace
   * @param {String} name Name of the materialized view
   * @param {Function} [callback] The callback with the err as a first parameter and the {@link MaterializedView} as
   * second parameter.
   */
  getMaterializedView(keyspaceName, name, callback) {
    return promiseUtils$6.optionalCallback(this._getMaterializedView(keyspaceName, name), callback);
  }

  /**
   * @param {String} keyspaceName
   * @param {String} name
   * @returns {Promise<MaterializedView|null>}
   * @private
   */
  async _getMaterializedView(keyspaceName, name) {
    if (!this.initialized) {
      throw this._uninitializedError();
    }
    let cache;
    if (this.options.isMetadataSyncEnabled) {
      const keyspace = this.keyspaces[keyspaceName];
      if (!keyspace) {
        return null;
      }
      cache = keyspace.views;
    }
    return await this._schemaParser.getMaterializedView(keyspaceName, name, cache);
  }

  /**
   * Gets a map of cql function definitions or aggregates based on signature.
   * @param {String} keyspaceName
   * @param {String} name Name of the function or aggregate
   * @param {Boolean} aggregate
   * @returns {Promise<Map>}
   * @private
   */
  async _getFunctions(keyspaceName, name, aggregate) {
    if (!this.initialized) {
      throw this._uninitializedError();
    }
    let cache;
    if (this.options.isMetadataSyncEnabled) {
      const keyspace = this.keyspaces[keyspaceName];
      if (!keyspace) {
        return new Map();
      }
      cache = aggregate ? keyspace.aggregates : keyspace.functions;
    }
    return await this._schemaParser.getFunctions(keyspaceName, name, aggregate, cache);
  }

  /**
   * Gets a single cql function or aggregate definition
   * @param {String} keyspaceName
   * @param {String} name
   * @param {Array} signature
   * @param {Boolean} aggregate
   * @returns {Promise<SchemaFunction|Aggregate|null>}
   * @private
   */
  async _getSingleFunction(keyspaceName, name, signature, aggregate) {
    if (!keyspaceName || !name) {
      throw new errors$9.ArgumentError('You must provide the keyspace name and cql function name to retrieve the metadata');
    }
    if (!Array.isArray(signature)) {
      throw new errors$9.ArgumentError('Signature must be an array of types');
    }
    signature = signature.map(item => {
      if (typeof item === 'string') {
        return item;
      }
      return types$b.getDataTypeNameByCode(item);
    });
    const functionsMap = await this._getFunctions(keyspaceName, name, aggregate);
    return functionsMap.get(signature.join(',')) || null;
  }

  /**
   * Gets the trace session generated by Cassandra when query tracing is enabled for the
   * query. The trace itself is stored in Cassandra in the <code>sessions</code> and
   * <code>events</code> table in the <code>system_traces</code> keyspace and can be
   * retrieve manually using the trace identifier.
   * <p>
   *   If a <code>callback</code> is provided, the callback is invoked when the metadata retrieval completes.
   *   Otherwise, it returns a <code>Promise</code>.
   * </p>
   * @param {Uuid} traceId Identifier of the trace session.
   * @param {Number} [consistency] The consistency level to obtain the trace.
   * @param {Function} [callback] The callback with the err as first parameter and the query trace as second parameter.
   */
  getTrace(traceId, consistency, callback) {
    if (!callback && typeof consistency === 'function') {
      // Both callback and consistency are optional parameters
      // In this case, the second parameter is the callback
      callback = consistency;
      consistency = null;
    }

    return promiseUtils$6.optionalCallback(this._getTrace(traceId, consistency), callback);
  }

  /**
   * @param {Uuid} traceId
   * @param {Number} consistency
   * @returns {Promise<Object>}
   * @private
   */
  async _getTrace(traceId, consistency) {
    if (!this.initialized) {
      throw this._uninitializedError();
    }

    let trace;
    let attempts = 0;
    const info = ExecutionOptions$1.empty();
    info.getConsistency = () => consistency;

    const sessionRequest = new requests$4.QueryRequest(util$9.format(_selectTraceSession, traceId), null, info);
    const eventsRequest = new requests$4.QueryRequest(util$9.format(_selectTraceEvents, traceId), null, info);

    while (!trace && (attempts++ < _traceMaxAttemps)) {
      const sessionResponse = await this.controlConnection.query(sessionRequest);
      const sessionRow = sessionResponse.rows[0];

      if (!sessionRow || typeof sessionRow['duration'] !== 'number') {
        await promiseUtils$6.delay(_traceAttemptDelay);
        continue;
      }

      trace = {
        requestType: sessionRow['request'],
        coordinator: sessionRow['coordinator'],
        parameters: sessionRow['parameters'],
        startedAt: sessionRow['started_at'],
        duration: sessionRow['duration'],
        clientAddress: sessionRow['client'],
        events: null
      };

      const eventsResponse = await this.controlConnection.query(eventsRequest);
      trace.events = eventsResponse.rows.map(row => ({
        id: row['event_id'],
        activity: row['activity'],
        source: row['source'],
        elapsed: row['source_elapsed'],
        thread: row['thread']
      }));
    }

    if (!trace) {
      throw new Error(`Trace ${traceId.toString()} could not fully retrieved after ${_traceMaxAttemps} attempts`);
    }

    return trace;
  }

  /**
   * Checks whether hosts that are currently up agree on the schema definition.
   * <p>
   *   This method performs a one-time check only, without any form of retry; therefore
   *   <code>protocolOptions.maxSchemaAgreementWaitSeconds</code> setting does not apply in this case.
   * </p>
   * @param {Function} [callback] A function that is invoked with a value
   * <code>true</code> when all hosts agree on the schema and <code>false</code> when there is no agreement or when
   * the check could not be performed (for example, if the control connection is down).
   * @returns {Promise} Returns a <code>Promise</code> when a callback is not provided. The promise resolves to
   * <code>true</code> when all hosts agree on the schema and <code>false</code> when there is no agreement or when
   * the check could not be performed (for example, if the control connection is down).
   */
  checkSchemaAgreement(callback) {
    return promiseUtils$6.optionalCallback(this._checkSchemaAgreement(), callback);
  }

  /**
   * Async-only version of check schema agreement.
   * @private
   */
  async _checkSchemaAgreement() {
    const connection = this.controlConnection.connection;
    if (!connection) {
      return false;
    }
    try {
      return await this.compareSchemaVersions(connection);
    }
    catch (err) {
      return false;
    }
  }

  /**
   * Uses the metadata to fill the user provided parameter hints
   * @param {String} keyspace
   * @param {Array} hints
   * @internal
   * @ignore
   */
  async adaptUserHints(keyspace, hints) {
    if (!Array.isArray(hints)) {
      return;
    }
    const udts = [];
    // Check for udts and get the metadata
    for (let i = 0; i < hints.length; i++) {
      const hint = hints[i];
      if (typeof hint !== 'string') {
        continue;
      }

      const type = types$b.dataTypes.getByName(hint);
      this._checkUdtTypes(udts, type, keyspace);
      hints[i] = type;
    }

    for (const type of udts) {
      const udtInfo = await this.getUdt(type.info.keyspace, type.info.name);
      if (!udtInfo) {
        throw new TypeError('User defined type not found: ' + type.info.keyspace + '.' + type.info.name);
      }
      type.info = udtInfo;
    }
  }

  /**
   * @param {Array} udts
   * @param {{code, info}} type
   * @param {string} keyspace
   * @private
   */
  _checkUdtTypes(udts, type, keyspace) {
    if (type.code === types$b.dataTypes.udt) {
      const udtName = type.info.split('.');
      type.info = {
        keyspace: udtName[0],
        name: udtName[1]
      };
      if (!type.info.name) {
        if (!keyspace) {
          throw new TypeError('No keyspace specified for udt: ' + udtName.join('.'));
        }
        //use the provided keyspace
        type.info.name = type.info.keyspace;
        type.info.keyspace = keyspace;
      }
      udts.push(type);
      return;
    }

    if (!type.info) {
      return;
    }
    if (type.code === types$b.dataTypes.list || type.code === types$b.dataTypes.set) {
      return this._checkUdtTypes(udts, type.info, keyspace);
    }
    if (type.code === types$b.dataTypes.map) {
      this._checkUdtTypes(udts, type.info[0], keyspace);
      this._checkUdtTypes(udts, type.info[1], keyspace);
    }
  }

  /**
   * Uses the provided connection to query the schema versions and compare them.
   * @param {Connection} connection
   * @internal
   * @ignore
   */
  async compareSchemaVersions(connection) {
    const versions = new Set();
    const response1 = await connection.send(new requests$4.QueryRequest(_selectSchemaVersionLocal), null);
    if (response1 && response1.rows && response1.rows.length === 1) {
      versions.add(response1.rows[0]['schema_version'].toString());
    }
    const response2 = await connection.send(new requests$4.QueryRequest(_selectSchemaVersionPeers), null);
    if (response2 && response2.rows) {
      for (const row of response2.rows) {
        const value = row['schema_version'];
        if (!value) {
          continue;
        }
        versions.add(value.toString());
      }
    }
    return versions.size === 1;
  }
};

/**
 * Allows to store prepared queries and retrieval by query or query id.
 * @ignore
 */
class PreparedQueries {

  /**
   * @param {Number} maxPrepared
   * @param {Function} logger
   */
  constructor(maxPrepared, logger) {
    this.length = 0;
    this._maxPrepared = maxPrepared;
    this._mapByKey = new Map();
    this._mapById = new Map();
    this._logger = logger;
  }

  _getKey(keyspace, query) {
    return (keyspace || '') + query;
  }

  getOrAdd(keyspace, query) {
    const key = this._getKey(keyspace, query);
    let info = this._mapByKey.get(key);
    if (info) {
      return info;
    }

    this._validateOverflow();

    info = new events$2.EventEmitter();
    info.setMaxListeners(0);
    info.query = query;
    // The keyspace in which it was prepared
    info.keyspace = keyspace;
    this._mapByKey.set(key, info);
    this.length++;
    return info;
  }

  _validateOverflow() {
    if (this.length < this._maxPrepared) {
      return;
    }

    const toRemove = [];
    this._logger('warning',
      'Prepared statements exceeded maximum. This could be caused by preparing queries that contain parameters');

    const toRemoveLength = this.length - this._maxPrepared + 1;

    for (const [key, info] of this._mapByKey) {
      if (!info.queryId) {
        // Only remove queries that contain queryId
        continue;
      }

      const length = toRemove.push([key, info]);
      if (length >= toRemoveLength) {
        break;
      }
    }

    for (const [key, info] of toRemove) {
      this._mapByKey.delete(key);
      this._mapById.delete(info.queryId.toString('hex'));
      this.length--;
    }
  }

  setById(info) {
    this._mapById.set(info.queryId.toString('hex'), info);
  }

  getById(id) {
    return this._mapById.get(id.toString('hex'));
  }

  clear() {
    this._mapByKey = new Map();
    this._mapById = new Map();
    this.length = 0;
  }

  getAll() {
    return Array.from(this._mapByKey.values()).filter(info => !!info.queryId);
  }
}

var metadata = Metadata$2;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const util$8 = require$$0$4;
const utils$h = utils$K;
const promiseUtils$5 = promiseUtils$e;

const _queueOverflowThreshold = 1000;

/**
 * Debounce protocol events by acting on those events with a sliding delay.
 * @ignore
 * @constructor
 */
let EventDebouncer$1 = class EventDebouncer {

  /**
   * Creates a new instance of the event debouncer.
   * @param {Number} delay
   * @param {Function} logger
   */
  constructor(delay, logger) {
    this._delay = delay;
    this._logger = logger;
    this._queue = null;
    this._timeout = null;
  }

  /**
   * Adds a new event to the queue and moves the delay.
   * @param {{ handler: Function, all: boolean|undefined, keyspace: String|undefined,
   * cqlObject: String|null|undefined }} event
   * @param {Boolean} processNow
   * @returns {Promise}
   */
  eventReceived(event, processNow) {
    return new Promise((resolve, reject) => {
      event.callback = promiseUtils$5.getCallback(resolve, reject);
      this._queue = this._queue || { callbacks: [], keyspaces: {} };
      const delay = !processNow ? this._delay : 0;
      if (event.all) {
        // when an event marked with all is received, it supersedes all the rest of events
        // a full update (hosts + keyspaces + tokens) is going to be made
        this._queue.mainEvent = event;
      }
      if (this._queue.callbacks.length === _queueOverflowThreshold) {
        // warn once
        this._logger('warn', util$8.format('Event debouncer queue exceeded %d events', _queueOverflowThreshold));
      }
      this._queue.callbacks.push(event.callback);
      if (this._queue.mainEvent) {
        // a full refresh is scheduled and the callback was added, nothing else to do.
        return this._slideDelay(delay);
      }
      // Insert at keyspace level
      let keyspaceEvents = this._queue.keyspaces[event.keyspace];
      if (!keyspaceEvents) {
        keyspaceEvents = this._queue.keyspaces[event.keyspace] = { events: [] };
      }
      if (event.cqlObject === undefined) {
        // a full refresh of the keyspace, supersedes all child keyspace events
        keyspaceEvents.mainEvent = event;
      }
      keyspaceEvents.events.push(event);
      this._slideDelay(delay);
    });
  }

  /**
   * @param {Number} delay
   * @private
   * */
  _slideDelay(delay) {
    const self = this;
    function process() {
      const q = self._queue;
      self._queue = null;
      self._timeout = null;
      processQueue(q);
    }
    if (delay === 0) {
      // no delay, process immediately
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      return process();
    }
    const previousTimeout = this._timeout;
    // Add the new timeout before removing the previous one performs better
    this._timeout = setTimeout(process, delay);
    if (previousTimeout) {
      clearTimeout(previousTimeout);
    }
  }

  /**
   * Clears the timeout and invokes all pending callback.
   */
  shutdown() {
    if (!this._queue) {
      return;
    }
    this._queue.callbacks.forEach(function (cb) {
      cb();
    });
    this._queue = null;
    clearTimeout(this._timeout);
    this._timeout = null;
  }
};

/**
 * @param {{callbacks: Array, keyspaces: Object, mainEvent: Object}} q
 * @private
 */
function processQueue (q) {
  if (q.mainEvent) {
    // refresh all by invoking 1 handler and invoke all pending callbacks
    return promiseUtils$5.toCallback(q.mainEvent.handler(), (err) => {
      for (let i = 0; i < q.callbacks.length; i++) {
        q.callbacks[i](err);
      }
    });
  }

  utils$h.each(Object.keys(q.keyspaces), function eachKeyspace(name, next) {
    const keyspaceEvents = q.keyspaces[name];
    if (keyspaceEvents.mainEvent) {
      // refresh a keyspace
      return promiseUtils$5.toCallback(keyspaceEvents.mainEvent.handler(), function mainEventCallback(err) {
        for (let i = 0; i < keyspaceEvents.events.length; i++) {
          keyspaceEvents.events[i].callback(err);
        }

        next();
      });
    }

    // deal with individual handlers and callbacks
    keyspaceEvents.events.forEach(event => {
      // sync handlers
      event.handler();
      event.callback();
    });

    next();
  });
}

var eventDebouncer = EventDebouncer$1;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const events$1 = require$$0;
const util$7 = require$$0$4;
const net = require$$1$2;
const dns = require$$0$7;

const errors$8 = errors$n;
const { Host, HostMap } = host;
const Metadata$1 = metadata;
const EventDebouncer = eventDebouncer;
const Connection = connection;
const requests$3 = requests$7;
const utils$g = utils$K;
const types$a = requireTypes();
const promiseUtils$4 = promiseUtils$e;
const f = util$7.format;

const selectPeers = "SELECT * FROM system.peers";
const selectLocal = "SELECT * FROM system.local WHERE key='local'";
const newNodeDelay = 1000;
const metadataQueryAbortTimeout = 2000;
const schemaChangeTypes = {
  created: 'CREATED',
  updated: 'UPDATED',
  dropped: 'DROPPED'
};
const supportedProductTypeKey = 'PRODUCT_TYPE';
const supportedDbaas = 'DATASTAX_APOLLO';

/**
 * Represents a connection used by the driver to receive events and to check the status of the cluster.
 * <p>It uses an existing connection from the hosts' connection pool to maintain the driver metadata up-to-date.</p>
 */
let ControlConnection$1 = class ControlConnection extends events$1.EventEmitter {

  /**
   * Creates a new instance of <code>ControlConnection</code>.
   * @param {Object} options
   * @param {ProfileManager} profileManager
   * @param {{borrowHostConnection: function, createConnection: function}} [context] An object containing methods to
   * allow dependency injection.
   */
  constructor(options, profileManager, context) {
    super();

    this.protocolVersion = null;
    this.hosts = new HostMap();
    this.setMaxListeners(0);
    this.log = utils$g.log;
    Object.defineProperty(this, "options", { value: options, enumerable: false, writable: false});

    /**
     * Cluster metadata that is going to be shared between the Client and ControlConnection
     */
    this.metadata = new Metadata$1(this.options, this);
    this.initialized = false;

    /**
     * Host used by the control connection
     * @type {Host|null}
     */
    this.host = null;

    /**
     * Connection used to retrieve metadata and subscribed to events
     * @type {Connection|null}
     */
    this.connection = null;

    this._addressTranslator = this.options.policies.addressResolution;
    this._reconnectionPolicy = this.options.policies.reconnection;
    this._reconnectionSchedule = this._reconnectionPolicy.newSchedule();
    this._isShuttingDown = false;

    // Reference to the encoder of the last valid connection
    this._encoder = null;
    this._debouncer = new EventDebouncer(options.refreshSchemaDelay, this.log.bind(this));
    this._profileManager = profileManager;
    this._triedHosts = null;
    this._resolvedContactPoints = new Map();
    this._contactPoints = new Set();

    // Timeout used for delayed handling of topology changes
    this._topologyChangeTimeout = null;
    // Timeout used for delayed handling of node status changes
    this._nodeStatusChangeTimeout = null;

    if (context && context.borrowHostConnection) {
      this._borrowHostConnection = context.borrowHostConnection;
    }

    if (context && context.createConnection) {
      this._createConnection = context.createConnection;
    }
  }

  /**
   * Stores the contact point information and what it resolved to.
   * @param {String|null} address
   * @param {String} port
   * @param {String} name
   * @param {Boolean} isIPv6
   */
  _addContactPoint(address, port, name, isIPv6) {
    if (address === null) {
      // Contact point could not be resolved, store that the resolution came back empty
      this._resolvedContactPoints.set(name, utils$g.emptyArray);
      return;
    }

    const portNumber = parseInt(port, 10) || this.options.protocolOptions.port;
    const endpoint = `${address}:${portNumber}`;
    this._contactPoints.add(endpoint);

    // Use RFC 3986 for IPv4 and IPv6
    const standardEndpoint = !isIPv6 ? endpoint : `[${address}]:${portNumber}`;

    let resolvedAddressedByName = this._resolvedContactPoints.get(name);

    // NODEJS-646
    //
    // We might have a frozen empty array if DNS resolution wasn't working when this name was
    // initially added, and if that's the case we can't add anything.  Detect that case and
    // reset to a mutable array.
    if (resolvedAddressedByName === undefined || resolvedAddressedByName === utils$g.emptyArray) {
      resolvedAddressedByName = [];
      this._resolvedContactPoints.set(name, resolvedAddressedByName);
    }

    resolvedAddressedByName.push(standardEndpoint);
  }

  async _parseContactPoint(name) {
    let addressOrName = name;
    let port = null;

    if (name.indexOf('[') === 0 && name.indexOf(']:') > 1) {
      // IPv6 host notation [ip]:port (RFC 3986 section 3.2.2)
      const index = name.lastIndexOf(']:');
      addressOrName = name.substr(1, index - 1);
      port = name.substr(index + 2);
    } else if (name.indexOf(':') > 0) {
      // IPv4 or host name with port notation
      const parts = name.split(':');
      if (parts.length === 2) {
        addressOrName = parts[0];
        port = parts[1];
      }
    }

    if (net.isIP(addressOrName)) {
      this._addContactPoint(addressOrName, port, name, net.isIPv6(addressOrName));
      return;
    }

    const addresses = await this._resolveAll(addressOrName);
    if (addresses.length > 0) {
      addresses.forEach(addressInfo => this._addContactPoint(addressInfo.address, port, name, addressInfo.isIPv6));
    } else {
      // Store that we attempted resolving the name but was not found
      this._addContactPoint(null, null, name, false);
    }
  }

  /**
   * Initializes the control connection by establishing a Connection using a suitable protocol
   * version to be used and retrieving cluster metadata.
   */
  async init() {
    if (this.initialized) {
      // Prevent multiple serial initializations
      return;
    }

    if (!this.options.sni) {
      // Parse and resolve contact points
      await Promise.all(this.options.contactPoints.map(name => this._parseContactPoint(name)));
    } else {
      this.options.contactPoints.forEach(cp => this._contactPoints.add(cp));
      const address = this.options.sni.address;
      const separatorIndex = address.lastIndexOf(':');

      if (separatorIndex === -1) {
        throw new new errors$8.DriverInternalError('The SNI endpoint address should contain ip/name and port');
      }

      const nameOrIp = address.substr(0, separatorIndex);
      this.options.sni.port = address.substr(separatorIndex + 1);
      this.options.sni.addressResolver = new utils$g.AddressResolver({ nameOrIp, dns });
      await this.options.sni.addressResolver.init();
    }

    if (this._contactPoints.size === 0) {
      throw new errors$8.NoHostAvailableError({}, 'No host could be resolved');
    }

    await this._initializeConnection();
  }

  _setHealthListeners(host, connection) {
    const self = this;
    let wasRefreshCalled = 0;

    function removeListeners() {
      host.removeListener('down', downOrIgnoredHandler);
      host.removeListener('ignore', downOrIgnoredHandler);
      connection.removeListener('socketClose', socketClosedHandler);
    }

    function startReconnecting(hostDown) {
      if (wasRefreshCalled++ !== 0) {
        // Prevent multiple calls to reconnect
        return;
      }

      removeListeners();

      if (self._isShuttingDown) {
        // Don't attempt to reconnect when the ControlConnection is being shutdown
        return;
      }

      if (hostDown) {
        self.log('warning',
          `Host ${host.address} used by the ControlConnection DOWN, ` +
          `connection to ${connection.endpointFriendlyName} will not longer be used`);
      } else {
        self.log('warning', `Connection to ${connection.endpointFriendlyName} used by the ControlConnection was closed`);
      }

      promiseUtils$4.toBackground(self._refresh());
    }

    function downOrIgnoredHandler() {
      startReconnecting(true);
    }

    function socketClosedHandler() {
      startReconnecting(false);
    }

    host.once('down', downOrIgnoredHandler);
    host.once('ignore', downOrIgnoredHandler);
    connection.once('socketClose', socketClosedHandler);
  }

  /**
   * Iterates through the hostIterator and Gets the following open connection.
   * @param {Iterator<Host>} hostIterator
   * @returns {Connection!}
   */
  _borrowAConnection(hostIterator) {
    let connection = null;

    while (!connection) {
      const item = hostIterator.next();
      const host = item.value;

      if (item.done) {
        throw new errors$8.NoHostAvailableError(this._triedHosts);
      }

      // Only check distance once the load-balancing policies have been initialized
      const distance = this._profileManager.getDistance(host);
      if (!host.isUp() || distance === types$a.distance.ignored) {
        continue;
      }

      try {
        connection = this._borrowHostConnection(host);
      } catch (err) {
        this._triedHosts[host.address] = err;
      }
    }

    return connection;
  }

  /**
   * Iterates through the contact points and tries to open a connection.
   * @param {Iterator<string>} contactPointsIterator
   * @returns {Promise<void>}
   */
  async _borrowFirstConnection(contactPointsIterator) {
    let connection = null;

    while (!connection) {
      const item = contactPointsIterator.next();
      const contactPoint = item.value;

      if (item.done) {
        throw new errors$8.NoHostAvailableError(this._triedHosts);
      }

      try {
        connection = await this._createConnection(contactPoint);
      } catch (err) {
        this._triedHosts[contactPoint] = err;
      }
    }

    if (!connection) {
      const err = new errors$8.NoHostAvailableError(this._triedHosts);
      this.log('error', 'ControlConnection failed to acquire a connection');
      throw err;
    }

    this.protocolVersion = connection.protocolVersion;
    this._encoder = connection.encoder;
    this.connection = connection;
  }

  /** Default implementation for borrowing connections, that can be injected at constructor level */
  _borrowHostConnection(host) {
    // Borrow any open connection, regardless of the keyspace
    return host.borrowConnection();
  }

  /**
   * Default implementation for creating initial connections, that can be injected at constructor level
   * @param {String} contactPoint
   */
  async _createConnection(contactPoint) {
    const c = new Connection(contactPoint, null, this.options);

    try {
      await c.openAsync();
    } catch (err) {
      promiseUtils$4.toBackground(c.closeAsync());
      throw err;
    }

    return c;
  }

  /**
   * Gets the info from local and peer metadata, reloads the keyspaces metadata and rebuilds tokens.
   * <p>It throws an error when there's a failure or when reconnecting and there's no connection.</p>
   * @param {Boolean} initializing Determines whether this function was called in order to initialize the control
   * connection the first time
   * @param {Boolean} isReconnecting Determines whether the refresh is being done because the ControlConnection is
   * switching to use this connection to this host.
   */
  async _refreshHosts(initializing, isReconnecting) {
    // Get a reference to the current connection as it might change from external events
    const c = this.connection;

    if (!c) {
      if (isReconnecting) {
        throw new errors$8.DriverInternalError('Connection reference has been lost when reconnecting');
      }

      // it's possible that this was called as a result of a topology change, but the connection was lost
      // between scheduling time and now. This will be called again when there is a new connection.
      return;
    }

    this.log('info', 'Refreshing local and peers info');

    const rsLocal = await c.send(new requests$3.QueryRequest(selectLocal), null);
    this._setLocalInfo(initializing, isReconnecting, c, rsLocal);

    if (!this.host) {
      throw new errors$8.DriverInternalError('Information from system.local could not be retrieved');
    }

    const rsPeers = await c.send(new requests$3.QueryRequest(selectPeers), null);
    await this.setPeersInfo(initializing, rsPeers);

    if (!this.initialized) {
      // resolve protocol version from highest common version among hosts.
      const highestCommon = types$a.protocolVersion.getHighestCommon(c, this.hosts);
      const reconnect = highestCommon !== this.protocolVersion;

      // set protocol version on each host.
      this.protocolVersion = highestCommon;
      this.hosts.forEach(h => h.setProtocolVersion(this.protocolVersion));

      // if protocol version changed, reconnect the control connection with new version.
      if (reconnect) {
        this.log('info', `Reconnecting since the protocol version changed to 0x${highestCommon.toString(16)}`);
        c.decreaseVersion(this.protocolVersion);
        await c.closeAsync();

        try {
          await c.openAsync();
        } catch (err) {
          // Close in the background
          promiseUtils$4.toBackground(c.closeAsync());

          throw err;
        }
      }

      // To acquire metadata we need to specify the cassandra version
      this.metadata.setCassandraVersion(this.host.getCassandraVersion());
      this.metadata.buildTokens(this.hosts);

      if (!this.options.isMetadataSyncEnabled) {
        this.metadata.initialized = true;
        return;
      }

      await this.metadata.refreshKeyspacesInternal(false);
      this.metadata.initialized = true;
    }
  }

  async _refreshControlConnection(hostIterator) {

    if (this.options.sni) {
      this.connection = this._borrowAConnection(hostIterator);
    }
    else {
      try { this.connection = this._borrowAConnection(hostIterator); }
      catch(err) {

        /* NODEJS-632: refresh nodes before getting hosts for reconnect since some hostnames may have
         * shifted during the flight. */
        this.log("info", "ControlConnection could not reconnect using existing connections.  Refreshing contact points and retrying");
        this._contactPoints.clear();
        this._resolvedContactPoints.clear();
        await Promise.all(this.options.contactPoints.map(name => this._parseContactPoint(name)));
        const refreshedContactPoints = Array.from(this._contactPoints).join(',');
        this.log('info', `Refreshed contact points: ${refreshedContactPoints}`);
        await this._initializeConnection();
      }
    }
  }

  /**
   * Acquires a new connection and refreshes topology and keyspace metadata.
   * <p>When it fails obtaining a connection and there aren't any more hosts, it schedules reconnection.</p>
   * <p>When it fails obtaining the metadata, it marks connection and/or host unusable and retries using the same
   * iterator from query plan / host list</p>
   * @param {Iterator<Host>} [hostIterator]
   */
  async _refresh(hostIterator) {
    if (this._isShuttingDown) {
      this.log('info', 'The ControlConnection will not be refreshed as the Client is being shutdown');
      return;
    }

    // Reset host and connection
    this.host = null;
    this.connection = null;

    try {
      if (!hostIterator) {
        this.log('info', 'Trying to acquire a connection to a new host');
        this._triedHosts = {};
        hostIterator = await promiseUtils$4.newQueryPlan(this._profileManager.getDefaultLoadBalancing(), null, null);
      }

      await this._refreshControlConnection(hostIterator);
    } catch (err) {
      // There was a failure obtaining a connection or during metadata retrieval
      this.log('error', 'ControlConnection failed to acquire a connection', err);

      if (!this._isShuttingDown) {
        const delay = this._reconnectionSchedule.next().value;
        this.log('warning', `ControlConnection could not reconnect, scheduling reconnection in ${delay}ms`);
        setTimeout(() => this._refresh(), delay);
        this.emit('newConnection', err);
      }

      return;
    }

    this.log('info',`ControlConnection connected to ${this.connection.endpointFriendlyName}`);

    try {
      await this._refreshHosts(false, true);

      await this._registerToConnectionEvents();
    } catch (err) {
      this.log('error', 'ControlConnection failed to retrieve topology and keyspaces information', err);
      this._triedHosts[this.connection.endpoint] = err;

      if (err.isSocketError && this.host) {
        this.host.removeFromPool(this.connection);
      }

      // Retry the whole thing with the same query plan
      return await this._refresh(hostIterator);
    }

    this._reconnectionSchedule = this._reconnectionPolicy.newSchedule();
    this._setHealthListeners(this.host, this.connection);
    this.emit('newConnection', null, this.connection, this.host);

    this.log('info', `ControlConnection connected to ${this.connection.endpointFriendlyName} and up to date`);
  }

  /**
   * Acquires a connection and refreshes topology and keyspace metadata for the first time.
   * @returns {Promise<void>}
   */
  async _initializeConnection() {
    this.log('info', 'Getting first connection');

    // Reset host and connection
    this.host = null;
    this.connection = null;
    this._triedHosts = {};

    // Randomize order of contact points resolved.
    const contactPointsIterator = utils$g.shuffleArray(Array.from(this._contactPoints))[Symbol.iterator]();

    while (true) {
      await this._borrowFirstConnection(contactPointsIterator);

      this.log('info', `ControlConnection using protocol version 0x${
        this.protocolVersion.toString(16)}, connected to ${this.connection.endpointFriendlyName}`);

      try {
        await this._getSupportedOptions();
        await this._refreshHosts(true, true);
        await this._registerToConnectionEvents();

        // We have a valid connection, leave the loop
        break;

      } catch (err) {
        this.log('error', 'ControlConnection failed to retrieve topology and keyspaces information', err);
        this._triedHosts[this.connection.endpoint] = err;
      }
    }

    // The healthy connection used to initialize should be part of the Host pool
    this.host.pool.addExistingConnection(this.connection);

    this.initialized = true;
    this._setHealthListeners(this.host, this.connection);
    this.log('info', `ControlConnection connected to ${this.connection.endpointFriendlyName}`);
  }

  async _getSupportedOptions() {
    const response = await this.connection.send(requests$3.options, null);

    // response.supported is a string multi map, decoded as an Object.
    const productType = response.supported && response.supported[supportedProductTypeKey];
    if (Array.isArray(productType) && productType[0] === supportedDbaas) {
      this.metadata.setProductTypeAsDbaas();
    }
  }

  async _registerToConnectionEvents() {
    this.connection.on('nodeTopologyChange', this._nodeTopologyChangeHandler.bind(this));
    this.connection.on('nodeStatusChange', this._nodeStatusChangeHandler.bind(this));
    this.connection.on('nodeSchemaChange', this._nodeSchemaChangeHandler.bind(this));
    const request = new requests$3.RegisterRequest(['TOPOLOGY_CHANGE', 'STATUS_CHANGE', 'SCHEMA_CHANGE']);
    await this.connection.send(request, null);
  }

  /**
   * Handles a TOPOLOGY_CHANGE event
   */
  _nodeTopologyChangeHandler(event) {
    this.log('info', 'Received topology change', event);

    // all hosts information needs to be refreshed as tokens might have changed
    clearTimeout(this._topologyChangeTimeout);

    // Use an additional timer to make sure that the refresh hosts is executed only AFTER the delay
    // In this case, the event debouncer doesn't help because it could not honor the sliding delay (ie: processNow)
    this._topologyChangeTimeout = setTimeout(() =>
      promiseUtils$4.toBackground(this._scheduleRefreshHosts()), newNodeDelay);
  }

  /**
   * Handles a STATUS_CHANGE event
   */
  _nodeStatusChangeHandler(event) {
    const self = this;
    const addressToTranslate = event.inet.address.toString();
    const port = this.options.protocolOptions.port;
    this._addressTranslator.translate(addressToTranslate, port, function translateCallback(endPoint) {
      const host = self.hosts.get(endPoint);
      if (!host) {
        self.log('warning', 'Received status change event but host was not found: ' + addressToTranslate);
        return;
      }
      const distance = self._profileManager.getDistance(host);
      if (event.up) {
        if (distance === types$a.distance.ignored) {
          return host.setUp(true);
        }
        clearTimeout(self._nodeStatusChangeTimeout);
        // Waits a couple of seconds before marking it as UP
        self._nodeStatusChangeTimeout = setTimeout(() => host.checkIsUp(), newNodeDelay);
        return;
      }
      // marked as down
      if (distance === types$a.distance.ignored) {
        return host.setDown();
      }
      self.log('warning', 'Received status change to DOWN for host ' + host.address);
    });
  }

  /**
   * Handles a SCHEMA_CHANGE event
   */
  _nodeSchemaChangeHandler(event) {
    this.log('info', 'Schema change', event);
    if (!this.options.isMetadataSyncEnabled) {
      return;
    }

    promiseUtils$4.toBackground(this.handleSchemaChange(event, false));
  }

  /**
   * Schedules metadata refresh and callbacks when is refreshed.
   * @param {{keyspace: string, isKeyspace: boolean, schemaChangeType, table, udt, functionName, aggregate}} event
   * @param {Boolean} processNow
   * @returns {Promise<void>}
   */
  handleSchemaChange(event, processNow) {
    const self = this;
    let handler, cqlObject;

    if (event.isKeyspace) {
      if (event.schemaChangeType === schemaChangeTypes.dropped) {
        handler = function removeKeyspace() {
          // if on the same event queue there is a creation, this handler is not going to be executed
          // it is safe to remove the keyspace metadata
          delete self.metadata.keyspaces[event.keyspace];
        };

        return this._scheduleObjectRefresh(handler, event.keyspace, null, processNow);
      }

      return this._scheduleKeyspaceRefresh(event.keyspace, processNow);
    }

    const ksInfo = this.metadata.keyspaces[event.keyspace];
    if (!ksInfo) {
      // it hasn't been loaded and it is not part of the metadata, don't mind
      return Promise.resolve();
    }

    if (event.table) {
      cqlObject = event.table;
      handler = function clearTableState() {
        delete ksInfo.tables[event.table];
        delete ksInfo.views[event.table];
      };
    }
    else if (event.udt) {
      cqlObject = event.udt;
      handler = function clearUdtState() {
        delete ksInfo.udts[event.udt];
      };
    }
    else if (event.functionName) {
      cqlObject = event.functionName;
      handler = function clearFunctionState() {
        delete ksInfo.functions[event.functionName];
      };
    }
    else if (event.aggregate) {
      cqlObject = event.aggregate;
      handler = function clearKeyspaceState() {
        delete ksInfo.aggregates[event.aggregate];
      };
    }

    if (!handler) {
      // Forward compatibility
      return Promise.resolve();
    }

    // It's a cql object change clean the internal cache
    return this._scheduleObjectRefresh(handler, event.keyspace, cqlObject, processNow);
  }

  /**
   * @param {Function} handler
   * @param {String} keyspace
   * @param {String} cqlObject
   * @param {Boolean} processNow
   * @returns {Promise<void>}
   */
  _scheduleObjectRefresh(handler, keyspace, cqlObject, processNow) {
    return this._debouncer.eventReceived({ handler, keyspace, cqlObject }, processNow);
  }

  /**
   * @param {String} keyspace
   * @param {Boolean} processNow
   * @returns {Promise<void>}
   */
  _scheduleKeyspaceRefresh(keyspace, processNow) {
    return this._debouncer.eventReceived({
      handler: () => this.metadata.refreshKeyspace(keyspace),
      keyspace
    }, processNow);
  }

  /** @returns {Promise<void>} */
  _scheduleRefreshHosts() {
    return this._debouncer.eventReceived({
      handler: () => this._refreshHosts(false, false),
      all: true
    }, false);
  }

  /**
   * Sets the information for the host used by the control connection.
   * @param {Boolean} initializing
   * @param {Connection} c
   * @param {Boolean} setCurrentHost Determines if the host retrieved must be set as the current host
   * @param result
   */
  _setLocalInfo(initializing, setCurrentHost, c, result) {
    if (!result || !result.rows || !result.rows.length) {
      this.log('warning', 'No local info could be obtained');
      return;
    }

    const row = result.rows[0];

    let localHost;

    // Note that with SNI enabled, we can trust that rpc_address will contain a valid value.
    const endpoint = !this.options.sni
      ? c.endpoint
      : `${row['rpc_address']}:${this.options.protocolOptions.port}`;

    if (initializing) {
      localHost = new Host(endpoint, this.protocolVersion, this.options, this.metadata);
      this.hosts.set(endpoint, localHost);
      this.log('info', `Adding host ${endpoint}`);
    } else {
      localHost = this.hosts.get(endpoint);

      if (!localHost) {
        this.log('error', 'Localhost could not be found');
        return;
      }
    }

    localHost.datacenter = row['data_center'];
    localHost.rack = row['rack'];
    localHost.tokens = row['tokens'];
    localHost.hostId = row['host_id'];
    localHost.cassandraVersion = row['release_version'];
    setDseParameters(localHost, row);
    this.metadata.setPartitioner(row['partitioner']);
    this.log('info', 'Local info retrieved');

    if (setCurrentHost) {
      // Set the host as the one being used by the ControlConnection.
      this.host = localHost;
    }
  }

  /**
   * @param {Boolean} initializing Determines whether this function was called in order to initialize the control
   * connection the first time.
   * @param {ResultSet} result
   */
  async setPeersInfo(initializing, result) {
    if (!result || !result.rows) {
      return;
    }

    // A map of peers, could useful for in case there are discrepancies
    const peers = {};
    const port = this.options.protocolOptions.port;
    const foundDataCenters = new Set();

    if (this.host && this.host.datacenter) {
      foundDataCenters.add(this.host.datacenter);
    }

    for (const row of result.rows) {
      const endpoint = await this.getAddressForPeerHost(row, port);

      if (!endpoint) {
        continue;
      }

      peers[endpoint] = true;
      let host = this.hosts.get(endpoint);
      let isNewHost = !host;

      if (isNewHost) {
        host = new Host(endpoint, this.protocolVersion, this.options, this.metadata);
        this.log('info', `Adding host ${endpoint}`);
        isNewHost = true;
      }

      host.datacenter = row['data_center'];
      host.rack = row['rack'];
      host.tokens = row['tokens'];
      host.hostId = row['host_id'];
      host.cassandraVersion = row['release_version'];
      setDseParameters(host, row);

      if (host.datacenter) {
        foundDataCenters.add(host.datacenter);
      }

      if (isNewHost) {
        // Add it to the map (and trigger events) after all the properties
        // were set to avoid race conditions
        this.hosts.set(endpoint, host);

        if (!initializing) {
          // Set the distance at Host level, that way the connection pool is created with the correct settings
          this._profileManager.getDistance(host);

          // When we are not initializing, we start with the node set as DOWN
          host.setDown();
        }
      }
    }

    // Is there a difference in number between peers + local != hosts
    if (this.hosts.length > result.rows.length + 1) {
      // There are hosts in the current state that don't belong (nodes removed or wrong contactPoints)
      this.log('info', 'Removing nodes from the pool');
      const toRemove = [];

      this.hosts.forEach(h => {
        //It is not a peer and it is not local host
        if (!peers[h.address] && h !== this.host) {
          this.log('info', 'Removing host ' + h.address);
          toRemove.push(h.address);
          h.shutdown(true);
        }
      });

      this.hosts.removeMultiple(toRemove);
    }

    if (initializing && this.options.localDataCenter) {
      const localDc = this.options.localDataCenter;

      if (!foundDataCenters.has(localDc)) {
        throw new errors$8.ArgumentError(`localDataCenter was configured as '${
          localDc}', but only found hosts in data centers: [${Array.from(foundDataCenters).join(', ')}]`);
      }
    }

    this.log('info', 'Peers info retrieved');
  }

  /**
   * Gets the address from a peers row and translates the address.
   * @param {Object|Row} row
   * @param {Number} defaultPort
   * @returns {Promise<string>}
   */
  getAddressForPeerHost(row, defaultPort) {
    return new Promise(resolve => {
      let address = row['rpc_address'];
      const peer = row['peer'];
      const bindAllAddress = '0.0.0.0';

      if (!address) {
        this.log('error', f('No rpc_address found for host %s in %s\'s peers system table. %s will be ignored.',
          peer, this.host.address, peer));
        return resolve(null);
      }

      if (address.toString() === bindAllAddress) {
        this.log('warning', f('Found host with 0.0.0.0 as rpc_address, using listen_address (%s) to contact it instead.' +
          ' If this is incorrect you should avoid the use of 0.0.0.0 server side.', peer));
        address = peer;
      }

      this._addressTranslator.translate(address.toString(), defaultPort, resolve);
    });
  }

  /**
   * Uses the DNS protocol to resolve a IPv4 and IPv6 addresses (A and AAAA records) for the hostname.
   * It returns an Array of addresses that can be empty and logs the error.
   * @private
   * @param name
   */
  async _resolveAll(name) {
    const addresses = [];
    const resolve4 = util$7.promisify(dns.resolve4);
    const resolve6 = util$7.promisify(dns.resolve6);
    const lookup = util$7.promisify(dns.lookup);

    // Ignore errors for resolve calls
    const ipv4Promise = resolve4(name).catch(() => {}).then(r => r || utils$g.emptyArray);
    const ipv6Promise = resolve6(name).catch(() => {}).then(r => r || utils$g.emptyArray);

    let arr;
    arr = await ipv4Promise;
    arr.forEach(address => addresses.push({address, isIPv6: false}));

    arr = await ipv6Promise;
    arr.forEach(address => addresses.push({address, isIPv6: true}));

    if (addresses.length === 0) {
      // In case dns.resolve*() methods don't yield a valid address for the host name
      // Use system call getaddrinfo() that might resolve according to host system definitions
      try {
        arr = await lookup(name, { all: true });
        arr.forEach(({address, family}) => addresses.push({address, isIPv6: family === 6}));
      } catch (err) {
        this.log('error', `Host with name ${name} could not be resolved`, err);
      }
    }

    return addresses;
  }

  /**
   * Waits for a connection to be available. If timeout expires before getting a connection it callbacks in error.
   * @returns {Promise<void>}
   */
  _waitForReconnection() {
    return new Promise((resolve, reject) => {
      const callback = promiseUtils$4.getCallback(resolve, reject);

      // eslint-disable-next-line prefer-const
      let timeout;

      function newConnectionListener(err) {
        clearTimeout(timeout);
        callback(err);
      }

      this.once('newConnection', newConnectionListener);

      timeout = setTimeout(() => {
        this.removeListener('newConnection', newConnectionListener);
        callback(new errors$8.OperationTimedOutError('A connection could not be acquired before timeout.'));
      }, metadataQueryAbortTimeout);
    });
  }

  /**
   * Executes a query using the active connection
   * @param {String|Request} cqlQuery
   * @param {Boolean} [waitReconnect] Determines if it should wait for reconnection in case the control connection is not
   * connected at the moment. Default: true.
   */
  async query(cqlQuery, waitReconnect = true) {
    const queryOnConnection = async () => {
      if (!this.connection || this._isShuttingDown) {
        throw new errors$8.NoHostAvailableError({}, 'ControlConnection is not connected at the time');
      }

      const request = typeof cqlQuery === 'string' ? new requests$3.QueryRequest(cqlQuery, null, null) : cqlQuery;
      return await this.connection.send(request, null);
    };

    if (!this.connection && waitReconnect) {
      // Wait until its reconnected (or timer elapses)
      await this._waitForReconnection();
    }

    return await queryOnConnection();
  }

  /** @returns {Encoder} The encoder used by the current connection */
  getEncoder() {
    if (!this._encoder) {
      throw new errors$8.DriverInternalError('Encoder is not defined');
    }
    return this._encoder;
  }

  /**
   * Cancels all timers and shuts down synchronously.
   */
  shutdown() {
    this._isShuttingDown = true;
    this._debouncer.shutdown();
    // Emit a "newConnection" event with Error, as it may clear timeouts that were waiting new connections
    this.emit('newConnection', new errors$8.DriverError('ControlConnection is being shutdown'));
    // Cancel timers
    clearTimeout(this._topologyChangeTimeout);
    clearTimeout(this._nodeStatusChangeTimeout);
  }

  /**
   * Resets the Connection to its initial state.
   */
  async reset() {
    // Reset the internal state of the ControlConnection for future initialization attempts
    const currentHosts = this.hosts.clear();

    // Set the shutting down flag temporarily to avoid reconnects.
    this._isShuttingDown = true;

    // Shutdown all individual pools, ignoring any shutdown error
    await Promise.all(currentHosts.map(h => h.shutdown()));

    this.initialized = false;
    this._isShuttingDown = false;
  }

  /**
   * Gets a Map containing the original contact points and the addresses that each one resolved to.
   */
  getResolvedContactPoints() {
    return this._resolvedContactPoints;
  }

  /**
   * Gets the local IP address to which the control connection socket is bound to.
   * @returns {String|undefined}
   */
  getLocalAddress() {
    if (!this.connection) {
      return undefined;
    }

    return this.connection.getLocalAddress();
  }

  /**
   * Gets the address and port of host the control connection is connected to.
   * @returns {String|undefined}
   */
  getEndpoint() {
    if (!this.connection) {
      return undefined;
    }

    return this.connection.endpoint;
  }
};

/**
 * Parses the DSE workload and assigns it to a host.
 * @param {Host} host
 * @param {Row} row
 * @private
 */
function setDseParameters(host, row) {
  if (row['workloads'] !== undefined) {
    host.workloads = row['workloads'];
  }
  else if (row['workload']) {
    host.workloads = [ row['workload'] ];
  }
  else {
    host.workloads = utils$g.emptyArray;
  }

  if (row['dse_version'] !== undefined) {
    host.dseVersion = row['dse_version'];
  }
}

var controlConnection = ControlConnection$1;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const errors$7 = errors$n;
const requests$2 = requests$7;
const retry = retry$1;
const types$9 = requireTypes();
const utils$f = utils$K;
const promiseUtils$3 = promiseUtils$e;

const retryOnCurrentHost = Object.freeze({
  decision: retry.RetryPolicy.retryDecision.retry,
  useCurrentHost: true,
  consistency: undefined
});

const rethrowDecision = Object.freeze({ decision: retry.RetryPolicy.retryDecision.rethrow });

/**
 * An internal representation of an error that occurred during the execution of a request.
 */
const errorCodes = {
  none: 0,
  // Socket error
  socketError: 1,
  // Socket error before the request was written to the wire
  socketErrorBeforeRequestWritten: 2,
  // OperationTimedOutError
  clientTimeout: 3,
  // Response error "unprepared"
  serverErrorUnprepared: 4,
  // Response error "overloaded", "is_bootstrapping" and "truncateError":
  serverErrorOverloaded: 5,
  serverErrorReadTimeout: 6,
  serverErrorUnavailable: 7,
  serverErrorWriteTimeout: 8,
  // Any other server error (different from the ones detailed above)
  serverErrorOther: 9
};

const metricsHandlers = new Map([
  [ errorCodes.none, (metrics, err, latency) => metrics.onSuccessfulResponse(latency) ],
  [ errorCodes.socketError, (metrics, err) => metrics.onConnectionError(err) ],
  [ errorCodes.clientTimeout, (metrics, err) => metrics.onClientTimeoutError(err) ],
  [ errorCodes.serverErrorOverloaded, (metrics, err) => metrics.onOtherError(err) ],
  [ errorCodes.serverErrorReadTimeout, (metrics, err) => metrics.onReadTimeoutError(err) ],
  [ errorCodes.serverErrorUnavailable, (metrics, err) => metrics.onUnavailableError(err) ],
  [ errorCodes.serverErrorWriteTimeout, (metrics, err) => metrics.onWriteTimeoutError(err) ],
  [ errorCodes.serverErrorOther, (metrics, err) => metrics.onOtherError(err) ]
]);

const metricsRetryHandlers = new Map([
  [ errorCodes.socketError, (metrics, err) => metrics.onOtherErrorRetry(err) ],
  [ errorCodes.clientTimeout, (metrics, err) => metrics.onClientTimeoutRetry(err) ],
  [ errorCodes.serverErrorOverloaded, (metrics, err) => metrics.onOtherErrorRetry(err) ],
  [ errorCodes.serverErrorReadTimeout, (metrics, err) => metrics.onReadTimeoutRetry(err) ],
  [ errorCodes.serverErrorUnavailable, (metrics, err) => metrics.onUnavailableRetry(err) ],
  [ errorCodes.serverErrorWriteTimeout, (metrics, err) => metrics.onWriteTimeoutRetry(err) ],
  [ errorCodes.serverErrorOther, (metrics, err) => metrics.onOtherErrorRetry(err) ]
]);

let RequestExecution$1 = class RequestExecution {
  /**
   * Encapsulates a single flow of execution against a coordinator, handling individual retries and failover.
   * @param {RequestHandler!} parent
   * @param {Host!} host
   * @param {Connection!} connection
   */
  constructor(parent, host, connection) {
    this._parent = parent;
    /** @type {OperationState} */
    this._operation = null;
    this._host = host;
    this._connection = connection;
    this._cancelled = false;
    this._startTime = null;
    this._retryCount = 0;
    // The streamId information is not included in the request.
    // A pointer to the parent request can be used, except when changing the consistency level from the retry policy
    this._request = this._parent.request;

    // Mark that it launched a new execution
    parent.speculativeExecutions++;
  }

  /**
   * Sends the request using the active connection.
   */
  start() {
    this._sendOnConnection();
  }

  /**
   * Borrows the next connection available using the query plan and sends the request.
   * @returns {Promise<void>}
   */
  async restart() {
    try {
      const { host, connection } = this._parent.getNextConnection();

      this._connection = connection;
      this._host = host;
    } catch (err) {
      return this._parent.handleNoHostAvailable(err, this);
    }

    // It could be a new connection from the pool, we should make sure it's in the correct keyspace.
    const keyspace = this._parent.client.keyspace;
    if (keyspace && keyspace !== this._connection.keyspace) {
      try {
        await this._connection.changeKeyspace(keyspace);
      } catch (err) {
        // When its a socket error, attempt to retry.
        // Otherwise, rethrow the error to the user.
        return this._handleError(err, RequestExecution._getErrorCode(err));
      }
    }

    if (this._cancelled) {
      // No need to send the request or invoke any callback
      return;
    }

    this._sendOnConnection();
  }

  /**
   * Sends the request using the active connection.
   * @private
   */
  _sendOnConnection() {
    this._startTime = process.hrtime();

    this._operation =
      this._connection.sendStream(this._request, this._parent.executionOptions, (err, response, length) => {
        const errorCode = RequestExecution._getErrorCode(err);

        this._trackResponse(process.hrtime(this._startTime), errorCode, err, length);

        if (this._cancelled) {
          // Avoid handling the response / err
          return;
        }

        if (errorCode !== errorCodes.none) {
          return this._handleError(errorCode, err);
        }

        if (response.schemaChange) {
          return promiseUtils$3.toBackground(
            this._parent.client
              .handleSchemaAgreementAndRefresh(this._connection, response.schemaChange)
              .then(agreement => {
                if (this._cancelled) {
                  // After the schema agreement method was started, this execution was cancelled
                  return;
                }

                this._parent.setCompleted(null, this._getResultSet(response, agreement));
              })
          );
        }

        if (response.keyspaceSet) {
          this._parent.client.keyspace = response.keyspaceSet;
        }

        if (response.meta && response.meta.newResultId && this._request.queryId) {
          // Update the resultId on the existing prepared statement.
          // Eventually would want to update the result metadata as well (NODEJS-433)
          const info = this._parent.client.metadata.getPreparedById(this._request.queryId);
          info.meta.resultId = response.meta.newResultId;
        }

        this._parent.setCompleted(null, this._getResultSet(response));
      });
  }

  _trackResponse(latency, errorCode, err, length) {
    // Record metrics
    RequestExecution._invokeMetricsHandler(errorCode, this._parent.client.metrics, err, latency);

    // Request tracker
    const tracker = this._parent.client.options.requestTracker;

    if (tracker === null) {
      return;
    }

    // Avoid using instanceof as property check is faster
    const query = this._request.query || this._request.queries;
    const parameters = this._request.params;
    const requestLength = this._request.length;

    if (err) {
      tracker.onError(this._host, query, parameters, this._parent.executionOptions, requestLength, err, latency);
    } else {
      tracker.onSuccess(this._host, query, parameters, this._parent.executionOptions, requestLength, length, latency);
    }
  }

  _getResultSet(response, agreement) {
    const rs = new types$9.ResultSet(response, this._host.address, this._parent.triedHosts, this._parent.speculativeExecutions,
      this._request.consistency, agreement === undefined || agreement);

    if (rs.rawPageState) {
      rs.nextPageAsync = this._parent.getNextPageHandler();
    }

    return rs;
  }

  /**
   * Gets the method of the {ClientMetrics} instance depending on the error code and invokes it.
   * @param {Number} errorCode
   * @param {ClientMetrics} metrics
   * @param {Error} err
   * @param {Array} latency
   * @private
   */
  static _invokeMetricsHandler(errorCode, metrics, err, latency) {
    const handler = metricsHandlers.get(errorCode);
    if (handler !== undefined) {
      handler(metrics, err, latency);
    }

    if (!err || err instanceof errors$7.ResponseError) {
      metrics.onResponse(latency);
    }
  }

  /**
   * Gets the method of the {ClientMetrics} instance related to retry depending on the error code and invokes it.
   * @param {Number} errorCode
   * @param {ClientMetrics} metrics
   * @param {Error} err
   * @private
   */
  static _invokeMetricsHandlerForRetry(errorCode, metrics, err) {
    const handler = metricsRetryHandlers.get(errorCode);

    if (handler !== undefined) {
      handler(metrics, err);
    }
  }

  /**
   * Allows the handler to cancel the current request.
   * When the request has been already written, we can unset the callback and forget about it.
   */
  cancel() {
    this._cancelled = true;

    if (this._operation === null) {
      return;
    }

    this._operation.cancel();
  }

  /**
   * Determines if the current execution was cancelled.
   */
  wasCancelled() {
    return this._cancelled;
  }

  _handleError(errorCode, err) {
    this._parent.triedHosts[this._host.address] = err;
    err['coordinator'] = this._host.address;

    if (errorCode === errorCodes.serverErrorUnprepared) {
      return this._prepareAndRetry(err.queryId);
    }

    if (errorCode === errorCodes.socketError || errorCode === errorCodes.socketErrorBeforeRequestWritten) {
      this._host.removeFromPool(this._connection);
    } else if (errorCode === errorCodes.clientTimeout) {
      this._parent.log('warning', err.message);
      this._host.checkHealth(this._connection);
    }

    const decisionInfo = this._getDecision(errorCode, err);

    if (!decisionInfo || decisionInfo.decision === retry.RetryPolicy.retryDecision.rethrow) {
      if (this._request instanceof requests$2.QueryRequest || this._request instanceof requests$2.ExecuteRequest) {
        err['query'] = this._request.query;
      }
      return this._parent.setCompleted(err);
    }

    const metrics = this._parent.client.metrics;

    if (decisionInfo.decision === retry.RetryPolicy.retryDecision.ignore) {
      metrics.onIgnoreError(err);

      // Return an empty ResultSet
      return this._parent.setCompleted(null, this._getResultSet(utils$f.emptyObject));
    }

    RequestExecution._invokeMetricsHandlerForRetry(errorCode, metrics, err);

    return this._retry(decisionInfo.consistency, decisionInfo.useCurrentHost);
  }

  /**
   * Gets a decision whether or not to retry based on the error information.
   * @param {Number} errorCode
   * @param {Error} err
   * @returns {{decision, useCurrentHost, consistency}}
   */
  _getDecision(errorCode, err) {
    const operationInfo = {
      query: this._request && this._request.query,
      executionOptions: this._parent.executionOptions,
      nbRetry: this._retryCount
    };

    const retryPolicy = operationInfo.executionOptions.getRetryPolicy();

    switch (errorCode) {
      case errorCodes.socketErrorBeforeRequestWritten:
        // The request was definitely not applied, it's safe to retry.
        // Retry on the current host as there might be other connections open, in case it fails to obtain a connection
        // on the current host, the driver will immediately retry on the next host.
        return retryOnCurrentHost;
      case errorCodes.socketError:
      case errorCodes.clientTimeout:
      case errorCodes.serverErrorOverloaded:
        if (operationInfo.executionOptions.isIdempotent()) {
          return retryPolicy.onRequestError(operationInfo, this._request.consistency, err);
        }
        return rethrowDecision;
      case errorCodes.serverErrorUnavailable:
        return retryPolicy.onUnavailable(operationInfo, err.consistencies, err.required, err.alive);
      case errorCodes.serverErrorReadTimeout:
        return retryPolicy.onReadTimeout(
          operationInfo, err.consistencies, err.received, err.blockFor, err.isDataPresent);
      case errorCodes.serverErrorWriteTimeout:
        if (operationInfo.executionOptions.isIdempotent()) {
          return retryPolicy.onWriteTimeout(
            operationInfo, err.consistencies, err.received, err.blockFor, err.writeType);
        }
        return rethrowDecision;
      default:
        return rethrowDecision;
    }
  }

  static _getErrorCode(err) {
    if (!err) {
      return errorCodes.none;
    }

    if (err.isSocketError) {
      if (err.requestNotWritten) {
        return errorCodes.socketErrorBeforeRequestWritten;
      }
      return errorCodes.socketError;
    }

    if (err instanceof errors$7.OperationTimedOutError) {
      return errorCodes.clientTimeout;
    }

    if (err instanceof errors$7.ResponseError) {
      switch (err.code) {
        case types$9.responseErrorCodes.overloaded:
        case types$9.responseErrorCodes.isBootstrapping:
        case types$9.responseErrorCodes.truncateError:
          return errorCodes.serverErrorOverloaded;
        case types$9.responseErrorCodes.unavailableException:
          return errorCodes.serverErrorUnavailable;
        case types$9.responseErrorCodes.readTimeout:
          return errorCodes.serverErrorReadTimeout;
        case types$9.responseErrorCodes.writeTimeout:
          return errorCodes.serverErrorWriteTimeout;
        case types$9.responseErrorCodes.unprepared:
          return errorCodes.serverErrorUnprepared;
      }
    }

    return errorCodes.serverErrorOther;
  }

  /**
   * @param {Number|undefined} consistency
   * @param {Boolean} useCurrentHost
   * @param {Object} [meta]
   * @private
   */
  _retry(consistency, useCurrentHost, meta) {
    if (this._cancelled) {
      // No point in retrying
      return;
    }

    this._parent.log('info', 'Retrying request');
    this._retryCount++;

    if (meta || (typeof consistency === 'number' && this._request.consistency !== consistency)) {
      this._request = this._request.clone();
      if (typeof consistency === 'number') {
        this._request.consistency = consistency;
      }
      // possible that we are retrying because we had to reprepare.  In this case it is also possible
      // that our known metadata had changed, therefore we update it on the request.
      if (meta) {
        this._request.meta = meta;
      }
    }

    if (useCurrentHost !== false) {
      // Reusing the existing connection is suitable for the most common scenarios, like server read timeouts that
      // will be fixed with a new request.
      // To cover all scenarios (e.g., where a different connection to the same host might mean something different),
      // we obtain a new connection from the host pool.
      // When there was a socket error, the connection provided was already removed from the pool earlier.
      try {
        this._connection = this._host.borrowConnection(this._connection);
      } catch (err) {
        // All connections are busy (`BusyConnectionError`) or there isn't a ready connection in the pool (`Error`)
        // The retry policy declared the intention to retry on the current host but its not available anymore.
        // Use the next host
        return promiseUtils$3.toBackground(this.restart());
      }

      return this._sendOnConnection();
    }

    // Use the next host in the query plan to send the request in the background
    promiseUtils$3.toBackground(this.restart());
  }

  /**
   * Issues a PREPARE request on the current connection.
   * If there's a socket or timeout issue, it moves to next host and executes the original request.
   * @param {Buffer} queryId
   * @private
   */
  _prepareAndRetry(queryId) {
    const connection = this._connection;

    this._parent.log('info',
      `Query 0x${queryId.toString('hex')} not prepared on` +
      ` host ${connection.endpointFriendlyName}, preparing and retrying`);

    const info = this._parent.client.metadata.getPreparedById(queryId);

    if (!info) {
      return this._parent.setCompleted(new errors$7.DriverInternalError(
        `Unprepared response invalid, id: 0x${queryId.toString('hex')}`));
    }

    const version = this._connection.protocolVersion;

    if (!types$9.protocolVersion.supportsKeyspaceInRequest(version) && info.keyspace && info.keyspace !== connection.keyspace) {
      return this._parent.setCompleted(
        new Error(`Query was prepared on keyspace ${info.keyspace}, can't execute it on ${connection.keyspace} (${info.query})`));
    }

    const self = this;
    this._connection.prepareOnce(info.query, info.keyspace, function (err, result) {
      if (err) {
        if (!err.isSocketError && err instanceof errors$7.OperationTimedOutError) {
          self._parent.log('warning',
            `Unexpected timeout error when re-preparing query on host ${connection.endpointFriendlyName}`);
        }

        // There was a failure re-preparing on this connection.
        // Execute the original request on the next connection and forget about the PREPARE-UNPREPARE flow.
        return self._retry(undefined, false);
      }

      // It's possible that when re-preparing we got new metadata (i.e. if schema changed), update cache.
      info.meta = result.meta;
      // pass the metadata so it can be used in retry.
      self._retry(undefined, true, result.meta);
    });
  }
};

var requestExecution = RequestExecution$1;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const util$6 = require$$0$4;

const errors$6 = errors$n;
const types$8 = requireTypes();
const utils$e = utils$K;
const RequestExecution = requestExecution;
const promiseUtils$2 = promiseUtils$e;

/**
 * Handles a BATCH, QUERY and EXECUTE request to the server, dealing with host fail-over and retries on error
 */
let RequestHandler$1 = class RequestHandler {
  /**
   * Creates a new instance of RequestHandler.
   * @param {Request} request
   * @param {ExecutionOptions} execOptions
   * @param {Client} client Client instance used to retrieve and set the keyspace.
   */
  constructor(request, execOptions, client) {
    this.client = client;
    this._speculativeExecutionPlan = client.options.policies.speculativeExecution.newPlan(
      client.keyspace, request.query || request.queries);
    this.logEmitter = client.options.logEmitter;
    this.log = utils$e.log;
    this.request = request;
    this.executionOptions = execOptions;
    this.stackContainer = null;
    this.triedHosts = {};
    // start at -1 as first request does not count.
    this.speculativeExecutions = -1;
    this._hostIterator = null;
    this._resolveCallback = null;
    this._rejectCallback = null;
    this._newExecutionTimeout = null;
    /** @type {RequestExecution[]} */
    this._executions = [];
  }

  /**
   * Sends a new BATCH, QUERY or EXECUTE request.
   * @param {Request} request
   * @param {ExecutionOptions} execOptions
   * @param {Client} client Client instance used to retrieve and set the keyspace.
   * @returns {Promise<ResultSet>}
   */
  static send(request, execOptions, client) {
    const instance = new RequestHandler(request, execOptions, client);
    return instance.send();
  }

  /**
   * Gets a connection from the next host according to the query plan or throws a NoHostAvailableError.
   * @returns {{host, connection}}
   * @throws {NoHostAvailableError}
   */
  getNextConnection() {
    let host;
    let connection;
    const iterator = this._hostIterator;

    // Get a host that is UP in a sync loop
    while (true) {
      const item = iterator.next();
      if (item.done) {
        throw new errors$6.NoHostAvailableError(this.triedHosts);
      }

      host = item.value;

      // Set the distance relative to the client first
      const distance = this.client.profileManager.getDistance(host);
      if (distance === types$8.distance.ignored) {
        //If its marked as ignore by the load balancing policy, move on.
        continue;
      }

      if (!host.isUp()) {
        this.triedHosts[host.address] = 'Host considered as DOWN';
        continue;
      }

      try {
        connection = host.borrowConnection();
        this.triedHosts[host.address] = null;
        break;
      } catch (err) {
        this.triedHosts[host.address] = err;
      }
    }

    return { connection, host };
  }

  /**
   * Gets an available connection and sends the request
   * @returns {Promise<ResultSet>}
   */
  send() {
    if (this.executionOptions.getCaptureStackTrace()) {
      Error.captureStackTrace(this.stackContainer = {});
    }

    return new Promise((resolve, reject) => {
      this._resolveCallback = resolve;
      this._rejectCallback = reject;

      const lbp = this.executionOptions.getLoadBalancingPolicy();
      const fixedHost = this.executionOptions.getFixedHost();

      if (fixedHost) {
        // if host is configured bypass load balancing policy and use
        // a single host plan.
        this._hostIterator = utils$e.arrayIterator([fixedHost]);
        promiseUtils$2.toBackground(this._startNewExecution());
      } else {
        lbp.newQueryPlan(this.client.keyspace, this.executionOptions, (err, iterator) => {
          if (err) {
            return reject(err);
          }

          this._hostIterator = iterator;
          promiseUtils$2.toBackground(this._startNewExecution());
        });
      }
    });
  }

  /**
   * Starts a new execution on the next host of the query plan.
   * @param {Boolean} [isSpecExec]
   * @returns {Promise<void>}
   * @private
   */
  async _startNewExecution(isSpecExec) {
    if (isSpecExec) {
      this.client.metrics.onSpeculativeExecution();
    }

    let host;
    let connection;

    try {
      ({ host, connection } = this.getNextConnection());
    } catch (err) {
      return this.handleNoHostAvailable(err, null);
    }

    if (isSpecExec && this._executions.length >= 0 && this._executions[0].wasCancelled()) {
      // This method was called on the next tick and could not be cleared, the previous execution was cancelled so
      // there's no point in launching a new execution.
      return;
    }

    if (this.client.keyspace && this.client.keyspace !== connection.keyspace) {
      try {
        await connection.changeKeyspace(this.client.keyspace);
      } catch (err) {
        this.triedHosts[host.address] = err;
        // The error occurred asynchronously
        // We can blindly re-try to obtain a different host/connection.
        return this._startNewExecution(isSpecExec);
      }
    }

    const execution = new RequestExecution(this, host, connection);
    this._executions.push(execution);
    execution.start();

    if (this.executionOptions.isIdempotent()) {
      this._scheduleSpeculativeExecution(host);
    }
  }

  /**
   * Schedules next speculative execution, if any.
   * @param {Host!} host
   * @private
   */
  _scheduleSpeculativeExecution(host) {
    const delay = this._speculativeExecutionPlan.nextExecution(host);
    if (typeof delay !== 'number' || delay < 0) {
      return;
    }

    if (delay === 0) {
      // Parallel speculative execution
      return process.nextTick(() => {
        promiseUtils$2.toBackground(this._startNewExecution(true));
      });
    }

    // Create timer for speculative execution
    this._newExecutionTimeout = setTimeout(() =>
      promiseUtils$2.toBackground(this._startNewExecution(true)), delay);
  }

  /**
   * Sets the keyspace in any connection that is already opened.
   * @param {Client} client
   * @returns {Promise}
   */
  static setKeyspace(client) {
    let connection;

    for (const host of client.hosts.values()) {
      connection = host.getActiveConnection();
      if (connection) {
        break;
      }
    }

    if (!connection) {
      throw new errors$6.DriverInternalError('No active connection found');
    }

    return connection.changeKeyspace(client.keyspace);
  }

  /**
   * @param {Error} err
   * @param {ResultSet} [result]
   */
  setCompleted(err, result) {
    if (this._newExecutionTimeout !== null) {
      clearTimeout(this._newExecutionTimeout);
    }

    // Mark all executions as cancelled
    for (const execution of this._executions) {
      execution.cancel();
    }

    if (err) {
      if (this.executionOptions.getCaptureStackTrace()) {
        utils$e.fixStack(this.stackContainer.stack, err);
      }

      // Reject the promise
      return this._rejectCallback(err);
    }

    if (result.info.warnings) {
      // Log the warnings from the response
      result.info.warnings.forEach(function (message, i, warnings) {
        this.log('warning', util$6.format(
          'Received warning (%d of %d) "%s" for "%s"',
          i + 1,
          warnings.length,
          message,
          this.request.query || 'batch'));
      }, this);
    }

    // We used to invoke the callback on next tick to allow stack unwinding and prevent the optimizing compiler to
    // optimize read and write functions together.
    // As we are resolving a Promise then() and catch() are always scheduled in the microtask queue
    // We can invoke the resolve method directly.
    this._resolveCallback(result);
  }

  /**
   * @param {NoHostAvailableError} err
   * @param {RequestExecution|null} execution
   */
  handleNoHostAvailable(err, execution) {
    if (execution !== null) {
      // Remove the execution
      const index = this._executions.indexOf(execution);
      this._executions.splice(index, 1);
    }

    if (this._executions.length === 0) {
      // There aren't any other executions, we should report back to the user that there isn't
      // a host available for executing the request
      this.setCompleted(err);
    }
  }

  /**
   * Gets a long lived closure that can fetch the next page.
   * @returns {Function}
   */
  getNextPageHandler() {
    const request = this.request;
    const execOptions = this.executionOptions;
    const client = this.client;

    return function nextPageHandler(pageState) {
      execOptions.setPageState(pageState);
      return new RequestHandler(request, execOptions, client).send();
    };
  }
};

var requestHandler = RequestHandler$1;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const os = require$$0$3;
const path = require$$0$5;
const fs$2 = require$$1;
const utils$d = utils$K;
const promiseUtils$1 = promiseUtils$e;
const types$7 = requireTypes();
const requests$1 = requests$7;
const { ExecutionOptions } = executionOptions;
const packageInfo = require$$17;
const VersionNumber = versionNumber;
const { NoAuthProvider: NoAuthProvider$1 } = auth;

let kerberosModule;

try {
  // eslint-disable-next-line
  kerberosModule = require('kerberos');
}
catch (err) {
  // Kerberos is an optional dependency
}

const minDse6Version = new VersionNumber(6, 0, 5);
const minDse51Version = new VersionNumber(5, 1, 13);
const dse600Version = new VersionNumber(6, 0, 0);
const rpc = "CALL InsightsRpc.reportInsight(?)";
const maxStatusErrorLogs = 5;

/**
 * Contains methods and functionality to send events to DSE Insights.
 */
let InsightsClient$1 = class InsightsClient {

  /**
   * Creates a new instance of the {@link InsightsClient} using the driver {@link Client}.
   * @param {Client} client
   * @param {Object} [options]
   * @param {Number} [options.statusEventDelay]
   * @param {Function} [options.errorCallback]
   */
  constructor(client, options) {
    this._client = client;
    this._sessionId = types$7.Uuid.random().toString();
    this._enabled = false;
    this._closed = false;
    this._firstTimeout = null;
    this._recurrentTimeout = null;
    this._statusErrorLogs = 0;

    options = options || {};

    this._statusEventDelay = options.statusEventDelay || 300000;
    this._errorCallback = options.errorCallback || utils$d.noop;
  }

  /**
   * Initializes the insights client in the background by sending the startup event and scheduling status events at
   * regular intervals.
   * @returns {undefined}
   */
  init() {
    this._enabled = this._client.options.monitorReporting.enabled && this._dseSupportsInsights();
    if (!this._enabled) {
      return;
    }

    promiseUtils$1.toBackground(this._init());
  }

  async _init() {
    try {
      await this._sendStartupEvent();

      if (this._closed) {
        // The client was shutdown
        return;
      }

      // Send the status event the first time with a delay containing some random portion
      // Initial delay should be statusEventDelay - (0 to 10%)
      const firstDelay = Math.floor(this._statusEventDelay - 0.1 * this._statusEventDelay * Math.random());
      // Schedule the first timer
      this._firstTimeout = setTimeout(() => {
        // Send the first status event, the promise will never be rejected
        this._sendStatusEvent();
        // The following status events are sent at regular intervals
        this._recurrentTimeout = setInterval(() => this._sendStatusEvent(), this._statusEventDelay);
      }, firstDelay);
    } catch (err) {
      if (this._closed) {
        // Sending failed because the Client was shutdown
        return;
      }
      // We shouldn't try to recover
      this._client.log('verbose', `Insights startup message could not be sent (${err})`, err);
      this._errorCallback(err);
    }
  }

  /**
   * Sends the startup event.
   * @returns {Promise}
   * @private
   */
  async _sendStartupEvent() {
    const message = await this._getStartupMessage();
    const request = new requests$1.QueryRequest(rpc, [message], ExecutionOptions.empty());
    await this._client.controlConnection.query(request, false);
  }

  /**
   * Sends the status event.
   * @returns {Promise} A promise that is never rejected.
   * @private
   */
  async _sendStatusEvent() {
    const request = new requests$1.QueryRequest(rpc, [ this._getStatusEvent() ], ExecutionOptions.empty());

    try {
      await this._client.controlConnection.query(request, false);
    } catch (err) {
      if (this._closed) {
        // Sending failed because the Client was shutdown
        return;
      }

      if (this._statusErrorLogs < maxStatusErrorLogs) {
        this._client.log('warning', `Insights status message could not be sent (${err})`, err);
        this._statusErrorLogs++;
      }

      this._errorCallback(err);
    }
  }

  /**
   * Validates the minimum server version for all nodes in the cluster.
   * @private
   */
  _dseSupportsInsights() {
    if (this._client.hosts.length === 0) {
      return false;
    }

    return this._client.hosts.values().reduce((acc, host) => {
      if (!acc) {
        return acc;
      }

      const versionArr = host.getDseVersion();

      if (versionArr.length === 0) {
        return false;
      }

      const version = new VersionNumber(...versionArr);

      return version.compare(minDse6Version) >= 0 ||
        (version.compare(dse600Version) < 0 && version.compare(minDse51Version) >= 0);

    }, true);
  }

  /**
   * @returns {Promise<String>} Returns a json string with the startup message.
   * @private
   */
  async _getStartupMessage() {
    const cc = this._client.controlConnection;
    const options = this._client.options;


    const appInfo = await this._getAppInfo(options);
    const message = {
      metadata: {
        name: 'driver.startup',
        insightMappingId: 'v1',
        insightType: 'EVENT',
        timestamp: Date.now(),
        tags: { language: 'nodejs' }
      },
      data: {
        driverName: packageInfo.description,
        driverVersion: packageInfo.version,
        clientId: options.id,
        sessionId: this._sessionId,
        applicationName: appInfo.applicationName,
        applicationVersion: appInfo.applicationVersion,
        applicationNameWasGenerated: appInfo.applicationNameWasGenerated,
        contactPoints: mapToObject(cc.getResolvedContactPoints()),
        dataCenters: this._getDataCenters(),
        initialControlConnection: cc.host ? cc.host.address : undefined,
        protocolVersion: cc.protocolVersion,
        localAddress: cc.getLocalAddress(),
        hostName: os.hostname(),
        executionProfiles: getExecutionProfiles(this._client),
        poolSizeByHostDistance: {
          local: options.pooling.coreConnectionsPerHost[types$7.distance.local],
          remote: options.pooling.coreConnectionsPerHost[types$7.distance.remote]
        },
        heartbeatInterval: options.pooling.heartBeatInterval,
        compression: 'NONE',
        reconnectionPolicy: getPolicyInfo(options.policies.reconnection),
        ssl: {
          enabled: !!options.sslOptions,
          certValidation: options.sslOptions ? !!options.sslOptions.rejectUnauthorized : undefined
        },
        authProvider: {
          type: !(options.authProvider instanceof NoAuthProvider$1) ? getConstructor(options.authProvider) : undefined,
        },
        otherOptions: {
          coalescingThreshold: options.socketOptions.coalescingThreshold,
        },
        platformInfo: {
          os: {
            name: os.platform(),
            version: os.release(),
            arch: os.arch()
          },
          cpus: {
            length: os.cpus().length,
            model: os.cpus()[0].model
          },
          runtime: {
            node: process.versions['node'],
            v8: process.versions['v8'],
            uv: process.versions['uv'],
            openssl: process.versions['openssl'],
            kerberos: kerberosModule ? kerberosModule.version : undefined
          }
        },
        configAntiPatterns: this._getConfigAntiPatterns(),
        periodicStatusInterval: Math.floor(this._statusEventDelay / 1000)
      }
    };

    return JSON.stringify(message);
  }

  _getConfigAntiPatterns() {
    const options = this._client.options;
    const result = {};

    if (options.sslOptions && !options.sslOptions.rejectUnauthorized) {
      result.sslWithoutCertValidation =
        'Client-to-node encryption is enabled but server certificate validation is disabled';
    }

    return result;
  }

  /**
   * Gets an array of data centers the driver connects to.
   * Whether the driver connects to a certain host is determined by the host distance (local and remote hosts)
   * and the pooling options (whether connection length for remote hosts is greater than 0).
   * @returns {Array}
   * @private
   */
  _getDataCenters() {
    const remoteConnectionsLength = this._client.options.pooling.coreConnectionsPerHost[types$7.distance.remote];
    const dataCenters = new Set();

    this._client.hosts.values().forEach(h => {
      const distance = this._client.profileManager.getDistance(h);
      if (distance === types$7.distance.local || (distance === types$7.distance.remote && remoteConnectionsLength > 0)) {
        dataCenters.add(h.datacenter);
      }
    });

    return Array.from(dataCenters);
  }

  /**
   * Tries to obtain the application name and version from
   * @param {DseClientOptions} options
   * @returns {Promise}
   * @private
   */
  async _getAppInfo(options) {
    if (typeof options.applicationName === 'string') {
      return Promise.resolve({
        applicationName: options.applicationName,
        applicationVersion: options.applicationVersion,
        applicationNameWasGenerated: false
      });
    }

    let readPromise = Promise.resolve();

    if (require.main && require.main.filename) {
      const packageInfoPath = path.dirname(require.main.filename);
      readPromise = this._readPackageInfoFile(packageInfoPath);
    }

    const text = await readPromise;
    let applicationName = 'Default Node.js Application';
    let applicationVersion;

    if (text) {
      try {
        const packageInfo = JSON.parse(text);
        if (packageInfo.name) {
          applicationName = packageInfo.name;
          applicationVersion = packageInfo.version;
        }
      }
      catch (err) {
        // The package.json file could not be parsed
        // Use the default name
      }
    }

    return {
      applicationName,
      applicationVersion,
      applicationNameWasGenerated: true
    };
  }

  /**
   * @private
   * @returns {Promise<string>} A Promise that will never be rejected
   */
  _readPackageInfoFile(packageInfoPath) {
    return new Promise(resolve => {
      fs$2.readFile(path.join(packageInfoPath, 'package.json'), 'utf8', (err, data) => {
        // Swallow error
        resolve(data);
      });
    });
  }

  /**
   * @returns {String} Returns a json string with the startup message.
   * @private
   */
  _getStatusEvent() {
    const cc = this._client.controlConnection;
    const options = this._client.options;
    const state = this._client.getState();
    const connectedNodes = {};

    state.getConnectedHosts().forEach(h => {
      connectedNodes[h.address] = {
        connections: state.getOpenConnections(h),
        inFlightQueries: state.getInFlightQueries(h)
      };
    });

    const message = {
      metadata: {
        name: 'driver.status',
        insightMappingId: 'v1',
        insightType: 'EVENT',
        timestamp: Date.now(),
        tags: { language: 'nodejs' }
      },
      data: {
        clientId: options.id,
        sessionId: this._sessionId,
        controlConnection: cc.host ? cc.host.address : undefined,
        connectedNodes
      }
    };

    return JSON.stringify(message);
  }

  /**
   * Cleans any timer used internally and sets the client as closed.
   */
  shutdown() {
    if (!this._enabled) {
      return;
    }

    this._closed = true;

    if (this._firstTimeout !== null) {
      clearTimeout(this._firstTimeout);
    }

    if (this._recurrentTimeout !== null) {
      clearInterval(this._recurrentTimeout);
    }
  }
};

var insightsClient = InsightsClient$1;

function mapToObject(map) {
  const result = {};
  map.forEach((value, key) => result[key] = value);
  return result;
}

function getPolicyInfo(policy) {
  if (!policy) {
    return undefined;
  }

  const options = policy.getOptions && policy.getOptions();

  return {
    type: policy.constructor.name,
    options: (options instanceof Map) ? mapToObject(options) : utils$d.emptyObject
  };
}

function getConsistencyString(c) {
  if (typeof c !== 'number') {
    return undefined;
  }

  return types$7.consistencyToString[c];
}

function getConstructor(instance) {
  return instance ? instance.constructor.name : undefined;
}

function getExecutionProfiles(client) {
  const executionProfiles = {};

  const defaultProfile = client.profileManager.getDefault();
  setExecutionProfileProperties(client, executionProfiles, defaultProfile, defaultProfile);

  client.profileManager.getAll()
    .filter(p => p !== defaultProfile)
    .forEach(profile => setExecutionProfileProperties(client, executionProfiles, profile, defaultProfile));

  return executionProfiles;
}

function setExecutionProfileProperties(client, parent, profile, defaultProfile) {
  const output = parent[profile.name] = {};
  setExecutionProfileItem(output, profile, defaultProfile, 'readTimeout');
  setExecutionProfileItem(output, profile, defaultProfile, 'loadBalancing', getPolicyInfo);
  setExecutionProfileItem(output, profile, defaultProfile, 'retry', getPolicyInfo);
  setExecutionProfileItem(output, profile, defaultProfile, 'consistency', getConsistencyString);
  setExecutionProfileItem(output, profile, defaultProfile, 'serialConsistency', getConsistencyString);

  if (profile === defaultProfile) {
    // Speculative execution policy is included in the profiles as some drivers support
    // different spec exec policy per profile, in this case is fixed for all profiles
    output.speculativeExecution = getPolicyInfo(client.options.policies.speculativeExecution);
  }

  if (profile.graphOptions) {
    output.graphOptions = {};
    const defaultGraphOptions = defaultProfile.graphOptions || utils$d.emptyObject;
    setExecutionProfileItem(output.graphOptions, profile.graphOptions, defaultGraphOptions, 'language');
    setExecutionProfileItem(output.graphOptions, profile.graphOptions, defaultGraphOptions, 'name');
    setExecutionProfileItem(output.graphOptions, profile.graphOptions, defaultGraphOptions, 'readConsistency',
      getConsistencyString);
    setExecutionProfileItem(output.graphOptions, profile.graphOptions, defaultGraphOptions, 'source');
    setExecutionProfileItem(output.graphOptions, profile.graphOptions, defaultGraphOptions, 'writeConsistency',
      getConsistencyString);

    if (Object.keys(output.graphOptions).length === 0) {
      // Properties that are undefined will not be included in the JSON
      output.graphOptions = undefined;
    }
  }
}

function setExecutionProfileItem(output, profile, defaultProfile, prop, valueGetter) {
  const value = profile[prop];
  valueGetter = valueGetter || (x => x);

  if ((profile === defaultProfile && value !== undefined) || value !== defaultProfile[prop]) {
    output[prop] = valueGetter(value);
  }
}

var utilExports = {};
var util$5 = {
  get exports(){ return utilExports; },
  set exports(v){ utilExports = v; },
};

var fileSystem = {};

var require$1 = fileSystem.require = function () {
    if (typeof process === "object" && process.versions && process.versions["electron"]) {
        try {
            const originalFs = require$1("original-fs");
            if (Object.keys(originalFs).length > 0) {
                return originalFs;
            }
        } catch (e) {}
    }
    return require$$1;
};

var constants = {
    /* The local file header */
    LOCHDR           : 30, // LOC header size
    LOCSIG           : 0x04034b50, // "PK\003\004"
    LOCVER           : 4,	// version needed to extract
    LOCFLG           : 6, // general purpose bit flag
    LOCHOW           : 8, // compression method
    LOCTIM           : 10, // modification time (2 bytes time, 2 bytes date)
    LOCCRC           : 14, // uncompressed file crc-32 value
    LOCSIZ           : 18, // compressed size
    LOCLEN           : 22, // uncompressed size
    LOCNAM           : 26, // filename length
    LOCEXT           : 28, // extra field length

    /* The Data descriptor */
    EXTSIG           : 0x08074b50, // "PK\007\008"
    EXTHDR           : 16, // EXT header size
    EXTCRC           : 4, // uncompressed file crc-32 value
    EXTSIZ           : 8, // compressed size
    EXTLEN           : 12, // uncompressed size

    /* The central directory file header */
    CENHDR           : 46, // CEN header size
    CENSIG           : 0x02014b50, // "PK\001\002"
    CENVEM           : 4, // version made by
    CENVER           : 6, // version needed to extract
    CENFLG           : 8, // encrypt, decrypt flags
    CENHOW           : 10, // compression method
    CENTIM           : 12, // modification time (2 bytes time, 2 bytes date)
    CENCRC           : 16, // uncompressed file crc-32 value
    CENSIZ           : 20, // compressed size
    CENLEN           : 24, // uncompressed size
    CENNAM           : 28, // filename length
    CENEXT           : 30, // extra field length
    CENCOM           : 32, // file comment length
    CENDSK           : 34, // volume number start
    CENATT           : 36, // internal file attributes
    CENATX           : 38, // external file attributes (host system dependent)
    CENOFF           : 42, // LOC header offset

    /* The entries in the end of central directory */
    ENDHDR           : 22, // END header size
    ENDSIG           : 0x06054b50, // "PK\005\006"
    ENDSUB           : 8, // number of entries on this disk
    ENDTOT           : 10, // total number of entries
    ENDSIZ           : 12, // central directory size in bytes
    ENDOFF           : 16, // offset of first CEN header
    ENDCOM           : 20, // zip file comment length

    END64HDR         : 20, // zip64 END header size
    END64SIG         : 0x07064b50, // zip64 Locator signature, "PK\006\007"
    END64START       : 4, // number of the disk with the start of the zip64
    END64OFF         : 8, // relative offset of the zip64 end of central directory
    END64NUMDISKS    : 16, // total number of disks

    ZIP64SIG         : 0x06064b50, // zip64 signature, "PK\006\006"
    ZIP64HDR         : 56, // zip64 record minimum size
    ZIP64LEAD        : 12, // leading bytes at the start of the record, not counted by the value stored in ZIP64SIZE
    ZIP64SIZE        : 4, // zip64 size of the central directory record
    ZIP64VEM         : 12, // zip64 version made by
    ZIP64VER         : 14, // zip64 version needed to extract
    ZIP64DSK         : 16, // zip64 number of this disk
    ZIP64DSKDIR      : 20, // number of the disk with the start of the record directory
    ZIP64SUB         : 24, // number of entries on this disk
    ZIP64TOT         : 32, // total number of entries
    ZIP64SIZB        : 40, // zip64 central directory size in bytes
    ZIP64OFF         : 48, // offset of start of central directory with respect to the starting disk number
    ZIP64EXTRA       : 56, // extensible data sector

    /* Compression methods */
    STORED           : 0, // no compression
    SHRUNK           : 1, // shrunk
    REDUCED1         : 2, // reduced with compression factor 1
    REDUCED2         : 3, // reduced with compression factor 2
    REDUCED3         : 4, // reduced with compression factor 3
    REDUCED4         : 5, // reduced with compression factor 4
    IMPLODED         : 6, // imploded
    // 7 reserved for Tokenizing compression algorithm
    DEFLATED         : 8, // deflated
    ENHANCED_DEFLATED: 9, // enhanced deflated
    PKWARE           : 10,// PKWare DCL imploded
    // 11 reserved by PKWARE
    BZIP2            : 12, //  compressed using BZIP2
    // 13 reserved by PKWARE
    LZMA             : 14, // LZMA
    // 15-17 reserved by PKWARE
    IBM_TERSE        : 18, // compressed using IBM TERSE
    IBM_LZ77         : 19, // IBM LZ77 z
    AES_ENCRYPT      : 99, // WinZIP AES encryption method

    /* General purpose bit flag */
    // values can obtained with expression 2**bitnr
    FLG_ENC          : 1,    // Bit 0: encrypted file
    FLG_COMP1        : 2,    // Bit 1, compression option
    FLG_COMP2        : 4,    // Bit 2, compression option
    FLG_DESC         : 8,    // Bit 3, data descriptor
    FLG_ENH          : 16,   // Bit 4, enhanced deflating
    FLG_PATCH        : 32,   // Bit 5, indicates that the file is compressed patched data.
    FLG_STR          : 64,   // Bit 6, strong encryption (patented)
                             // Bits 7-10: Currently unused.
    FLG_EFS          : 2048, // Bit 11: Language encoding flag (EFS)
                             // Bit 12: Reserved by PKWARE for enhanced compression.
                             // Bit 13: encrypted the Central Directory (patented).
                             // Bits 14-15: Reserved by PKWARE.
    FLG_MSK          : 4096, // mask header values

    /* Load type */
    FILE             : 2,
    BUFFER           : 1,
    NONE             : 0,

    /* 4.5 Extensible data fields */
    EF_ID            : 0,
    EF_SIZE          : 2,

    /* Header IDs */
    ID_ZIP64         : 0x0001,
    ID_AVINFO        : 0x0007,
    ID_PFS           : 0x0008,
    ID_OS2           : 0x0009,
    ID_NTFS          : 0x000a,
    ID_OPENVMS       : 0x000c,
    ID_UNIX          : 0x000d,
    ID_FORK          : 0x000e,
    ID_PATCH         : 0x000f,
    ID_X509_PKCS7    : 0x0014,
    ID_X509_CERTID_F : 0x0015,
    ID_X509_CERTID_C : 0x0016,
    ID_STRONGENC     : 0x0017,
    ID_RECORD_MGT    : 0x0018,
    ID_X509_PKCS7_RL : 0x0019,
    ID_IBM1          : 0x0065,
    ID_IBM2          : 0x0066,
    ID_POSZIP        : 0x4690,

    EF_ZIP64_OR_32   : 0xffffffff,
    EF_ZIP64_OR_16   : 0xffff,
    EF_ZIP64_SUNCOMP : 0,
    EF_ZIP64_SCOMP   : 8,
    EF_ZIP64_RHO     : 16,
    EF_ZIP64_DSN     : 24
};

var errors$5 = {
    /* Header error messages */
    INVALID_LOC: "Invalid LOC header (bad signature)",
    INVALID_CEN: "Invalid CEN header (bad signature)",
    INVALID_END: "Invalid END header (bad signature)",

    /* ZipEntry error messages*/
    NO_DATA: "Nothing to decompress",
    BAD_CRC: "CRC32 checksum failed",
    FILE_IN_THE_WAY: "There is a file in the way: %s",
    UNKNOWN_METHOD: "Invalid/unsupported compression method",

    /* Inflater error messages */
    AVAIL_DATA: "inflate::Available inflate data did not terminate",
    INVALID_DISTANCE: "inflate::Invalid literal/length or distance code in fixed or dynamic block",
    TO_MANY_CODES: "inflate::Dynamic block code description: too many length or distance codes",
    INVALID_REPEAT_LEN: "inflate::Dynamic block code description: repeat more than specified lengths",
    INVALID_REPEAT_FIRST: "inflate::Dynamic block code description: repeat lengths with no first length",
    INCOMPLETE_CODES: "inflate::Dynamic block code description: code lengths codes incomplete",
    INVALID_DYN_DISTANCE: "inflate::Dynamic block code description: invalid distance code lengths",
    INVALID_CODES_LEN: "inflate::Dynamic block code description: invalid literal/length code lengths",
    INVALID_STORE_BLOCK: "inflate::Stored block length did not match one's complement",
    INVALID_BLOCK_TYPE: "inflate::Invalid block type (type == 3)",

    /* ADM-ZIP error messages */
    CANT_EXTRACT_FILE: "Could not extract the file",
    CANT_OVERRIDE: "Target file already exists",
    NO_ZIP: "No zip file was loaded",
    NO_ENTRY: "Entry doesn't exist",
    DIRECTORY_CONTENT_ERROR: "A directory cannot have content",
    FILE_NOT_FOUND: "File not found: %s",
    NOT_IMPLEMENTED: "Not implemented",
    INVALID_FILENAME: "Invalid filename",
    INVALID_FORMAT: "Invalid or unsupported zip format. No END header found"
};

const fsystem = fileSystem.require();
const pth$2 = require$$0$5;
const Constants$3 = constants;
const Errors = errors$5;
const isWin = typeof process === "object" && "win32" === process.platform;

const is_Obj = (obj) => obj && typeof obj === "object";

// generate CRC32 lookup table
const crcTable = new Uint32Array(256).map((t, c) => {
    for (let k = 0; k < 8; k++) {
        if ((c & 1) !== 0) {
            c = 0xedb88320 ^ (c >>> 1);
        } else {
            c >>>= 1;
        }
    }
    return c >>> 0;
});

// UTILS functions

function Utils$5(opts) {
    this.sep = pth$2.sep;
    this.fs = fsystem;

    if (is_Obj(opts)) {
        // custom filesystem
        if (is_Obj(opts.fs) && typeof opts.fs.statSync === "function") {
            this.fs = opts.fs;
        }
    }
}

var utils$c = Utils$5;

// INSTANCED functions

Utils$5.prototype.makeDir = function (/*String*/ folder) {
    const self = this;

    // Sync - make directories tree
    function mkdirSync(/*String*/ fpath) {
        let resolvedPath = fpath.split(self.sep)[0];
        fpath.split(self.sep).forEach(function (name) {
            if (!name || name.substr(-1, 1) === ":") return;
            resolvedPath += self.sep + name;
            var stat;
            try {
                stat = self.fs.statSync(resolvedPath);
            } catch (e) {
                self.fs.mkdirSync(resolvedPath);
            }
            if (stat && stat.isFile()) throw Errors.FILE_IN_THE_WAY.replace("%s", resolvedPath);
        });
    }

    mkdirSync(folder);
};

Utils$5.prototype.writeFileTo = function (/*String*/ path, /*Buffer*/ content, /*Boolean*/ overwrite, /*Number*/ attr) {
    const self = this;
    if (self.fs.existsSync(path)) {
        if (!overwrite) return false; // cannot overwrite

        var stat = self.fs.statSync(path);
        if (stat.isDirectory()) {
            return false;
        }
    }
    var folder = pth$2.dirname(path);
    if (!self.fs.existsSync(folder)) {
        self.makeDir(folder);
    }

    var fd;
    try {
        fd = self.fs.openSync(path, "w", 438); // 0666
    } catch (e) {
        self.fs.chmodSync(path, 438);
        fd = self.fs.openSync(path, "w", 438);
    }
    if (fd) {
        try {
            self.fs.writeSync(fd, content, 0, content.length, 0);
        } finally {
            self.fs.closeSync(fd);
        }
    }
    self.fs.chmodSync(path, attr || 438);
    return true;
};

Utils$5.prototype.writeFileToAsync = function (/*String*/ path, /*Buffer*/ content, /*Boolean*/ overwrite, /*Number*/ attr, /*Function*/ callback) {
    if (typeof attr === "function") {
        callback = attr;
        attr = undefined;
    }

    const self = this;

    self.fs.exists(path, function (exist) {
        if (exist && !overwrite) return callback(false);

        self.fs.stat(path, function (err, stat) {
            if (exist && stat.isDirectory()) {
                return callback(false);
            }

            var folder = pth$2.dirname(path);
            self.fs.exists(folder, function (exists) {
                if (!exists) self.makeDir(folder);

                self.fs.open(path, "w", 438, function (err, fd) {
                    if (err) {
                        self.fs.chmod(path, 438, function () {
                            self.fs.open(path, "w", 438, function (err, fd) {
                                self.fs.write(fd, content, 0, content.length, 0, function () {
                                    self.fs.close(fd, function () {
                                        self.fs.chmod(path, attr || 438, function () {
                                            callback(true);
                                        });
                                    });
                                });
                            });
                        });
                    } else if (fd) {
                        self.fs.write(fd, content, 0, content.length, 0, function () {
                            self.fs.close(fd, function () {
                                self.fs.chmod(path, attr || 438, function () {
                                    callback(true);
                                });
                            });
                        });
                    } else {
                        self.fs.chmod(path, attr || 438, function () {
                            callback(true);
                        });
                    }
                });
            });
        });
    });
};

Utils$5.prototype.findFiles = function (/*String*/ path) {
    const self = this;

    function findSync(/*String*/ dir, /*RegExp*/ pattern, /*Boolean*/ recursive) {
        if (typeof pattern === "boolean") {
            recursive = pattern;
            pattern = undefined;
        }
        let files = [];
        self.fs.readdirSync(dir).forEach(function (file) {
            var path = pth$2.join(dir, file);

            if (self.fs.statSync(path).isDirectory() && recursive) files = files.concat(findSync(path, pattern, recursive));

            if (!pattern || pattern.test(path)) {
                files.push(pth$2.normalize(path) + (self.fs.statSync(path).isDirectory() ? self.sep : ""));
            }
        });
        return files;
    }

    return findSync(path, undefined, true);
};

Utils$5.prototype.getAttributes = function () {};

Utils$5.prototype.setAttributes = function () {};

// STATIC functions

// crc32 single update (it is part of crc32)
Utils$5.crc32update = function (crc, byte) {
    return crcTable[(crc ^ byte) & 0xff] ^ (crc >>> 8);
};

Utils$5.crc32 = function (buf) {
    if (typeof buf === "string") {
        buf = Buffer.from(buf, "utf8");
    }
    // Generate crcTable
    if (!crcTable.length) genCRCTable();

    let len = buf.length;
    let crc = ~0;
    for (let off = 0; off < len; ) crc = Utils$5.crc32update(crc, buf[off++]);
    // xor and cast as uint32 number
    return ~crc >>> 0;
};

Utils$5.methodToString = function (/*Number*/ method) {
    switch (method) {
        case Constants$3.STORED:
            return "STORED (" + method + ")";
        case Constants$3.DEFLATED:
            return "DEFLATED (" + method + ")";
        default:
            return "UNSUPPORTED (" + method + ")";
    }
};

// removes ".." style path elements
Utils$5.canonical = function (/*string*/ path) {
    if (!path) return "";
    // trick normalize think path is absolute
    var safeSuffix = pth$2.posix.normalize("/" + path.split("\\").join("/"));
    return pth$2.join(".", safeSuffix);
};

// make abolute paths taking prefix as root folder
Utils$5.sanitize = function (/*string*/ prefix, /*string*/ name) {
    prefix = pth$2.resolve(pth$2.normalize(prefix));
    var parts = name.split("/");
    for (var i = 0, l = parts.length; i < l; i++) {
        var path = pth$2.normalize(pth$2.join(prefix, parts.slice(i, l).join(pth$2.sep)));
        if (path.indexOf(prefix) === 0) {
            return path;
        }
    }
    return pth$2.normalize(pth$2.join(prefix, pth$2.basename(name)));
};

// converts buffer, Uint8Array, string types to buffer
Utils$5.toBuffer = function toBuffer(/*buffer, Uint8Array, string*/ input) {
    if (Buffer.isBuffer(input)) {
        return input;
    } else if (input instanceof Uint8Array) {
        return Buffer.from(input);
    } else {
        // expect string all other values are invalid and return empty buffer
        return typeof input === "string" ? Buffer.from(input, "utf8") : Buffer.alloc(0);
    }
};

Utils$5.readBigUInt64LE = function (/*Buffer*/ buffer, /*int*/ index) {
    var slice = Buffer.from(buffer.slice(index, index + 8));
    slice.swap64();

    return parseInt(`0x${slice.toString("hex")}`);
};

Utils$5.isWin = isWin; // Do we have windows system
Utils$5.crcTable = crcTable;

const fs$1 = fileSystem.require();
const pth$1 = require$$0$5;

fs$1.existsSync = fs$1.existsSync || pth$1.existsSync;

var fattr = function (/*String*/ path) {
    var _path = path || "",
        _obj = newAttr(),
        _stat = null;

    function newAttr() {
        return {
            directory: false,
            readonly: false,
            hidden: false,
            executable: false,
            mtime: 0,
            atime: 0
        };
    }

    if (_path && fs$1.existsSync(_path)) {
        _stat = fs$1.statSync(_path);
        _obj.directory = _stat.isDirectory();
        _obj.mtime = _stat.mtime;
        _obj.atime = _stat.atime;
        _obj.executable = (0o111 & _stat.mode) !== 0; // file is executable who ever har right not just owner
        _obj.readonly = (0o200 & _stat.mode) === 0; // readonly if owner has no write right
        _obj.hidden = pth$1.basename(_path)[0] === ".";
    } else {
        console.warn("Invalid path: " + _path);
    }

    return {
        get directory() {
            return _obj.directory;
        },

        get readOnly() {
            return _obj.readonly;
        },

        get hidden() {
            return _obj.hidden;
        },

        get mtime() {
            return _obj.mtime;
        },

        get atime() {
            return _obj.atime;
        },

        get executable() {
            return _obj.executable;
        },

        decodeAttributes: function () {},

        encodeAttributes: function () {},

        toJSON: function () {
            return {
                path: _path,
                isDirectory: _obj.directory,
                isReadOnly: _obj.readonly,
                isHidden: _obj.hidden,
                isExecutable: _obj.executable,
                mTime: _obj.mtime,
                aTime: _obj.atime
            };
        },

        toString: function () {
            return JSON.stringify(this.toJSON(), null, "\t");
        }
    };
};

(function (module) {
	module.exports = utils$c;
	module.exports.Constants = constants;
	module.exports.Errors = errors$5;
	module.exports.FileAttr = fattr;
} (util$5));

var headers = {};

var Utils$4 = utilExports,
    Constants$2 = Utils$4.Constants;

/* The central directory file header */
var entryHeader = function () {
    var _verMade = 20, // v2.0
        _version = 10, // v1.0
        _flags = 0,
        _method = 0,
        _time = 0,
        _crc = 0,
        _compressedSize = 0,
        _size = 0,
        _fnameLen = 0,
        _extraLen = 0,
        _comLen = 0,
        _diskStart = 0,
        _inattr = 0,
        _attr = 0,
        _offset = 0;

    _verMade |= Utils$4.isWin ? 0x0a00 : 0x0300;

    // Set EFS flag since filename and comment fields are all by default encoded using UTF-8.
    // Without it file names may be corrupted for other apps when file names use unicode chars
    _flags |= Constants$2.FLG_EFS;

    var _dataHeader = {};

    function setTime(val) {
        val = new Date(val);
        _time =
            (((val.getFullYear() - 1980) & 0x7f) << 25) | // b09-16 years from 1980
            ((val.getMonth() + 1) << 21) | // b05-08 month
            (val.getDate() << 16) | // b00-04 hour
            // 2 bytes time
            (val.getHours() << 11) | // b11-15 hour
            (val.getMinutes() << 5) | // b05-10 minute
            (val.getSeconds() >> 1); // b00-04 seconds divided by 2
    }

    setTime(+new Date());

    return {
        get made() {
            return _verMade;
        },
        set made(val) {
            _verMade = val;
        },

        get version() {
            return _version;
        },
        set version(val) {
            _version = val;
        },

        get flags() {
            return _flags;
        },
        set flags(val) {
            _flags = val;
        },

        get method() {
            return _method;
        },
        set method(val) {
            switch (val) {
                case Constants$2.STORED:
                    this.version = 10;
                case Constants$2.DEFLATED:
                default:
                    this.version = 20;
            }
            _method = val;
        },

        get time() {
            return new Date(((_time >> 25) & 0x7f) + 1980, ((_time >> 21) & 0x0f) - 1, (_time >> 16) & 0x1f, (_time >> 11) & 0x1f, (_time >> 5) & 0x3f, (_time & 0x1f) << 1);
        },
        set time(val) {
            setTime(val);
        },

        get crc() {
            return _crc;
        },
        set crc(val) {
            _crc = Math.max(0, val) >>> 0;
        },

        get compressedSize() {
            return _compressedSize;
        },
        set compressedSize(val) {
            _compressedSize = Math.max(0, val) >>> 0;
        },

        get size() {
            return _size;
        },
        set size(val) {
            _size = Math.max(0, val) >>> 0;
        },

        get fileNameLength() {
            return _fnameLen;
        },
        set fileNameLength(val) {
            _fnameLen = val;
        },

        get extraLength() {
            return _extraLen;
        },
        set extraLength(val) {
            _extraLen = val;
        },

        get commentLength() {
            return _comLen;
        },
        set commentLength(val) {
            _comLen = val;
        },

        get diskNumStart() {
            return _diskStart;
        },
        set diskNumStart(val) {
            _diskStart = Math.max(0, val) >>> 0;
        },

        get inAttr() {
            return _inattr;
        },
        set inAttr(val) {
            _inattr = Math.max(0, val) >>> 0;
        },

        get attr() {
            return _attr;
        },
        set attr(val) {
            _attr = Math.max(0, val) >>> 0;
        },

        // get Unix file permissions
        get fileAttr() {
            return _attr ? (((_attr >>> 0) | 0) >> 16) & 0xfff : 0;
        },

        get offset() {
            return _offset;
        },
        set offset(val) {
            _offset = Math.max(0, val) >>> 0;
        },

        get encripted() {
            return (_flags & 1) === 1;
        },

        get entryHeaderSize() {
            return Constants$2.CENHDR + _fnameLen + _extraLen + _comLen;
        },

        get realDataOffset() {
            return _offset + Constants$2.LOCHDR + _dataHeader.fnameLen + _dataHeader.extraLen;
        },

        get dataHeader() {
            return _dataHeader;
        },

        loadDataHeaderFromBinary: function (/*Buffer*/ input) {
            var data = input.slice(_offset, _offset + Constants$2.LOCHDR);
            // 30 bytes and should start with "PK\003\004"
            if (data.readUInt32LE(0) !== Constants$2.LOCSIG) {
                throw new Error(Utils$4.Errors.INVALID_LOC);
            }
            _dataHeader = {
                // version needed to extract
                version: data.readUInt16LE(Constants$2.LOCVER),
                // general purpose bit flag
                flags: data.readUInt16LE(Constants$2.LOCFLG),
                // compression method
                method: data.readUInt16LE(Constants$2.LOCHOW),
                // modification time (2 bytes time, 2 bytes date)
                time: data.readUInt32LE(Constants$2.LOCTIM),
                // uncompressed file crc-32 value
                crc: data.readUInt32LE(Constants$2.LOCCRC),
                // compressed size
                compressedSize: data.readUInt32LE(Constants$2.LOCSIZ),
                // uncompressed size
                size: data.readUInt32LE(Constants$2.LOCLEN),
                // filename length
                fnameLen: data.readUInt16LE(Constants$2.LOCNAM),
                // extra field length
                extraLen: data.readUInt16LE(Constants$2.LOCEXT)
            };
        },

        loadFromBinary: function (/*Buffer*/ data) {
            // data should be 46 bytes and start with "PK 01 02"
            if (data.length !== Constants$2.CENHDR || data.readUInt32LE(0) !== Constants$2.CENSIG) {
                throw new Error(Utils$4.Errors.INVALID_CEN);
            }
            // version made by
            _verMade = data.readUInt16LE(Constants$2.CENVEM);
            // version needed to extract
            _version = data.readUInt16LE(Constants$2.CENVER);
            // encrypt, decrypt flags
            _flags = data.readUInt16LE(Constants$2.CENFLG);
            // compression method
            _method = data.readUInt16LE(Constants$2.CENHOW);
            // modification time (2 bytes time, 2 bytes date)
            _time = data.readUInt32LE(Constants$2.CENTIM);
            // uncompressed file crc-32 value
            _crc = data.readUInt32LE(Constants$2.CENCRC);
            // compressed size
            _compressedSize = data.readUInt32LE(Constants$2.CENSIZ);
            // uncompressed size
            _size = data.readUInt32LE(Constants$2.CENLEN);
            // filename length
            _fnameLen = data.readUInt16LE(Constants$2.CENNAM);
            // extra field length
            _extraLen = data.readUInt16LE(Constants$2.CENEXT);
            // file comment length
            _comLen = data.readUInt16LE(Constants$2.CENCOM);
            // volume number start
            _diskStart = data.readUInt16LE(Constants$2.CENDSK);
            // internal file attributes
            _inattr = data.readUInt16LE(Constants$2.CENATT);
            // external file attributes
            _attr = data.readUInt32LE(Constants$2.CENATX);
            // LOC header offset
            _offset = data.readUInt32LE(Constants$2.CENOFF);
        },

        dataHeaderToBinary: function () {
            // LOC header size (30 bytes)
            var data = Buffer.alloc(Constants$2.LOCHDR);
            // "PK\003\004"
            data.writeUInt32LE(Constants$2.LOCSIG, 0);
            // version needed to extract
            data.writeUInt16LE(_version, Constants$2.LOCVER);
            // general purpose bit flag
            data.writeUInt16LE(_flags, Constants$2.LOCFLG);
            // compression method
            data.writeUInt16LE(_method, Constants$2.LOCHOW);
            // modification time (2 bytes time, 2 bytes date)
            data.writeUInt32LE(_time, Constants$2.LOCTIM);
            // uncompressed file crc-32 value
            data.writeUInt32LE(_crc, Constants$2.LOCCRC);
            // compressed size
            data.writeUInt32LE(_compressedSize, Constants$2.LOCSIZ);
            // uncompressed size
            data.writeUInt32LE(_size, Constants$2.LOCLEN);
            // filename length
            data.writeUInt16LE(_fnameLen, Constants$2.LOCNAM);
            // extra field length
            data.writeUInt16LE(_extraLen, Constants$2.LOCEXT);
            return data;
        },

        entryHeaderToBinary: function () {
            // CEN header size (46 bytes)
            var data = Buffer.alloc(Constants$2.CENHDR + _fnameLen + _extraLen + _comLen);
            // "PK\001\002"
            data.writeUInt32LE(Constants$2.CENSIG, 0);
            // version made by
            data.writeUInt16LE(_verMade, Constants$2.CENVEM);
            // version needed to extract
            data.writeUInt16LE(_version, Constants$2.CENVER);
            // encrypt, decrypt flags
            data.writeUInt16LE(_flags, Constants$2.CENFLG);
            // compression method
            data.writeUInt16LE(_method, Constants$2.CENHOW);
            // modification time (2 bytes time, 2 bytes date)
            data.writeUInt32LE(_time, Constants$2.CENTIM);
            // uncompressed file crc-32 value
            data.writeUInt32LE(_crc, Constants$2.CENCRC);
            // compressed size
            data.writeUInt32LE(_compressedSize, Constants$2.CENSIZ);
            // uncompressed size
            data.writeUInt32LE(_size, Constants$2.CENLEN);
            // filename length
            data.writeUInt16LE(_fnameLen, Constants$2.CENNAM);
            // extra field length
            data.writeUInt16LE(_extraLen, Constants$2.CENEXT);
            // file comment length
            data.writeUInt16LE(_comLen, Constants$2.CENCOM);
            // volume number start
            data.writeUInt16LE(_diskStart, Constants$2.CENDSK);
            // internal file attributes
            data.writeUInt16LE(_inattr, Constants$2.CENATT);
            // external file attributes
            data.writeUInt32LE(_attr, Constants$2.CENATX);
            // LOC header offset
            data.writeUInt32LE(_offset, Constants$2.CENOFF);
            // fill all with
            data.fill(0x00, Constants$2.CENHDR);
            return data;
        },

        toJSON: function () {
            const bytes = function (nr) {
                return nr + " bytes";
            };

            return {
                made: _verMade,
                version: _version,
                flags: _flags,
                method: Utils$4.methodToString(_method),
                time: this.time,
                crc: "0x" + _crc.toString(16).toUpperCase(),
                compressedSize: bytes(_compressedSize),
                size: bytes(_size),
                fileNameLength: bytes(_fnameLen),
                extraLength: bytes(_extraLen),
                commentLength: bytes(_comLen),
                diskNumStart: _diskStart,
                inAttr: _inattr,
                attr: _attr,
                offset: _offset,
                entryHeaderSize: bytes(Constants$2.CENHDR + _fnameLen + _extraLen + _comLen)
            };
        },

        toString: function () {
            return JSON.stringify(this.toJSON(), null, "\t");
        }
    };
};

var Utils$3 = utilExports,
    Constants$1 = Utils$3.Constants;

/* The entries in the end of central directory */
var mainHeader = function () {
    var _volumeEntries = 0,
        _totalEntries = 0,
        _size = 0,
        _offset = 0,
        _commentLength = 0;

    return {
        get diskEntries() {
            return _volumeEntries;
        },
        set diskEntries(/*Number*/ val) {
            _volumeEntries = _totalEntries = val;
        },

        get totalEntries() {
            return _totalEntries;
        },
        set totalEntries(/*Number*/ val) {
            _totalEntries = _volumeEntries = val;
        },

        get size() {
            return _size;
        },
        set size(/*Number*/ val) {
            _size = val;
        },

        get offset() {
            return _offset;
        },
        set offset(/*Number*/ val) {
            _offset = val;
        },

        get commentLength() {
            return _commentLength;
        },
        set commentLength(/*Number*/ val) {
            _commentLength = val;
        },

        get mainHeaderSize() {
            return Constants$1.ENDHDR + _commentLength;
        },

        loadFromBinary: function (/*Buffer*/ data) {
            // data should be 22 bytes and start with "PK 05 06"
            // or be 56+ bytes and start with "PK 06 06" for Zip64
            if (
                (data.length !== Constants$1.ENDHDR || data.readUInt32LE(0) !== Constants$1.ENDSIG) &&
                (data.length < Constants$1.ZIP64HDR || data.readUInt32LE(0) !== Constants$1.ZIP64SIG)
            ) {
                throw new Error(Utils$3.Errors.INVALID_END);
            }

            if (data.readUInt32LE(0) === Constants$1.ENDSIG) {
                // number of entries on this volume
                _volumeEntries = data.readUInt16LE(Constants$1.ENDSUB);
                // total number of entries
                _totalEntries = data.readUInt16LE(Constants$1.ENDTOT);
                // central directory size in bytes
                _size = data.readUInt32LE(Constants$1.ENDSIZ);
                // offset of first CEN header
                _offset = data.readUInt32LE(Constants$1.ENDOFF);
                // zip file comment length
                _commentLength = data.readUInt16LE(Constants$1.ENDCOM);
            } else {
                // number of entries on this volume
                _volumeEntries = Utils$3.readBigUInt64LE(data, Constants$1.ZIP64SUB);
                // total number of entries
                _totalEntries = Utils$3.readBigUInt64LE(data, Constants$1.ZIP64TOT);
                // central directory size in bytes
                _size = Utils$3.readBigUInt64LE(data, Constants$1.ZIP64SIZE);
                // offset of first CEN header
                _offset = Utils$3.readBigUInt64LE(data, Constants$1.ZIP64OFF);

                _commentLength = 0;
            }
        },

        toBinary: function () {
            var b = Buffer.alloc(Constants$1.ENDHDR + _commentLength);
            // "PK 05 06" signature
            b.writeUInt32LE(Constants$1.ENDSIG, 0);
            b.writeUInt32LE(0, 4);
            // number of entries on this volume
            b.writeUInt16LE(_volumeEntries, Constants$1.ENDSUB);
            // total number of entries
            b.writeUInt16LE(_totalEntries, Constants$1.ENDTOT);
            // central directory size in bytes
            b.writeUInt32LE(_size, Constants$1.ENDSIZ);
            // offset of first CEN header
            b.writeUInt32LE(_offset, Constants$1.ENDOFF);
            // zip file comment length
            b.writeUInt16LE(_commentLength, Constants$1.ENDCOM);
            // fill comment memory with spaces so no garbage is left there
            b.fill(" ", Constants$1.ENDHDR);

            return b;
        },

        toJSON: function () {
            // creates 0x0000 style output
            const offset = function (nr, len) {
                let offs = nr.toString(16).toUpperCase();
                while (offs.length < len) offs = "0" + offs;
                return "0x" + offs;
            };

            return {
                diskEntries: _volumeEntries,
                totalEntries: _totalEntries,
                size: _size + " bytes",
                offset: offset(_offset, 4),
                commentLength: _commentLength
            };
        },

        toString: function () {
            return JSON.stringify(this.toJSON(), null, "\t");
        }
    };
};

headers.EntryHeader = entryHeader;
headers.MainHeader = mainHeader;

var methods = {};

var deflater = function (/*Buffer*/ inbuf) {
    var zlib = require$$0$9;

    var opts = { chunkSize: (parseInt(inbuf.length / 1024) + 1) * 1024 };

    return {
        deflate: function () {
            return zlib.deflateRawSync(inbuf, opts);
        },

        deflateAsync: function (/*Function*/ callback) {
            var tmp = zlib.createDeflateRaw(opts),
                parts = [],
                total = 0;
            tmp.on("data", function (data) {
                parts.push(data);
                total += data.length;
            });
            tmp.on("end", function () {
                var buf = Buffer.alloc(total),
                    written = 0;
                buf.fill(0);
                for (var i = 0; i < parts.length; i++) {
                    var part = parts[i];
                    part.copy(buf, written);
                    written += part.length;
                }
                callback && callback(buf);
            });
            tmp.end(inbuf);
        }
    };
};

var inflater = function (/*Buffer*/ inbuf) {
    var zlib = require$$0$9;

    return {
        inflate: function () {
            return zlib.inflateRawSync(inbuf);
        },

        inflateAsync: function (/*Function*/ callback) {
            var tmp = zlib.createInflateRaw(),
                parts = [],
                total = 0;
            tmp.on("data", function (data) {
                parts.push(data);
                total += data.length;
            });
            tmp.on("end", function () {
                var buf = Buffer.alloc(total),
                    written = 0;
                buf.fill(0);
                for (var i = 0; i < parts.length; i++) {
                    var part = parts[i];
                    part.copy(buf, written);
                    written += part.length;
                }
                callback && callback(buf);
            });
            tmp.end(inbuf);
        }
    };
};

// node crypt, we use it for generate salt
// eslint-disable-next-line node/no-unsupported-features/node-builtins
const { randomFillSync } = require$$0$8;

// generate CRC32 lookup table
const crctable = new Uint32Array(256).map((t, crc) => {
    for (let j = 0; j < 8; j++) {
        if (0 !== (crc & 1)) {
            crc = (crc >>> 1) ^ 0xedb88320;
        } else {
            crc >>>= 1;
        }
    }
    return crc >>> 0;
});

// C-style uInt32 Multiply (discards higher bits, when JS multiply discards lower bits)
const uMul = (a, b) => Math.imul(a, b) >>> 0;

// crc32 byte single update (actually same function is part of utils.crc32 function :) )
const crc32update = (pCrc32, bval) => {
    return crctable[(pCrc32 ^ bval) & 0xff] ^ (pCrc32 >>> 8);
};

// function for generating salt for encrytion header
const genSalt = () => {
    if ("function" === typeof randomFillSync) {
        return randomFillSync(Buffer.alloc(12));
    } else {
        // fallback if function is not defined
        return genSalt.node();
    }
};

// salt generation with node random function (mainly as fallback)
genSalt.node = () => {
    const salt = Buffer.alloc(12);
    const len = salt.length;
    for (let i = 0; i < len; i++) salt[i] = (Math.random() * 256) & 0xff;
    return salt;
};

// general config
const config = {
    genSalt
};

// Class Initkeys handles same basic ops with keys
function Initkeys(pw) {
    const pass = Buffer.isBuffer(pw) ? pw : Buffer.from(pw);
    this.keys = new Uint32Array([0x12345678, 0x23456789, 0x34567890]);
    for (let i = 0; i < pass.length; i++) {
        this.updateKeys(pass[i]);
    }
}

Initkeys.prototype.updateKeys = function (byteValue) {
    const keys = this.keys;
    keys[0] = crc32update(keys[0], byteValue);
    keys[1] += keys[0] & 0xff;
    keys[1] = uMul(keys[1], 134775813) + 1;
    keys[2] = crc32update(keys[2], keys[1] >>> 24);
    return byteValue;
};

Initkeys.prototype.next = function () {
    const k = (this.keys[2] | 2) >>> 0; // key
    return (uMul(k, k ^ 1) >> 8) & 0xff; // decode
};

function make_decrypter(/*Buffer*/ pwd) {
    // 1. Stage initialize key
    const keys = new Initkeys(pwd);

    // return decrypter function
    return function (/*Buffer*/ data) {
        // result - we create new Buffer for results
        const result = Buffer.alloc(data.length);
        let pos = 0;
        // process input data
        for (let c of data) {
            //c ^= keys.next();
            //result[pos++] = c; // decode & Save Value
            result[pos++] = keys.updateKeys(c ^ keys.next()); // update keys with decoded byte
        }
        return result;
    };
}

function make_encrypter(/*Buffer*/ pwd) {
    // 1. Stage initialize key
    const keys = new Initkeys(pwd);

    // return encrypting function, result and pos is here so we dont have to merge buffers later
    return function (/*Buffer*/ data, /*Buffer*/ result, /* Number */ pos = 0) {
        // result - we create new Buffer for results
        if (!result) result = Buffer.alloc(data.length);
        // process input data
        for (let c of data) {
            const k = keys.next(); // save key byte
            result[pos++] = c ^ k; // save val
            keys.updateKeys(c); // update keys with decoded byte
        }
        return result;
    };
}

function decrypt(/*Buffer*/ data, /*Object*/ header, /*String, Buffer*/ pwd) {
    if (!data || !Buffer.isBuffer(data) || data.length < 12) {
        return Buffer.alloc(0);
    }

    // 1. We Initialize and generate decrypting function
    const decrypter = make_decrypter(pwd);

    // 2. decrypt salt what is always 12 bytes and is a part of file content
    const salt = decrypter(data.slice(0, 12));

    // 3. does password meet expectations
    if (salt[11] !== header.crc >>> 24) {
        throw "ADM-ZIP: Wrong Password";
    }

    // 4. decode content
    return decrypter(data.slice(12));
}

// lets add way to populate salt, NOT RECOMMENDED for production but maybe useful for testing general functionality
function _salter(data) {
    if (Buffer.isBuffer(data) && data.length >= 12) {
        // be aware - currently salting buffer data is modified
        config.genSalt = function () {
            return data.slice(0, 12);
        };
    } else if (data === "node") {
        // test salt generation with node random function
        config.genSalt = genSalt.node;
    } else {
        // if value is not acceptable config gets reset.
        config.genSalt = genSalt;
    }
}

function encrypt(/*Buffer*/ data, /*Object*/ header, /*String, Buffer*/ pwd, /*Boolean*/ oldlike = false) {
    // 1. test data if data is not Buffer we make buffer from it
    if (data == null) data = Buffer.alloc(0);
    // if data is not buffer be make buffer from it
    if (!Buffer.isBuffer(data)) data = Buffer.from(data.toString());

    // 2. We Initialize and generate encrypting function
    const encrypter = make_encrypter(pwd);

    // 3. generate salt (12-bytes of random data)
    const salt = config.genSalt();
    salt[11] = (header.crc >>> 24) & 0xff;

    // old implementations (before PKZip 2.04g) used two byte check
    if (oldlike) salt[10] = (header.crc >>> 16) & 0xff;

    // 4. create output
    const result = Buffer.alloc(data.length + 12);
    encrypter(salt, result);

    // finally encode content
    return encrypter(data, result, 12);
}

var zipcrypto = { decrypt, encrypt, _salter };

methods.Deflater = deflater;
methods.Inflater = inflater;
methods.ZipCrypto = zipcrypto;

var Utils$2 = utilExports,
    Headers$1 = headers,
    Constants = Utils$2.Constants,
    Methods = methods;

var zipEntry = function (/*Buffer*/ input) {
    var _entryHeader = new Headers$1.EntryHeader(),
        _entryName = Buffer.alloc(0),
        _comment = Buffer.alloc(0),
        _isDirectory = false,
        uncompressedData = null,
        _extra = Buffer.alloc(0);

    function getCompressedDataFromZip() {
        if (!input || !Buffer.isBuffer(input)) {
            return Buffer.alloc(0);
        }
        _entryHeader.loadDataHeaderFromBinary(input);
        return input.slice(_entryHeader.realDataOffset, _entryHeader.realDataOffset + _entryHeader.compressedSize);
    }

    function crc32OK(data) {
        // if bit 3 (0x08) of the general-purpose flags field is set, then the CRC-32 and file sizes are not known when the header is written
        if ((_entryHeader.flags & 0x8) !== 0x8) {
            if (Utils$2.crc32(data) !== _entryHeader.dataHeader.crc) {
                return false;
            }
        }
        return true;
    }

    function decompress(/*Boolean*/ async, /*Function*/ callback, /*String, Buffer*/ pass) {
        if (typeof callback === "undefined" && typeof async === "string") {
            pass = async;
            async = void 0;
        }
        if (_isDirectory) {
            if (async && callback) {
                callback(Buffer.alloc(0), Utils$2.Errors.DIRECTORY_CONTENT_ERROR); //si added error.
            }
            return Buffer.alloc(0);
        }

        var compressedData = getCompressedDataFromZip();

        if (compressedData.length === 0) {
            // File is empty, nothing to decompress.
            if (async && callback) callback(compressedData);
            return compressedData;
        }

        if (_entryHeader.encripted) {
            if ("string" !== typeof pass && !Buffer.isBuffer(pass)) {
                throw new Error("ADM-ZIP: Incompatible password parameter");
            }
            compressedData = Methods.ZipCrypto.decrypt(compressedData, _entryHeader, pass);
        }

        var data = Buffer.alloc(_entryHeader.size);

        switch (_entryHeader.method) {
            case Utils$2.Constants.STORED:
                compressedData.copy(data);
                if (!crc32OK(data)) {
                    if (async && callback) callback(data, Utils$2.Errors.BAD_CRC); //si added error
                    throw new Error(Utils$2.Errors.BAD_CRC);
                } else {
                    //si added otherwise did not seem to return data.
                    if (async && callback) callback(data);
                    return data;
                }
            case Utils$2.Constants.DEFLATED:
                var inflater = new Methods.Inflater(compressedData);
                if (!async) {
                    const result = inflater.inflate(data);
                    result.copy(data, 0);
                    if (!crc32OK(data)) {
                        throw new Error(Utils$2.Errors.BAD_CRC + " " + _entryName.toString());
                    }
                    return data;
                } else {
                    inflater.inflateAsync(function (result) {
                        result.copy(result, 0);
                        if (callback) {
                            if (!crc32OK(result)) {
                                callback(result, Utils$2.Errors.BAD_CRC); //si added error
                            } else {
                                callback(result);
                            }
                        }
                    });
                }
                break;
            default:
                if (async && callback) callback(Buffer.alloc(0), Utils$2.Errors.UNKNOWN_METHOD);
                throw new Error(Utils$2.Errors.UNKNOWN_METHOD);
        }
    }

    function compress(/*Boolean*/ async, /*Function*/ callback) {
        if ((!uncompressedData || !uncompressedData.length) && Buffer.isBuffer(input)) {
            // no data set or the data wasn't changed to require recompression
            if (async && callback) callback(getCompressedDataFromZip());
            return getCompressedDataFromZip();
        }

        if (uncompressedData.length && !_isDirectory) {
            var compressedData;
            // Local file header
            switch (_entryHeader.method) {
                case Utils$2.Constants.STORED:
                    _entryHeader.compressedSize = _entryHeader.size;

                    compressedData = Buffer.alloc(uncompressedData.length);
                    uncompressedData.copy(compressedData);

                    if (async && callback) callback(compressedData);
                    return compressedData;
                default:
                case Utils$2.Constants.DEFLATED:
                    var deflater = new Methods.Deflater(uncompressedData);
                    if (!async) {
                        var deflated = deflater.deflate();
                        _entryHeader.compressedSize = deflated.length;
                        return deflated;
                    } else {
                        deflater.deflateAsync(function (data) {
                            compressedData = Buffer.alloc(data.length);
                            _entryHeader.compressedSize = data.length;
                            data.copy(compressedData);
                            callback && callback(compressedData);
                        });
                    }
                    deflater = null;
                    break;
            }
        } else if (async && callback) {
            callback(Buffer.alloc(0));
        } else {
            return Buffer.alloc(0);
        }
    }

    function readUInt64LE(buffer, offset) {
        return (buffer.readUInt32LE(offset + 4) << 4) + buffer.readUInt32LE(offset);
    }

    function parseExtra(data) {
        var offset = 0;
        var signature, size, part;
        while (offset < data.length) {
            signature = data.readUInt16LE(offset);
            offset += 2;
            size = data.readUInt16LE(offset);
            offset += 2;
            part = data.slice(offset, offset + size);
            offset += size;
            if (Constants.ID_ZIP64 === signature) {
                parseZip64ExtendedInformation(part);
            }
        }
    }

    //Override header field values with values from the ZIP64 extra field
    function parseZip64ExtendedInformation(data) {
        var size, compressedSize, offset, diskNumStart;

        if (data.length >= Constants.EF_ZIP64_SCOMP) {
            size = readUInt64LE(data, Constants.EF_ZIP64_SUNCOMP);
            if (_entryHeader.size === Constants.EF_ZIP64_OR_32) {
                _entryHeader.size = size;
            }
        }
        if (data.length >= Constants.EF_ZIP64_RHO) {
            compressedSize = readUInt64LE(data, Constants.EF_ZIP64_SCOMP);
            if (_entryHeader.compressedSize === Constants.EF_ZIP64_OR_32) {
                _entryHeader.compressedSize = compressedSize;
            }
        }
        if (data.length >= Constants.EF_ZIP64_DSN) {
            offset = readUInt64LE(data, Constants.EF_ZIP64_RHO);
            if (_entryHeader.offset === Constants.EF_ZIP64_OR_32) {
                _entryHeader.offset = offset;
            }
        }
        if (data.length >= Constants.EF_ZIP64_DSN + 4) {
            diskNumStart = data.readUInt32LE(Constants.EF_ZIP64_DSN);
            if (_entryHeader.diskNumStart === Constants.EF_ZIP64_OR_16) {
                _entryHeader.diskNumStart = diskNumStart;
            }
        }
    }

    return {
        get entryName() {
            return _entryName.toString();
        },
        get rawEntryName() {
            return _entryName;
        },
        set entryName(val) {
            _entryName = Utils$2.toBuffer(val);
            var lastChar = _entryName[_entryName.length - 1];
            _isDirectory = lastChar === 47 || lastChar === 92;
            _entryHeader.fileNameLength = _entryName.length;
        },

        get extra() {
            return _extra;
        },
        set extra(val) {
            _extra = val;
            _entryHeader.extraLength = val.length;
            parseExtra(val);
        },

        get comment() {
            return _comment.toString();
        },
        set comment(val) {
            _comment = Utils$2.toBuffer(val);
            _entryHeader.commentLength = _comment.length;
        },

        get name() {
            var n = _entryName.toString();
            return _isDirectory
                ? n
                      .substr(n.length - 1)
                      .split("/")
                      .pop()
                : n.split("/").pop();
        },
        get isDirectory() {
            return _isDirectory;
        },

        getCompressedData: function () {
            return compress(false, null);
        },

        getCompressedDataAsync: function (/*Function*/ callback) {
            compress(true, callback);
        },

        setData: function (value) {
            uncompressedData = Utils$2.toBuffer(value);
            if (!_isDirectory && uncompressedData.length) {
                _entryHeader.size = uncompressedData.length;
                _entryHeader.method = Utils$2.Constants.DEFLATED;
                _entryHeader.crc = Utils$2.crc32(value);
                _entryHeader.changed = true;
            } else {
                // folders and blank files should be stored
                _entryHeader.method = Utils$2.Constants.STORED;
            }
        },

        getData: function (pass) {
            if (_entryHeader.changed) {
                return uncompressedData;
            } else {
                return decompress(false, null, pass);
            }
        },

        getDataAsync: function (/*Function*/ callback, pass) {
            if (_entryHeader.changed) {
                callback(uncompressedData);
            } else {
                decompress(true, callback, pass);
            }
        },

        set attr(attr) {
            _entryHeader.attr = attr;
        },
        get attr() {
            return _entryHeader.attr;
        },

        set header(/*Buffer*/ data) {
            _entryHeader.loadFromBinary(data);
        },

        get header() {
            return _entryHeader;
        },

        packHeader: function () {
            // 1. create header (buffer)
            var header = _entryHeader.entryHeaderToBinary();
            var addpos = Utils$2.Constants.CENHDR;
            // 2. add file name
            _entryName.copy(header, addpos);
            addpos += _entryName.length;
            // 3. add extra data
            if (_entryHeader.extraLength) {
                _extra.copy(header, addpos);
                addpos += _entryHeader.extraLength;
            }
            // 4. add file comment
            if (_entryHeader.commentLength) {
                _comment.copy(header, addpos);
            }
            return header;
        },

        toJSON: function () {
            const bytes = function (nr) {
                return "<" + ((nr && nr.length + " bytes buffer") || "null") + ">";
            };

            return {
                entryName: this.entryName,
                name: this.name,
                comment: this.comment,
                isDirectory: this.isDirectory,
                header: _entryHeader.toJSON(),
                compressedData: bytes(input),
                data: bytes(uncompressedData)
            };
        },

        toString: function () {
            return JSON.stringify(this.toJSON(), null, "\t");
        }
    };
};

const ZipEntry$1 = zipEntry;
const Headers = headers;
const Utils$1 = utilExports;

var zipFile = function (/*Buffer|null*/ inBuffer, /** object */ options) {
    var entryList = [],
        entryTable = {},
        _comment = Buffer.alloc(0),
        mainHeader = new Headers.MainHeader(),
        loadedEntries = false;

    // assign options
    const opts = Object.assign(Object.create(null), options);

    const { noSort } = opts;

    if (inBuffer) {
        // is a memory buffer
        readMainHeader(opts.readEntries);
    } else {
        // none. is a new file
        loadedEntries = true;
    }

    function iterateEntries(callback) {
        const totalEntries = mainHeader.diskEntries; // total number of entries
        let index = mainHeader.offset; // offset of first CEN header

        for (let i = 0; i < totalEntries; i++) {
            let tmp = index;
            const entry = new ZipEntry$1(inBuffer);

            entry.header = inBuffer.slice(tmp, (tmp += Utils$1.Constants.CENHDR));
            entry.entryName = inBuffer.slice(tmp, (tmp += entry.header.fileNameLength));

            index += entry.header.entryHeaderSize;

            callback(entry);
        }
    }

    function readEntries() {
        loadedEntries = true;
        entryTable = {};
        entryList = new Array(mainHeader.diskEntries); // total number of entries
        var index = mainHeader.offset; // offset of first CEN header
        for (var i = 0; i < entryList.length; i++) {
            var tmp = index,
                entry = new ZipEntry$1(inBuffer);
            entry.header = inBuffer.slice(tmp, (tmp += Utils$1.Constants.CENHDR));

            entry.entryName = inBuffer.slice(tmp, (tmp += entry.header.fileNameLength));

            if (entry.header.extraLength) {
                entry.extra = inBuffer.slice(tmp, (tmp += entry.header.extraLength));
            }

            if (entry.header.commentLength) entry.comment = inBuffer.slice(tmp, tmp + entry.header.commentLength);

            index += entry.header.entryHeaderSize;

            entryList[i] = entry;
            entryTable[entry.entryName] = entry;
        }
    }

    function readMainHeader(/*Boolean*/ readNow) {
        var i = inBuffer.length - Utils$1.Constants.ENDHDR, // END header size
            max = Math.max(0, i - 0xffff), // 0xFFFF is the max zip file comment length
            n = max,
            endStart = inBuffer.length,
            endOffset = -1, // Start offset of the END header
            commentEnd = 0;

        for (i; i >= n; i--) {
            if (inBuffer[i] !== 0x50) continue; // quick check that the byte is 'P'
            if (inBuffer.readUInt32LE(i) === Utils$1.Constants.ENDSIG) {
                // "PK\005\006"
                endOffset = i;
                commentEnd = i;
                endStart = i + Utils$1.Constants.ENDHDR;
                // We already found a regular signature, let's look just a bit further to check if there's any zip64 signature
                n = i - Utils$1.Constants.END64HDR;
                continue;
            }

            if (inBuffer.readUInt32LE(i) === Utils$1.Constants.END64SIG) {
                // Found a zip64 signature, let's continue reading the whole zip64 record
                n = max;
                continue;
            }

            if (inBuffer.readUInt32LE(i) === Utils$1.Constants.ZIP64SIG) {
                // Found the zip64 record, let's determine it's size
                endOffset = i;
                endStart = i + Utils$1.readBigUInt64LE(inBuffer, i + Utils$1.Constants.ZIP64SIZE) + Utils$1.Constants.ZIP64LEAD;
                break;
            }
        }

        if (!~endOffset) throw new Error(Utils$1.Errors.INVALID_FORMAT);

        mainHeader.loadFromBinary(inBuffer.slice(endOffset, endStart));
        if (mainHeader.commentLength) {
            _comment = inBuffer.slice(commentEnd + Utils$1.Constants.ENDHDR);
        }
        if (readNow) readEntries();
    }

    function sortEntries() {
        if (entryList.length > 1 && !noSort) {
            entryList.sort((a, b) => a.entryName.toLowerCase().localeCompare(b.entryName.toLowerCase()));
        }
    }

    return {
        /**
         * Returns an array of ZipEntry objects existent in the current opened archive
         * @return Array
         */
        get entries() {
            if (!loadedEntries) {
                readEntries();
            }
            return entryList;
        },

        /**
         * Archive comment
         * @return {String}
         */
        get comment() {
            return _comment.toString();
        },
        set comment(val) {
            _comment = Utils$1.toBuffer(val);
            mainHeader.commentLength = _comment.length;
        },

        getEntryCount: function () {
            if (!loadedEntries) {
                return mainHeader.diskEntries;
            }

            return entryList.length;
        },

        forEach: function (callback) {
            if (!loadedEntries) {
                iterateEntries(callback);
                return;
            }

            entryList.forEach(callback);
        },

        /**
         * Returns a reference to the entry with the given name or null if entry is inexistent
         *
         * @param entryName
         * @return ZipEntry
         */
        getEntry: function (/*String*/ entryName) {
            if (!loadedEntries) {
                readEntries();
            }
            return entryTable[entryName] || null;
        },

        /**
         * Adds the given entry to the entry list
         *
         * @param entry
         */
        setEntry: function (/*ZipEntry*/ entry) {
            if (!loadedEntries) {
                readEntries();
            }
            entryList.push(entry);
            entryTable[entry.entryName] = entry;
            mainHeader.totalEntries = entryList.length;
        },

        /**
         * Removes the entry with the given name from the entry list.
         *
         * If the entry is a directory, then all nested files and directories will be removed
         * @param entryName
         */
        deleteEntry: function (/*String*/ entryName) {
            if (!loadedEntries) {
                readEntries();
            }
            var entry = entryTable[entryName];
            if (entry && entry.isDirectory) {
                var _self = this;
                this.getEntryChildren(entry).forEach(function (child) {
                    if (child.entryName !== entryName) {
                        _self.deleteEntry(child.entryName);
                    }
                });
            }
            entryList.splice(entryList.indexOf(entry), 1);
            delete entryTable[entryName];
            mainHeader.totalEntries = entryList.length;
        },

        /**
         *  Iterates and returns all nested files and directories of the given entry
         *
         * @param entry
         * @return Array
         */
        getEntryChildren: function (/*ZipEntry*/ entry) {
            if (!loadedEntries) {
                readEntries();
            }
            if (entry && entry.isDirectory) {
                const list = [];
                const name = entry.entryName;
                const len = name.length;

                entryList.forEach(function (zipEntry) {
                    if (zipEntry.entryName.substr(0, len) === name) {
                        list.push(zipEntry);
                    }
                });
                return list;
            }
            return [];
        },

        /**
         * Returns the zip file
         *
         * @return Buffer
         */
        compressToBuffer: function () {
            if (!loadedEntries) {
                readEntries();
            }
            sortEntries();

            const dataBlock = [];
            const entryHeaders = [];
            let totalSize = 0;
            let dindex = 0;

            mainHeader.size = 0;
            mainHeader.offset = 0;

            for (const entry of entryList) {
                // compress data and set local and entry header accordingly. Reason why is called first
                const compressedData = entry.getCompressedData();
                // 1. construct data header
                entry.header.offset = dindex;
                const dataHeader = entry.header.dataHeaderToBinary();
                const entryNameLen = entry.rawEntryName.length;
                // 1.2. postheader - data after data header
                const postHeader = Buffer.alloc(entryNameLen + entry.extra.length);
                entry.rawEntryName.copy(postHeader, 0);
                postHeader.copy(entry.extra, entryNameLen);

                // 2. offsets
                const dataLength = dataHeader.length + postHeader.length + compressedData.length;
                dindex += dataLength;

                // 3. store values in sequence
                dataBlock.push(dataHeader);
                dataBlock.push(postHeader);
                dataBlock.push(compressedData);

                // 4. construct entry header
                const entryHeader = entry.packHeader();
                entryHeaders.push(entryHeader);
                // 5. update main header
                mainHeader.size += entryHeader.length;
                totalSize += dataLength + entryHeader.length;
            }

            totalSize += mainHeader.mainHeaderSize; // also includes zip file comment length
            // point to end of data and beginning of central directory first record
            mainHeader.offset = dindex;

            dindex = 0;
            const outBuffer = Buffer.alloc(totalSize);
            // write data blocks
            for (const content of dataBlock) {
                content.copy(outBuffer, dindex);
                dindex += content.length;
            }

            // write central directory entries
            for (const content of entryHeaders) {
                content.copy(outBuffer, dindex);
                dindex += content.length;
            }

            // write main header
            const mh = mainHeader.toBinary();
            if (_comment) {
                _comment.copy(mh, Utils$1.Constants.ENDHDR); // add zip file comment
            }
            mh.copy(outBuffer, dindex);

            return outBuffer;
        },

        toAsyncBuffer: function (/*Function*/ onSuccess, /*Function*/ onFail, /*Function*/ onItemStart, /*Function*/ onItemEnd) {
            try {
                if (!loadedEntries) {
                    readEntries();
                }
                sortEntries();

                const dataBlock = [];
                const entryHeaders = [];
                let totalSize = 0;
                let dindex = 0;

                mainHeader.size = 0;
                mainHeader.offset = 0;

                const compress2Buffer = function (entryLists) {
                    if (entryLists.length) {
                        const entry = entryLists.pop();
                        const name = entry.entryName + entry.extra.toString();
                        if (onItemStart) onItemStart(name);
                        entry.getCompressedDataAsync(function (compressedData) {
                            if (onItemEnd) onItemEnd(name);

                            entry.header.offset = dindex;
                            // data header
                            const dataHeader = entry.header.dataHeaderToBinary();
                            const postHeader = Buffer.alloc(name.length, name);
                            const dataLength = dataHeader.length + postHeader.length + compressedData.length;

                            dindex += dataLength;

                            dataBlock.push(dataHeader);
                            dataBlock.push(postHeader);
                            dataBlock.push(compressedData);

                            const entryHeader = entry.packHeader();
                            entryHeaders.push(entryHeader);
                            mainHeader.size += entryHeader.length;
                            totalSize += dataLength + entryHeader.length;

                            compress2Buffer(entryLists);
                        });
                    } else {
                        totalSize += mainHeader.mainHeaderSize; // also includes zip file comment length
                        // point to end of data and beginning of central directory first record
                        mainHeader.offset = dindex;

                        dindex = 0;
                        const outBuffer = Buffer.alloc(totalSize);
                        dataBlock.forEach(function (content) {
                            content.copy(outBuffer, dindex); // write data blocks
                            dindex += content.length;
                        });
                        entryHeaders.forEach(function (content) {
                            content.copy(outBuffer, dindex); // write central directory entries
                            dindex += content.length;
                        });

                        const mh = mainHeader.toBinary();
                        if (_comment) {
                            _comment.copy(mh, Utils$1.Constants.ENDHDR); // add zip file comment
                        }

                        mh.copy(outBuffer, dindex); // write main header

                        onSuccess(outBuffer);
                    }
                };

                compress2Buffer(entryList);
            } catch (e) {
                onFail(e);
            }
        }
    };
};

const Utils = utilExports;
const pth = require$$0$5;
const ZipEntry = zipEntry;
const ZipFile = zipFile;

const get_Bool = (val, def) => (typeof val === "boolean" ? val : def);
const get_Str = (val, def) => (typeof val === "string" ? val : def);

const defaultOptions = {
    // option "noSort" : if true it disables files sorting
    noSort: false,
    // read entries during load (initial loading may be slower)
    readEntries: false,
    // default method is none
    method: Utils.Constants.NONE,
    // file system
    fs: null
};

var admZip = function (/**String*/ input, /** object */ options) {
    let inBuffer = null;

    // create object based default options, allowing them to be overwritten
    const opts = Object.assign(Object.create(null), defaultOptions);

    // test input variable
    if (input && "object" === typeof input) {
        // if value is not buffer we accept it to be object with options
        if (!(input instanceof Uint8Array)) {
            Object.assign(opts, input);
            input = opts.input ? opts.input : undefined;
            if (opts.input) delete opts.input;
        }

        // if input is buffer
        if (Buffer.isBuffer(input)) {
            inBuffer = input;
            opts.method = Utils.Constants.BUFFER;
            input = undefined;
        }
    }

    // assign options
    Object.assign(opts, options);

    // instanciate utils filesystem
    const filetools = new Utils(opts);

    // if input is file name we retrieve its content
    if (input && "string" === typeof input) {
        // load zip file
        if (filetools.fs.existsSync(input)) {
            opts.method = Utils.Constants.FILE;
            opts.filename = input;
            inBuffer = filetools.fs.readFileSync(input);
        } else {
            throw new Error(Utils.Errors.INVALID_FILENAME);
        }
    }

    // create variable
    const _zip = new ZipFile(inBuffer, opts);

    const { canonical, sanitize } = Utils;

    function getEntry(/**Object*/ entry) {
        if (entry && _zip) {
            var item;
            // If entry was given as a file name
            if (typeof entry === "string") item = _zip.getEntry(entry);
            // if entry was given as a ZipEntry object
            if (typeof entry === "object" && typeof entry.entryName !== "undefined" && typeof entry.header !== "undefined") item = _zip.getEntry(entry.entryName);

            if (item) {
                return item;
            }
        }
        return null;
    }

    function fixPath(zipPath) {
        const { join, normalize, sep } = pth.posix;
        // convert windows file separators and normalize
        return join(".", normalize(sep + zipPath.split("\\").join(sep) + sep));
    }

    return {
        /**
         * Extracts the given entry from the archive and returns the content as a Buffer object
         * @param entry ZipEntry object or String with the full path of the entry
         *
         * @return Buffer or Null in case of error
         */
        readFile: function (/**Object*/ entry, /*String, Buffer*/ pass) {
            var item = getEntry(entry);
            return (item && item.getData(pass)) || null;
        },

        /**
         * Asynchronous readFile
         * @param entry ZipEntry object or String with the full path of the entry
         * @param callback
         *
         * @return Buffer or Null in case of error
         */
        readFileAsync: function (/**Object*/ entry, /**Function*/ callback) {
            var item = getEntry(entry);
            if (item) {
                item.getDataAsync(callback);
            } else {
                callback(null, "getEntry failed for:" + entry);
            }
        },

        /**
         * Extracts the given entry from the archive and returns the content as plain text in the given encoding
         * @param entry ZipEntry object or String with the full path of the entry
         * @param encoding Optional. If no encoding is specified utf8 is used
         *
         * @return String
         */
        readAsText: function (/**Object*/ entry, /**String=*/ encoding) {
            var item = getEntry(entry);
            if (item) {
                var data = item.getData();
                if (data && data.length) {
                    return data.toString(encoding || "utf8");
                }
            }
            return "";
        },

        /**
         * Asynchronous readAsText
         * @param entry ZipEntry object or String with the full path of the entry
         * @param callback
         * @param encoding Optional. If no encoding is specified utf8 is used
         *
         * @return String
         */
        readAsTextAsync: function (/**Object*/ entry, /**Function*/ callback, /**String=*/ encoding) {
            var item = getEntry(entry);
            if (item) {
                item.getDataAsync(function (data, err) {
                    if (err) {
                        callback(data, err);
                        return;
                    }

                    if (data && data.length) {
                        callback(data.toString(encoding || "utf8"));
                    } else {
                        callback("");
                    }
                });
            } else {
                callback("");
            }
        },

        /**
         * Remove the entry from the file or the entry and all it's nested directories and files if the given entry is a directory
         *
         * @param entry
         */
        deleteFile: function (/**Object*/ entry) {
            // @TODO: test deleteFile
            var item = getEntry(entry);
            if (item) {
                _zip.deleteEntry(item.entryName);
            }
        },

        /**
         * Adds a comment to the zip. The zip must be rewritten after adding the comment.
         *
         * @param comment
         */
        addZipComment: function (/**String*/ comment) {
            // @TODO: test addZipComment
            _zip.comment = comment;
        },

        /**
         * Returns the zip comment
         *
         * @return String
         */
        getZipComment: function () {
            return _zip.comment || "";
        },

        /**
         * Adds a comment to a specified zipEntry. The zip must be rewritten after adding the comment
         * The comment cannot exceed 65535 characters in length
         *
         * @param entry
         * @param comment
         */
        addZipEntryComment: function (/**Object*/ entry, /**String*/ comment) {
            var item = getEntry(entry);
            if (item) {
                item.comment = comment;
            }
        },

        /**
         * Returns the comment of the specified entry
         *
         * @param entry
         * @return String
         */
        getZipEntryComment: function (/**Object*/ entry) {
            var item = getEntry(entry);
            if (item) {
                return item.comment || "";
            }
            return "";
        },

        /**
         * Updates the content of an existing entry inside the archive. The zip must be rewritten after updating the content
         *
         * @param entry
         * @param content
         */
        updateFile: function (/**Object*/ entry, /**Buffer*/ content) {
            var item = getEntry(entry);
            if (item) {
                item.setData(content);
            }
        },

        /**
         * Adds a file from the disk to the archive
         *
         * @param localPath File to add to zip
         * @param zipPath Optional path inside the zip
         * @param zipName Optional name for the file
         */
        addLocalFile: function (/**String*/ localPath, /**String=*/ zipPath, /**String=*/ zipName, /**String*/ comment) {
            if (filetools.fs.existsSync(localPath)) {
                // fix ZipPath
                zipPath = zipPath ? fixPath(zipPath) : "";

                // p - local file name
                var p = localPath.split("\\").join("/").split("/").pop();

                // add file name into zippath
                zipPath += zipName ? zipName : p;

                // read file attributes
                const _attr = filetools.fs.statSync(localPath);

                // add file into zip file
                this.addFile(zipPath, filetools.fs.readFileSync(localPath), comment, _attr);
            } else {
                throw new Error(Utils.Errors.FILE_NOT_FOUND.replace("%s", localPath));
            }
        },

        /**
         * Adds a local directory and all its nested files and directories to the archive
         *
         * @param localPath
         * @param zipPath optional path inside zip
         * @param filter optional RegExp or Function if files match will
         *               be included.
         * @param {number | object} attr - number as unix file permissions, object as filesystem Stats object
         */
        addLocalFolder: function (/**String*/ localPath, /**String=*/ zipPath, /**=RegExp|Function*/ filter, /**=number|object*/ attr) {
            // Prepare filter
            if (filter instanceof RegExp) {
                // if filter is RegExp wrap it
                filter = (function (rx) {
                    return function (filename) {
                        return rx.test(filename);
                    };
                })(filter);
            } else if ("function" !== typeof filter) {
                // if filter is not function we will replace it
                filter = function () {
                    return true;
                };
            }

            // fix ZipPath
            zipPath = zipPath ? fixPath(zipPath) : "";

            // normalize the path first
            localPath = pth.normalize(localPath);

            if (filetools.fs.existsSync(localPath)) {
                const items = filetools.findFiles(localPath);
                const self = this;

                if (items.length) {
                    items.forEach(function (filepath) {
                        var p = pth.relative(localPath, filepath).split("\\").join("/"); //windows fix
                        if (filter(p)) {
                            var stats = filetools.fs.statSync(filepath);
                            if (stats.isFile()) {
                                self.addFile(zipPath + p, filetools.fs.readFileSync(filepath), "", attr ? attr : stats);
                            } else {
                                self.addFile(zipPath + p + "/", Buffer.alloc(0), "", attr ? attr : stats);
                            }
                        }
                    });
                }
            } else {
                throw new Error(Utils.Errors.FILE_NOT_FOUND.replace("%s", localPath));
            }
        },

        /**
         * Asynchronous addLocalFile
         * @param localPath
         * @param callback
         * @param zipPath optional path inside zip
         * @param filter optional RegExp or Function if files match will
         *               be included.
         */
        addLocalFolderAsync: function (/*String*/ localPath, /*Function*/ callback, /*String*/ zipPath, /*RegExp|Function*/ filter) {
            if (filter instanceof RegExp) {
                filter = (function (rx) {
                    return function (filename) {
                        return rx.test(filename);
                    };
                })(filter);
            } else if ("function" !== typeof filter) {
                filter = function () {
                    return true;
                };
            }

            // fix ZipPath
            zipPath = zipPath ? fixPath(zipPath) : "";

            // normalize the path first
            localPath = pth.normalize(localPath);

            var self = this;
            filetools.fs.open(localPath, "r", function (err) {
                if (err && err.code === "ENOENT") {
                    callback(undefined, Utils.Errors.FILE_NOT_FOUND.replace("%s", localPath));
                } else if (err) {
                    callback(undefined, err);
                } else {
                    var items = filetools.findFiles(localPath);
                    var i = -1;

                    var next = function () {
                        i += 1;
                        if (i < items.length) {
                            var filepath = items[i];
                            var p = pth.relative(localPath, filepath).split("\\").join("/"); //windows fix
                            p = p
                                .normalize("NFD")
                                .replace(/[\u0300-\u036f]/g, "")
                                .replace(/[^\x20-\x7E]/g, ""); // accent fix
                            if (filter(p)) {
                                filetools.fs.stat(filepath, function (er0, stats) {
                                    if (er0) callback(undefined, er0);
                                    if (stats.isFile()) {
                                        filetools.fs.readFile(filepath, function (er1, data) {
                                            if (er1) {
                                                callback(undefined, er1);
                                            } else {
                                                self.addFile(zipPath + p, data, "", stats);
                                                next();
                                            }
                                        });
                                    } else {
                                        self.addFile(zipPath + p + "/", Buffer.alloc(0), "", stats);
                                        next();
                                    }
                                });
                            } else {
                                process.nextTick(() => {
                                    next();
                                });
                            }
                        } else {
                            callback(true, undefined);
                        }
                    };

                    next();
                }
            });
        },

        /**
         *
         * @param {string} localPath - path where files will be extracted
         * @param {object} props - optional properties
         * @param {string} props.zipPath - optional path inside zip
         * @param {regexp, function} props.filter - RegExp or Function if files match will be included.
         */
        addLocalFolderPromise: function (/*String*/ localPath, /* object */ props) {
            return new Promise((resolve, reject) => {
                const { filter, zipPath } = Object.assign({}, props);
                this.addLocalFolderAsync(
                    localPath,
                    (done, err) => {
                        if (err) reject(err);
                        if (done) resolve(this);
                    },
                    zipPath,
                    filter
                );
            });
        },

        /**
         * Allows you to create a entry (file or directory) in the zip file.
         * If you want to create a directory the entryName must end in / and a null buffer should be provided.
         * Comment and attributes are optional
         *
         * @param {string} entryName
         * @param {Buffer | string} content - file content as buffer or utf8 coded string
         * @param {string} comment - file comment
         * @param {number | object} attr - number as unix file permissions, object as filesystem Stats object
         */
        addFile: function (/**String*/ entryName, /**Buffer*/ content, /**String*/ comment, /**Number*/ attr) {
            let entry = getEntry(entryName);
            const update = entry != null;

            // prepare new entry
            if (!update) {
                entry = new ZipEntry();
                entry.entryName = entryName;
            }
            entry.comment = comment || "";

            const isStat = "object" === typeof attr && attr instanceof filetools.fs.Stats;

            // last modification time from file stats
            if (isStat) {
                entry.header.time = attr.mtime;
            }

            // Set file attribute
            var fileattr = entry.isDirectory ? 0x10 : 0; // (MS-DOS directory flag)

            // extended attributes field for Unix
            // set file type either S_IFDIR / S_IFREG
            let unix = entry.isDirectory ? 0x4000 : 0x8000;

            if (isStat) {
                // File attributes from file stats
                unix |= 0xfff & attr.mode;
            } else if ("number" === typeof attr) {
                // attr from given attr values
                unix |= 0xfff & attr;
            } else {
                // Default values:
                unix |= entry.isDirectory ? 0o755 : 0o644; // permissions (drwxr-xr-x) or (-r-wr--r--)
            }

            fileattr = (fileattr | (unix << 16)) >>> 0; // add attributes

            entry.attr = fileattr;

            entry.setData(content);
            if (!update) _zip.setEntry(entry);
        },

        /**
         * Returns an array of ZipEntry objects representing the files and folders inside the archive
         *
         * @return Array
         */
        getEntries: function () {
            return _zip ? _zip.entries : [];
        },

        /**
         * Returns a ZipEntry object representing the file or folder specified by ``name``.
         *
         * @param name
         * @return ZipEntry
         */
        getEntry: function (/**String*/ name) {
            return getEntry(name);
        },

        getEntryCount: function () {
            return _zip.getEntryCount();
        },

        forEach: function (callback) {
            return _zip.forEach(callback);
        },

        /**
         * Extracts the given entry to the given targetPath
         * If the entry is a directory inside the archive, the entire directory and it's subdirectories will be extracted
         *
         * @param entry ZipEntry object or String with the full path of the entry
         * @param targetPath Target folder where to write the file
         * @param maintainEntryPath If maintainEntryPath is true and the entry is inside a folder, the entry folder
         *                          will be created in targetPath as well. Default is TRUE
         * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.
         *                  Default is FALSE
         * @param keepOriginalPermission The file will be set as the permission from the entry if this is true.
         *                  Default is FALSE
         * @param outFileName String If set will override the filename of the extracted file (Only works if the entry is a file)
         *
         * @return Boolean
         */
        extractEntryTo: function (
            /**Object*/ entry,
            /**String*/ targetPath,
            /**Boolean*/ maintainEntryPath,
            /**Boolean*/ overwrite,
            /**Boolean*/ keepOriginalPermission,
            /**String**/ outFileName
        ) {
            overwrite = get_Bool(overwrite, false);
            keepOriginalPermission = get_Bool(keepOriginalPermission, false);
            maintainEntryPath = get_Bool(maintainEntryPath, true);
            outFileName = get_Str(outFileName, get_Str(keepOriginalPermission, undefined));

            var item = getEntry(entry);
            if (!item) {
                throw new Error(Utils.Errors.NO_ENTRY);
            }

            var entryName = canonical(item.entryName);

            var target = sanitize(targetPath, outFileName && !item.isDirectory ? outFileName : maintainEntryPath ? entryName : pth.basename(entryName));

            if (item.isDirectory) {
                var children = _zip.getEntryChildren(item);
                children.forEach(function (child) {
                    if (child.isDirectory) return;
                    var content = child.getData();
                    if (!content) {
                        throw new Error(Utils.Errors.CANT_EXTRACT_FILE);
                    }
                    var name = canonical(child.entryName);
                    var childName = sanitize(targetPath, maintainEntryPath ? name : pth.basename(name));
                    // The reverse operation for attr depend on method addFile()
                    const fileAttr = keepOriginalPermission ? child.header.fileAttr : undefined;
                    filetools.writeFileTo(childName, content, overwrite, fileAttr);
                });
                return true;
            }

            var content = item.getData();
            if (!content) throw new Error(Utils.Errors.CANT_EXTRACT_FILE);

            if (filetools.fs.existsSync(target) && !overwrite) {
                throw new Error(Utils.Errors.CANT_OVERRIDE);
            }
            // The reverse operation for attr depend on method addFile()
            const fileAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;
            filetools.writeFileTo(target, content, overwrite, fileAttr);

            return true;
        },

        /**
         * Test the archive
         *
         */
        test: function (pass) {
            if (!_zip) {
                return false;
            }

            for (var entry in _zip.entries) {
                try {
                    if (entry.isDirectory) {
                        continue;
                    }
                    var content = _zip.entries[entry].getData(pass);
                    if (!content) {
                        return false;
                    }
                } catch (err) {
                    return false;
                }
            }
            return true;
        },

        /**
         * Extracts the entire archive to the given location
         *
         * @param targetPath Target location
         * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.
         *                  Default is FALSE
         * @param keepOriginalPermission The file will be set as the permission from the entry if this is true.
         *                  Default is FALSE
         */
        extractAllTo: function (/**String*/ targetPath, /**Boolean*/ overwrite, /**Boolean*/ keepOriginalPermission, /*String, Buffer*/ pass) {
            overwrite = get_Bool(overwrite, false);
            pass = get_Str(keepOriginalPermission, pass);
            keepOriginalPermission = get_Bool(keepOriginalPermission, false);
            if (!_zip) {
                throw new Error(Utils.Errors.NO_ZIP);
            }
            _zip.entries.forEach(function (entry) {
                var entryName = sanitize(targetPath, canonical(entry.entryName.toString()));
                if (entry.isDirectory) {
                    filetools.makeDir(entryName);
                    return;
                }
                var content = entry.getData(pass);
                if (!content) {
                    throw new Error(Utils.Errors.CANT_EXTRACT_FILE);
                }
                // The reverse operation for attr depend on method addFile()
                const fileAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;
                filetools.writeFileTo(entryName, content, overwrite, fileAttr);
                try {
                    filetools.fs.utimesSync(entryName, entry.header.time, entry.header.time);
                } catch (err) {
                    throw new Error(Utils.Errors.CANT_EXTRACT_FILE);
                }
            });
        },

        /**
         * Asynchronous extractAllTo
         *
         * @param targetPath Target location
         * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.
         *                  Default is FALSE
         * @param keepOriginalPermission The file will be set as the permission from the entry if this is true.
         *                  Default is FALSE
         * @param callback The callback will be executed when all entries are extracted successfully or any error is thrown.
         */
        extractAllToAsync: function (/**String*/ targetPath, /**Boolean*/ overwrite, /**Boolean*/ keepOriginalPermission, /**Function*/ callback) {
            overwrite = get_Bool(overwrite, false);
            if (typeof keepOriginalPermission === "function" && !callback) callback = keepOriginalPermission;
            keepOriginalPermission = get_Bool(keepOriginalPermission, false);
            if (!callback) {
                callback = function (err) {
                    throw new Error(err);
                };
            }
            if (!_zip) {
                callback(new Error(Utils.Errors.NO_ZIP));
                return;
            }

            targetPath = pth.resolve(targetPath);
            // convert entryName to
            const getPath = (entry) => sanitize(targetPath, pth.normalize(canonical(entry.entryName.toString())));
            const getError = (msg, file) => new Error(msg + ': "' + file + '"');

            // separate directories from files
            const dirEntries = [];
            const fileEntries = new Set();
            _zip.entries.forEach((e) => {
                if (e.isDirectory) {
                    dirEntries.push(e);
                } else {
                    fileEntries.add(e);
                }
            });

            // Create directory entries first synchronously
            // this prevents race condition and assures folders are there before writing files
            for (const entry of dirEntries) {
                const dirPath = getPath(entry);
                // The reverse operation for attr depend on method addFile()
                const dirAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;
                try {
                    filetools.makeDir(dirPath);
                    if (dirAttr) filetools.fs.chmodSync(dirPath, dirAttr);
                    // in unix timestamp will change if files are later added to folder, but still
                    filetools.fs.utimesSync(dirPath, entry.header.time, entry.header.time);
                } catch (er) {
                    callback(getError("Unable to create folder", dirPath));
                }
            }

            // callback wrapper, for some house keeping
            const done = () => {
                if (fileEntries.size === 0) {
                    callback();
                }
            };

            // Extract file entries asynchronously
            for (const entry of fileEntries.values()) {
                const entryName = pth.normalize(canonical(entry.entryName.toString()));
                const filePath = sanitize(targetPath, entryName);
                entry.getDataAsync(function (content, err_1) {
                    if (err_1) {
                        callback(new Error(err_1));
                        return;
                    }
                    if (!content) {
                        callback(new Error(Utils.Errors.CANT_EXTRACT_FILE));
                    } else {
                        // The reverse operation for attr depend on method addFile()
                        const fileAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;
                        filetools.writeFileToAsync(filePath, content, overwrite, fileAttr, function (succ) {
                            if (!succ) {
                                callback(getError("Unable to write file", filePath));
                                return;
                            }
                            filetools.fs.utimes(filePath, entry.header.time, entry.header.time, function (err_2) {
                                if (err_2) {
                                    callback(getError("Unable to set times", filePath));
                                    return;
                                }
                                fileEntries.delete(entry);
                                // call the callback if it was last entry
                                done();
                            });
                        });
                    }
                });
            }
            // call the callback if fileEntries was empty
            done();
        },

        /**
         * Writes the newly created zip file to disk at the specified location or if a zip was opened and no ``targetFileName`` is provided, it will overwrite the opened zip
         *
         * @param targetFileName
         * @param callback
         */
        writeZip: function (/**String*/ targetFileName, /**Function*/ callback) {
            if (arguments.length === 1) {
                if (typeof targetFileName === "function") {
                    callback = targetFileName;
                    targetFileName = "";
                }
            }

            if (!targetFileName && opts.filename) {
                targetFileName = opts.filename;
            }
            if (!targetFileName) return;

            var zipData = _zip.compressToBuffer();
            if (zipData) {
                var ok = filetools.writeFileTo(targetFileName, zipData, true);
                if (typeof callback === "function") callback(!ok ? new Error("failed") : null, "");
            }
        },

        writeZipPromise: function (/**String*/ targetFileName, /* object */ props) {
            const { overwrite, perm } = Object.assign({ overwrite: true }, props);

            return new Promise((resolve, reject) => {
                // find file name
                if (!targetFileName && opts.filename) targetFileName = opts.filename;
                if (!targetFileName) reject("ADM-ZIP: ZIP File Name Missing");

                this.toBufferPromise().then((zipData) => {
                    const ret = (done) => (done ? resolve(done) : reject("ADM-ZIP: Wasn't able to write zip file"));
                    filetools.writeFileToAsync(targetFileName, zipData, overwrite, perm, ret);
                }, reject);
            });
        },

        toBufferPromise: function () {
            return new Promise((resolve, reject) => {
                _zip.toAsyncBuffer(resolve, reject);
            });
        },

        /**
         * Returns the content of the entire zip file as a Buffer object
         *
         * @return Buffer
         */
        toBuffer: function (/**Function=*/ onSuccess, /**Function=*/ onFail, /**Function=*/ onItemStart, /**Function=*/ onItemEnd) {
            this.valueOf = 2;
            if (typeof onSuccess === "function") {
                _zip.toAsyncBuffer(onSuccess, onFail, onItemStart, onItemEnd);
                return null;
            }
            return _zip.compressToBuffer();
        }
    };
};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const https = require$$0$a;
const fs = require$$1;
const util$4 = require$$0$4;
const AdmZip = admZip;
const { URL: URL$1 } = require$$1$1;

const errors$4 = errors$n;
const utils$b = utils$K;
const { DsePlainTextAuthProvider, NoAuthProvider } = auth;

// Use the callback-based method fs.readFile() instead of fs.promises as we have to support Node.js 8+
const readFile = util$4.promisify(fs.readFile);

/**
 * When the user sets the cloud options, it uses the secure bundle or endpoint to access the metadata service and
 * setting the connection options
 * @param {ClientOptions} options
 * @returns {Promise<void>}
 */
async function init(options) {
  if (!options.cloud) {
    return;
  }

  const cloudOptions = new CloudOptions(options);
  await parseZipFile(cloudOptions);
  await getMetadataServiceInfoAsync(cloudOptions);

  if (!cloudOptions.clientOptions.sslOptions.checkServerIdentity) {
    // With SNI enabled, hostname (uuid) and CN will not match
    // Use a custom validation function to validate against the proxy address.
    // Note: this function is only called if the certificate passed all other checks, like CA validation.
    cloudOptions.clientOptions.sslOptions.checkServerIdentity = (_, cert) =>
      checkServerIdentity(cert, cloudOptions.clientOptions.sni.address);
  }
}

class CloudOptions {
  constructor(clientOptions) {
    this.clientOptions = clientOptions;

    if (clientOptions.cloud.secureConnectBundle) {
      this.secureConnectBundle = clientOptions.cloud.secureConnectBundle;
      this.serviceUrl = null;
    } else {
      this.serviceUrl = clientOptions.cloud.endpoint;
    }
    // Include a log emitter to enable logging within the cloud connection logic
    this.logEmitter = clientOptions.logEmitter;

    this.contactPoints = null;
    this.localDataCenter = null;
  }

  /**
   * The sslOptions in the client options from a given map.
   * @param {Map<String, Buffer>} zipEntries
   */
  setSslOptions(zipEntries) {
    this.clientOptions.sslOptions = Object.assign({
      ca: [zipEntries.get('ca.crt') ],
      cert: zipEntries.get('cert'),
      key: zipEntries.get('key'),
      rejectUnauthorized: true
    }, this.clientOptions.sslOptions);
  }

  /**
   *
   * @param username
   * @param password
   */
  setAuthProvider(username, password) {
    if (!username || !password) {
      return;
    }

    if (this.clientOptions.authProvider && !(this.clientOptions.authProvider instanceof NoAuthProvider)) {
      // There is an auth provider set by the user
      return;
    }

    this.clientOptions.authProvider = new DsePlainTextAuthProvider(username, password);
  }
}

/**
 * @param {CloudOptions} cloudOptions
 * @returns {Promise<void>}
 */
async function parseZipFile(cloudOptions) {
  if (cloudOptions.serviceUrl) {
    // Service url already was provided
    return;
  }

  if (!cloudOptions.secureConnectBundle) {
    throw new TypeError('secureConnectBundle must be provided');
  }

  const data = await readFile(cloudOptions.secureConnectBundle);
  const zip = new AdmZip(data);
  const zipEntries = new Map(zip.getEntries().map(e => [e.entryName, e.getData()]));

  if (!zipEntries.get('config.json')) {
    throw new TypeError('Config file must be contained in secure bundle');
  }

  const config = JSON.parse(zipEntries.get('config.json').toString('utf8'));
  if (!config['host'] || !config['port']) {
    throw new TypeError('Config file must include host and port information');
  }

  cloudOptions.serviceUrl = `${config['host']}:${config['port']}/metadata`;
  cloudOptions.setSslOptions(zipEntries);
  cloudOptions.setAuthProvider(config.username, config.password);
}

/**
 * Gets the information retrieved from the metadata service.
 * Invokes the callback with {proxyAddress, localDataCenter, contactPoints} as result
 * @param {CloudOptions} cloudOptions
 * @param {Function} callback
 */
function getMetadataServiceInfo(cloudOptions, callback) {
  const regex = /^(.+?):(\d+)(.*)$/;
  const matches = regex.exec(cloudOptions.serviceUrl);
  callback = utils$b.callbackOnce(callback);

  if (!matches || matches.length !== 4) {
    throw new TypeError('url should be composed of host, port number and path, without scheme');
  }

  const requestOptions = Object.assign({
    hostname: matches[1],
    port: matches[2],
    path: matches[3] || undefined,
    timeout: cloudOptions.clientOptions.socketOptions.connectTimeout
  }, cloudOptions.clientOptions.sslOptions);

  const req = https.get(requestOptions, res => {
    let data = '';

    utils$b.log('verbose', `Connected to metadata service with SSL/TLS protocol ${res.socket.getProtocol()}`, {}, cloudOptions);

    res
      .on('data', chunk => data += chunk.toString())
      .on('end', () => {
        if (res.statusCode !== 200) {
          return callback(getServiceRequestError(new Error(`Obtained http status ${res.statusCode}`), requestOptions));
        }

        let message;

        try {
          message = JSON.parse(data);

          if (!message || !message['contact_info']) {
            throw new TypeError('contact_info should be defined in response');
          }

        } catch (err) {
          return callback(getServiceRequestError(err, requestOptions, true));
        }

        const contactInfo = message['contact_info'];

        // Set the connect options
        cloudOptions.clientOptions.contactPoints = contactInfo['contact_points'];
        cloudOptions.clientOptions.localDataCenter = contactInfo['local_dc'];
        cloudOptions.clientOptions.sni = { address: contactInfo['sni_proxy_address'] };

        callback();
      });
  });

  req.on('error', err => callback(getServiceRequestError(err, requestOptions)));

  // We need to both set the timeout in the requestOptions and invoke ClientRequest#setTimeout()
  // to handle all possible scenarios, for some reason... (tested with one OR the other and didn't fully work)
  // Setting the also the timeout handler, aborting will emit 'error' and close
  req.setTimeout(cloudOptions.clientOptions.socketOptions.connectTimeout, () => req.abort());
}

const getMetadataServiceInfoAsync = util$4.promisify(getMetadataServiceInfo);

/**
 * Returns an Error that wraps the inner error obtained while fetching metadata information.
 * @private
 */
function getServiceRequestError(err, requestOptions, isParsingError) {
  const message = isParsingError
    ? 'There was an error while parsing the metadata service information'
    : 'There was an error fetching the metadata information';

  const url = `${requestOptions.hostname}:${requestOptions.port}${(requestOptions.path) ? requestOptions.path : '/'}`;
  return new errors$4.NoHostAvailableError({ [url] : err }, message);
}

/**
 * @param {{subject: {CN: string}, subjectaltname: string?}} cert A certificate object as defined by
 * TLS module https://nodejs.org/docs/latest-v12.x/api/tls.html#tls_certificate_object
 * @param {string} sniAddress
 * @returns {Error|undefined} Similar to tls.checkServerIdentity() returns an Error object, populating it with reason,
 * host, and cert on failure. Otherwise, it returns undefined.
 * @internal
 * @ignore
 */
function checkServerIdentity(cert, sniAddress) {
  // Based on logic defined by the Node.js Core module
  // https://github.com/nodejs/node/blob/ff48009fefcecedfee2c6ff1719e5be3f6969049/lib/tls.js#L212-L290

  // SNI address is composed by hostname and port
  const hostName = sniAddress.split(':')[0];
  const altNames = cert.subjectaltname;
  const cn = cert.subject.CN;

  if (hostName === cn) {
    // quick check based on common name
    return undefined;
  }

  const parsedAltNames = [];
  if (altNames) {
    for (const name of altNames.split(', ')) {
      if (name.startsWith('DNS:')) {
        parsedAltNames.push(name.slice(4));
      } else if (name.startsWith('URI:')) {
        parsedAltNames.push(new URL$1(name.slice(4)).hostname);
      }
    }
  }

  const hostParts = hostName.split('.');
  const wildcard = (pattern) => checkParts(hostParts, pattern);

  let valid;
  if (parsedAltNames.length > 0) {
    valid = parsedAltNames.some(wildcard);
  } else {
    // Use the common name
    valid = wildcard(cn);
  }

  if (!valid) {
    const error = new Error(`Host: ${hostName} is not cert's CN/altnames: ${cn} / ${altNames}`);
    error.reason = error.message;
    error.host = hostName;
    error.cert = cert;
    return error;
  }
}

/**
 * Simplified version of Node.js tls core lib check() function
 * https://github.com/nodejs/node/blob/ff48009fefcecedfee2c6ff1719e5be3f6969049/lib/tls.js#L148-L209
 * @private
 * @returns {boolean}
 */
function checkParts(hostParts, pattern) {
  // Empty strings, null, undefined, etc. never match.
  if (!pattern) {
    return false;
  }

  const patternParts = pattern.split('.');

  if (hostParts.length !== patternParts.length) {
    return false;
  }

  // Check host parts from right to left first.
  for (let i = hostParts.length - 1; i > 0; i -= 1) {
    if (hostParts[i] !== patternParts[i]) {
      return false;
    }
  }

  const hostSubdomain = hostParts[0];
  const patternSubdomain = patternParts[0];
  const patternSubdomainParts = patternSubdomain.split('*');

  // Short-circuit when the subdomain does not contain a wildcard.
  // RFC 6125 does not allow wildcard substitution for components
  // containing IDNA A-labels (Punycode) so match those verbatim.
  if (patternSubdomainParts.length === 1 || patternSubdomain.includes('xn--')) {
    return hostSubdomain === patternSubdomain;
  }

  // More than one wildcard is always wrong.
  if (patternSubdomainParts.length > 2) {
    return false;
  }

  // *.tld wildcards are not allowed.
  if (patternParts.length <= 2) {
    return false;
  }

  const [prefix, suffix] = patternSubdomainParts;

  if (prefix.length + suffix.length > hostSubdomain.length) {
    return false;
  }

  if (!hostSubdomain.startsWith(prefix)) {
    return false;
  }

  if (!hostSubdomain.endsWith(suffix)) {
    return false;
  }

  return true;
}

var cloud$1 = {
  checkServerIdentity,
  init
};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const utils$a = utils$K;

/**
 * Creates a new instance of <code>GraphResultSet</code>.
 * @class
 * @classdesc
 * Represents the result set of a [graph query execution]{@link Client#executeGraph} containing vertices, edges or
 * scalar values depending on the query.
 * <p>
 * It allows iteration of the items using <code>for..of</code> statements under ES2015 and exposes
 * <code>forEach()</code>, <code>first()</code> and <code>toArray()</code> to access the underlying items.
 * </p>
 * @example
 * for (let vertex of result} { ... }
 * @example
 * const arr = result.toArray();
 * @example
 * const vertex = result.first();
 * @param {ResultSet} result
 * @param {Function} [rowParser]
 * @alias module:datastax/graph~GraphResultSet
 * @constructor
 */
function GraphResultSet$2(result, rowParser) {
  /**
   * Information on the execution of a successful query:
   * @member {Object}
   * @property {Number} achievedConsistency The consistency level that has been actually achieved by the query.
   * @property {String} queriedHost The Cassandra host that coordinated this query.
   * @property {Object} triedHosts Gets the associative array of host that were queried before getting a valid response,
   * being the last host the one that replied correctly.
   * @property {Uuid} traceId Identifier of the trace session.
   * @property {Array.<string>} warnings Warning messages generated by the server when executing the query.
   */
  this.info = result.info;
  const rows = result.rows;
  rowParser = rowParser || parsePlainJsonRow;

  /**
   * This property has been deprecated because it may return a lower value than the actual length of the results.
   * Use <code>toArray()</code> instead.
   * <p>Gets the length of the result.</p>
   * @deprecated Use <code>toArray()</code> instead. This property will be removed in the following major version.
   * @member {Number}
   */
  this.length = result.rowLength;

  /**
   * A string token representing the current page state of query. It can be used in the following executions to
   * continue paging and retrieve the remained of the result for the query.
   * @member {String}
   */
  this.pageState = result.pageState;

  /**
   * Returns the first element of the result or null if the result is empty.
   * @returns {Object}
   */
  this.first = function first() {
    const iterator = this.values();
    const item = iterator.next();
    if (item.done) {
      return null;
    }

    return item.value;
  };

  /**
   * Executes a provided function once per result element.
   * @param {Function} callback Function to execute for each element, taking two arguments: currentValue and index.
   * @param {Object} [thisArg] Value to use as <code>this</code> when executing callback.
   */
  this.forEach = function forEach(callback, thisArg) {
    if (!rows.length) {
      return;
    }
    const iterator = this.values();
    let item = iterator.next();
    let index = 0;
    while (!item.done) {
      callback.call(thisArg || this, item.value, index++);
      item = iterator.next();
    }
  };

  /**
   * Results an Array of graph result elements (vertex, edge, scalar).
   * @returns {Array}
   */
  this.toArray = function toArray() {
    if (!rows.length) {
      return utils$a.emptyArray;
    }
    return utils$a.iteratorToArray(this.values());
  };

  /**
   * Returns a new Iterator object that contains the values for each index in the result.
   * @returns {Iterator}
   */
  this.values = function* values() {
    for (const traverser of this.getTraversers()) {
      const bulk = traverser.bulk || 1;

      for (let j = 0; j < bulk; j++) {
        yield traverser.object;
      }
    }
  };

  /**
   * Gets the traversers represented contained in the result set.
   * @returns {Iterator}
   */
  this.getTraversers = function* () {
    for (const row of rows) {
      yield rowParser(row);
    }
  };
}

if (typeof Symbol !== 'undefined' && typeof Symbol.iterator === 'symbol') {
  // Make iterable
  GraphResultSet$2.prototype[Symbol.iterator] = function getIterator() {
    return this.values();
  };
}

/**
 * @param {Row} row
 * @private
 */
function parsePlainJsonRow(row) {
  const parsed = JSON.parse(row['gremlin']);
  return { object: parsed.result, bulk: parsed.bulk || 1 };
}

var resultSet = GraphResultSet$2;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const types$6 = requireTypes();
const { dataTypes: dataTypes$3 } = types$6;

/**
 * Internal representation of a value with additional type information.
 * @internal
 * @ignore
 */
let GraphTypeWrapper$3 = class GraphTypeWrapper {
  constructor(value, typeInfo) {
    this.value = value;
    this.typeInfo = typeof typeInfo === 'number' ? { code: typeInfo } : typeInfo;
  }
};


/**
 * Internal representation of user-defined type with the metadata.
 * @internal
 * @ignore
 */
let UdtGraphWrapper$3 = class UdtGraphWrapper {
  constructor(value, udtInfo) {
    this.value = value;

    if (!udtInfo || !udtInfo.name || !udtInfo.keyspace || !udtInfo.fields) {
      throw new TypeError(`udtInfo must be an object with name, keyspace and field properties defined`);
    }

    this.udtInfo = udtInfo;
  }
};

/**
 * Wraps a number or null value to hint the client driver that the data type of the value is an int
 * @memberOf module:datastax/graph
 */
function asInt$1(value) { return new GraphTypeWrapper$3(value, dataTypes$3.int); }

/**
 * Wraps a number or null value to hint the client driver that the data type of the value is a double
 * @memberOf module:datastax/graph
 */
function asDouble$1(value) { return new GraphTypeWrapper$3(value, dataTypes$3.double); }

/**
 * Wraps a number or null value to hint the client driver that the data type of the value is a double
 * @memberOf module:datastax/graph
 */
function asFloat$1(value) { return new GraphTypeWrapper$3(value, dataTypes$3.float); }

/**
 * Wraps a Date or null value to hint the client driver that the data type of the value is a timestamp
 * @memberOf module:datastax/graph
 */
function asTimestamp$1(value) { return new GraphTypeWrapper$3(value, dataTypes$3.timestamp); }

/**
 * Wraps an Object or null value to hint the client driver that the data type of the value is a user-defined type.
 * @memberOf module:datastax/graph
 * @param {object} value The object representing the UDT.
 * @param {{name: string, keyspace: string, fields: Array}} udtInfo The UDT metadata as defined by the driver.
 */
function asUdt$1(value, udtInfo) { return new UdtGraphWrapper$3(value, udtInfo); }

var wrappers = { asInt: asInt$1, asDouble: asDouble$1, asFloat: asFloat$1, asTimestamp: asTimestamp$1, asUdt: asUdt$1, UdtGraphWrapper: UdtGraphWrapper$3, GraphTypeWrapper: GraphTypeWrapper$3 };

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const { GraphTypeWrapper: GraphTypeWrapper$2, UdtGraphWrapper: UdtGraphWrapper$2 } = wrappers;
const types$5 = requireTypes();
const Encoder = encoder;
const { dataTypes: dataTypes$2 } = types$5;

function getTypeDefinitionByValue$1(value) {
  if (value instanceof types$5.Tuple) {
    return {
      'cqlType': 'tuple',
      'definition': value.elements.map(getTypeDefinitionByValue$1)
    };
  }

  if (value instanceof Map) {
    // Try to guess the types of the key and value based on the first element
    const result = { 'cqlType': 'map' };
    if (value.size > 0) {
      const first = value.entries().next().value;
      result['definition'] = first.map(getTypeDefinitionByValue$1);
    }

    return result;
  }

  if (value instanceof UdtGraphWrapper$2) {
    return getUdtTypeDefinitionByValue$1(value);
  }

  let type;
  if (value instanceof GraphTypeWrapper$2) {
    type = value.typeInfo;
  } else {
    type = Encoder.guessDataType(value);
  }

  if (!type) {
    return null;
  }

  return getDefinitionByType(type);
}

function getDefinitionByType(type) {
  if (type.code === dataTypes$2.udt) {
    return getUdtTypeDefinition(type.info);
  }

  if (type.code === dataTypes$2.tuple || type.code === dataTypes$2.map) {
    return {
      'cqlType': types$5.getDataTypeNameByCode(type),
      'definition': type.info.map(getDefinitionByType)
    };
  }

  if (type.code === dataTypes$2.list || type.code === dataTypes$2.set) {
    return {
      'cqlType': type.code === dataTypes$2.list ? 'list' : 'set',
      'definition': [ getDefinitionByType(type.info) ]
    };
  }

  return { 'cqlType': types$5.getDataTypeNameByCode(type) };
}

function getUdtTypeDefinition(udtInfo) {
  return {
    'cqlType': 'udt',
    'keyspace': udtInfo.keyspace,
    'name': udtInfo.name,
    'definition': udtInfo.fields.map(field =>
      // fieldName should be the first property serialized
      Object.assign({ 'fieldName': field.name }, getDefinitionByType(field.type))
    ),
  };
}

function getUdtTypeDefinitionByValue$1(wrappedValue) {
  return getUdtTypeDefinition(wrappedValue.udtInfo);
}

var complexTypeHelper = { getTypeDefinitionByValue: getTypeDefinitionByValue$1, getUdtTypeDefinitionByValue: getUdtTypeDefinitionByValue$1 };

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const util$3 = require$$0$4;

/**
 * @classdesc
 * Represents a graph Element.
 * @param id
 * @param label
 * @abstract
 * @memberOf module:datastax/graph
 * @constructor
 */
function Element$1(id, label) {
  /**
   * Gets the element id.
   */
  this.id = id;
  /**
   * Gets the element label.
   * @type {String}
   */
  this.label = label;
}

/**
 * @classdesc
 * Represents a graph Vertex.
 * @param id
 * @param {String} label
 * @param {Object<string, Array>} properties
 * @extends {Element}
 * @memberOf module:datastax/graph
 * @constructor
 */
function Vertex$1(id, label, properties) {
  Element$1.call(this, id, label);
  /**
   * Gets the vertex properties.
   * @type {Object<string, Array>}
   */
  this.properties = properties;
}

util$3.inherits(Vertex$1, Element$1);

/**
 * @classdesc
 * Represents a graph Edge.
 * @param id
 * @param outV
 * @param {outVLabel} outVLabel
 * @param {String} label
 * @param inV
 * @param {String} inVLabel
 * @param {Object<string, Property>} properties
 * @extends {Element}
 * @memberOf module:datastax/graph
 * @constructor
 */
function Edge$2(id, outV, outVLabel, label, inV, inVLabel, properties) {
  Element$1.call(this, id, label);
  /**
   * Gets the id of outgoing vertex of the edge.
   */
  this.outV = outV;
  /**
   * Gets the label of the outgoing vertex.
   */
  this.outVLabel = outVLabel;
  /**
   * Gets the id of the incoming vertex of the edge.
   */
  this.inV = inV;

  /**
   * Gets the label of the incoming vertex.
   */
  this.inVLabel = inVLabel;
  /**
   * Gets the properties of the edge as an associative array.
   * @type {Object}
   */
  this.properties = {};
  (function adaptProperties(self) {
    if (properties) {
      const keys = Object.keys(properties);
      for (let i = 0; i < keys.length; i++) {
        const k = keys[i];
        self.properties[k] = properties[k].value;
      }
    }
  })(this);
}

util$3.inherits(Edge$2, Element$1);

/**
 * @classdesc
 * Represents a graph vertex property.
 * @param id
 * @param {String} label
 * @param value
 * @param {Object} properties
 * @extends {Element}
 * @memberOf module:datastax/graph
 * @constructor
 */
function VertexProperty$1(id, label, value, properties) {
  Element$1.call(this, id, label);
  this.value = value;
  this.key = this.label;
  this.properties = properties;
}

util$3.inherits(VertexProperty$1, Element$1);

/**
 * @classdesc
 * Represents a property.
 * @param key
 * @param value
 * @memberOf module:datastax/graph
 * @constructor
 */
function Property$1(key, value) {
  this.key = key;
  this.value = value;
}

/**
 * @classdesc
 * Represents a walk through a graph as defined by a traversal.
 * @param {Array} labels
 * @param {Array} objects
 * @memberOf module:datastax/graph
 * @constructor
 */
function Path$1(labels, objects) {
  this.labels = labels;
  this.objects = objects;
}

var structure = {
  Edge: Edge$2,
  Element: Element$1,
  Path: Path$1,
  Property: Property$1,
  Vertex: Vertex$1,
  VertexProperty: VertexProperty$1
};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const types$4 = requireTypes();
const utils$9 = utils$K;
const { getTypeDefinitionByValue, getUdtTypeDefinitionByValue } = complexTypeHelper;
const { Point, Polygon, LineString } = geometry$1;
const { Edge: Edge$1 } = structure;
const { GraphTypeWrapper: GraphTypeWrapper$1, UdtGraphWrapper: UdtGraphWrapper$1 } = wrappers;
const { Tuple, dataTypes: dataTypes$1 } = types$4;

const typeKey$1 = '@type';
const valueKey$1 = '@value';

class EdgeDeserializer {
  constructor() {
    this.key = 'g:Edge';
  }

  deserialize(obj) {
    const value = obj[valueKey$1];
    return new Edge$1(this.reader.read(value['id']), this.reader.read(value['outV']), value['outVLabel'], value['label'], this.reader.read(value['inV']), value['inVLabel'], this.reader.read(value['properties']));
  }
}

/**
 * Uses toString() instance method and fromString() static method to serialize and deserialize the value.
 * @abstract
 * @private
 */
class StringBasedTypeSerializer {

  /**
   * Creates a new instance of the deserializer.
   * @param {String} key
   * @param {Function} targetType
   */
  constructor(key, targetType) {
    if (!key) {
      throw new Error('Deserializer must provide a type key');
    }
    if (!targetType) {
      throw new Error('Deserializer must provide a target type');
    }
    this.key = key;
    this.targetType = targetType;
  }

  deserialize(obj) {
    let value = obj[valueKey$1];
    if (typeof value !== 'string') {
      value = value.toString();
    }
    return this.targetType.fromString(value);
  }

  serialize(value) {
    return {
      [typeKey$1]: this.key,
      [valueKey$1]: value.toString()
    };
  }

  canBeUsedFor(value) {
    return value instanceof this.targetType;
  }
}

class UuidSerializer extends StringBasedTypeSerializer {
  constructor() {
    super('g:UUID', types$4.Uuid);
  }
}

let LongSerializer$1 = class LongSerializer extends StringBasedTypeSerializer {
  constructor() {
    super('g:Int64', types$4.Long);
  }
};

class BigDecimalSerializer extends StringBasedTypeSerializer {
  constructor() {
    super('gx:BigDecimal', types$4.BigDecimal);
  }
}

class BigIntegerSerializer extends StringBasedTypeSerializer {
  constructor() {
    super('gx:BigInteger', types$4.Integer);
  }
}

class InetAddressSerializer extends StringBasedTypeSerializer {
  constructor() {
    super('gx:InetAddress', types$4.InetAddress);
  }
}

class LocalDateSerializer extends StringBasedTypeSerializer {
  constructor() {
    super('gx:LocalDate', types$4.LocalDate);
  }
}

class LocalTimeSerializer extends StringBasedTypeSerializer {
  constructor() {
    super('gx:LocalTime', types$4.LocalTime);
  }
}

class InstantSerializer extends StringBasedTypeSerializer {
  constructor() {
    super('gx:Instant', Date);
  }

  serialize(item) {
    return {
      [typeKey$1]: this.key,
      [valueKey$1]: item.toISOString()
    };
  }

  deserialize(obj) {
    return new Date(obj[valueKey$1]);
  }
}

class BlobSerializer extends StringBasedTypeSerializer {
  constructor() {
    super('dse:Blob', Buffer);
  }

  deserialize(obj) {
    return utils$9.allocBufferFromString(obj[valueKey$1], 'base64');
  }

  serialize(item) {
    return {
      [typeKey$1]: this.key,
      [valueKey$1]: item.toString('base64')
    };
  }
}

class PointSerializer extends StringBasedTypeSerializer {
  constructor() {
    super('dse:Point', Point);
  }
}

class LineStringSerializer extends StringBasedTypeSerializer {
  constructor() {
    super('dse:LineString', LineString);
  }
}

class PolygonSerializer extends StringBasedTypeSerializer {
  constructor() {
    super('dse:Polygon', Polygon);
  }
}

class TupleSerializer {
  constructor() {
    this.key = 'dse:Tuple';
  }

  deserialize(obj) {
    // Skip definitions and go to the value
    const value = obj[valueKey$1]['value'];

    if (!Array.isArray(value)) {
      throw new Error('Expected Array, obtained: ' + value);
    }

    const result = [];

    for (const element of value) {
      result.push(this.reader.read(element));
    }

    return Tuple.fromArray(result);
  }

  /** @param {Tuple} tuple */
  serialize(tuple) {
    const result = {
      'cqlType': 'tuple',
      'definition': tuple.elements.map(getTypeDefinitionByValue),
      'value': tuple.elements.map(e => this.writer.adaptObject(e))
    };

    return {
      [typeKey$1]: this.key,
      [valueKey$1]: result
    };
  }

  canBeUsedFor(value) {
    return value instanceof Tuple;
  }
}

class DurationSerializer {
  constructor() {
    this.key = 'dse:Duration';
  }

  deserialize(obj) {
    // Skip definitions and go to the value
    const value = obj[valueKey$1];

    return new types$4.Duration(
      this.reader.read(value['months']), this.reader.read(value['days']), this.reader.read(value['nanos']));
  }

  /** @param {Duration} value */
  serialize(value) {
    return {
      [typeKey$1]: this.key,
      [valueKey$1]: {
        'months': value['months'],
        'days': value['days'],
        'nanos': value['nanoseconds'],
      }
    };
  }

  canBeUsedFor(value) {
    return value instanceof types$4.Duration;
  }
}

class UdtSerializer {
  constructor() {
    this.key = 'dse:UDT';
  }

  deserialize(obj) {
    // Skip definitions and go to the value
    const valueRoot = obj[valueKey$1];
    const result = {};
    const value = valueRoot['value'];

    valueRoot['definition'].forEach((definition, index) => {
      result[definition.fieldName] = this.reader.read(value[index]);
    });

    return result;
  }

  serialize(udtWrapper) {
    const serializedValue = getUdtTypeDefinitionByValue(udtWrapper);
    // New properties can be added to the existing object without need to clone
    // as getTypeDefinition() returns a new object each time
    serializedValue['value'] = Object.entries(udtWrapper.value).map(([_, v]) => this.writer.adaptObject(v));

    return {
      [typeKey$1]: this.key,
      [valueKey$1]: serializedValue
    };
  }

  canBeUsedFor(value) {
    return value instanceof UdtGraphWrapper$1;
  }
}

class InternalSerializer {
  constructor(name, transformFn) {
    this._name = name;
    this._transformFn = transformFn || (x => x);
  }

  serialize(item) {
    return {
      [typeKey$1]: this._name,
      [valueKey$1]: this._transformFn(item)
    };
  }
}

// Associative array of graph type name by CQL type code, used by the type wrapper
const graphSONSerializerByCqlType = {
  [dataTypes$1.int]: new InternalSerializer('g:Int32'),
  [dataTypes$1.bigint]: new InternalSerializer('g:Int64'),
  [dataTypes$1.double]: new InternalSerializer('g:Double'),
  [dataTypes$1.float]: new InternalSerializer('g:Float'),
  [dataTypes$1.timestamp]: new InternalSerializer('g:Timestamp', x => x.getTime())
};

class GraphTypeWrapperSerializer {
  constructor() {
    // Use a fixed name that doesn't conflict with TinkerPop and DS Graph
    this.key = 'client:wrapper';
  }

  serialize(wrappedValue) {
    const s = graphSONSerializerByCqlType[wrappedValue.typeInfo.code];

    if (!s) {
      throw new Error(`No serializer found for wrapped value ${wrappedValue}`);
    }

    return s.serialize(wrappedValue.value);
  }

  canBeUsedFor(value) {
    return value instanceof GraphTypeWrapper$1;
  }
}

const serializersArray = [
  EdgeDeserializer,
  UuidSerializer,
  LongSerializer$1,
  BigDecimalSerializer,
  BigIntegerSerializer,
  InetAddressSerializer,
  LocalDateSerializer,
  LocalTimeSerializer,
  InstantSerializer,
  BlobSerializer,
  PointSerializer,
  LineStringSerializer,
  PolygonSerializer,
  TupleSerializer,
  UdtSerializer,
  GraphTypeWrapperSerializer,
  DurationSerializer
];

function getCustomSerializers() {
  const customSerializers = {};

  serializersArray.forEach(sConstructor => {
    const instance = new sConstructor();
    if (!instance.key) {
      throw new TypeError(`Key for ${sConstructor} instance not set`);
    }

    customSerializers[instance.key] = instance;
  });

  return customSerializers;
}

var customTypeSerializers = getCustomSerializers;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Graph module.
 * @module datastax/graph
 */

const GraphResultSet$1 = resultSet;
const getCustomTypeSerializers$1 = customTypeSerializers;
const { asInt, asDouble, asFloat, asTimestamp, asUdt, UdtGraphWrapper, GraphTypeWrapper} = wrappers;
const { Edge, Element, Path, Property, Vertex, VertexProperty } = structure;

class EnumValue {
  constructor(typeName, elementName) {
    this.typeName = typeName;
    this.elementName = elementName;
  }

  toString() {
    return this.elementName;
  }
}

/**
 * Represents a collection of tokens for more concise Traversal definitions.
 */
const t$1 = {
  id: new EnumValue('T', 'id'),
  key: new EnumValue('T', 'key'),
  label: new EnumValue('T', 'label'),
  value: new EnumValue('T', 'value'),
};

/**
 * Represents the edge direction.
 */
const direction = {
  'both': new EnumValue('Direction', 'BOTH'),
  'in': new EnumValue('Direction', 'IN'),
  'out': new EnumValue('Direction', 'OUT')
};

// `in` is a reserved keyword depending on the context
// TinkerPop JavaScript GLV only exposes `in` but it can lead to issues for TypeScript users and others.
// Expose an extra property to represent `Direction.IN`.
direction.in_ = direction.in;

var graph = {
  Edge,
  Element,
  Path,
  Property,
  Vertex,
  VertexProperty,

  asInt,
  asDouble,
  asFloat,
  asTimestamp,
  asUdt,
  direction,
  getCustomTypeSerializers: getCustomTypeSerializers$1,
  GraphResultSet: GraphResultSet$1,
  GraphTypeWrapper,
  t: t$1,
  UdtGraphWrapper
};

/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  "License"); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

// Replace dependencies to minimize code changes from Apache TinkerPop
const t = {
  P: UnsupportedType, TextP: UnsupportedType, Traversal: UnsupportedType, Traverser: UnsupportedType,
  EnumValue: UnsupportedType
};
const ts = { TraversalStrategy: UnsupportedType };
const Bytecode = UnsupportedType;
const g = graph;
const utils$8 = { Long: UnsupportedType };
t.t = g.t;
t.direction = g.direction;

function UnsupportedType() { }

const valueKey = '@value';
const typeKey = '@type';

/**
 * @abstract
 */
class TypeSerializer {
  serialize() {
    throw new Error('serialize() method not implemented for ' + this.constructor.name);
  }

  deserialize() {
    throw new Error('deserialize() method not implemented for ' + this.constructor.name);
  }

  canBeUsedFor() {
    throw new Error('canBeUsedFor() method not implemented for ' + this.constructor.name);
  }
}

class NumberSerializer extends TypeSerializer {
  serialize(item) {
    if (isNaN(item)) {
      return {
        [typeKey]: 'g:Double',
        [valueKey]: 'NaN'
      };
    } else if (item === Number.POSITIVE_INFINITY) {
      return {
        [typeKey]: 'g:Double',
        [valueKey]: 'Infinity'
      };
    } else if (item === Number.NEGATIVE_INFINITY) {
      return {
        [typeKey]: 'g:Double',
        [valueKey]: '-Infinity'
      };
    } else {
      return item;
    }
  }

  deserialize(obj) {
    var val = obj[valueKey];
    if (val === 'NaN') {
      return NaN;
    } else if (val === 'Infinity') {
      return Number.POSITIVE_INFINITY;
    } else if (val === '-Infinity') {
      return Number.NEGATIVE_INFINITY;
    } else {
      return parseFloat(val);
    }
  }

  canBeUsedFor(value) {
    return (typeof value === 'number');
  }
}

class DateSerializer extends TypeSerializer {
  serialize(item) {
    return {
      [typeKey]: 'g:Date',
      [valueKey]: item.getTime()
    };
  }

  deserialize(obj) {
    return new Date(obj[valueKey]);
  }

  canBeUsedFor(value) {
    return (value instanceof Date);
  }
}

class LongSerializer extends TypeSerializer {
  serialize(item) {
    return {
      [typeKey]: 'g:Int64',
      [valueKey]: item.value
    };
  }

  canBeUsedFor(value) {
    return (value instanceof utils$8.Long);
  }
}

class BytecodeSerializer extends TypeSerializer {
  serialize(item) {
    let bytecode = item;
    if (item instanceof t.Traversal) {
      bytecode = item.getBytecode();
    }
    const result = {};
    result[typeKey] = 'g:Bytecode';
    const resultValue = result[valueKey] = {};
    const sources = this._serializeInstructions(bytecode.sourceInstructions);
    if (sources) {
      resultValue['source'] = sources;
    }
    const steps = this._serializeInstructions(bytecode.stepInstructions);
    if (steps) {
      resultValue['step'] = steps;
    }
    return result;
  }

  _serializeInstructions(instructions) {
    if (instructions.length === 0) {
      return null;
    }
    const result = new Array(instructions.length);
    result[0] = instructions[0];
    for (let i = 0; i < instructions.length; i++) {
      result[i] = instructions[i].map(item => this.writer.adaptObject(item));
    }
    return result;
  }

  canBeUsedFor(value) {
    return (value instanceof Bytecode) || (value instanceof t.Traversal);
  }
}

class PSerializer extends TypeSerializer {
  /** @param {P} item */
  serialize(item) {
    const result = {};
    result[typeKey] = 'g:P';
    const resultValue = result[valueKey] = {
      'predicate': item.operator
    };
    if (item.other === undefined || item.other === null) {
      resultValue['value'] = this.writer.adaptObject(item.value);
    }
    else {
      resultValue['value'] = [ this.writer.adaptObject(item.value), this.writer.adaptObject(item.other) ];
    }
    return result;
  }

  canBeUsedFor(value) {
    return (value instanceof t.P);
  }
}

class TextPSerializer extends TypeSerializer {
  /** @param {TextP} item */
  serialize(item) {
    const result = {};
    result[typeKey] = 'g:TextP';
    const resultValue = result[valueKey] = {
      'predicate': item.operator
    };
    if (item.other === undefined || item.other === null) {
      resultValue['value'] = this.writer.adaptObject(item.value);
    }
    else {
      resultValue['value'] = [ this.writer.adaptObject(item.value), this.writer.adaptObject(item.other) ];
    }
    return result;
  }

  canBeUsedFor(value) {
    return (value instanceof t.TextP);
  }
}

class LambdaSerializer extends TypeSerializer {
  /** @param {Function} item */
  serialize(item) {
    return {
      [typeKey]: 'g:Lambda',
      [valueKey]: {
        'arguments': item.length,
        'language': 'gremlin-javascript',
        'script': item.toString()
      }
    };
  }

  canBeUsedFor(value) {
    return (typeof value === 'function');
  }
}

class EnumSerializer extends TypeSerializer {
  /** @param {EnumValue} item */
  serialize(item) {
    return {
      [typeKey]: 'g:' + item.typeName,
      [valueKey]: item.elementName
    };
  }

  canBeUsedFor(value) {
    return value && value.typeName && value instanceof t.EnumValue;
  }
}

class TraverserSerializer extends TypeSerializer {
  /** @param {Traverser} item */
  serialize(item) {
    return {
      [typeKey]: 'g:Traverser',
      [valueKey]: {
        'value': this.writer.adaptObject(item.object),
        'bulk': this.writer.adaptObject(item.bulk)
      }
    };
  }

  deserialize(obj) {
    const value = obj[valueKey];
    return new t.Traverser(this.reader.read(value['value']), this.reader.read(value['bulk']));
  }

  canBeUsedFor(value) {
    return (value instanceof t.Traverser);
  }
}

class TraversalStrategySerializer extends TypeSerializer {
  /** @param {TraversalStrategy} item */
  serialize(item) {
    return {
      [typeKey]: 'g:' + item.constructor.name,
      [valueKey]: item.configuration
    };
  }

  canBeUsedFor(value) {
    return (value instanceof ts.TraversalStrategy);
  }
}

class VertexSerializer extends TypeSerializer {
  deserialize(obj) {
    const value = obj[valueKey];
    return new g.Vertex(this.reader.read(value['id']), value['label'], this.reader.read(value['properties']));
  }

  /** @param {Vertex} item */
  serialize(item) {
    return {
      [typeKey]: 'g:Vertex',
      [valueKey]: {
        'id': this.writer.adaptObject(item.id),
        'label': item.label
      }
    };
  }

  canBeUsedFor(value) {
    return (value instanceof g.Vertex);
  }
}

class VertexPropertySerializer extends TypeSerializer {
  deserialize(obj) {
    const value = obj[valueKey];
    return new g.VertexProperty(
      this.reader.read(value['id']),
      value['label'],
      this.reader.read(value['value']),
      this.reader.read(value['properties'])
    );
  }
}

class PropertySerializer extends TypeSerializer {
  deserialize(obj) {
    const value = obj[valueKey];
    return new g.Property(
      value['key'],
      this.reader.read(value['value']));
  }
}

class EdgeSerializer extends TypeSerializer {
  deserialize(obj) {
    const value = obj[valueKey];
    return new g.Edge(
      this.reader.read(value['id']),
      new g.Vertex(this.reader.read(value['outV']), this.reader.read(value['outVLabel'])),
      value['label'],
      new g.Vertex(this.reader.read(value['inV']), this.reader.read(value['inVLabel'])),
      this.reader.read(value['properties'])
    );
  }

  /** @param {Edge} item */
  serialize(item) {
    return {
      [typeKey]: 'g:Edge',
      [valueKey]: {
        'id': this.writer.adaptObject(item.id),
        'label': item.label,
        'outV': this.writer.adaptObject(item.outV.id),
        'outVLabel': item.outV.label,
        'inV': this.writer.adaptObject(item.inV.id),
        'inVLabel': item.inV.label
      }
    };
  }

  canBeUsedFor(value) {
    return (value instanceof g.Edge);
  }
}

class PathSerializer extends TypeSerializer {
  deserialize(obj) {
    const value = obj[valueKey];
    const objects = value['objects'].map(o => this.reader.read(o));
    return new g.Path(this.reader.read(value['labels']), objects);
  }
}

class Path3Serializer extends TypeSerializer {
  deserialize(obj) {
    const value = obj[valueKey];
    return new g.Path(this.reader.read(value['labels']), this.reader.read(value['objects']));
  }
}

class TSerializer extends TypeSerializer {
  deserialize(obj) {
    return t.t[obj[valueKey]];
  }
}

class DirectionSerializer extends TypeSerializer {
    deserialize(obj) {
        return t.direction[obj[valueKey].toLowerCase()];
    }
}

class ArraySerializer extends TypeSerializer {
  constructor(typeKey) {
    super();
    this.typeKey = typeKey;
  }

  deserialize(obj) {
    const value = obj[valueKey];
    if (!Array.isArray(value)) {
      throw new Error('Expected Array, obtained: ' + value);
    }
    return value.map(x => this.reader.read(x));
  }

  /** @param {Array} item */
  serialize(item) {
    return {
      [typeKey]: this.typeKey,
      [valueKey]: item.map(x => this.writer.adaptObject(x))
    };
  }

  canBeUsedFor(value) {
    return Array.isArray(value);
  }
}

class BulkSetSerializer extends TypeSerializer {
  deserialize(obj) {
      const value = obj[valueKey];
      if (!Array.isArray(value)) {
          throw new Error('Expected Array, obtained: ' + value);
      }

      // coerce the BulkSet to List. if the bulk exceeds the int space then we can't coerce to List anyway,
      // so this query will be trouble. we'd need a legit BulkSet implementation here in js. this current
      // implementation is here to replicate the previous functionality that existed on the server side in
      // previous versions.
      let result = [];
      for (let ix = 0, iy = value.length; ix < iy; ix += 2) {
        const pair = value.slice(ix, ix + 2);
        result = result.concat(Array(this.reader.read(pair[1])).fill(this.reader.read(pair[0])));
      }

      return result;
  }
}

class MapSerializer extends TypeSerializer {
  deserialize(obj) {
    const value = obj[valueKey];
    if (!Array.isArray(value)) {
      throw new Error('Expected Array, obtained: ' + value);
    }
    const result = new Map();
    for (let i = 0; i < value.length; i += 2) {
      result.set(this.reader.read(value[i]), this.reader.read(value[i + 1]));
    }
    return result;
  }

  /** @param {Map} map */
  serialize(map) {
    const arr = [];
    map.forEach((v, k) => {
      arr.push(this.writer.adaptObject(k));
      arr.push(this.writer.adaptObject(v));
    });
    return {
      [typeKey]: 'g:Map',
      [valueKey]: arr
    };
  }

  canBeUsedFor(value) {
    return value instanceof Map;
  }
}

class ListSerializer extends ArraySerializer {
  constructor() {
    super('g:List');
  }
}

class SetSerializer extends ArraySerializer {
  constructor() {
    super('g:Set');
  }
}

var typeSerializers$1 = {
  BulkSetSerializer,
  BytecodeSerializer,
  DateSerializer,
  DirectionSerializer,
  EdgeSerializer,
  EnumSerializer,
  LambdaSerializer,
  ListSerializer,
  LongSerializer,
  MapSerializer,
  NumberSerializer,
  Path3Serializer,
  PathSerializer,
  PropertySerializer,
  PSerializer,
  TextPSerializer,
  SetSerializer,
  TSerializer,
  TraverserSerializer,
  TraversalStrategySerializer,
  typeKey,
  valueKey,
  VertexPropertySerializer,
  VertexSerializer
};

/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  "License"); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

const typeSerializers = typeSerializers$1;

/**
 * GraphSON2 writer.
 */
let GraphSON2Writer$1 = class GraphSON2Writer {

  /**
   * @param {Object} [options]
   * @param {Object} [options.serializers] An object used as an associative array with GraphSON 2 type name as keys and
   * serializer instances as values, ie: { 'g:Int64': longSerializer }.
   * @constructor
   */
  constructor(options) {
    this._options = options || {};
    // Create instance of the default serializers
    this._serializers = this.getDefaultSerializers().map(serializerConstructor => {
      const s = new serializerConstructor();
      s.writer = this;
      return s;
    });

    const customSerializers = this._options.serializers || {};

    Object.keys(customSerializers).forEach(key => {
      const s = customSerializers[key];
      if (!s.serialize) {
        return;
      }
      s.writer = this;
      // Insert custom serializers first
      this._serializers.unshift(s);
    });
  }

  /**
   * Gets the default serializers to be used.
   * @returns {Array}
   */
  getDefaultSerializers() {
    return graphSON2Serializers;
  }

  adaptObject(value) {
    let s;

    for (let i = 0; i < this._serializers.length; i++) {
      const currentSerializer = this._serializers[i];
      if (currentSerializer.canBeUsedFor && currentSerializer.canBeUsedFor(value)) {
        s = currentSerializer;
        break;
      }
    }

    if (s) {
      return s.serialize(value);
    }

    if (Array.isArray(value)) {
      // We need to handle arrays when there is no serializer
      // for older versions of GraphSON
      return value.map(item => this.adaptObject(item));
    }

    // Default (strings / objects / ...)
    return value;
  }

  /**
   * Returns the GraphSON representation of the provided object instance.
   * @param {Object} obj
   * @returns {String}
   */
  write(obj) {
    return JSON.stringify(this.adaptObject(obj));
  }
};

/**
 * GraphSON3 writer.
 */
let GraphSON3Writer$1 = class GraphSON3Writer extends GraphSON2Writer$1 {
  getDefaultSerializers() {
    return graphSON3Serializers;
  }
};

/**
 * GraphSON2 reader.
 */
let GraphSON2Reader$1 = class GraphSON2Reader {
  /**
   * GraphSON Reader
   * @param {Object} [options]
   * @param {Object} [options.serializers] An object used as an associative array with GraphSON 2 type name as keys and
   * deserializer instances as values, ie: { 'g:Int64': longSerializer }.
   * @constructor
   */
  constructor(options) {
    this._options = options || {};
    this._deserializers = {};

    const defaultDeserializers = this.getDefaultDeserializers();
    Object.keys(defaultDeserializers).forEach(typeName => {
      const serializerConstructor = defaultDeserializers[typeName];
      const s = new serializerConstructor();
      s.reader = this;
      this._deserializers[typeName] = s;
    });

    if (this._options.serializers) {
      const customSerializers = this._options.serializers || {};
      Object.keys(customSerializers).forEach(key => {
        const s = customSerializers[key];
        if (!s.deserialize) {
          return;
        }
        s.reader = this;
        this._deserializers[key] = s;
      });
    }
  }

  /**
   * Gets the default deserializers as an associative array.
   * @returns {Object}
   */
  getDefaultDeserializers() {
    return graphSON2Deserializers;
  }

  read(obj) {
    if (obj === undefined) {
      return undefined;
    }
    if (obj === null) {
      return null;
    }
    if (Array.isArray(obj)) {
      return obj.map(item => this.read(item));
    }
    const type = obj[typeSerializers.typeKey];
    if (type) {
      const d = this._deserializers[type];
      if (d) {
        // Use type serializer
        return d.deserialize(obj);
      }
      return obj[typeSerializers.valueKey];
    }
    if (obj && typeof obj === 'object' && obj.constructor === Object) {
      return this._deserializeObject(obj);
    }
    // Default (for boolean, number and other scalars)
    return obj;
  }

  _deserializeObject(obj) {
    const keys = Object.keys(obj);
    const result = {};
    for (let i = 0; i < keys.length; i++) {
      result[keys[i]] = this.read(obj[keys[i]]);
    }
    return result;
  }
};

/**
 * GraphSON3 reader.
 */
let GraphSON3Reader$1 = class GraphSON3Reader extends GraphSON2Reader$1 {
  getDefaultDeserializers() {
    return graphSON3Deserializers;
  }
};

const graphSON2Deserializers = {
  'g:Traverser': typeSerializers.TraverserSerializer,
  'g:TraversalStrategy': typeSerializers.TraversalStrategySerializer,
  'g:Int32':  typeSerializers.NumberSerializer,
  'g:Int64':  typeSerializers.NumberSerializer,
  'g:Float':  typeSerializers.NumberSerializer,
  'g:Double': typeSerializers.NumberSerializer,
  'g:Date': typeSerializers.DateSerializer,
  'g:Direction': typeSerializers.DirectionSerializer,
  'g:Vertex': typeSerializers.VertexSerializer,
  'g:Edge': typeSerializers.EdgeSerializer,
  'g:VertexProperty': typeSerializers.VertexPropertySerializer,
  'g:Property': typeSerializers.PropertySerializer,
  'g:Path': typeSerializers.Path3Serializer,
  'g:TextP': typeSerializers.TextPSerializer,
  'g:T': typeSerializers.TSerializer,
  'g:BulkSet': typeSerializers.BulkSetSerializer
};

const graphSON3Deserializers = Object.assign({}, graphSON2Deserializers, {
  'g:List': typeSerializers.ListSerializer,
  'g:Set': typeSerializers.SetSerializer,
  'g:Map': typeSerializers.MapSerializer
});

const graphSON2Serializers = [
  typeSerializers.NumberSerializer,
  typeSerializers.DateSerializer,
  typeSerializers.BytecodeSerializer,
  typeSerializers.TraverserSerializer,
  typeSerializers.TraversalStrategySerializer,
  typeSerializers.PSerializer,
  typeSerializers.TextPSerializer,
  typeSerializers.LambdaSerializer,
  typeSerializers.EnumSerializer,
  typeSerializers.VertexSerializer,
  typeSerializers.EdgeSerializer,
  typeSerializers.LongSerializer
];

const graphSON3Serializers = graphSON2Serializers.concat([
  typeSerializers.ListSerializer,
  typeSerializers.SetSerializer,
  typeSerializers.MapSerializer
]);

var graphSerializer = {
  GraphSON3Writer: GraphSON3Writer$1,
  GraphSON3Reader: GraphSON3Reader$1,
  GraphSON2Writer: GraphSON2Writer$1,
  GraphSON2Reader: GraphSON2Reader$1,
  GraphSONWriter: GraphSON3Writer$1,
  GraphSONReader: GraphSON3Reader$1
};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const util$2 = require$$0$4;
const types$3 = requireTypes();
const utils$7 = utils$K;
const { DefaultExecutionOptions: DefaultExecutionOptions$1, proxyExecuteKey } = executionOptions;
const Long = types$3.Long;

let consistencyNames;

const graphProtocol$1 = Object.freeze({
  graphson1: 'graphson-1.0',
  graphson2: 'graphson-2.0',
  graphson3: 'graphson-3.0'
});

const payloadKeys = Object.freeze({
  language :'graph-language',
  source: 'graph-source',
  name: 'graph-name',
  results: 'graph-results',
  writeConsistency: 'graph-write-consistency',
  readConsistency: 'graph-read-consistency',
  timeout: 'request-timeout'
});

/**
 * Graph options that extends {@link QueryOptions}.
 * <p>
 *   Consider using [execution profiles]{@link ExecutionProfile} if you plan to reuse options across different
 *   query executions.
 * </p>
 * @typedef {QueryOptions} module:datastax/graph~GraphQueryOptions
 * @property {String} [graphLanguage] The graph language to use in graph queries.
 * @property {String} [graphResults] The protocol to use for serializing and deserializing graph results.
 * <p>
 *   Note that this value should rarely be set by users and will otherwise be unset. When unset the server resolves
 *   the protocol based on the <code>graphLanguage</code> specified.
 * </p>
 * @property {String} [graphName] The graph name to be used in the query. You can use <code>null</code> to clear the
 * value from the <code>DseClientOptions</code> and execute a query without a default graph.
 * @property {Number} [graphReadConsistency] Specifies the
 * [consistency level]{@link module:types~consistencies}
 * to be used for the graph read queries in this execution.
 * <p>
 *   When defined, it overrides the consistency level only for the READ part of the graph query.
 * </p>
 * @property {String} [graphSource] The graph traversal source name to use in graph queries.
 * @property {Number} [graphWriteConsistency] Specifies the [consistency level]{@link module:types~consistencies} to
 * be used for the graph write queries in this execution.
 * <p>
 *   When defined, it overrides the consistency level only for the WRITE part of the graph query.
 * </p>
 * @property {RetryPolicy} [retry] Sets the retry policy to be used for the graph query execution.
 * <p>
 *   When not specified in the {@link GraphQueryOptions} or in the {@link ExecutionProfile}, it will use by default
 *   a retry policy that does not retry graph executions.
 * </p>
 */

/**
 * Gets the default options with the custom payload for a given profile.
 * @param {ProfileManager} profileManager
 * @param baseOptions
 * @param {RetryPolicy|null} defaultRetryPolicy
 * @param {ExecutionProfile} profile
 * @returns {DseClientOptions}
 * @private
 */
function getDefaultGraphOptions(profileManager, baseOptions, defaultRetryPolicy, profile) {
  return profileManager.getOrCreateGraphOptions(profile, function createDefaultOptions() {
    const profileOptions = profile.graphOptions || utils$7.emptyObject;
    const defaultProfile = profileManager.getDefault();
    const options = {
      customPayload: {
        [payloadKeys.language]: utils$7.allocBufferFromString(profileOptions.language || baseOptions.language),
        [payloadKeys.source]: utils$7.allocBufferFromString(profileOptions.source || baseOptions.source)
      },
      graphLanguage: profileOptions.language || baseOptions.language,
      graphResults: profileOptions.results || baseOptions.results,
      graphSource: profileOptions.source || baseOptions.source,
      graphName: utils$7.ifUndefined(profileOptions.name, baseOptions.name)
    };

    if (profile !== defaultProfile) {
      options.retry = profile.retry || baseOptions.retry;
    } else {
      // Based on an implementation detail of the execution profiles, the retry policy for the default profile is
      // always loaded (required), but that doesn't mean that it was specified by the user.
      // If it wasn't specified by the user, use the default retry policy for graph statements.
      options.retry = defaultRetryPolicy || baseOptions.retry;
    }

    if (baseOptions.executeAs) {
      options.customPayload[proxyExecuteKey] = utils$7.allocBufferFromString(baseOptions.executeAs);
    }

    if (options.graphName) {
      options.customPayload[payloadKeys.name] = utils$7.allocBufferFromString(options.graphName);
    }

    const graphResults = utils$7.ifUndefined(profileOptions.results, baseOptions.graphResults);
    if (graphResults !== undefined) {
      options.customPayload[payloadKeys.results] = utils$7.allocBufferFromString(graphResults);
    }

    const readConsistency = utils$7.ifUndefined(profileOptions.readConsistency, baseOptions.readConsistency);
    if (readConsistency !== undefined) {
      options.customPayload[payloadKeys.readConsistency] =
        utils$7.allocBufferFromString(getConsistencyName(readConsistency));
    }

    const writeConsistency = utils$7.ifUndefined(profileOptions.writeConsistency, baseOptions.writeConsistency);
    if (writeConsistency !== undefined) {
      options.customPayload[payloadKeys.writeConsistency] =
        utils$7.allocBufferFromString(getConsistencyName(writeConsistency));
    }

    options.readTimeout = utils$7.ifUndefined3(profile.readTimeout, defaultProfile.readTimeout, baseOptions.readTimeout);
    if (options.readTimeout > 0) {
      // Write the graph read timeout payload
      options.customPayload[payloadKeys.timeout] = longBuffer(options.readTimeout);
    }

    return options;
  });
}

/**
 * Sets the payload key. If the value is not provided, it uses the value from the default profile options.
 * @param {Object} payload
 * @param {QueryOptions} profileOptions
 * @param {String} key
 * @param {String|Number|null} value
 * @param {Function} [converter]
 * @private
 */
function setPayloadKey(payload, profileOptions, key, value, converter) {
  converter = converter || utils$7.allocBufferFromString;
  if (value === null) {
    // Use null to avoid set payload for a key
    return;
  }

  if (value !== undefined) {
    payload[key] = converter(value);
    return;
  }

  if (profileOptions.customPayload[key]) {
    payload[key] = profileOptions.customPayload[key];
  }
}

function longBuffer(value) {
  value = Long.fromNumber(value);
  return Long.toBuffer(value);
}

/**
 * Gets the name in upper case of the consistency level.
 * @param {Number} consistency
 * @private
 */
function getConsistencyName(consistency) {
  // eslint-disable-next-line
  if (consistency == undefined) {
    //null or undefined => undefined
    return undefined;
  }
  loadConsistencyNames();
  const name = consistencyNames[consistency];
  if (!name) {
    throw new Error(util$2.format(
      'Consistency %s not found, use values defined as properties in types.consistencies object', consistency
    ));
  }
  return name;
}

function loadConsistencyNames() {
  if (consistencyNames) {
    return;
  }
  consistencyNames = {};
  const propertyNames = Object.keys(types$3.consistencies);
  for (let i = 0; i < propertyNames.length; i++) {
    const name = propertyNames[i];
    consistencyNames[types$3.consistencies[name]] = name.toUpperCase();
  }
  //Using java constants naming conventions
  consistencyNames[types$3.consistencies.localQuorum] = 'LOCAL_QUORUM';
  consistencyNames[types$3.consistencies.eachQuorum] = 'EACH_QUORUM';
  consistencyNames[types$3.consistencies.localSerial] = 'LOCAL_SERIAL';
  consistencyNames[types$3.consistencies.localOne] = 'LOCAL_ONE';
}

/**
 * Represents a wrapper around the options related to a graph execution.
 * @internal
 * @ignore
 */
let GraphExecutionOptions$1 = class GraphExecutionOptions extends DefaultExecutionOptions$1 {

  /**
   * Creates a new instance of GraphExecutionOptions.
   * @param {GraphQueryOptions} queryOptions The user provided query options.
   * @param {Client} client the client instance.
   * @param graphBaseOptions The default graph base options.
   * @param {RetryPolicy} defaultProfileRetryPolicy
   */
  constructor(queryOptions, client, graphBaseOptions, defaultProfileRetryPolicy) {

    queryOptions = queryOptions || utils$7.emptyObject;
    super(queryOptions, client, null);

    this._defaultGraphOptions = getDefaultGraphOptions(
      client.profileManager, graphBaseOptions, defaultProfileRetryPolicy, this.getProfile());

    this._preferredHost = null;
    this._graphSubProtocol = queryOptions.graphResults || this._defaultGraphOptions.graphResults;
    this._graphLanguage = queryOptions.graphLanguage || this._defaultGraphOptions.graphLanguage;
  }

  setPreferredHost(host) {
    this._preferredHost = host;
  }

  getPreferredHost() {
    return this._preferredHost;
  }

  getGraphSource() {
    return this.getRawQueryOptions().graphSource || this._defaultGraphOptions.graphSource;
  }

  getGraphLanguage() {
    return this._graphLanguage;
  }

  setGraphLanguage(value) {
    this._graphLanguage = value;
  }

  getGraphName() {
    return utils$7.ifUndefined(this.getRawQueryOptions().graphName, this._defaultGraphOptions.graphName);
  }

  getGraphSubProtocol() {
    return this._graphSubProtocol;
  }

  setGraphSubProtocol(protocol) {
    this._graphSubProtocol = protocol;
  }

  /** Graph executions have a specific default read timeout */
  getReadTimeout() {
    return this.getRawQueryOptions().readTimeout || this._defaultGraphOptions.readTimeout;
  }

  /** Graph executions have a specific default retry policy */
  getRetryPolicy() {
    return this.getRawQueryOptions().retry || this._defaultGraphOptions.retry;
  }

  getRowParser() {
    const factory = this.getRawQueryOptions().rowParserFactory;

    if (!factory) {
      return null;
    }

    return factory(this.getGraphSubProtocol());
  }

  getQueryWriter() {
    const factory = this.getRawQueryOptions().queryWriterFactory;

    if (!factory) {
      return null;
    }

    return factory(this.getGraphSubProtocol());
  }

  setGraphPayload() {
    const options = this.getRawQueryOptions();
    const defaultOptions = this._defaultGraphOptions;

    // Clone the existing custom payload (if any)
    const payload = Object.assign({}, this.getCustomPayload());

    // Override the payload for DSE Graph exclusive options
    setPayloadKey(payload, defaultOptions, payloadKeys.language,
      this.getGraphLanguage() !== this._defaultGraphOptions.graphLanguage ? this.getGraphLanguage() : undefined);
    setPayloadKey(payload, defaultOptions, payloadKeys.source, options.graphSource);
    setPayloadKey(payload, defaultOptions, payloadKeys.name, options.graphName);
    setPayloadKey(payload, defaultOptions, payloadKeys.readConsistency,
      getConsistencyName(options.graphReadConsistency));
    setPayloadKey(payload, defaultOptions, payloadKeys.writeConsistency,
      getConsistencyName(options.graphWriteConsistency));

    // Use the read timeout defined by the user or the one default to graph executions
    setPayloadKey(payload, defaultOptions, payloadKeys.timeout,
      this.getReadTimeout() > 0 ? this.getReadTimeout() : null, longBuffer);

    // Graph result is always set
    payload[payloadKeys.results] = defaultOptions.graphResults === this.getGraphSubProtocol()
      ? defaultOptions.customPayload[payloadKeys.results] : utils$7.allocBufferFromString(this.getGraphSubProtocol());

    this.setCustomPayload(payload);
  }
};

var options = {
  GraphExecutionOptions: GraphExecutionOptions$1,
  graphProtocol: graphProtocol$1,
  payloadKeys
};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const utils$6 = utils$K;
const policies = requirePolicies();
const GraphResultSet = resultSet;
const { GraphSON2Reader, GraphSON2Writer, GraphSON3Reader, GraphSON3Writer } = graphSerializer;
const getCustomTypeSerializers = customTypeSerializers;
const { GraphExecutionOptions, graphProtocol } = options;

const graphLanguageGroovyString = 'gremlin-groovy';
const graphEngineCore = 'Core';

const graphSON2Reader = new GraphSON2Reader({ serializers: getCustomTypeSerializers() });
const graphSON2Writer = new GraphSON2Writer({ serializers: getCustomTypeSerializers() });
const graphSON3Reader = new GraphSON3Reader({ serializers: getCustomTypeSerializers() });
const graphSON3Writer = new GraphSON3Writer({ serializers: getCustomTypeSerializers() });

const rowParsers = new Map([
  [ graphProtocol.graphson2, getRowParser(graphSON2Reader) ],
  [ graphProtocol.graphson3, getRowParser(graphSON3Reader) ]
]);

const defaultWriters = new Map([
  [ graphProtocol.graphson1, x => JSON.stringify(x) ],
  [ graphProtocol.graphson2, getDefaultWriter(graphSON2Writer) ],
  [ graphProtocol.graphson3, getDefaultWriter(graphSON3Writer) ]
]);

/**
 * Internal class that contains the logic for executing a graph traversal.
 * @ignore
 */
let GraphExecutor$1 = class GraphExecutor {

  /**
   * Creates a new instance of GraphExecutor.
   * @param {Client} client
   * @param {ClientOptions} rawOptions
   * @param {Function} handler
   */
  constructor(client, rawOptions, handler) {
    this._client = client;
    this._handler = handler;

    // Retrieve the retry policy for the default profile to determine if it was specified
    this._defaultProfileRetryPolicy = client.profileManager.getDefaultConfiguredRetryPolicy();

    // Use graphBaseOptions as a way to gather all defaults that affect graph executions
    this._graphBaseOptions = utils$6.extend({
      executeAs: client.options.queryOptions.executeAs,
      language: graphLanguageGroovyString,
      source: 'g',
      readTimeout: 0,
      // As the default retry policy might retry non-idempotent queries
      // we should use default retry policy for all graph queries that does not retry
      retry: new policies.retry.FallthroughRetryPolicy()
    }, rawOptions.graphOptions, client.profileManager.getDefault().graphOptions);

    if (this._graphBaseOptions.readTimeout === null) {
      this._graphBaseOptions.readTimeout = client.options.socketOptions.readTimeout;
    }
  }

  /**
   * Executes the graph traversal.
   * @param {String|Object} query
   * @param {Object} parameters
   * @param {GraphQueryOptions} options
   */
  async send(query, parameters, options) {
    if (Array.isArray(parameters)) {
      throw new TypeError('Parameters must be a Object instance as an associative array');
    }

    if (!query) {
      throw new TypeError('Query must be defined');
    }

    const execOptions = new GraphExecutionOptions(
      options, this._client, this._graphBaseOptions, this._defaultProfileRetryPolicy);

    if (execOptions.getGraphSource() === 'a') {
      const host = await this._getAnalyticsMaster();
      execOptions.setPreferredHost(host);
    }

    // A query object that allows to plugin any executable thing
    const isQueryObject = typeof query === 'object' && query.graphLanguage && query.value && query.queryWriterFactory;

    if (isQueryObject) {
      // Use the provided graph language to override the current
      execOptions.setGraphLanguage(query.graphLanguage);
    }

    this._setGraphProtocol(execOptions);
    execOptions.setGraphPayload();
    parameters = GraphExecutor._buildGraphParameters(parameters, execOptions.getGraphSubProtocol());

    if (typeof query !== 'string') {
      // Its a traversal that needs to be converted
      // Transforming the provided query into a traversal requires the protocol to be set first.
      // Query writer factory can be defined in the options or in the query object
      let queryWriter = execOptions.getQueryWriter();

      if (isQueryObject) {
        queryWriter = query.queryWriterFactory(execOptions.getGraphSubProtocol());
      } else if (!queryWriter) {
        queryWriter = GraphExecutor._writerFactory(execOptions.getGraphSubProtocol());
      }

      query = queryWriter(!isQueryObject ? query : query.value);
    }

    return await this._executeGraphQuery(query, parameters, execOptions);
  }

  /**
   * Sends the graph traversal.
   * @param {string} query
   * @param {object} parameters
   * @param {GraphExecutionOptions} execOptions
   * @returns {Promise<GraphResultSet>}
   * @private
   */
  async _executeGraphQuery(query, parameters, execOptions) {
    const result = await this._handler.call(this._client, query, parameters, execOptions);

    // Instances of rowParser transform Row instances into Traverser instances.
    // Traverser instance is an object with the following form { object: any, bulk: number }
    const rowParser = execOptions.getRowParser() || GraphExecutor._rowParserFactory(execOptions.getGraphSubProtocol());

    return new GraphResultSet(result, rowParser);
  }

  /**
   * Uses the RPC call to obtain the analytics master host.
   * @returns {Promise<Host|null>}
   * @private
   */
  async _getAnalyticsMaster() {
    try {
      const result = await this._client.execute('CALL DseClientTool.getAnalyticsGraphServer()', utils$6.emptyArray);

      if (result.rows.length === 0) {
        this._client.log('verbose',
          'Empty response querying graph analytics server, query will not be routed optimally');
        return null;
      }

      const resultField = result.rows[0]['result'];
      if (!resultField || !resultField['location']) {
        this._client.log('verbose',
          'Unexpected response querying graph analytics server, query will not be routed optimally',
          result.rows[0]);
        return null;
      }

      const hostName = resultField['location'].substr(0, resultField['location'].lastIndexOf(':'));
      const addressTranslator = this._client.options.policies.addressResolution;

      return await new Promise(resolve => {
        addressTranslator.translate(hostName, this._client.options.protocolOptions.port, (endpoint) =>
          resolve(this._client.hosts.get(endpoint)));
      });
    } catch (err) {
      this._client.log('verbose', 'Error querying graph analytics server, query will not be routed optimally', err);
      return null;
    }
  }

  /**
   * Resolves what protocol should be used for decoding graph results for the given execution.
   *
   * <p>Resolution is done in the following manner if graphResults is not set:</p>
   *
   * <ul>
   *   <li>If graph name is set, and associated keyspace's graph engine is set to "Core", use {@link
    *       graphProtocol#graphson3}.
   *   <li>Else, if the graph language is not 'gremlin-groovy', use {@link graphProtocol#graphson2}
   *   <li>Otherwise, use {@link graphProtocol#graphson1}
   * </ul>
   * @param {GraphExecutionOptions} execOptions
   */
  _setGraphProtocol(execOptions) {
    let protocol = execOptions.getGraphSubProtocol();

    if (protocol) {
      return;
    }

    if (execOptions.getGraphName()) {
      const keyspace = this._client.metadata.keyspaces[execOptions.getGraphName()];
      if (keyspace && keyspace.graphEngine === graphEngineCore) {
        protocol = graphProtocol.graphson3;
      }
    }

    if (!protocol) {
      // Decide the minimal version supported by the graph language
      if (execOptions.getGraphLanguage() === graphLanguageGroovyString) {
        protocol = graphProtocol.graphson1;
      } else {
        protocol = graphProtocol.graphson2;
      }
    }

    execOptions.setGraphSubProtocol(protocol);
  }

  /**
   * Only GraphSON1 parameters are supported.
   * @param {Array|function|null} parameters
   * @param {string} protocol
   * @returns {string[]|null}
   * @private
   */
  static _buildGraphParameters(parameters, protocol) {
    if (!parameters || typeof parameters !== 'object') {
      return null;
    }

    const queryWriter = GraphExecutor._writerFactory(protocol);

    return [
      (protocol !== graphProtocol.graphson1 && protocol !== graphProtocol.graphson2)
        ? queryWriter(new Map(Object.entries(parameters)))
        : queryWriter(parameters)
    ];
  }

  static _rowParserFactory(protocol) {
    const handler = rowParsers.get(protocol);

    if (!handler) {
      // Default to no row parser
      return null;
    }

    return handler;
  }

  static _writerFactory(protocol) {
    const handler = defaultWriters.get(protocol);

    if (!handler) {
      throw new Error(`No writer defined for protocol ${protocol}`);
    }

    return handler;
  }
};

function getRowParser(reader) {
  return row => {
    const item = reader.read(JSON.parse(row['gremlin']));
    return { object: item['result'], bulk: item['bulk'] || 1 };
  };
}

function getDefaultWriter(writer) {
  return value => writer.write(value);
}

var graphExecutor = GraphExecutor$1;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const events = require$$0;
const util$1 = require$$0$4;

const utils$5 = utils$K;
const errors$3 = errors$n;
const types$2 = requireTypes();
const { ProfileManager } = executionProfile;
const requests = requests$7;
const clientOptions$1 = requireClientOptions();
const ClientState = clientState;
const description = require$$17.description;
const { version } = require$$17;
const { DefaultExecutionOptions } = executionOptions;
const ControlConnection = controlConnection;
const RequestHandler = requestHandler;
const PrepareHandler = prepareHandler;
const InsightsClient = insightsClient;
const cloud = cloud$1;
const GraphExecutor = graphExecutor;
const promiseUtils = promiseUtils$e;

/**
 * Max amount of pools being warmup in parallel, when warmup is enabled
 * @private
 */
const warmupLimit = 32;

/**
 * Client options.
 * <p>While the driver provides lots of extensibility points and configurability, few client options are required.</p>
 * <p>Default values for all settings are designed to be suitable for the majority of use cases, you should avoid
 * fine tuning it when not needed.</p>
 * <p>See [Client constructor]{@link Client} documentation for recommended options.</p>
 * @typedef {Object} ClientOptions
 * @property {Array.<string>} contactPoints
 * Array of addresses or host names of the nodes to add as contact points.
 * <p>
 *  Contact points are addresses of Cassandra nodes that the driver uses to discover the cluster topology.
 * </p>
 * <p>
 *  Only one contact point is required (the driver will retrieve the address of the other nodes automatically),
 *  but it is usually a good idea to provide more than one contact point, because if that single contact point is
 *  unavailable, the driver will not be able to initialize correctly.
 * </p>
 * @property {String} [localDataCenter] The local data center to use.
 * <p>
 *   If using DCAwareRoundRobinPolicy (default), this option is required and only hosts from this data center are
 *   connected to and used in query plans.
 * </p>
 * @property {String} [keyspace] The logged keyspace for all the connections created within the {@link Client} instance.
 * @property {Object} [credentials] An object containing the username and password for plain-text authentication.
 * It configures the authentication provider to be used against Apache Cassandra's PasswordAuthenticator or DSE's
 * DseAuthenticator, when default auth scheme is plain-text.
 * <p>
 *   Note that you should configure either <code>credentials</code> or <code>authProvider</code> to connect to an
 *   auth-enabled cluster, but not both.
 * </p>
 * @property {String} [credentials.username] The username to use for plain-text authentication.
 * @property {String} [credentials.password] The password to use for plain-text authentication.
 * @property {Uuid} [id] A unique identifier assigned to a {@link Client} object, that will be communicated to the
 * server (DSE 6.0+) to identify the client instance created with this options. When not defined, the driver will
 * generate a random identifier.
 * @property {String} [applicationName] An optional setting identifying the name of the application using
 * the {@link Client} instance.
 * <p>This value is passed to DSE and is useful as metadata for describing a client connection on the server side.</p>
 * @property {String} [applicationVersion] An optional setting identifying the version of the application using
 * the {@link Client} instance.
 * <p>This value is passed to DSE and is useful as metadata for describing a client connection on the server side.</p>
 * @property {Object} [monitorReporting] Options for reporting mechanism from the client to the DSE server, for
 * versions that support it.
 * @property {Boolean} [monitorReporting.enabled=true] Determines whether the reporting mechanism is enabled.
 * Defaults to <code>true</code>.
 * @property {Object} [cloud] The options to connect to a cloud instance.
 * @property {String|URL} cloud.secureConnectBundle Determines the file path for the credentials file bundle.
 * @property {Number} [refreshSchemaDelay] The default window size in milliseconds used to debounce node list and schema
 * refresh metadata requests. Default: 1000.
 * @property {Boolean} [isMetadataSyncEnabled] Determines whether client-side schema metadata retrieval and update is
 * enabled.
 * <p>Setting this value to <code>false</code> will cause keyspace information not to be automatically loaded, affecting
 * replica calculation per token in the different keyspaces. When disabling metadata synchronization, use
 * [Metadata.refreshKeyspaces()]{@link module:metadata~Metadata#refreshKeyspaces} to keep keyspace information up to
 * date or token-awareness will not work correctly.</p>
 * Default: <code>true</code>.
 * @property {Boolean} [prepareOnAllHosts] Determines if the driver should prepare queries on all hosts in the cluster.
 * Default: <code>true</code>.
 * @property {Boolean} [rePrepareOnUp] Determines if the driver should re-prepare all cached prepared queries on a
 * host when it marks it back up.
 * Default: <code>true</code>.
 * @property {Number} [maxPrepared] Determines the maximum amount of different prepared queries before evicting items
 * from the internal cache. Reaching a high threshold hints that the queries are not being reused, like when
 * hard-coding parameter values inside the queries.
 * Default: <code>500</code>.
 * @property {Object} [policies]
 * @property {LoadBalancingPolicy} [policies.loadBalancing] The load balancing policy instance to be used to determine
 * the coordinator per query.
 * @property {RetryPolicy} [policies.retry] The retry policy.
 * @property {ReconnectionPolicy} [policies.reconnection] The reconnection policy to be used.
 * @property {AddressTranslator} [policies.addressResolution] The address resolution policy.
 * @property {SpeculativeExecutionPolicy} [policies.speculativeExecution] The <code>SpeculativeExecutionPolicy</code>
 * instance to be used to determine if the client should send speculative queries when the selected host takes more
 * time than expected.
 * <p>
 *   Default: <code>[NoSpeculativeExecutionPolicy]{@link
  *   module:policies/speculativeExecution~NoSpeculativeExecutionPolicy}</code>
 * </p>
 * @property {TimestampGenerator} [policies.timestampGeneration] The client-side
 * [query timestamp generator]{@link module:policies/timestampGeneration~TimestampGenerator}.
 * <p>
 *   Default: <code>[MonotonicTimestampGenerator]{@link module:policies/timestampGeneration~MonotonicTimestampGenerator}
 *   </code>
 * </p>
 * <p>Use <code>null</code> to disable client-side timestamp generation.</p>
 * @property {QueryOptions} [queryOptions] Default options for all queries.
 * @property {Object} [pooling] Pooling options.
 * @property {Number} [pooling.heartBeatInterval] The amount of idle time in milliseconds that has to pass before the
 * driver issues a request on an active connection to avoid idle time disconnections. Default: 30000.
 * @property {Object} [pooling.coreConnectionsPerHost] Associative array containing amount of connections per host
 * distance.
 * @property {Number} [pooling.maxRequestsPerConnection] The maximum number of requests per connection. The default
 * value is:
 * <ul>
 *   <li>For modern protocol versions (v3 and above): 2048</li>
 *   <li>For older protocol versions (v1 and v2): 128</li>
 * </ul>
 * @property {Boolean} [pooling.warmup] Determines if all connections to hosts in the local datacenter must be opened on
 * connect. Default: true.
 * @property {Object} [protocolOptions]
 * @property {Number} [protocolOptions.port] The port to use to connect to the Cassandra host. If not set through this
 * method, the default port (9042) will be used instead.
 * @property {Number} [protocolOptions.maxSchemaAgreementWaitSeconds] The maximum time in seconds to wait for schema
 * agreement between nodes before returning from a DDL query. Default: 10.
 * @property {Number} [protocolOptions.maxVersion] When set, it limits the maximum protocol version used to connect to
 * the nodes.
 * Useful for using the driver against a cluster that contains nodes with different major/minor versions of Cassandra.
 * @property {Boolean} [protocolOptions.noCompact] When set to true, enables the NO_COMPACT startup option.
 * <p>
 * When this option is supplied <code>SELECT</code>, <code>UPDATE</code>, <code>DELETE</code>, and <code>BATCH</code>
 * statements on <code>COMPACT STORAGE</code> tables function in "compatibility" mode which allows seeing these tables
 * as if they were "regular" CQL tables.
 * </p>
 * <p>
 * This option only effects interactions with interactions with tables using <code>COMPACT STORAGE</code> and is only
 * supported by C* 3.0.16+, 3.11.2+, 4.0+ and DSE 6.0+.
 * </p>
 * @property {Object} [socketOptions]
 * @property {Number} [socketOptions.connectTimeout] Connection timeout in milliseconds. Default: 5000.
 * @property {Number} [socketOptions.defunctReadTimeoutThreshold] Determines the amount of requests that simultaneously
 * have to timeout before closing the connection. Default: 64.
 * @property {Boolean} [socketOptions.keepAlive] Whether to enable TCP keep-alive on the socket. Default: true.
 * @property {Number} [socketOptions.keepAliveDelay] TCP keep-alive delay in milliseconds. Default: 0.
 * @property {Number} [socketOptions.readTimeout] Per-host read timeout in milliseconds.
 * <p>
 *   Please note that this is not the maximum time a call to {@link Client#execute} may have to wait;
 *   this is the maximum time that call will wait for one particular Cassandra host, but other hosts will be tried if
 *   one of them timeout. In other words, a {@link Client#execute} call may theoretically wait up to
 *   <code>readTimeout * number_of_cassandra_hosts</code> (though the total number of hosts tried for a given query also
 *   depends on the LoadBalancingPolicy in use).
 * <p>When setting this value, keep in mind the following:</p>
 * <ul>
 *   <li>the timeout settings used on the Cassandra side (*_request_timeout_in_ms in cassandra.yaml) should be taken
 *   into account when picking a value for this read timeout. You should pick a value a couple of seconds greater than
 *   the Cassandra timeout settings.
 *   </li>
 *   <li>
 *     the read timeout is only approximate and only control the timeout to one Cassandra host, not the full query.
 *   </li>
 * </ul>
 * Setting a value of 0 disables read timeouts. Default: <code>12000</code>.
 * @property {Boolean} [socketOptions.tcpNoDelay] When set to true, it disables the Nagle algorithm. Default: true.
 * @property {Number} [socketOptions.coalescingThreshold] Buffer length in bytes use by the write queue before flushing
 * the frames. Default: 8000.
 * @property {AuthProvider} [authProvider] Provider to be used to authenticate to an auth-enabled cluster.
 * @property {RequestTracker} [requestTracker] The instance of RequestTracker used to monitor or log requests executed
 * with this instance.
 * @property {Object} [sslOptions] Client-to-node ssl options. When set the driver will use the secure layer.
 * You can specify cert, ca, ... options named after the Node.js <code>tls.connect()</code> options.
 * <p>
 *   It uses the same default values as Node.js <code>tls.connect()</code> except for <code>rejectUnauthorized</code>
 *   which is set to <code>false</code> by default (for historical reasons). This setting is likely to change
 *   in upcoming versions to enable validation by default.
 * </p>
 * @property {Object} [encoding] Encoding options.
 * @property {Function} [encoding.map] Map constructor to use for Cassandra map<k,v> type encoding and decoding.
 * If not set, it will default to Javascript Object with map keys as property names.
 * @property {Function} [encoding.set] Set constructor to use for Cassandra set<k> type encoding and decoding.
 * If not set, it will default to Javascript Array.
 * @property {Boolean} [encoding.copyBuffer] Determines if the network buffer should be copied for buffer based data
 * types (blob, uuid, timeuuid and inet).
 * <p>
 *   Setting it to true will cause that the network buffer is copied for each row value of those types,
 *   causing additional allocations but freeing the network buffer to be reused.
 *   Setting it to true is a good choice for cases where the Row and ResultSet returned by the queries are long-lived
 *   objects.
 * </p>
 * <p>
 *  Setting it to false will cause less overhead and the reference of the network buffer to be maintained until the row
 *  / result set are de-referenced.
 *  Default: true.
 * </p>
 * @property {Boolean} [encoding.useUndefinedAsUnset] Valid for Cassandra 2.2 and above. Determines that, if a parameter
 * is set to
 * <code>undefined</code> it should be encoded as <code>unset</code>.
 * <p>
 *  By default, ECMAScript <code>undefined</code> is encoded as <code>null</code> in the driver. Cassandra 2.2
 *  introduced the concept of unset.
 *  At driver level, you can set a parameter to unset using the field <code>types.unset</code>. Setting this flag to
 *  true allows you to use ECMAScript undefined as Cassandra <code>unset</code>.
 * </p>
 * <p>
 *   Default: true.
 * </p>
 * @property {Boolean} [encoding.useBigIntAsLong] Use [BigInt ECMAScript type](https://tc39.github.io/proposal-bigint/)
 * to represent CQL bigint and counter data types.
 * @property {Boolean} [encoding.useBigIntAsVarint] Use [BigInt ECMAScript
 * type](https://tc39.github.io/proposal-bigint/) to represent CQL varint data type.
 * @property {Array.<ExecutionProfile>} [profiles] The array of [execution profiles]{@link ExecutionProfile}.
 * @property {Function} [promiseFactory] Function to be used to create a <code>Promise</code> from a
 * callback-style function.
 * <p>
 *   Promise libraries often provide different methods to create a promise. For example, you can use Bluebird's
 *   <code>Promise.fromCallback()</code> method.
 * </p>
 * <p>
 *   By default, the driver will use the
 *   [Promise constructor]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise}.
 * </p>
 */

/**
 * Query options
 * @typedef {Object} QueryOptions
 * @property {Boolean} [autoPage] Determines if the driver must retrieve the following result pages automatically.
 * <p>
 *   This setting is only considered by the [Client#eachRow()]{@link Client#eachRow} method. For more information,
 *   check the
 *   [paging results documentation]{@link https://docs.datastax.com/en/developer/nodejs-driver/latest/features/paging/}.
 * </p>
 * @property {Boolean} [captureStackTrace] Determines if the stack trace before the query execution should be
 * maintained.
 * <p>
 *   Useful for debugging purposes, it should be set to <code>false</code> under production environment as it adds an
 *   unnecessary overhead to each execution.
 * </p>
 * Default: false.
 * @property {Number} [consistency] [Consistency level]{@link module:types~consistencies}.
 * <p>
 *   Defaults to <code>localOne</code> for Apache Cassandra and DSE deployments.
 *   For DataStax Astra, it defaults to <code>localQuorum</code>.
 * </p>
 * @property {Object} [customPayload] Key-value payload to be passed to the server. On the Cassandra side,
 * implementations of QueryHandler can use this data.
 * @property {String} [executeAs] The user or role name to act as when executing this statement.
 * <p>When set, it executes as a different user/role than the one currently authenticated (a.k.a. proxy execution).</p>
 * <p>This feature is only available in DSE 5.1+.</p>
 * @property {String|ExecutionProfile} [executionProfile] Name or instance of the [profile]{@link ExecutionProfile} to
 * be used for this execution. If not set, it will the use "default" execution profile.
 * @property {Number} [fetchSize] Amount of rows to retrieve per page.
 * @property {Array|Array<Array>} [hints] Type hints for parameters given in the query, ordered as for the parameters.
 * <p>For batch queries, an array of such arrays, ordered as with the queries in the batch.</p>
 * @property {Host} [host] The host that should handle the query.
 * <p>
 *   Use of this option is <em>heavily discouraged</em> and should only be used in the following cases:
 * </p>
 * <ol>
 *   <li>
 *     Querying node-local tables, such as tables in the <code>system</code> and <code>system_views</code>
 *     keyspaces.
 *   </li>
 *   <li>
 *     Applying a series of schema changes, where it may be advantageous to execute schema changes in sequence on the
 *     same node.
 *   </li>
 * </ol>
 * <p>
 *   Configuring a specific host causes the configured
 *   [LoadBalancingPolicy]{@link module:policies/loadBalancing~LoadBalancingPolicy} to be completely bypassed.
 *   However, if the load balancing policy dictates that the host is at a
 *   [distance of ignored]{@link module:types~distance} or there is no active connectivity to the host, the request will
 *   fail with a [NoHostAvailableError]{@link module:errors~NoHostAvailableError}.
 * </p>
 * @property {Boolean} [isIdempotent] Defines whether the query can be applied multiple times without changing the result
 * beyond the initial application.
 * <p>
 *   The query execution idempotence can be used at [RetryPolicy]{@link module:policies/retry~RetryPolicy} level to
 *   determine if an statement can be retried in case of request error or write timeout.
 * </p>
 * <p>Default: <code>false</code>.</p>
 * @property {String} [keyspace] Specifies the keyspace for the query. It is used for the following:
 * <ol>
 * <li>To indicate what keyspace the statement is applicable to (protocol V5+ only).  This is useful when the
 * query does not provide an explicit keyspace and you want to override the current {@link Client#keyspace}.</li>
 * <li>For query routing when the query operates on a different keyspace than the current {@link Client#keyspace}.</li>
 * </ol>
 * @property {Boolean} [logged] Determines if the batch should be written to the batchlog. Only valid for
 * [Client#batch()]{@link Client#batch}, it will be ignored by other methods. Default: true.
 * @property {Boolean} [counter] Determines if its a counter batch. Only valid for
 * [Client#batch()]{@link Client#batch}, it will be ignored by other methods. Default: false.
 * @property {Buffer|String} [pageState] Buffer or string token representing the paging state.
 * <p>Useful for manual paging, if provided, the query will be executed starting from a given paging state.</p>
 * @property {Boolean} [prepare] Determines if the query must be executed as a prepared statement.
 * @property {Number} [readTimeout] When defined, it overrides the default read timeout
 * (<code>socketOptions.readTimeout</code>) in milliseconds for this execution per coordinator.
 * <p>
 *   Suitable for statements for which the coordinator may allow a longer server-side timeout, for example aggregation
 *   queries.
 * </p>
 * <p>
 *   A value of <code>0</code> disables client side read timeout for the execution. Default: <code>undefined</code>.
 * </p>
 * @property {RetryPolicy} [retry] Retry policy for the query.
 * <p>
 *   This property can be used to specify a different [retry policy]{@link module:policies/retry} to the one specified
 *   in the {@link ClientOptions}.policies.
 * </p>
 * @property {Array} [routingIndexes] Index of the parameters that are part of the partition key to determine
 * the routing.
 * @property {Buffer|Array} [routingKey] Partition key(s) to determine which coordinator should be used for the query.
 * @property {Array} [routingNames] Array of the parameters names that are part of the partition key to determine the
 * routing. Only valid for non-prepared requests, it's recommended that you use the prepare flag instead.
 * @property {Number} [serialConsistency] Serial consistency is the consistency level for the serial phase of
 * conditional updates.
 * This option will be ignored for anything else that a conditional update/insert.
 * @property {Number|Long} [timestamp] The default timestamp for the query in microseconds from the unix epoch
 * (00:00:00, January 1st, 1970).
 * <p>If provided, this will replace the server side assigned timestamp as default timestamp.</p>
 * <p>Use [generateTimestamp()]{@link module:types~generateTimestamp} utility method to generate a valid timestamp
 * based on a Date and microseconds parts.</p>
 * @property {Boolean} [traceQuery] Enable query tracing for the execution. Use query tracing to diagnose performance
 * problems related to query executions. Default: false.
 * <p>To retrieve trace, you can call [Metadata.getTrace()]{@link module:metadata~Metadata#getTrace} method.</p>
 * @property {Object} [graphOptions] Default options for graph query executions.
 * <p>
 *   These options are meant to provide defaults for all graph query executions. Consider using
 *   [execution profiles]{@link ExecutionProfile} if you plan to reuse different set of options across different
 *   query executions.
 * </p>
 * @property {String} [graphOptions.language] The graph language to use in graph queries. Default:
 * <code>'gremlin-groovy'</code>.
 * @property {String} [graphOptions.name] The graph name to be used in all graph queries.
 * <p>
 * This property is required but there is no default value for it. This value can be overridden at query level.
 * </p>
 * @property {Number} [graphOptions.readConsistency] Overrides the
 * [consistency level]{@link module:types~consistencies}
 * defined in the query options for graph read queries.
 * @property {Number} [graphOptions.readTimeout] Overrides the default per-host read timeout (in milliseconds) for all
 * graph queries. Default: <code>0</code>.
 * <p>
 *   Use <code>null</code> to reset the value and use the default on <code>socketOptions.readTimeout</code> .
 * </p>
 * @property {String} [graphOptions.source] The graph traversal source name to use in graph queries. Default:
 * <code>'g'</code>.
 * @property {Number} [graphOptions.writeConsistency] Overrides the [consistency
 * level]{@link module:types~consistencies} defined in the query options for graph write queries.
 */

/**
 * Creates a new instance of {@link Client}.
 * @classdesc
 * Represents a database client that maintains multiple connections to the cluster nodes, providing methods to
 * execute CQL statements.
 * <p>
 * The <code>Client</code> uses [policies]{@link module:policies} to decide which nodes to connect to, which node
 * to use per each query execution, when it should retry failed or timed-out executions and how reconnection to down
 * nodes should be made.
 * </p>
 * @extends EventEmitter
 * @param {ClientOptions} options The options for this instance.
 * @example <caption>Creating a new client instance</caption>
 * const client = new Client({
 *   contactPoints: ['10.0.1.101', '10.0.1.102'],
 *   localDataCenter: 'datacenter1'
 * });
 * @example <caption>Executing a query</caption>
 * const result = await client.connect();
 * console.log(`Connected to ${client.hosts.length} nodes in the cluster: ${client.hosts.keys().join(', ')}`);
 * @example <caption>Executing a query</caption>
 * const result = await client.execute('SELECT key FROM system.local');
 * const row = result.first();
 * console.log(row['key']);
 * @constructor
 */
function Client(options) {
  events.EventEmitter.call(this);
  this.options = clientOptions$1.extend({ logEmitter: this.emit.bind(this), id: types$2.Uuid.random() }, options);
  Object.defineProperty(this, 'profileManager', { value: new ProfileManager(this.options) });
  Object.defineProperty(this, 'controlConnection', {
    value: new ControlConnection(this.options, this.profileManager), writable: true }
  );
  Object.defineProperty(this, 'insightsClient', { value: new InsightsClient(this)});

  //Unlimited amount of listeners for internal event queues by default
  this.setMaxListeners(0);
  this.connected = false;
  this.isShuttingDown = false;
  /**
   * Gets the name of the active keyspace.
   * @type {String}
   */
  this.keyspace = options.keyspace;
  /**
   * Gets the schema and cluster metadata information.
   * @type {Metadata}
   */
  this.metadata = this.controlConnection.metadata;
  /**
   * Gets an associative array of cluster hosts.
   * @type {HostMap}
   */
  this.hosts = this.controlConnection.hosts;

  /**
   * The [ClientMetrics]{@link module:metrics~ClientMetrics} instance used to expose measurements of its internal
   * behavior and of the server as seen from the driver side.
   * <p>By default, a [DefaultMetrics]{@link module:metrics~DefaultMetrics} instance is used.</p>
   * @type {ClientMetrics}
   */
  this.metrics = this.options.metrics;

  this._graphExecutor = new GraphExecutor(this, options, this._execute);
}

util$1.inherits(Client, events.EventEmitter);

/**
 * Emitted when a new host is added to the cluster.
 * <ul>
 *   <li>{@link Host} The host being added.</li>
 * </ul>
 * @event Client#hostAdd
 */
/**
 * Emitted when a host is removed from the cluster
 * <ul>
 *   <li>{@link Host} The host being removed.</li>
 * </ul>
 * @event Client#hostRemove
 */
/**
 * Emitted when a host in the cluster changed status from down to up.
 * <ul>
 *   <li>{@link Host host} The host that changed the status.</li>
 * </ul>
 * @event Client#hostUp
 */
/**
 * Emitted when a host in the cluster changed status from up to down.
 * <ul>
 *   <li>{@link Host host} The host that changed the status.</li>
 * </ul>
 * @event Client#hostDown
 */

/**
 * Attempts to connect to one of the [contactPoints]{@link ClientOptions} and discovers the rest the nodes of the
 * cluster.
 * <p>When the {@link Client} is already connected, it resolves immediately.</p>
 * <p>It returns a <code>Promise</code> when a <code>callback</code> is not provided.</p>
 * @param {function} [callback] The optional callback that is invoked when the pool is connected or it failed to
 * connect.
 * @example <caption>Usage example</caption>
 * await client.connect();
 */
Client.prototype.connect = function (callback) {
  if (this.connected && callback) {
    // Avoid creating Promise to immediately resolve them
    return callback();
  }

  return promiseUtils.optionalCallback(this._connect(), callback);
};

/**
 * Async-only version of {@link Client#connect()}.
 * @private
 */
Client.prototype._connect = async function () {
  if (this.connected) {
    return;
  }

  if (this.isShuttingDown) {
    //it is being shutdown, don't allow further calls to connect()
    throw new errors$3.NoHostAvailableError(null, 'Connecting after shutdown is not supported');
  }

  if (this.connecting) {
    return promiseUtils.fromEvent(this, 'connected');
  }

  this.connecting = true;
  this.log('info', util$1.format("Connecting to cluster using '%s' version %s", description, version));

  try {
    await cloud.init(this.options);
    await this.controlConnection.init();
    this.hosts = this.controlConnection.hosts;
    await this.profileManager.init(this, this.hosts);

    if (this.keyspace) {
      await RequestHandler.setKeyspace(this);
    }

    clientOptions$1.setMetadataDependent(this);

    await this._warmup();

  } catch (err) {
    // We should close the pools (if any) and reset the state to allow successive calls to connect()
    await this.controlConnection.reset();
    this.connected = false;
    this.connecting = false;
    this.emit('connected', err);
    throw err;
  }

  this._setHostListeners();

  // Set the distance of the control connection host relatively to this instance
  this.profileManager.getDistance(this.controlConnection.host);
  this.insightsClient.init();
  this.connected = true;
  this.connecting = false;
  this.emit('connected');
};

/**
 * Executes a query on an available connection.
 * <p>The query can be prepared (recommended) or not depending on the [prepare]{@linkcode QueryOptions} flag.</p>
 * <p>
 *   Some execution failures can be handled transparently by the driver, according to the
 *   [RetryPolicy]{@linkcode module:policies/retry~RetryPolicy} or the
 *   [SpeculativeExecutionPolicy]{@linkcode module:policies/speculativeExecution} used.
 * </p>
 * <p>It returns a <code>Promise</code> when a <code>callback</code> is not provided.</p>
 * @param {String} query The query to execute.
 * @param {Array|Object} [params] Array of parameter values or an associative array (object) containing parameter names
 * as keys and its value.
 * @param {QueryOptions} [options] The query options for the execution.
 * @param {ResultCallback} [callback] Executes callback(err, result) when execution completed. When not defined, the
 * method will return a promise.
 * @example <caption>Promise-based API, using async/await</caption>
 * const query = 'SELECT name, email FROM users WHERE id = ?';
 * const result = await client.execute(query, [ id ], { prepare: true });
 * const row = result.first();
 * console.log('%s: %s', row['name'], row['email']);
 * @example <caption>Callback-based API</caption>
 * const query = 'SELECT name, email FROM users WHERE id = ?';
 * client.execute(query, [ id ], { prepare: true }, function (err, result) {
 *   assert.ifError(err);
 *   const row = result.first();
 *   console.log('%s: %s', row['name'], row['email']);
 * });
 * @see {@link ExecutionProfile} to reuse a set of options across different query executions.
 */
Client.prototype.execute = function (query, params, options, callback) {
  // This method acts as a wrapper for the async method _execute()

  if (!callback) {
    // Set default argument values for optional parameters
    if (typeof options === 'function') {
      callback = options;
      options = null;
    } else if (typeof params === 'function') {
      callback = params;
      params = null;
    }
  }

  try {
    const execOptions = DefaultExecutionOptions.create(options, this);
    return promiseUtils.optionalCallback(this._execute(query, params, execOptions), callback);
  }
  catch (err) {
    // There was an error when parsing the user options
    if (callback) {
      return callback(err);
    }

    return Promise.reject(err);
  }
};

/**
 * Executes a graph query.
 * <p>It returns a <code>Promise</code> when a <code>callback</code> is not provided.</p>
 * @param {String} query The gremlin query.
 * @param {Object|null} [parameters] An associative array containing the key and values of the parameters.
 * @param {GraphQueryOptions|null} [options] The graph query options.
 * @param {Function} [callback] Function to execute when the response is retrieved, taking two arguments:
 * <code>err</code> and <code>result</code>. When not defined, the method will return a promise.
 * @example <caption>Promise-based API, using async/await</caption>
 * const result = await client.executeGraph('g.V()');
 * // Get the first item (vertex, edge, scalar value, ...)
 * const vertex = result.first();
 * console.log(vertex.label);
 * @example <caption>Callback-based API</caption>
 * client.executeGraph('g.V()', (err, result) => {
 *   const vertex = result.first();
 *   console.log(vertex.label);
 * });
 * @example <caption>Iterating through the results</caption>
 * const result = await client.executeGraph('g.E()');
 * for (let edge of result) {
 *   console.log(edge.label); // created
 * });
 * @example <caption>Using result.forEach()</caption>
 * const result = await client.executeGraph('g.V().hasLabel("person")');
 * result.forEach(function(vertex) {
 *   console.log(vertex.type); // vertex
 *   console.log(vertex.label); // person
 * });
 * @see {@link ExecutionProfile} to reuse a set of options across different query executions.
 */
Client.prototype.executeGraph = function (query, parameters, options, callback) {
  callback = callback || (options ? options : parameters);

  if (typeof callback === 'function') {
    parameters = typeof parameters !== 'function' ? parameters : null;
    return promiseUtils.toCallback(this._graphExecutor.send(query, parameters, options), callback);
  }

  return this._graphExecutor.send(query, parameters, options);
};

/**
 * Executes the query and calls <code>rowCallback</code> for each row as soon as they are received. Calls the final
 * <code>callback</code> after all rows have been sent, or when there is an error.
 * <p>
 *   The query can be prepared (recommended) or not depending on the [prepare]{@linkcode QueryOptions} flag.
 * </p>
 * @param {String} query The query to execute
 * @param {Array|Object} [params] Array of parameter values or an associative array (object) containing parameter names
 * as keys and its value.
 * @param {QueryOptions} [options] The query options.
 * @param {function} rowCallback Executes <code>rowCallback(n, row)</code> per each row received, where n is the row
 * index and row is the current Row.
 * @param {function} [callback] Executes <code>callback(err, result)</code> after all rows have been received.
 * <p>
 *   When dealing with paged results, [ResultSet#nextPage()]{@link module:types~ResultSet#nextPage} method can be used
 *   to retrieve the following page. In that case, <code>rowCallback()</code> will be again called for each row and
 *   the final callback will be invoked when all rows in the following page has been retrieved.
 * </p>
 * @example <caption>Using per-row callback and arrow functions</caption>
 * client.eachRow(query, params, { prepare: true }, (n, row) => console.log(n, row), err => console.error(err));
 * @example <caption>Overloads</caption>
 * client.eachRow(query, rowCallback);
 * client.eachRow(query, params, rowCallback);
 * client.eachRow(query, params, options, rowCallback);
 * client.eachRow(query, params, rowCallback, callback);
 * client.eachRow(query, params, options, rowCallback, callback);
 */
Client.prototype.eachRow = function (query, params, options, rowCallback, callback) {
  if (!callback && rowCallback && typeof options === 'function') {
    callback = utils$5.validateFn(rowCallback, 'rowCallback');
    rowCallback = options;
  } else {
    callback = callback || utils$5.noop;
    rowCallback = utils$5.validateFn(rowCallback || options || params, 'rowCallback');
  }

  params = typeof params !== 'function' ? params : null;

  let execOptions;
  try {
    execOptions = DefaultExecutionOptions.create(options, this, rowCallback);
  }
  catch (e) {
    return callback(e);
  }

  let rowLength = 0;

  const nextPage = () => promiseUtils.toCallback(this._execute(query, params, execOptions), pageCallback);

  function pageCallback (err, result) {
    if (err) {
      return callback(err);
    }
    // Next requests in case paging (auto or explicit) is used
    rowLength += result.rowLength;

    if (result.rawPageState !== undefined) {
      // Use new page state as next request page state
      execOptions.setPageState(result.rawPageState);
      if (execOptions.isAutoPage()) {
        // Issue next request for the next page
        return nextPage();
      }
      // Allows for explicit (manual) paging, in case the caller needs it
      result.nextPage = nextPage;
    }

    // Finished auto-paging
    result.rowLength = rowLength;
    callback(null, result);
  }

  promiseUtils.toCallback(this._execute(query, params, execOptions), pageCallback);
};

/**
 * Executes the query and pushes the rows to the result stream as soon as they received.
 * <p>
 * The stream is a [ReadableStream]{@linkcode https://nodejs.org/api/stream.html#stream_class_stream_readable} object
 *  that emits rows.
 *  It can be piped downstream and provides automatic pause/resume logic (it buffers when not read).
 * </p>
 * <p>
 *   The query can be prepared (recommended) or not depending on {@link QueryOptions}.prepare flag. Retries on multiple
 *   hosts if needed.
 * </p>
 * @param {String} query The query to prepare and execute.
 * @param {Array|Object} [params] Array of parameter values or an associative array (object) containing parameter names
 * as keys and its value
 * @param {QueryOptions} [options] The query options.
 * @param {function} [callback] executes callback(err) after all rows have been received or if there is an error
 * @returns {ResultStream}
 */
Client.prototype.stream = function (query, params, options, callback) {
  callback = callback || utils$5.noop;
  // NOTE: the nodejs stream maintains yet another internal buffer
  // we rely on the default stream implementation to keep memory
  // usage reasonable.
  const resultStream = new types$2.ResultStream({ objectMode: 1 });
  function onFinish(err, result) {
    if (err) {
      resultStream.emit('error', err);
    }
    if (result && result.nextPage ) {
      // allows for throttling as per the
      // default nodejs stream implementation
      resultStream._valve(function pageValve() {
        try {
          result.nextPage();
        }
        catch( ex ) {
          resultStream.emit('error', ex );
        }
      });
      return;
    }
    // Explicitly dropping the valve (closure)
    resultStream._valve(null);
    resultStream.add(null);
    callback(err);
  }
  let sync = true;
  this.eachRow(query, params, options, function rowCallback(n, row) {
    resultStream.add(row);
  }, function eachRowFinished(err, result) {
    if (sync) {
      // Prevent sync callback
      return setImmediate(function eachRowFinishedImmediate() {
        onFinish(err, result);
      });
    }
    onFinish(err, result);
  });
  sync = false;
  return resultStream;
};

/**
 * Executes batch of queries on an available connection to a host.
 * <p>It returns a <code>Promise</code> when a <code>callback</code> is not provided.</p>
 * @param {Array.<string>|Array.<{query, params}>} queries The queries to execute as an Array of strings or as an array
 * of object containing the query and params
 * @param {QueryOptions} [options] The query options.
 * @param {ResultCallback} [callback] Executes callback(err, result) when the batch was executed
 */
Client.prototype.batch = function (queries, options, callback) {
  if (!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }

  return promiseUtils.optionalCallback(this._batch(queries, options), callback);
};

/**
 * Async-only version of {@link Client#batch()} .
 * @param {Array.<string>|Array.<{query, params}>}queries
 * @param {QueryOptions} options
 * @returns {Promise<ResultSet>}
 * @private
 */
Client.prototype._batch = async function (queries, options) {
  if (!Array.isArray(queries)) {
    throw new errors$3.ArgumentError('Queries should be an Array');
  }

  if (queries.length === 0) {
    throw new errors$3.ArgumentError('Queries array should not be empty');
  }

  await this._connect();

  const execOptions = DefaultExecutionOptions.create(options, this);
  let queryItems;

  if (execOptions.isPrepared()) {
    // use keyspace from query options if protocol supports per-query keyspace, otherwise use connection keyspace.
    const version = this.controlConnection.protocolVersion;
    const queryKeyspace = types$2.protocolVersion.supportsKeyspaceInRequest(version) && options.keyspace || this.keyspace;
    queryItems = await PrepareHandler.getPreparedMultiple(
      this, execOptions.getLoadBalancingPolicy(), queries, queryKeyspace);
  } else {
    queryItems = new Array(queries.length);

    for (let i = 0; i < queries.length; i++) {
      const item = queries[i];
      if (!item) {
        throw new errors$3.ArgumentError(`Invalid query at index ${i}`);
      }

      const query = typeof item === 'string' ? item : item.query;
      if (!query) {
        throw new errors$3.ArgumentError(`Invalid query at index ${i}`);
      }

      queryItems[i] = { query, params: item.params };
    }
  }

  const request = await this._createBatchRequest(queryItems, execOptions);
  return await RequestHandler.send(request, execOptions, this);
};

/**
 * Gets the host that are replicas of a given token.
 * @param {String} keyspace
 * @param {Buffer} token
 * @returns {Array<Host>}
 */
Client.prototype.getReplicas = function (keyspace, token) {
  return this.metadata.getReplicas(keyspace, token);
};

/**
 * Gets a snapshot containing information on the connections pools held by this Client at the current time.
 * <p>
 *   The information provided in the returned object only represents the state at the moment this method was called and
 *   it's not maintained in sync with the driver metadata.
 * </p>
 * @returns {ClientState} A [ClientState]{@linkcode module:metadata~ClientState} instance.
 */
Client.prototype.getState = function () {
  return ClientState.from(this);
};

Client.prototype.log = utils$5.log;

/**
 * Closes all connections to all hosts.
 * <p>It returns a <code>Promise</code> when a <code>callback</code> is not provided.</p>
 * @param {Function} [callback] Optional callback to be invoked when finished closing all connections.
 */
Client.prototype.shutdown = function (callback) {
  return promiseUtils.optionalCallback(this._shutdown(), callback);
};

/** @private */
Client.prototype._shutdown = async function () {
  this.log('info', 'Shutting down');

  if (!this.hosts || !this.connected) {
    // not initialized
    this.connected = false;
    return;
  }

  if (this.connecting) {
    this.log('warning', 'Shutting down while connecting');
    // wait until finish connecting for easier troubleshooting
    await promiseUtils.fromEvent(this, 'connected');
  }

  this.connected = false;
  this.isShuttingDown = true;
  const hosts = this.hosts.values();

  this.insightsClient.shutdown();

  // Shutdown the ControlConnection before shutting down the pools
  this.controlConnection.shutdown();
  this.options.policies.speculativeExecution.shutdown();

  if (this.options.requestTracker) {
    this.options.requestTracker.shutdown();
  }

  // go through all the host and shut down their pools
  await Promise.all(hosts.map(h => h.shutdown(false)));
};

/**
 * Waits until that the schema version in all nodes is the same or the waiting time passed.
 * @param {Connection} connection
 * @returns {Promise<boolean>}
 * @ignore
 */
Client.prototype._waitForSchemaAgreement = async function (connection) {
  if (this.hosts.length === 1) {
    return true;
  }

  const start = process.hrtime();
  const maxWaitSeconds = this.options.protocolOptions.maxSchemaAgreementWaitSeconds;

  this.log('info', 'Waiting for schema agreement');

  let versionsMatch;

  while (!versionsMatch && process.hrtime(start)[0] < maxWaitSeconds) {
    versionsMatch = await this.metadata.compareSchemaVersions(connection);

    if (versionsMatch) {
      this.log('info', 'Schema versions match');
      break;
    }

    // Let some time pass before the next check
    await promiseUtils.delay(500);
  }

  return versionsMatch;
};

/**
 * Waits for schema agreements and schedules schema metadata refresh.
 * @param {Connection} connection
 * @param event
 * @returns {Promise<boolean>}
 * @ignore
 * @internal
 */
Client.prototype.handleSchemaAgreementAndRefresh = async function (connection, event) {
  let agreement = false;

  try {
    agreement = await this._waitForSchemaAgreement(connection);
  } catch (err) {
    //we issue a warning but we continue with the normal flow
    this.log('warning', 'There was an error while waiting for the schema agreement between nodes', err);
  }

  if (!this.options.isMetadataSyncEnabled) {
    return agreement;
  }

  // Refresh metadata immediately
  try {
    await this.controlConnection.handleSchemaChange(event, true);
  } catch (err) {
    this.log('warning', 'There was an error while handling schema change', err);
  }

  return agreement;
};

/**
 * Connects and handles the execution of prepared and simple statements.
 * @param {string} query
 * @param {Array} params
 * @param {ExecutionOptions} execOptions
 * @returns {Promise<ResultSet>}
 * @private
 */
Client.prototype._execute = async function (query, params, execOptions) {
  const version = this.controlConnection.protocolVersion;

  if (!execOptions.isPrepared() && params && !Array.isArray(params) &&
    !types$2.protocolVersion.supportsNamedParameters(version)) {
    // Only Cassandra 2.1 and above supports named parameters
    throw new errors$3.ArgumentError('Named parameters for simple statements are not supported, use prepare flag');
  }

  let request;

  if (!this.connected) {
    // Micro optimization to avoid an async execution for a simple check
    await this._connect();
  }

  if (!execOptions.isPrepared()) {
    request = await this._createQueryRequest(query, execOptions, params);
  } else {
    const lbp = execOptions.getLoadBalancingPolicy();

    // Use keyspace from query options if protocol supports per-query keyspace, otherwise use connection keyspace.
    const queryKeyspace = types$2.protocolVersion.supportsKeyspaceInRequest(version) &&
      execOptions.getKeyspace() || this.keyspace;

    const { queryId, meta } = await PrepareHandler.getPrepared(this, lbp, query, queryKeyspace);
    request = await this._createExecuteRequest(query, queryId, execOptions, params, meta);
  }

  return await RequestHandler.send(request, execOptions, this);
};

/**
 * Sets the listeners for the nodes.
 * @private
 */
Client.prototype._setHostListeners = function () {
  function getHostUpListener(emitter, h) {
    return () => emitter.emit('hostUp', h);
  }

  function getHostDownListener(emitter, h) {
    return () => emitter.emit('hostDown', h);
  }

  const self = this;

  // Add status listeners when new nodes are added and emit hostAdd
  this.hosts.on('add', function hostAddedListener(h) {
    h.on('up', getHostUpListener(self, h));
    h.on('down', getHostDownListener(self, h));
    self.emit('hostAdd', h);
  });

  // Remove all listeners and emit hostRemove
  this.hosts.on('remove', function hostRemovedListener(h) {
    h.removeAllListeners();
    self.emit('hostRemove', h);
  });

  // Add status listeners for existing hosts
  this.hosts.forEach(function (h) {
    h.on('up', getHostUpListener(self, h));
    h.on('down', getHostDownListener(self, h));
  });
};

/**
 * Sets the distance to each host and when warmup is true, creates all connections to local hosts.
 * @returns {Promise}
 * @private
 */
Client.prototype._warmup = function () {
  const hosts = this.hosts.values();

  return promiseUtils.times(hosts.length, warmupLimit, async (index) => {
    const h = hosts[index];
    const distance = this.profileManager.getDistance(h);

    if (distance === types$2.distance.ignored) {
      return;
    }

    if (this.options.pooling.warmup && distance === types$2.distance.local) {
      try {
        await h.warmupPool(this.keyspace);
      } catch (err) {
        // An error while trying to create a connection to one of the hosts.
        // Warn the user and move on.
        this.log('warning', `Connection pool to host ${h.address} could not be created: ${err}`, err);
      }
    } else {
      h.initializePool();
    }
  });
};

/**
 * @returns {Encoder}
 * @private
 */
Client.prototype._getEncoder = function () {
  const encoder = this.controlConnection.getEncoder();
  if (!encoder) {
    throw new errors$3.DriverInternalError('Encoder is not defined');
  }
  return encoder;
};

/**
 * Returns a BatchRequest instance and fills the routing key information in the provided options.
 * @private
 */
Client.prototype._createBatchRequest = async function (queryItems, info) {
  const firstQuery = queryItems[0];
  if (!firstQuery.meta) {
    return new requests.BatchRequest(queryItems, info);
  }

  await this._setRoutingInfo(info, firstQuery.params, firstQuery.meta);
  return new requests.BatchRequest(queryItems, info);
};

/**
 * Returns an ExecuteRequest instance and fills the routing key information in the provided options.
 * @private
 */
Client.prototype._createExecuteRequest = async function(query, queryId, info, params, meta) {
  params = utils$5.adaptNamedParamsPrepared(params, meta.columns);
  await this._setRoutingInfo(info, params, meta);
  return new requests.ExecuteRequest(query, queryId, params, info, meta);
};

/**
 * Returns a QueryRequest instance and fills the routing key information in the provided options.
 * @private
 */
Client.prototype._createQueryRequest = async function (query, execOptions, params) {
  await this.metadata.adaptUserHints(this.keyspace, execOptions.getHints());
  const paramsInfo = utils$5.adaptNamedParamsWithHints(params, execOptions);
  this._getEncoder().setRoutingKeyFromUser(paramsInfo.params, execOptions, paramsInfo.keyIndexes);

  return new requests.QueryRequest(query, paramsInfo.params, execOptions, paramsInfo.namedParameters);
};

/**
 * Sets the routing key based on the parameter values or the provided routing key components.
 * @param {ExecutionOptions} execOptions
 * @param {Array} params
 * @param meta
 * @private
 */
Client.prototype._setRoutingInfo = async function (execOptions, params, meta) {
  const encoder = this._getEncoder();

  if (!execOptions.getKeyspace() && meta.keyspace) {
    execOptions.setKeyspace(meta.keyspace);
  }
  if (execOptions.getRoutingKey()) {
    // Routing information provided by the user
    return encoder.setRoutingKeyFromUser(params, execOptions);
  }
  if (Array.isArray(meta.partitionKeys)) {
    // The partition keys are provided as part of the metadata for modern protocol versions
    execOptions.setRoutingIndexes(meta.partitionKeys);
    return encoder.setRoutingKeyFromMeta(meta, params, execOptions);
  }

  // Older versions of the protocol (v3 and below) don't provide routing information
  try {
    const tableInfo = await this.metadata.getTable(meta.keyspace, meta.table);

    if (!tableInfo) {
      // The schema data is not there, maybe it is being recreated, avoid setting the routing information
      return;
    }

    execOptions.setRoutingIndexes(tableInfo.partitionKeys.map(c => meta.columnsByName[c.name]));
    // Skip parsing metadata next time
    meta.partitionKeys = execOptions.getRoutingIndexes();
    encoder.setRoutingKeyFromMeta(meta, params, execOptions);
  } catch (err) {
    this.log('warning', util$1.format('Table %s.%s metadata could not be retrieved', meta.keyspace, meta.table));
  }
};

/**
 * Callback used by execution methods.
 * @callback ResultCallback
 * @param {Error} err Error occurred in the execution of the query.
 * @param {ResultSet} [result] Result of the execution of the query.
 */

var client = Client;

var mapping = {};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const EventEmitter = require$$0;

/**
 * Represents a tree node where the key is composed by 1 or more strings.
 * @ignore
 */
class Node extends EventEmitter {
  /**
   * Creates a new instance of {@link Node}.
   * @param {Array<String>} key
   * @param {Object} value
   * @param {Array} [edges]
   */
  constructor(key, value, edges) {
    super();
    this.key = key;
    this.value = value;
    this.edges = edges || [];
  }
}

/**
 * A radix tree where each node contains a key, a value and edges.
 * @ignore
 */
let Tree$2 = class Tree extends Node {
  constructor() {
    super([], null);
    this.length = 0;
  }

  /**
   * Gets the existing item in the tree or creates a new one with the value provided by valueHandler
   * @param {Iterator} keyIterator
   * @param {Function} valueHandler
   * @return {Object}
   */
  getOrCreate(keyIterator, valueHandler) {
    if (typeof keyIterator.next !== 'function') {
      keyIterator = keyIterator[Symbol.iterator]();
    }
    let node = this;
    let isMatch = false;
    let item = keyIterator.next();
    while (true) {
      let newBranch;
      // Check node keys at position 1 and above
      for (let i = 1; i < node.key.length; i++) {
        if (item.done || node.key[i] !== item.value) {
          // We should branch out
          newBranch = this._createBranch(node, i, item.done, valueHandler);
          break;
        }
        item = keyIterator.next();
      }

      if (item.done) {
        isMatch = true;
        break;
      }

      if (newBranch !== undefined) {
        break;
      }

      const edges = node.edges;
      let nextNode;
      for (let i = 0; i < edges.length; i++) {
        const e = edges[i];
        if (e.key[0] === item.value) {
          // its a match
          nextNode = e;
          item = keyIterator.next();
          break;
        }
      }

      if (nextNode === undefined) {
        // Current node is the root for a new leaf
        break;
      }
      else {
        node = nextNode;
      }
    }

    if (!isMatch) {
      // Create using "node" as the root
      const value = valueHandler();
      node.edges.push(new Node(iteratorToArray(item.value, keyIterator), value));
      this._onItemAdded();
      return value;
    }
    if (node.value === null && node.edges.length > 0) {
      node.value = valueHandler();
    }
    return node.value;
  }

  _createBranch(node, index, useNewValue, valueHandler) {
    const newBranch = new Node(node.key.slice(index), node.value, node.edges);
    node.key = node.key.slice(0, index);
    node.edges = [ newBranch ];
    if (useNewValue) {
      // The previous node value has moved to a leaf
      // The node containing the new leaf should use the new value
      node.value = valueHandler();
      this._onItemAdded();
    }
    else {
      // Clear the value as it was copied in the branch
      node.value = null;
    }
    return newBranch;
  }

  _onItemAdded() {
    this.length++;
    this.emit('add', this.length);
  }
};

function iteratorToArray(value, iterator) {
  const values = [ value ];
  let item = iterator.next();
  while (!item.done) {
    values.push(item.value);
    item = iterator.next();
  }
  return values;
}

var tree = Tree$2;

var q$1 = {};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const errors$2 = errors$n;

/**
 * Represents a CQL query operator, like >=, IN, <, ...
 * @ignore
 */
let QueryOperator$2 = class QueryOperator {
  /**
   * Creates a new instance of <code>QueryOperator</code>.
   * @param {String} key
   * @param value
   * @param [hasChildValues]
   * @param [isInOperator]
   */
  constructor(key, value, hasChildValues, isInOperator) {
    /**
     * The CQL key representing the operator
     * @type {string}
     */
    this.key = key;

    /**
     * The value to be used as parameter.
     */
    this.value = value;

    /**
     * Determines whether a query operator can have child values or operators (AND, OR)
     */
    this.hasChildValues = hasChildValues;

    /**
     * Determines whether this instance represents CQL "IN" operator.
     */
    this.isInOperator = isInOperator;
  }
};

/**
 * Represents a CQL assignment operation, like col = col + x.
 * @ignore
 */
let QueryAssignment$2 = class QueryAssignment {
  constructor(sign, value, inverted) {
    /**
     * Gets the sign of the assignment operation.
     */
    this.sign = sign;

    /**
     * Gets the value to be assigned.
     */
    this.value = value;

    /**
     * Determines whether the assignment should be inverted (prepends), e.g: col = x + col
     * @type {boolean}
     */
    this.inverted = !!inverted;
  }
};

/**
 * Contains functions that represents operators in a query.
 * @alias module:mapping~q
 * @type {Object}
 * @property {function} in_ Represents the CQL operator "IN".
 * @property {function} gt Represents the CQL operator greater than ">".
 * @property {function} gte Represents the CQL operator greater than or equals to ">=" .
 * @property {function} lt Represents the CQL operator less than "<" .
 * @property {function} lte Represents the CQL operator less than or equals to "<=" .
 * @property {function} notEq Represents the CQL operator not equals to "!=" .
 * @property {function} and When applied to a property, it represents two CQL conditions on the same column separated
 * by the logical AND operator, e.g: "col1 >= x col < y"
 * @property {function} incr Represents the CQL increment assignment used for counters, e.g: "col = col + x"
 * @property {function} decr Represents the CQL decrement assignment used for counters, e.g: "col = col - x"
 * @property {function} append Represents the CQL append assignment used for collections, e.g: "col = col + x"
 * @property {function} prepend Represents the CQL prepend assignment used for lists, e.g: "col = x + col"
 * @property {function} remove Represents the CQL remove assignment used for collections, e.g: "col = col - x"
 */
const q = {
  in_: function in_(arr) {
    if (!Array.isArray(arr)) {
      throw new errors$2.ArgumentError('IN operator supports only Array values');
    }
    return new QueryOperator$2('IN', arr, false, true);
  },

  gt: function gt(value) {
    return new QueryOperator$2('>', value);
  },

  gte: function gte(value) {
    return new QueryOperator$2('>=', value);
  },

  lt: function lt(value) {
    return new QueryOperator$2('<', value);
  },

  lte: function lte(value) {
    return new QueryOperator$2('<=', value);
  },

  notEq: function notEq(value) {
    return new QueryOperator$2('!=', value);
  },

  and: function (condition1, condition2) {
    return new QueryOperator$2('AND', [ condition1, condition2 ], true);
  },

  incr: function incr(value) {
    return new QueryAssignment$2('+', value);
  },

  decr: function decr(value) {
    return new QueryAssignment$2('-', value);
  },

  append: function append(value) {
    return new QueryAssignment$2('+', value);
  },

  prepend: function prepend(value) {
    return new QueryAssignment$2('+', value, true);
  },

  remove: function remove(value) {
    return new QueryAssignment$2('-', value);
  }
};

q$1.q = q;
q$1.QueryAssignment = QueryAssignment$2;
q$1.QueryOperator = QueryOperator$2;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const qModule$1 = q$1;
const QueryOperator$1 = qModule$1.QueryOperator;
const QueryAssignment$1 = qModule$1.QueryAssignment;

/**
 * Provides utility methods for obtaining a caching keys based on the specifics of the Mapper methods.
 * @ignore
 */
let Cache$2 = class Cache {
  /**
   * Gets an iterator of keys to uniquely identify a document shape for a select query.
   * @param {Array<String>} docKeys
   * @param {Object} doc
   * @param {{fields, limit, orderBy}} docInfo
   * @returns {Iterator}
   */
  static *getSelectKey(docKeys, doc, docInfo) {
    yield* Cache._yieldKeyAndOperators(docKeys, doc);

    yield* Cache._getSelectDocInfo(docInfo);
  }
  /**
   * Gets an iterator of keys to uniquely identify a shape for a select all query.
   * @param {{fields, limit, orderBy}} docInfo
   * @returns {Iterator}
   */
  static *getSelectAllKey(docInfo) {
    yield 'root';

    yield* Cache._getSelectDocInfo(docInfo);
  }

  /**
   * Gets the parts of the key for a select query related to the docInfo.
   * @param {{fields, limit, orderBy}} docInfo
   * @private
   */
  static *_getSelectDocInfo(docInfo) {
    if (docInfo) {
      if (docInfo.fields && docInfo.fields.length > 0) {
        // Use a separator from properties
        yield '|f|';
        yield* docInfo.fields;
      }

      if (typeof docInfo.limit === 'number') {
        yield '|l|';
      }

      if (docInfo.orderBy) {
        yield '|o|';

        // orderBy is uses property names as keys and 'asc'/'desc' as values
        const keys = Object.keys(docInfo.orderBy);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          yield key;
          yield docInfo.orderBy[key];
        }
      }
    }
  }

  /**
   * Gets an iterator of keys to uniquely identify a document shape for an insert query.
   * @param {Array<String>} docKeys
   * @param {{ifNotExists, ttl, fields}} docInfo
   * @returns {Iterator}
   */
  static *getInsertKey(docKeys, docInfo) {
    // No operator supported on INSERT values
    yield* docKeys;

    if (docInfo) {
      if (docInfo.fields && docInfo.fields.length > 0) {
        // Use a separator from properties
        yield '|f|';
        yield* docInfo.fields;
      }

      if (typeof docInfo.ttl === 'number') {
        yield '|t|';
      }

      if (docInfo.ifNotExists) {
        yield '|e|';
      }
    }
  }

  /**
   * Gets an iterator of keys to uniquely identify a document shape for an UPDATE query.
   * @param {Array<String>} docKeys
   * @param {Object} doc
   * @param {{ifExists, when, ttl, fields}} docInfo
   */
  static *getUpdateKey(docKeys, doc, docInfo) {
    yield* Cache._yieldKeyAndAllQs(docKeys, doc);

    if (docInfo) {
      if (docInfo.fields && docInfo.fields.length > 0) {
        // Use a separator from properties
        yield '|f|';
        yield* docInfo.fields;
      }

      if (typeof docInfo.ttl === 'number') {
        yield '|t|';
      }

      if (docInfo.ifExists) {
        yield '|e|';
      }

      if (docInfo.when) {
        yield* Cache._yieldKeyAndOperators(Object.keys(docInfo.when), docInfo.when);
      }
    }
  }

  /**
   * Gets an iterator of keys to uniquely identify a document shape for a DELETE query.
   * @param {Array<String>} docKeys
   * @param {Object} doc
   * @param {{ifExists, when, fields, deleteOnlyColumns}} docInfo
   * @returns {Iterator}
   */
  static *getRemoveKey(docKeys, doc, docInfo) {
    yield* Cache._yieldKeyAndOperators(docKeys, doc);

    if (docInfo) {
      if (docInfo.fields && docInfo.fields.length > 0) {
        // Use a separator from properties
        yield '|f|';
        yield* docInfo.fields;
      }

      if (docInfo.ifExists) {
        yield '|e|';
      }

      if (docInfo.deleteOnlyColumns) {
        yield '|dc|';
      }

      if (docInfo.when) {
        yield* Cache._yieldKeyAndOperators(Object.keys(docInfo.when), docInfo.when);
      }
    }
  }

  static *_yieldKeyAndOperators(keys, obj) {
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      yield key;
      yield* Cache._yieldOperators(obj[key]);
    }
  }

  static *_yieldOperators(value) {
    if (value !== null && value !== undefined && value instanceof QueryOperator$1) {
      yield value.key;
      if (value.hasChildValues) {
        yield* Cache._yieldOperators(value.value[0]);
        yield '|/|';
        yield* Cache._yieldOperators(value.value[1]);
      }
    }
  }

  static *_yieldKeyAndAllQs(keys, obj) {
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      yield key;
      const value = obj[key];
      if (value !== null && value !== undefined) {
        if (value instanceof QueryOperator$1) {
          yield* Cache._yieldOperators(value);
        }
        else if (value instanceof QueryAssignment$1) {
          yield value.sign;
          yield value.inverted;
        }
      }
    }
  }
};

var cache = Cache$2;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const Cache$1 = cache;

/**
 * Represents a query or a set of queries used to perform a mutation in a batch.
 * @alias module:mapping~ModelBatchItem
 */
let ModelBatchItem$1 = class ModelBatchItem {
  /**
   * @param {Object} doc
   * @param {Object} docInfo
   * @param {MappingHandler} handler
   * @param {Tree} cache
   */
  constructor(doc, docInfo, handler, cache) {
    this.doc = doc;
    this.docInfo = docInfo;
    this.handler = handler;
    this.cache = cache;
  }

  /**
   * @ignore
   * @returns <Promise<Array>>
   */
  getQueries() {
    const docKeys = Object.keys(this.doc);
    const cacheItem = this.cache.getOrCreate(this.getCacheKey(docKeys), () => ({ queries: null }));

    if (cacheItem.queries === null) {
      cacheItem.queries = this.createQueries(docKeys);
    }

    return cacheItem.queries;
  }

  /**
   * Gets the cache key for this item.
   * @abstract
   * @param {Array} docKeys
   * @returns {Iterator}
   */
  getCacheKey(docKeys) {
    throw new Error('getCacheKey must be implemented');
  }

  /**
   * Gets the Promise to create the queries.
   * @abstract
   * @param {Array} docKeys
   * @returns {Promise<Array>}
   */
  createQueries(docKeys) {
    throw new Error('getCacheKey must be implemented');
  }

  /**
   * Pushes the queries and parameters represented by this instance to the provided array.
   * @internal
   * @ignore
   * @param {Array} arr
   * @return {Promise<{isIdempotent, isCounter}>}
   */
  pushQueries(arr) {
    let isIdempotent = true;
    let isCounter;

    return this.getQueries().then(queries => {
      queries.forEach(q => {
        // It's idempotent if all the queries contained are idempotent
        isIdempotent = isIdempotent && q.isIdempotent;

        // Either all queries are counter mutation or we let it fail at server level
        isCounter = q.isCounter;

        arr.push({ query: q.query, params: q.paramsGetter(this.doc, this.docInfo, this.getMappingInfo()) });
      });

      return { isIdempotent, isCounter };
    });
  }

  /**
   * Gets the mapping information for this batch item.
   * @internal
   * @ignore
   */
  getMappingInfo() {
    return this.handler.info;
  }
};

/**
 * Represents a single or a set of INSERT queries in a batch.
 * @ignore
 * @internal
 */
let InsertModelBatchItem$1 = class InsertModelBatchItem extends ModelBatchItem$1 {
  /**
   * @param {Object} doc
   * @param {Object} docInfo
   * @param {MappingHandler} handler
   * @param {Tree} cache
   */
  constructor(doc, docInfo, handler, cache) {
    super(doc, docInfo, handler, cache);
  }

  /** @override */
  getCacheKey(docKeys) {
    return Cache$1.getInsertKey(docKeys, this.docInfo);
  }

  /** @override */
  createQueries(docKeys) {
    return this.handler.createInsertQueries(docKeys, this.doc, this.docInfo);
  }
};

/**
 * Represents a single or a set of UPDATE queries in a batch.
 * @ignore
 * @internal
 */
let UpdateModelBatchItem$1 = class UpdateModelBatchItem extends ModelBatchItem$1 {
  /**
   * @param {Object} doc
   * @param {Object} docInfo
   * @param {MappingHandler} handler
   * @param {Tree} cache
   */
  constructor(doc, docInfo, handler, cache) {
    super(doc, docInfo, handler, cache);
  }

  /** @override */
  getCacheKey(docKeys) {
    return Cache$1.getUpdateKey(docKeys, this.doc, this.docInfo);
  }

  /** @override */
  createQueries(docKeys) {
    return this.handler.createUpdateQueries(docKeys, this.doc, this.docInfo);
  }
};

/**
 * Represents a single or a set of DELETE queries in a batch.
 * @ignore
 * @internal
 */
let RemoveModelBatchItem$1 = class RemoveModelBatchItem extends ModelBatchItem$1 {
  /**
   * @param {Object} doc
   * @param {Object} docInfo
   * @param {MappingHandler} handler
   * @param {Tree} cache
   */
  constructor(doc, docInfo, handler, cache) {
    super(doc, docInfo, handler, cache);
  }

  /** @override */
  getCacheKey(docKeys) {
    return Cache$1.getRemoveKey(docKeys, this.doc, this.docInfo);
  }

  /** @override */
  createQueries(docKeys) {
    return this.handler.createDeleteQueries(docKeys, this.doc, this.docInfo);
  }
};

var modelBatchItem = { ModelBatchItem: ModelBatchItem$1, InsertModelBatchItem: InsertModelBatchItem$1, UpdateModelBatchItem: UpdateModelBatchItem$1, RemoveModelBatchItem: RemoveModelBatchItem$1 };

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const Tree$1 = tree;
const moduleBatchItemModule = modelBatchItem;
const InsertModelBatchItem = moduleBatchItemModule.InsertModelBatchItem;
const UpdateModelBatchItem = moduleBatchItemModule.UpdateModelBatchItem;
const RemoveModelBatchItem = moduleBatchItemModule.RemoveModelBatchItem;

/**
 * Provides utility methods to group multiple mutations on a single batch.
 * @alias module:mapping~ModelBatchMapper
 */
let ModelBatchMapper$1 = class ModelBatchMapper {
  /**
   * Creates a new instance of model batch mapper.
   * <p>
   *   An instance of this class is exposed as a singleton in the <code>batching</code> field of the
   *   [ModelMapper]{@link module:mapping~ModelMapper}. Note that new instances should not be create with this
   *   constructor.
   * </p>
   * @param {MappingHandler} handler
   * @ignore
   */
  constructor(handler) {
    this._handler = handler;
    this._cache = {
      insert: new Tree$1(),
      update: new Tree$1(),
      remove: new Tree$1()
    };
  }

  /**
   * Gets a [ModelBatchItem]{@link module:mapping~ModelBatchItem} containing the queries for the INSERT mutation to be
   * used in a batch execution.
   * @param {Object} doc An object containing the properties to insert.
   * @param {Object} [docInfo] An object containing the additional document information.
   * @param {Array<String>} [docInfo.fields] An Array containing the name of the properties that will be used in the
   * INSERT cql statements generated. If specified, it must include the columns to insert and the primary keys.
   * @param {Number} [docInfo.ttl] Specifies an optional Time To Live (in seconds) for the inserted values.
   * @param {Boolean} [docInfo.ifNotExists] When set, it only inserts if the row does not exist prior to the insertion.
   * <p>Please note that using IF NOT EXISTS will incur a non negligible performance cost so this should be used
   * sparingly.</p>
   * @returns {ModelBatchItem} A [ModelBatchItem]{@link module:mapping~ModelBatchItem} instance representing a query
   * or a set of queries to be included in a batch.
   */
  insert(doc, docInfo) {
    return new InsertModelBatchItem(doc, docInfo, this._handler, this._cache.insert);
  }

  /**
   * Gets a [ModelBatchItem]{@link module:mapping~ModelBatchItem} containing the queries for the UPDATE mutation to be
   * used in a batch execution.
   * @param {Object} doc An object containing the properties to update.
   * @param {Object} [docInfo] An object containing the additional document information.
   * @param {Array<String>} [docInfo.fields] An Array containing the name of the properties that will be used in the
   * UPDATE cql statements generated. If specified, it must include the columns to update and the primary keys.
   * @param {Number} [docInfo.ttl] Specifies an optional Time To Live (in seconds) for the inserted values.
   * @param {Boolean} [docInfo.ifExists] When set, it only updates if the row already exists on the server.
   * <p>
   *   Please note that using IF conditions will incur a non negligible performance cost on the server-side so this
   *   should be used sparingly.
   * </p>
   * @param {Object} [docInfo.when] A document that act as the condition that has to be met for the UPDATE to occur.
   * Use this property only in the case you want to specify a conditional clause for lightweight transactions (CAS).
   * <p>
   *   Please note that using IF conditions will incur a non negligible performance cost on the server-side so this
   *   should be used sparingly.
   * </p>
   * @returns {ModelBatchItem} A [ModelBatchItem]{@link module:mapping~ModelBatchItem} instance representing a query
   * or a set of queries to be included in a batch.
   */
  update(doc, docInfo) {
    return new UpdateModelBatchItem(doc, docInfo, this._handler, this._cache.update);
  }

  /**
   * Gets a [ModelBatchItem]{@link module:mapping~ModelBatchItem}  containing the queries for the DELETE mutation to be
   * used in a batch execution.
   * @param {Object} doc A document containing the primary keys values of the document to delete.
   * @param {Object} [docInfo] An object containing the additional doc information.
   * @param {Object} [docInfo.when] A document that act as the condition that has to be met for the DELETE to occur.
   * Use this property only in the case you want to specify a conditional clause for lightweight transactions (CAS).
   * When the CQL query is generated, this would be used to generate the `IF` clause.
   * <p>
   *   Please note that using IF conditions will incur a non negligible performance cost on the server-side so this
   *   should be used sparingly.
   * </p>
   * @param {Boolean} [docInfo.ifExists] When set, it only issues the DELETE command if the row already exists on the
   * server.
   * <p>
   *   Please note that using IF conditions will incur a non negligible performance cost on the server-side so this
   *   should be used sparingly.
   * </p>
   * @param {Array<String>} [docInfo.fields] An Array containing the name of the properties that will be used in the
   * DELETE cql statement generated. If specified, it must include the columns to delete and the primary keys.
   * @param {Boolean} [docInfo.deleteOnlyColumns] Determines that, when more document properties are specified
   * besides the primary keys, the generated DELETE statement should be used to delete some column values but leave
   * the row. When this is enabled and more properties are specified, a DELETE statement will have the following form:
   * "DELETE col1, col2 FROM table1 WHERE pk1 = ? AND pk2 = ?"
   * @returns {ModelBatchItem} A [ModelBatchItem]{@link module:mapping~ModelBatchItem} instance representing a query
   * or a set of queries to be included in a batch.
   */
  remove(doc, docInfo) {
    return new RemoveModelBatchItem(doc, docInfo, this._handler, this._cache.update);
  }
};

var modelBatchMapper = ModelBatchMapper$1;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const ModelBatchMapper = modelBatchMapper;

/**
 * Represents an object mapper for a specific model.
 * @alias module:mapping~ModelMapper
 */
let ModelMapper$1 = class ModelMapper {
  constructor(name, handler) {
    /**
     * Gets the name identifier of the model.
     * @type {String}
     */
    this.name = name;
    this._handler = handler;
    /**
     * Gets a [ModelBatchMapper]{@link module:mapping~ModelBatchMapper} instance containing utility methods to group
     * multiple doc mutations in a single batch.
     * @type {ModelBatchMapper}
     */
    this.batching = new ModelBatchMapper(this._handler);
  }

  /**
   * Gets the first document matching the provided filter or null when not found.
   * <p>
   *   Note that all partition and clustering keys must be defined in order to use this method.
   * </p>
   * @param {Object} doc The object containing the properties that map to the primary keys.
   * @param {Object} [docInfo] An object containing the additional document information.
   * @param {Array<String>} [docInfo.fields] An Array containing the name of the properties that will be used in the
   * SELECT cql statement generated, in order to restrict the amount of columns retrieved.
   * @param {Object|String} [executionOptions] An object containing the options to be used for the requests
   * execution or a string representing the name of the execution profile.
   * @param {String} [executionOptions.executionProfile] The name of the execution profile.
   * @return {Promise<Object>}
   * @example <caption>Get a video by id</caption>
   * videoMapper.get({ id })
   * @example <caption>Get a video by id, selecting specific columns</caption>
   * videoMapper.get({ id }, fields: ['name', 'description'])
   */
  get(doc, docInfo, executionOptions) {
    if (executionOptions === undefined && typeof docInfo === 'string') {
      executionOptions = docInfo;
      docInfo = null;
    }

    return this._handler.getSelectExecutor(doc, docInfo, true)
      .then(executor => executor(doc, docInfo, executionOptions))
      .then(result => result.first());
  }

  /**
   * Executes a SELECT query based on the filter and returns the result as an iterable of documents.
   * @param {Object} doc An object containing the properties that map to the primary keys to filter.
   * @param {Object} [docInfo] An object containing the additional document information.
   * @param {Array<String>} [docInfo.fields] An Array containing the name of the properties that will be used in the
   * SELECT cql statement generated, in order to restrict the amount of columns retrieved.
   * @param {Object<String, String>} [docInfo.orderBy] An associative array containing the column names as key and
   * the order string (asc or desc) as value used to set the order of the results server-side.
   * @param {Number} [docInfo.limit] Restricts the result of the query to a maximum number of rows on the
   * server.
   * @param {Object|String} [executionOptions] An object containing the options to be used for the requests
   * execution or a string representing the name of the execution profile.
   * @param {String} [executionOptions.executionProfile] The name of the execution profile.
   * @param {Number} [executionOptions.fetchSize] The amount of rows to retrieve per page.
   * @param {Number} [executionOptions.pageState] A Buffer instance or a string token representing the paging state.
   * <p>When provided, the query will be executed starting from a given paging state.</p>
   * @return {Promise<Result>} A Promise that resolves to a [Result]{@link module:mapping~Result} instance.
   * @example <caption>Get user's videos</caption>
   * const result = await videoMapper.find({ userId });
   * for (let video of result) {
   *   console.log(video.name);
   * }
   * @example <caption>Get user's videos from a certain date</caption>
   * videoMapper.find({ userId, addedDate: q.gte(date)});
   * @example <caption>Get user's videos in reverse order</caption>
   * videoMapper.find({ userId }, { orderBy: { addedDate: 'desc' }});
   */
  find(doc, docInfo, executionOptions) {
    if (executionOptions === undefined && typeof docInfo === 'string') {
      executionOptions = docInfo;
      docInfo = null;
    }

    return this._handler.getSelectExecutor(doc, docInfo, false)
      .then(executor => executor(doc, docInfo, executionOptions));
  }

  /**
   * Executes a SELECT query without a filter and returns the result as an iterable of documents.
   * <p>
   *   This is only recommended to be used for tables with a limited amount of results. Otherwise, breaking up the
   *   token ranges on the client side should be used.
   * </p>
   * @param {Object} [docInfo] An object containing the additional document information.
   * @param {Array<String>} [docInfo.fields] An Array containing the name of the properties that will be used in the
   * SELECT cql statement generated, in order to restrict the amount of columns retrieved.
   * @param {Object<String, String>} [docInfo.orderBy] An associative array containing the column names as key and
   * the order string (asc or desc) as value used to set the order of the results server-side.
   * @param {Number} [docInfo.limit] Restricts the result of the query to a maximum number of rows on the
   * server.
   * @param {Object|String} [executionOptions] An object containing the options to be used for the requests
   * execution or a string representing the name of the execution profile.
   * @param {String} [executionOptions.executionProfile] The name of the execution profile.
   * @param {Number} [executionOptions.fetchSize] The mount of rows to retrieve per page.
   * @param {Number} [executionOptions.pageState] A Buffer instance or a string token representing the paging state.
   * <p>When provided, the query will be executed starting from a given paging state.</p>
   * @return {Promise<Result>} A Promise that resolves to a [Result]{@link module:mapping~Result} instance.
   */
  findAll(docInfo, executionOptions) {
    if (executionOptions === undefined && typeof docInfo === 'string') {
      executionOptions = docInfo;
      docInfo = null;
    }

    const executor = this._handler.getSelectAllExecutor(docInfo);
    return executor(docInfo, executionOptions);
  }

  /**
   * Inserts a document.
   * <p>
   *   When the model is mapped to multiple tables, it will insert a row in each table when all the primary keys
   *   are specified.
   * </p>
   * @param {Object} doc An object containing the properties to insert.
   * @param {Object} [docInfo] An object containing the additional document information.
   * @param {Array<String>} [docInfo.fields] An Array containing the name of the properties that will be used in the
   * INSERT cql statements generated. If specified, it must include the columns to insert and the primary keys.
   * @param {Number} [docInfo.ttl] Specifies an optional Time To Live (in seconds) for the inserted values.
   * @param {Boolean} [docInfo.ifNotExists] When set, it only inserts if the row does not exist prior to the insertion.
   * <p>Please note that using IF NOT EXISTS will incur a non negligible performance cost so this should be used
   * sparingly.</p>
   * @param {Object|String} [executionOptions] An object containing the options to be used for the requests
   * execution or a string representing the name of the execution profile.
   * @param {String} [executionOptions.executionProfile] The name of the execution profile.
   * @param {Boolean} [executionOptions.isIdempotent] Defines whether the query can be applied multiple times without
   * changing the result beyond the initial application.
   * <p>
   *   By default all generated INSERT statements are considered idempotent, except in the case of lightweight
   *   transactions. Lightweight transactions at client level with transparent retries can
   *   break linearizability. If that is not an issue for your application, you can manually set this field to true.
   * </p>
   * @param {Number|Long} [executionOptions.timestamp] The default timestamp for the query in microseconds from the
   * unix epoch (00:00:00, January 1st, 1970).
   * <p>When provided, this will replace the client generated and the server side assigned timestamp.</p>
   * @return {Promise<Result>} A Promise that resolves to a [Result]{@link module:mapping~Result} instance.
   * @example <caption>Insert a video</caption>
   * videoMapper.insert({ id, name });
   */
  insert(doc, docInfo, executionOptions) {
    if (executionOptions === undefined && typeof docInfo === 'string') {
      executionOptions = docInfo;
      docInfo = null;
    }

    return this._handler.getInsertExecutor(doc, docInfo)
      .then(executor => executor(doc, docInfo, executionOptions));
  }

  /**
   * Updates a document.
   * <p>
   *   When the model is mapped to multiple tables, it will update a row in each table when all the primary keys
   *   are specified.
   * </p>
   * @param {Object} doc An object containing the properties to update.
   * @param {Object} [docInfo] An object containing the additional document information.
   * @param {Array<String>} [docInfo.fields] An Array containing the name of the properties that will be used in the
   * UPDATE cql statements generated. If specified, it must include the columns to update and the primary keys.
   * @param {Number} [docInfo.ttl] Specifies an optional Time To Live (in seconds) for the inserted values.
   * @param {Boolean} [docInfo.ifExists] When set, it only updates if the row already exists on the server.
   * <p>
   *   Please note that using IF conditions will incur a non negligible performance cost on the server-side so this
   *   should be used sparingly.
   * </p>
   * @param {Object} [docInfo.when] A document that act as the condition that has to be met for the UPDATE to occur.
   * Use this property only in the case you want to specify a conditional clause for lightweight transactions (CAS).
   * <p>
   *   Please note that using IF conditions will incur a non negligible performance cost on the server-side so this
   *   should be used sparingly.
   * </p>
   * @param {Object|String} [executionOptions] An object containing the options to be used for the requests
   * execution or a string representing the name of the execution profile.
   * @param {String} [executionOptions.executionProfile] The name of the execution profile.
   * @param {Boolean} [executionOptions.isIdempotent] Defines whether the query can be applied multiple times without
   * changing the result beyond the initial application.
   * <p>
   *   The mapper uses the generated queries to determine the default value. When an UPDATE is generated with a
   *   counter column or appending/prepending to a list column, the execution is marked as not idempotent.
   * </p>
   * <p>
   *   Additionally, the mapper uses the safest approach for queries with lightweight transactions (Compare and
   *   Set) by considering them as non-idempotent. Lightweight transactions at client level with transparent retries can
   *   break linearizability. If that is not an issue for your application, you can manually set this field to true.
   * </p>
   * @param {Number|Long} [executionOptions.timestamp] The default timestamp for the query in microseconds from the
   * unix epoch (00:00:00, January 1st, 1970).
   * <p>When provided, this will replace the client generated and the server side assigned timestamp.</p>
   * @return {Promise<Result>} A Promise that resolves to a [Result]{@link module:mapping~Result} instance.
   * @example <caption>Update the name of a video</caption>
   * videoMapper.update({ id, name });
   */
  update(doc, docInfo, executionOptions) {
    if (executionOptions === undefined && typeof docInfo === 'string') {
      executionOptions = docInfo;
      docInfo = null;
    }

    return this._handler.getUpdateExecutor(doc, docInfo)
      .then(executor => executor(doc, docInfo, executionOptions));
  }

  /**
   * Deletes a document.
   * @param {Object} doc A document containing the primary keys values of the document to delete.
   * @param {Object} [docInfo] An object containing the additional doc information.
   * @param {Object} [docInfo.when] A document that act as the condition that has to be met for the DELETE to occur.
   * Use this property only in the case you want to specify a conditional clause for lightweight transactions (CAS).
   * When the CQL query is generated, this would be used to generate the `IF` clause.
   * <p>
   *   Please note that using IF conditions will incur a non negligible performance cost on the server-side so this
   *   should be used sparingly.
   * </p>
   * @param {Boolean} [docInfo.ifExists] When set, it only issues the DELETE command if the row already exists on the
   * server.
   * <p>
   *   Please note that using IF conditions will incur a non negligible performance cost on the server-side so this
   *   should be used sparingly.
   * </p>
   * @param {Array<String>} [docInfo.fields] An Array containing the name of the properties that will be used in the
   * DELETE cql statement generated. If specified, it must include the columns to delete and the primary keys.
   * @param {Boolean} [docInfo.deleteOnlyColumns] Determines that, when more document properties are specified
   * besides the primary keys, the generated DELETE statement should be used to delete some column values but leave
   * the row. When this is enabled and more properties are specified, a DELETE statement will have the following form:
   * "DELETE col1, col2 FROM table1 WHERE pk1 = ? AND pk2 = ?"
   * @param {Object|String} [executionOptions] An object containing the options to be used for the requests
   * execution or a string representing the name of the execution profile.
   * @param {String} [executionOptions.executionProfile] The name of the execution profile.
   * @param {Boolean} [executionOptions.isIdempotent] Defines whether the query can be applied multiple times without
   * changing the result beyond the initial application.
   * <p>
   *   By default all generated DELETE statements are considered idempotent, except in the case of lightweight
   *   transactions. Lightweight transactions at client level with transparent retries can
   *   break linearizability. If that is not an issue for your application, you can manually set this field to true.
   * </p>
   * @param {Number|Long} [executionOptions.timestamp] The default timestamp for the query in microseconds from the
   * unix epoch (00:00:00, January 1st, 1970).
   * <p>When provided, this will replace the client generated and the server side assigned timestamp.</p>
   * @return {Promise<Result>} A Promise that resolves to a [Result]{@link module:mapping~Result} instance.
   * @example <caption>Delete a video</caption>
   * videoMapper.remove({ id });
   */
  remove(doc, docInfo, executionOptions) {
    if (executionOptions === undefined && typeof docInfo === 'string') {
      executionOptions = docInfo;
      docInfo = null;
    }

    return this._handler.getDeleteExecutor(doc, docInfo)
      .then(executor => executor(doc, docInfo, executionOptions));
  }

  /**
   * Uses the provided query and param getter function to execute a query and map the results.
   * Gets a function that takes the document, executes the query and returns the mapped results.
   * @param {String} query The query to execute.
   * @param {Function} paramsHandler The function to execute to extract the parameters of a document.
   * @param {Object|String} [executionOptions] When provided, the options for all executions generated with this
   * method will use the provided options and it will not consider the executionOptions per call.
   * @param {String} [executionOptions.executionProfile] The name of the execution profile.
   * @param {Number} [executionOptions.fetchSize] Amount of rows to retrieve per page.
   * @param {Boolean} [executionOptions.isIdempotent] Defines whether the query can be applied multiple times
   * without changing the result beyond the initial application.
   * @param {Number} [executionOptions.pageState] Buffer or string token representing the paging state.
   * <p>When provided, the query will be executed starting from a given paging state.</p>
   * @param {Number|Long} [executionOptions.timestamp] The default timestamp for the query in microseconds from the
   * unix epoch (00:00:00, January 1st, 1970).
   * <p>When provided, this will replace the client generated and the server side assigned timestamp.</p>
   * @return {Function} Returns a function that takes the document and execution options as parameters and returns a
   * Promise the resolves to a [Result]{@link module:mapping~Result} instance.
   */
  mapWithQuery(query, paramsHandler, executionOptions) {
    return this._handler.getExecutorFromQuery(query, paramsHandler, executionOptions);
  }
};

var modelMapper = ModelMapper$1;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const vm$1 = require$$0$b;
const qModule = q$1;
const QueryOperator = qModule.QueryOperator;
const QueryAssignment = qModule.QueryAssignment;
const types$1 = requireTypes();
const dataTypes = types$1.dataTypes;

const vmFileName = 'gen-param-getter.js';

/**
 * Provides methods to generate a query and parameter handlers.
 * @ignore
 */
let QueryGenerator$1 = class QueryGenerator {
  /**
   * Gets the SELECT query given the doc.
   * @param {String} tableName
   * @param {String} keyspace
   * @param {Array} propertiesInfo
   * @param {Array} fieldsInfo
   * @param {Array} orderByColumns
   * @param {Number|undefined} limit
   * @return {string}
   */
  static getSelect(tableName, keyspace, propertiesInfo, fieldsInfo, orderByColumns, limit) {
    let query = 'SELECT ';
    query += fieldsInfo.length > 0 ? fieldsInfo.map(p => p.columnName).join(', ') : '*';
    query += ` FROM ${keyspace}.${tableName}`;

    if (propertiesInfo.length > 0) {
      query += ' WHERE ';
      query += QueryGenerator._getConditionWithOperators(propertiesInfo);
    }

    if (orderByColumns.length > 0) {
      query += ' ORDER BY ';
      query += orderByColumns.map(order => order[0] + ' ' + order[1]).join(', ');
    }

    if (typeof limit === 'number') {
      query += ' LIMIT ?';
    }

    return query;
  }

  static selectParamsGetter(propertiesInfo, limit) {
    let scriptText = '(function getParametersSelect(doc, docInfo, mappingInfo) {\n';
    scriptText += '  return [';

    scriptText += QueryGenerator._valueGetterExpression(propertiesInfo);

    if (typeof limit === 'number') {
      if (propertiesInfo.length > 0) {
        scriptText += ', ';
      }
      scriptText += `docInfo['limit']`;
    }

    // Finish return statement
    scriptText += '];\n})';

    const script = new vm$1.Script(scriptText, { filename: vmFileName });
    return script.runInThisContext();
  }

  /**
   * Gets the INSERT query and function to obtain the parameters, given the doc.
   * @param {TableMetadata} table
   * @param {String} keyspace
   * @param {Array} propertiesInfo
   * @param {Object} docInfo
   * @param {Boolean|undefined} ifNotExists
   * @return {{query: String, paramsGetter: Function, isIdempotent: Boolean}}
   */
  static getInsert(table, keyspace, propertiesInfo, docInfo, ifNotExists) {
    const ttl = docInfo && docInfo.ttl;

    // Not all columns are contained in the table
    const filteredPropertiesInfo = propertiesInfo
      .filter(pInfo => table.columnsByName[pInfo.columnName] !== undefined);

    return ({
      query: QueryGenerator._getInsertQuery(table.name, keyspace, filteredPropertiesInfo, ifNotExists, ttl),
      paramsGetter: QueryGenerator._insertParamsGetter(filteredPropertiesInfo, docInfo),
      isIdempotent: !ifNotExists
    });
  }

  /**
   * Gets the query for an insert statement.
   * @param {String} tableName
   * @param {String} keyspace
   * @param {Array} propertiesInfo
   * @param {Boolean} ifNotExists
   * @param {Number|undefined} ttl
   * @return {String}
   */
  static _getInsertQuery(tableName, keyspace, propertiesInfo, ifNotExists, ttl) {
    let query = `INSERT INTO ${keyspace}.${tableName} (`;
    query += propertiesInfo.map(pInfo => pInfo.columnName).join(', ');
    query += ') VALUES (';
    query += propertiesInfo.map(() => '?').join(', ');
    query += ')';

    if (ifNotExists === true) {
      query += ' IF NOT EXISTS';
    }

    if (typeof ttl === 'number') {
      query += ' USING TTL ?';
    }
    return query;
  }

  static _insertParamsGetter(propertiesInfo, docInfo) {
    let scriptText = '(function getParametersInsert(doc, docInfo, mappingInfo) {\n';
    scriptText += '  return [';

    scriptText += QueryGenerator._valueGetterExpression(propertiesInfo);

    if (docInfo && typeof docInfo.ttl === 'number') {
      scriptText += `, docInfo['ttl']`;
    }

    // Finish return statement
    scriptText += '];\n})';

    const script = new vm$1.Script(scriptText, { filename: vmFileName });
    return script.runInThisContext();
  }

  /**
   * Gets the UPDATE query and function to obtain the parameters, given the doc.
   * @param {TableMetadata} table
   * @param {String} keyspace
   * @param {Array} propertiesInfo
   * @param {Object} docInfo
   * @param {Array} when
   * @param {Boolean|undefined} ifExists
   * @return {{query: String, paramsGetter: Function, isIdempotent: Boolean, isCounter}}
   */
  static getUpdate(table, keyspace, propertiesInfo, docInfo, when, ifExists) {
    const ttl = docInfo && docInfo.ttl;
    const primaryKeys = new Set(table.partitionKeys.concat(table.clusteringKeys).map(c => c.name));
    let isIdempotent = true;
    let isCounter = false;

    // Not all columns are contained in the table
    const filteredPropertiesInfo = propertiesInfo.filter(pInfo => {
      const column = table.columnsByName[pInfo.columnName];
      if (column === undefined) {
        return false;
      }

      if (column.type.code === dataTypes.list && pInfo.value instanceof QueryAssignment) {
        // Its not idempotent when list append/prepend
        isIdempotent = false;
      } else if (column.type.code === dataTypes.counter) {
        // Any update on a counter table is not idempotent
        isIdempotent = false;
        isCounter = true;
      }

      return true;
    });

    return {
      query: QueryGenerator._getUpdateQuery(
        table.name, keyspace, primaryKeys, filteredPropertiesInfo, when, ifExists, ttl),
      isIdempotent: isIdempotent && when.length === 0 && !ifExists,
      paramsGetter: QueryGenerator._updateParamsGetter(primaryKeys, filteredPropertiesInfo, when, ttl),
      isCounter
    };
  }

  /**
   * Gets the query for an UPDATE statement.
   * @param {String} tableName
   * @param {String} keyspace
   * @param {Set} primaryKeys
   * @param {Array} propertiesInfo
   * @param {Object} when
   * @param {Boolean} ifExists
   * @param {Number|undefined} ttl
   */
  static _getUpdateQuery(tableName, keyspace, primaryKeys, propertiesInfo, when, ifExists, ttl) {
    let query = `UPDATE ${keyspace}.${tableName} `;

    if (typeof ttl === 'number') {
      query += 'USING TTL ? ';
    }

    query += 'SET ';

    query += propertiesInfo
      .filter(p => !primaryKeys.has(p.columnName))
      .map(p => {
        if (p.value instanceof QueryAssignment) {
          if (p.value.inverted) {
            // e.g: prepend "col1 = ? + col1"
            return `${p.columnName} = ? ${p.value.sign} ${p.columnName}`;
          }
          // e.g: increment "col1 = col1 + ?"
          return `${p.columnName} = ${p.columnName} ${p.value.sign} ?`;
        }

        return p.columnName + ' = ?';
      })
      .join(', ');

    query += ' WHERE ';
    query += propertiesInfo.filter(p => primaryKeys.has(p.columnName)).map(p => p.columnName + ' = ?').join(' AND ');

    if (ifExists === true) {
      query += ' IF EXISTS';
    }
    else if (when.length > 0) {
      query += ' IF ' + QueryGenerator._getConditionWithOperators(when);
    }

    return query;
  }

  /**
   * Returns a function to obtain the parameter values from a doc for an UPDATE statement.
   * @param {Set} primaryKeys
   * @param {Array} propertiesInfo
   * @param {Array} when
   * @param {Number|undefined} ttl
   * @returns {Function}
   */
  static _updateParamsGetter(primaryKeys, propertiesInfo, when, ttl) {
    let scriptText = '(function getParametersUpdate(doc, docInfo, mappingInfo) {\n';
    scriptText += '  return [';

    if (typeof ttl === 'number') {
      scriptText += `docInfo['ttl'], `;
    }

    // Assignment clause
    scriptText += QueryGenerator._assignmentGetterExpression(propertiesInfo.filter(p => !primaryKeys.has(p.columnName)));
    scriptText += ', ';

    // Where clause
    scriptText += QueryGenerator._valueGetterExpression(propertiesInfo.filter(p => primaryKeys.has(p.columnName)));

    // Condition clause
    if (when.length > 0) {
      scriptText += ', ' + QueryGenerator._valueGetterExpression(when, 'docInfo.when');
    }

    // Finish return statement
    scriptText += '];\n})';

    const script = new vm$1.Script(scriptText, { filename: vmFileName });
    return script.runInThisContext();
  }

  /**
   * Gets the DELETE query and function to obtain the parameters, given the doc.
   * @param {TableMetadata} table
   * @param {String} keyspace
   * @param {Array} propertiesInfo
   * @param {Object} docInfo
   * @param {Array} when
   * @param {Boolean|undefined} ifExists
   * @return {{query: String, paramsGetter: Function, isIdempotent}}
   */
  static getDelete(table, keyspace, propertiesInfo, docInfo, when, ifExists) {
    const deleteOnlyColumns = docInfo && docInfo.deleteOnlyColumns;
    const primaryKeys = new Set(table.partitionKeys.concat(table.clusteringKeys).map(c => c.name));

    const filteredPropertiesInfo = propertiesInfo
      .filter(pInfo => table.columnsByName[pInfo.columnName] !== undefined);


    return ({
      query: QueryGenerator._getDeleteQuery(
        table.name, keyspace, primaryKeys, filteredPropertiesInfo, when, ifExists, deleteOnlyColumns),
      paramsGetter: QueryGenerator._deleteParamsGetter(primaryKeys, filteredPropertiesInfo, when),
      isIdempotent: when.length === 0 && !ifExists
    });
  }

  /**
   * Gets the query for an UPDATE statement.
   * @param {String} tableName
   * @param {String} keyspace
   * @param {Set} primaryKeys
   * @param {Array} propertiesInfo
   * @param {Array} when
   * @param {Boolean} ifExists
   * @param {Boolean} deleteOnlyColumns
   * @private
   * @return {String}
   */
  static _getDeleteQuery(tableName, keyspace, primaryKeys, propertiesInfo, when, ifExists, deleteOnlyColumns) {
    let query = 'DELETE';

    if (deleteOnlyColumns) {
      const columnsToDelete = propertiesInfo.filter(p => !primaryKeys.has(p.columnName))
        .map(p => p.columnName)
        .join(', ');

      if (columnsToDelete !== '') {
        query += ' ' + columnsToDelete;
      }
    }

    query += ` FROM ${keyspace}.${tableName} WHERE `;
    query += propertiesInfo.filter(p => primaryKeys.has(p.columnName)).map(p => p.columnName + ' = ?').join(' AND ');

    if (ifExists === true) {
      query += ' IF EXISTS';
    }
    else if (when.length > 0) {
      query += ' IF ' + QueryGenerator._getConditionWithOperators(when);
    }

    return query;
  }
  /**
   * Returns a function to obtain the parameter values from a doc for an UPDATE statement.
   * @param {Set} primaryKeys
   * @param {Array} propertiesInfo
   * @param {Array} when
   * @returns {Function}
   */
  static _deleteParamsGetter(primaryKeys, propertiesInfo, when) {
    let scriptText = '(function getParametersDelete(doc, docInfo, mappingInfo) {\n';
    scriptText += '  return [';

    // Where clause
    scriptText += QueryGenerator._valueGetterExpression(propertiesInfo.filter(p => primaryKeys.has(p.columnName)));

    // Condition clause
    if (when.length > 0) {
      scriptText += ', ' + QueryGenerator._valueGetterExpression(when, 'docInfo.when');
    }

    // Finish return statement
    scriptText += '];\n})';

    const script = new vm$1.Script(scriptText, { filename: vmFileName });
    return script.runInThisContext();
  }

  /**
   * Gets a string containing the doc properties to get.
   * @param {Array} propertiesInfo
   * @param {String} [objectName='doc']
   * @return {string}
   * @private
   */
  static _valueGetterExpression(propertiesInfo, objectName) {
    objectName = objectName || 'doc';

    return propertiesInfo
      .map(p =>
        QueryGenerator._valueGetterSingle(`${objectName}['${p.propertyName}']`, p.propertyName, p.value, p.fromModel))
      .join(', ');
  }

  static _valueGetterSingle(prefix, propName, value, fromModelFn) {
    let valueGetter = prefix;

    if (value instanceof QueryOperator) {
      if (value.hasChildValues) {
        return `${QueryGenerator._valueGetterSingle(`${prefix}.value[0]`, propName, value.value[0], fromModelFn)}` +
          `, ${QueryGenerator._valueGetterSingle(`${prefix}.value[1]`, propName, value.value[1], fromModelFn)}`;
      }

      valueGetter = `${prefix}.value`;

      if (value.isInOperator && fromModelFn) {
        // Transform each individual value
        return `${valueGetter}.map(v => ${QueryGenerator._getMappingFunctionCall(propName, 'v')})`;
      }
    }

    return !fromModelFn ? valueGetter : QueryGenerator._getMappingFunctionCall(propName, valueGetter);
  }

  /**
   * Gets a string containing the doc properties to SET, considering QueryAssignment instances.
   * @param {Array} propertiesInfo
   * @param {String} [prefix='doc']
   * @return {string}
   * @private
   */
  static _assignmentGetterExpression(propertiesInfo, prefix) {
    prefix = prefix || 'doc';

    return propertiesInfo
      .map(p => {
        const valueGetter = `${prefix}['${p.propertyName}']${p.value instanceof QueryAssignment ? '.value' : ''}`;
        if (p.fromModel) {
          return QueryGenerator._getMappingFunctionCall(p.propertyName, valueGetter);
        }
        return valueGetter;
      })
      .join(', ');
  }

  static _getConditionWithOperators(propertiesInfo) {
    return propertiesInfo
      .map(p => QueryGenerator._getSingleCondition(p.columnName, p.value))
      .join(' AND ');
  }

  static _getMappingFunctionCall(propName, valueGetter) {
    return `mappingInfo.getFromModelFn('${propName}')(${valueGetter})`;
  }

  static _getSingleCondition(columnName, value) {
    if (value instanceof QueryOperator) {
      if (value.hasChildValues) {
        return `${QueryGenerator._getSingleCondition(columnName, value.value[0])}` +
          ` ${value.key} ${QueryGenerator._getSingleCondition(columnName, value.value[1])}`;
      }
      return `${columnName} ${value.key} ?`;
    }
    return `${columnName} = ?`;
  }
};

var queryGenerator = QueryGenerator$1;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const vm = require$$0$b;
const utils$4 = utils$K;
const types = requireTypes();

/**
 * @ignore
 */
let ResultMapper$2 = class ResultMapper {
  /**
   * Gets a generated function to adapt the row to a document.
   * @param {ModelMappingInfo} info
   * @param {ResultSet} rs
   * @returns {Function}
   */
  static getSelectAdapter(info, rs) {
    const columns = rs.columns;
    if (!columns) {
      throw new Error('Expected ROWS result obtained VOID');
    }

    let scriptText = '(function rowAdapter(row, info) {\n' +
      '  const item = info.newInstance();\n';

    for (const c of columns) {
      scriptText += `  item['${info.getPropertyName(c.name)}'] = `;

      if (!info.getToModelFn(c.name)) {
        scriptText += `row['${c.name}'];\n`;
      } else {
        scriptText += `info.getToModelFn('${c.name}')(row['${c.name}']);\n`;
      }
    }

    scriptText += '  return item;\n})';

    const script = new vm.Script(scriptText, { filename: 'gen-result-mapper.js'});
    return script.runInThisContext();
  }

  /**
   * Gets a function used to adapt VOID results or conditional updates.
   * @param {ResultSet} rs
   * @returns {Function}
   */
  static getMutationAdapter(rs) {
    if (rs.columns === null) {
      // VOID result
      return utils$4.noop;
    }

    if (
      rs.columns.length === 1 && rs.columns[0].name === '[applied]' &&
      rs.columns[0].type.code === types.dataTypes.boolean) {
      return utils$4.noop;
    }

    return ResultMapper._getConditionalRowAdapter(rs);
  }

  static _getConditionalRowAdapter(rs) {
    return (function conditionalRowAdapter(row, info) {
      const item = info.newInstance();

      // Skip the first column ("[applied]")
      for (let i = 1; i < rs.columns.length; i++) {
        const c = rs.columns[i];
        item[info.getPropertyName(c.name)] = row[c.name];
      }

      return item;
    });
  }

  /**
   * @param {ModelMappingInfo} info
   * @param {ResultSet} rs
   * @returns {{canCache: Boolean, fn: Function}}
   */
  static getCustomQueryAdapter(info, rs) {
    if (rs.columns === null || rs.columns.length === 0) {
      // VOID result
      return { canCache: true, fn: utils$4.noop };
    }

    if (rs.columns[0].name === '[applied]' && rs.columns[0].type.code === types.dataTypes.boolean) {
      // Conditional update results adapter functions should not be cached
      return { canCache: false, fn: ResultMapper._getConditionalRowAdapter(rs) };
    }

    return { canCache: true, fn: ResultMapper.getSelectAdapter(info, rs) };
  }
};

var resultMapper = ResultMapper$2;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const util = require$$0$4;
const utils$3 = utils$K;
const inspectMethod = util.inspect.custom || 'inspect';

/**
 * Represents the result of an execution as an iterable of objects in the Mapper.
 * @alias module:mapping~Result
 */
let Result$2 = class Result {
  /**
   * Creates a new instance of Result.
   * @param {ResultSet} rs
   * @param {ModelMappingInfo} info
   * @param {Function} rowAdapter
   */
  constructor(rs, info, rowAdapter) {
    this._rs = rs;
    this._info = info;
    this._rowAdapter = rowAdapter;

    /**
     * When there is a single cell containing the result of the a LWT operation, hide the result from the user.
     * @private
     */
    this._isEmptyLwt = (rs.columns !== null
      && rs.columns.length === 1 && this._rs.rowLength === 1 && rs.columns[0].name === '[applied]');

    /**
     * Gets the amount of the documents contained in this Result instance.
     * <p>
     *   When the results are paged, it returns the length of the current paged results not the total amount of
     *   rows in the table matching the query.
     * </p>
     * @type {Number}
     */
    this.length = this._isEmptyLwt ? 0 : (rs.rowLength || 0);

    /**
     * A string token representing the current page state of query.
     * <p>
     *   When provided, it can be used in the following executions to continue paging and retrieve the remained of the
     *   result for the query.
     * </p>
     * @type {String}
     * @default null
     */
    this.pageState = rs.pageState;
  }

  /**
   * When this instance is the result of a conditional update query, it returns whether it was successful.
   * Otherwise, it returns <code>true</code>.
   * <p>
   *   For consistency, this method always returns <code>true</code> for non-conditional queries (although there is
   *   no reason to call the method in that case). This is also the case for conditional DDL statements
   *   (CREATE KEYSPACE... IF NOT EXISTS, CREATE TABLE... IF NOT EXISTS), for which the server doesn't return
   *   information whether it was applied or not.
   * </p>
   */
  wasApplied() {
    return this._rs.wasApplied();
  }

  /**
   * Gets the first document in this result or null when the result is empty.
   */
  first() {
    if (!this._rs.rowLength || this._isEmptyLwt) {
      return null;
    }
    return this._rowAdapter(this._rs.rows[0], this._info);
  }

  /**
   * Returns a new Iterator object that contains the document values.
   */
  *[Symbol.iterator]() {
    if (this._isEmptyLwt) {
      // Empty iterator
      return;
    }

    for (let i = 0; i < this._rs.rows.length; i++) {
      yield this._rowAdapter(this._rs.rows[i], this._info);
    }
  }

  /**
   * Converts the current instance to an Array of documents.
   * @return {Array<Object>}
   */
  toArray() {
    if (this._isEmptyLwt || !this._rs.rows) {
      return utils$3.emptyArray;
    }

    return this._rs.rows.map(row => this._rowAdapter(row, this._info));
  }

  /**
   * Executes a provided function once per result element.
   * @param {Function} callback Function to execute for each element, taking two arguments: currentValue and index.
   * @param {Object} [thisArg] Value to use as <code>this</code> when executing callback.
   */
  forEach(callback, thisArg) {
    let index = 0;
    thisArg = thisArg || this;
    for (const doc of this) {
      callback.call(thisArg, doc, index++);
    }
  }

  [inspectMethod]() {
    return this.toArray();
  }
};

var result = Result$2;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const keyMatches = {
  all: 1,
  none: 0,
  some: -1
};

/**
 * Provides utility methods to choose the correct tables and views that should be included in a statement.
 * @ignore
 */
let ObjectSelector$1 = class ObjectSelector {
  /**
   * Gets the table/view that should be used to execute the SELECT query.
   * @param {Client} client
   * @param {ModelMappingInfo} info
   * @param {Boolean} allPKsDefined
   * @param {Array} propertiesInfo
   * @param {Array} fieldsInfo
   * @param {Array<Array<String>>} orderByColumns
   * @return {Promise<String>} A promise that resolves to a table names.
   */
  static getForSelect(client, info, allPKsDefined, propertiesInfo, fieldsInfo, orderByColumns) {
    return Promise.all(
      info.tables.map(t => {
        if (t.isView) {
          return client.metadata.getMaterializedView(info.keyspace, t.name);
        }
        return client.metadata.getTable(info.keyspace, t.name);
      }))
      .then(tables => {
        for (let i = 0; i < tables.length; i++) {
          const table = tables[i];
          if (table === null) {
            throw new Error(`Table "${info.tables[i].name}" could not be retrieved`);
          }

          if (keysAreIncluded(table.partitionKeys, propertiesInfo) !== keyMatches.all) {
            // Not all the partition keys are covered
            continue;
          }


          if (allPKsDefined) {
            if (keysAreIncluded(table.clusteringKeys, propertiesInfo) !== keyMatches.all) {
              // All clustering keys should be included as allPKsDefined flag is set
              continue;
            }
          }

          if (propertiesInfo.length > table.partitionKeys.length) {
            // Check that the Where clause is composed by partition and clustering keys
            const allPropertiesArePrimaryKeys = propertiesInfo
              .reduce(
                (acc, p) => acc && (
                  contains(table.partitionKeys, c => c.name === p.columnName) ||
                  contains(table.clusteringKeys, c => c.name === p.columnName)
                ),
                true);

            if (!allPropertiesArePrimaryKeys) {
              continue;
            }
          }

          // All fields must be contained
          const containsAllFields = fieldsInfo
            .reduce((acc, p) => acc && table.columnsByName[p.columnName] !== undefined, true);

          if (!containsAllFields) {
            continue;
          }

          // CQL:
          // - "ORDER BY" is currently only supported on the clustered columns of the PRIMARY KEY
          // - "ORDER BY" currently only support the ordering of columns following their declared order in
          //   the PRIMARY KEY
          //
          // In the mapper, we validate that the ORDER BY columns appear in the same order as in the clustering keys
          const containsAllOrderByColumns = orderByColumns
            .reduce((acc, order, index) => {
              if (!acc) {
                return false;
              }

              const ck = table.clusteringKeys[index];

              return ck && ck.name === order[0];
            }, true);

          if (!containsAllOrderByColumns) {
            continue;
          }

          return table.name;
        }

        let message = `No table matches the filter (${allPKsDefined ? 'all PKs have to be specified' : 'PKs'}): [${
          propertiesInfo.map(p => p.columnName)}]`;

        if (fieldsInfo.length > 0) {
          message += `; fields: [${fieldsInfo.map(p => p.columnName)}]`;
        }
        if (orderByColumns.length > 0) {
          message += `; orderBy: [${orderByColumns.map(item => item[0])}]`;
        }

        throw new Error(message);
      });
  }

  /** Returns the name of the first table */
  static getForSelectAll(info) {
    return info.tables[0].name;
  }

  /**
   * Gets the tables that should be used to execute the INSERT query.
   * @param {Client} client
   * @param {ModelMappingInfo} info
   * @param {Array} propertiesInfo
   * @return {Promise<Array<TableMetadata>>} A promise that resolves to an Array of tables.
   */
  static getForInsert(client, info, propertiesInfo) {
    return Promise.all(info.tables.filter(t => !t.isView).map(t => client.metadata.getTable(info.keyspace, t.name)))
      .then(tables => {
        const filteredTables = tables
          .filter((table, i) => {
            if (table === null) {
              throw new Error(`Table "${info.tables[i].name}" could not be retrieved`);
            }

            if (keysAreIncluded(table.partitionKeys, propertiesInfo) !== keyMatches.all) {
              // Not all the partition keys are covered
              return false;
            }

            const clusteringKeyMatches = keysAreIncluded(table.clusteringKeys, propertiesInfo);

            // All clustering keys should be included or it can be inserting a static column value
            if (clusteringKeyMatches === keyMatches.all) {
              return true;
            }

            if (clusteringKeyMatches === keyMatches.some) {
              return false;
            }

            const staticColumns = staticColumnCount(table);
            return propertiesInfo.length === table.partitionKeys.length + staticColumns && staticColumns > 0;
          });

        if (filteredTables.length === 0) {
          throw new Error(`No table matches (all PKs have to be specified) fields: [${
            propertiesInfo.map(p => p.columnName)}]`);
        }

        return filteredTables;
      });
  }

  /**
   * Gets the tables that should be used to execute the UPDATE query.
   * @param {Client} client
   * @param {ModelMappingInfo} info
   * @param {Array} propertiesInfo
   * @param {Array} when
   * @return {Promise<Array<TableMetadata>>} A promise that resolves to an Array of tables.
   */
  static getForUpdate(client, info, propertiesInfo, when) {
    return Promise.all(info.tables.filter(t => !t.isView).map(t => client.metadata.getTable(info.keyspace, t.name)))
      .then(tables => {
        const filteredTables = tables
          .filter((table, i) => {
            if (table === null) {
              throw new Error(`Table "${info.tables[i].name}" could not be retrieved`);
            }

            if (keysAreIncluded(table.partitionKeys, propertiesInfo) !== keyMatches.all) {
              // Not all the partition keys are covered
              return false;
            }

            const clusteringKeyMatches = keysAreIncluded(table.clusteringKeys, propertiesInfo);

            // All clustering keys should be included or it can be updating a static column value
            if (clusteringKeyMatches === keyMatches.some) {
              return false;
            }

            if (clusteringKeyMatches === keyMatches.none && !hasStaticColumn(table)) {
              return false;
            }

            const applicableColumns = propertiesInfo
              .reduce((acc, p) => acc + (table.columnsByName[p.columnName] !== undefined ? 1 : 0), 0);

            if (applicableColumns <= table.partitionKeys.length + table.clusteringKeys.length) {
              if (!hasStaticColumn(table) || applicableColumns <= table.partitionKeys.length) {
                // UPDATE statement does not contain columns to SET
                return false;
              }
            }

            // "when" conditions should be contained in the table
            return when.reduce((acc, p) => acc && table.columnsByName[p.columnName] !== undefined, true);
          });

        if (filteredTables.length === 0) {
          let message = `No table matches (all PKs and columns to set have to be specified) fields: [${
            propertiesInfo.map(p => p.columnName)}]`;

          if (when.length > 0) {
            message += `; condition: [${when.map(p => p.columnName)}]`;
          }

          throw new Error(message);
        }

        return filteredTables;
      });
  }

  /**
   * Gets the tables that should be used to execute the DELETE query.
   * @param {Client} client
   * @param {ModelMappingInfo} info
   * @param {Array} propertiesInfo
   * @param {Array} when
   * @return {Promise<Array<TableMetadata>>} A promise that resolves to an Array of tables.
   */
  static getForDelete(client, info, propertiesInfo, when) {
    return Promise.all(info.tables.filter(t => !t.isView).map(t => client.metadata.getTable(info.keyspace, t.name)))
      .then(tables => {
        const filteredTables = tables
          .filter((table, i) => {
            if (table === null) {
              throw new Error(`Table "${info.tables[i].name}" could not be retrieved`);
            }

            // All partition and clustering keys from the table should be included in the document
            const keyNames = table.partitionKeys.concat(table.clusteringKeys).map(k => k.name);
            const columns = propertiesInfo.map(p => p.columnName);

            for (let i = 0; i < keyNames.length; i++) {
              if (columns.indexOf(keyNames[i]) === -1) {
                return false;
              }
            }

            // "when" conditions should be contained in the table
            return when.reduce((acc, p) => acc && table.columnsByName[p.columnName] !== undefined, true);
          });

        if (filteredTables.length === 0) {
          let message = `No table matches (all PKs have to be specified) fields: [${
            propertiesInfo.map(p => p.columnName)}]`;

          if (when.length > 0) {
            message += `; condition: [${when.map(p => p.columnName)}]`;
          }

          throw new Error(message);
        }

        return filteredTables;
      });
  }
};

function contains(arr, fn) {
  return arr.filter(fn).length > 0;
}

/**
 * Returns the amount of matches for a given key
 * @private
 * @param {Array} keys
 * @param {Array} propertiesInfo
 */
function keysAreIncluded(keys, propertiesInfo) {
  if (keys.length === 0) {
    return keyMatches.all;
  }

  // Filtering by name might look slow / ineffective to using hash maps
  // but we expect `keys` and `propertiesInfo` to contain only few items
  const matches = propertiesInfo.reduce((acc, p) => acc + (contains(keys, k => p.columnName === k.name) ? 1 : 0), 0);
  if (matches === 0) {
    return keyMatches.none;
  }

  return matches === keys.length ? keyMatches.all : keyMatches.some;
}

function hasStaticColumn(table) {
  return staticColumnCount(table) > 0;
}

function staticColumnCount(table) {
  return table.columns.reduce((acc, column) => acc + (column.isStatic ? 1 : 0), 0);
}

var objectSelector = ObjectSelector$1;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const errors$1 = errors$n;
const utils$2 = utils$K;

/**
 * Provides utility methods to adapt and map user provided docInfo and executionOptions to a predictable object format.
 * @ignore
 */
let DocInfoAdapter$2 = class DocInfoAdapter {
  /**
   * Returns an Array where each item contains the property name, the column name and the property value (to obtain
   * the operator).
   * When docInfo.fields is specified, it uses that array to obtain the information.
   * @param {Array<String>} docKeys
   * @param {null|{fields}} docInfo
   * @param {Object} doc
   * @param {ModelMappingInfo} mappingInfo
   * @returns {Array}
   */
  static getPropertiesInfo(docKeys, docInfo, doc, mappingInfo) {
    let propertyKeys = docKeys;
    if (docInfo && docInfo.fields && docInfo.fields.length > 0) {
      propertyKeys = docInfo.fields;
    }

    return propertyKeys.map(propertyName => ({
      propertyName,
      columnName: mappingInfo.getColumnName(propertyName),
      value: doc[propertyName],
      fromModel: mappingInfo.getFromModelFn(propertyName)
    }));
  }

  /**
   * @param {{orderBy}} docInfo
   * @param {ModelMappingInfo} mappingInfo
   * @returns {Array<String>}
   */
  static adaptOrderBy(docInfo, mappingInfo){
    if (!docInfo || !docInfo.orderBy) {
      return utils$2.emptyArray;
    }
    return Object.keys(docInfo.orderBy).map(key => {
      const value = docInfo.orderBy[key];
      const ordering = typeof value === 'string' ? value.toUpperCase() : value;
      if (ordering !== 'ASC' && ordering !== 'DESC') {
        throw new errors$1.ArgumentError('Order must be either "ASC" or "DESC", obtained: ' + value);
      }
      return [ mappingInfo.getColumnName(key), ordering ];
    });
  }

  /**
   * Returns the QueryOptions for an INSERT/UPDATE/DELETE statement.
   * @param {Object|String|undefined} executionOptions
   * @param {Boolean} isIdempotent
   */
  static adaptOptions(executionOptions, isIdempotent) {
    const options = {
      prepare: true,
      executionProfile: undefined,
      timestamp: undefined,
      isIdempotent: isIdempotent
    };

    if (typeof executionOptions === 'string') {
      options.executionProfile = executionOptions;
    }
    else if (executionOptions !== null && executionOptions !== undefined) {
      options.executionProfile = executionOptions.executionProfile;
      options.timestamp = executionOptions.timestamp;

      if (executionOptions.isIdempotent !== undefined) {
        options.isIdempotent = executionOptions.isIdempotent;
      }
    }
    return options;
  }

  /**
   * Returns the QueryOptions for a SELECT statement.
   * @param {Object|String|undefined} executionOptions
   * @param {Boolean} [overrideIdempotency]
   */
  static adaptAllOptions(executionOptions, overrideIdempotency) {
    const options = {
      prepare: true,
      executionProfile: undefined,
      fetchSize: undefined,
      pageState: undefined,
      timestamp: undefined,
      isIdempotent: undefined
    };

    if (typeof executionOptions === 'string') {
      options.executionProfile = executionOptions;
    }
    else if (executionOptions !== null && executionOptions !== undefined) {
      options.executionProfile = executionOptions.executionProfile;
      options.fetchSize = executionOptions.fetchSize;
      options.pageState = executionOptions.pageState;
      options.timestamp = executionOptions.timestamp;
      options.isIdempotent = executionOptions.isIdempotent;
    }

    if (overrideIdempotency) {
      options.isIdempotent = true;
    }

    return options;
  }

  /**
   * Returns the QueryOptions for a batch statement.
   * @param {Object|String|undefined} executionOptions
   * @param {Boolean} isIdempotent
   * @param {Boolean} isCounter
   */
  static adaptBatchOptions(executionOptions, isIdempotent, isCounter) {
    const options = {
      prepare: true,
      executionProfile: undefined,
      timestamp: undefined,
      logged: undefined,
      isIdempotent: isIdempotent,
      counter: isCounter
    };

    if (typeof executionOptions === 'string') {
      options.executionProfile = executionOptions;
    }
    else if (executionOptions !== null && executionOptions !== undefined) {
      options.executionProfile = executionOptions.executionProfile;
      options.timestamp = executionOptions.timestamp;
      options.logged = executionOptions.logged !== false;

      if (executionOptions.isIdempotent !== undefined) {
        options.isIdempotent = executionOptions.isIdempotent;
      }
    }
    return options;
  }
};

var docInfoAdapter = DocInfoAdapter$2;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const utils$1 = utils$K;
const QueryGenerator = queryGenerator;
const ResultMapper$1 = resultMapper;
const Result$1 = result;
const Cache = cache;
const Tree = tree;
const ObjectSelector = objectSelector;
const DocInfoAdapter$1 = docInfoAdapter;

const cacheHighWaterMark = 100;

/**
 * @ignore
 */
let MappingHandler$1 = class MappingHandler {
  /**
   * @param {Client} client
   * @param {ModelMappingInfo} mappingInfo
   */
  constructor(client, mappingInfo) {
    this._client = client;
    this._cache = {
      select: new Tree().on('add', length => this._validateCacheLength(length)),
      selectAll: new Tree().on('add', length => this._validateCacheLength(length)),
      insert: new Tree().on('add', length => this._validateCacheLength(length)),
      update: new Tree().on('add', length => this._validateCacheLength(length)),
      remove: new Tree().on('add', length => this._validateCacheLength(length)),
      customQueries: new Map()
    };

    /**
     * Gets the mapping information of the document.
     * @type {ModelMappingInfo}
     */
    this.info = mappingInfo;
  }

  /**
   * Gets a function to be used to execute SELECT the query using the document.
   * @param {Object} doc
   * @param {{fields, orderBy, limit}} docInfo
   * @param {Boolean} allPKsDefined Determines whether all primary keys must be defined in the doc for the query to
   * be valid.
   * @return {Promise<Function>}
   */
  getSelectExecutor(doc, docInfo, allPKsDefined) {
    const docKeys = Object.keys(doc);
    if (docKeys.length === 0) {
      return Promise.reject(new Error('Expected object with keys'));
    }

    const cacheKey = Cache.getSelectKey(docKeys, doc, docInfo);
    // Cache the executor and the result mapper under the same key
    // That way, those can get evicted together
    const cacheItem = this._cache.select.getOrCreate(cacheKey, () => ({ executor: null, resultAdapter: null }));

    if (cacheItem.executor !== null) {
      return Promise.resolve(cacheItem.executor);
    }

    const propertiesInfo = DocInfoAdapter$1.getPropertiesInfo(docKeys, null, doc, this.info);
    const fieldsInfo = DocInfoAdapter$1.getPropertiesInfo(utils$1.emptyArray, docInfo, doc, this.info);
    const orderByColumns = DocInfoAdapter$1.adaptOrderBy(docInfo, this.info);
    const limit = docInfo && docInfo.limit;

    return this._client.connect()
      .then(() =>
        ObjectSelector.getForSelect(this._client, this.info, allPKsDefined, propertiesInfo, fieldsInfo, orderByColumns))
      .then(tableName => {
        // Part of the closure
        const query = QueryGenerator.getSelect(tableName, this.info.keyspace, propertiesInfo, fieldsInfo,
          orderByColumns, limit);
        const paramsGetter = QueryGenerator.selectParamsGetter(propertiesInfo, limit);
        const self = this;

        cacheItem.executor = function selectExecutor(doc, docInfo, executionOptions) {
          return self._executeSelect(query, paramsGetter, doc, docInfo, executionOptions, cacheItem);
        };

        return cacheItem.executor;
      });
  }

  getSelectAllExecutor(docInfo) {
    const cacheKey = Cache.getSelectAllKey(docInfo);
    const cacheItem = this._cache.selectAll.getOrCreate(cacheKey, () => ({ executor: null, resultAdapter: null }));

    if (cacheItem.executor !== null) {
      return cacheItem.executor;
    }

    const fieldsInfo = DocInfoAdapter$1.getPropertiesInfo(utils$1.emptyArray, docInfo, utils$1.emptyObject, this.info);
    const orderByColumns = DocInfoAdapter$1.adaptOrderBy(docInfo, this.info);
    const limit = docInfo && docInfo.limit;

    const tableName = ObjectSelector.getForSelectAll(this.info);

    // Part of the closure
    const query = QueryGenerator.getSelect(
      tableName, this.info.keyspace, utils$1.emptyArray, fieldsInfo, orderByColumns, limit);
    const paramsGetter = QueryGenerator.selectParamsGetter(utils$1.emptyArray, limit);
    const self = this;

    cacheItem.executor = function selectAllExecutor(docInfo, executionOptions) {
      return self._executeSelect(query, paramsGetter, null, docInfo, executionOptions, cacheItem);
    };

    return cacheItem.executor;
  }

  /**
   * Executes a SELECT query and returns the adapted results.
   * When a result adapter is not yet created, it gets a new one and caches it.
   * @private
   */
  _executeSelect(query, paramsGetter, doc, docInfo, executionOptions, cacheItem) {
    const options = DocInfoAdapter$1.adaptAllOptions(executionOptions, true);

    return this._client.execute(query, paramsGetter(doc, docInfo, this.info), options)
      .then(rs => {
        if (cacheItem.resultAdapter === null) {
          cacheItem.resultAdapter = ResultMapper$1.getSelectAdapter(this.info, rs);
        }
        return new Result$1(rs, this.info, cacheItem.resultAdapter);
      });
  }

  /**
   * Gets a function to be used to execute INSERT the query using the document.
   * @param {Object} doc
   * @param {{ifNotExists, ttl, fields}} docInfo
   * @return {Promise<Function>}
   */
  getInsertExecutor(doc, docInfo) {
    const docKeys = Object.keys(doc);
    if (docKeys.length === 0) {
      return Promise.reject(new Error('Expected object with keys'));
    }

    const cacheKey = Cache.getInsertKey(docKeys, docInfo);
    const cacheItem = this._cache.insert.getOrCreate(cacheKey, () => ({ executor: null }));

    if (cacheItem.executor !== null) {
      return Promise.resolve(cacheItem.executor);
    }

    return this.createInsertQueries(docKeys, doc, docInfo)
      .then(queries => {
        if (queries.length === 1) {
          return this._setSingleExecutor(cacheItem, queries[0]);
        }

        return this._setBatchExecutor(cacheItem, queries);
      });
  }

  /**
   * Creates an Array containing the query and the params getter function for each table affected by the INSERT.
   * @param {Array<String>} docKeys
   * @param {Object} doc
   * @param {{ifNotExists, ttl, fields}} docInfo
   * @returns {Promise<Array<{query, paramsGetter}>>}
   */
  createInsertQueries(docKeys, doc, docInfo) {
    const propertiesInfo = DocInfoAdapter$1.getPropertiesInfo(docKeys, docInfo, doc, this.info);
    const ifNotExists = docInfo && docInfo.ifNotExists;

    // Get all the tables affected
    return this._client.connect()
      .then(() => ObjectSelector.getForInsert(this._client, this.info, propertiesInfo))
      .then(tables => {

        if (tables.length > 1 && ifNotExists) {
          throw new Error('Batch with ifNotExists conditions cannot span multiple tables');
        }

        // For each tables affected, Generate query and parameter getters
        return tables.map(table =>
          QueryGenerator.getInsert(table, this.info.keyspace, propertiesInfo, docInfo,ifNotExists));
      });
  }

  /**
   * Gets a function to be used to execute the UPDATE queries with the provided document.
   * @param {Object} doc
   * @param {{ifExists, when, ttl, fields}} docInfo
   * @return {Promise<Function>}
   */
  getUpdateExecutor(doc, docInfo) {
    const docKeys = Object.keys(doc);
    if (docKeys.length === 0) {
      return Promise.reject(new Error('Expected object with keys'));
    }

    const cacheKey = Cache.getUpdateKey(docKeys, doc, docInfo);
    const cacheItem = this._cache.update.getOrCreate(cacheKey, () => ({ executor: null }));

    if (cacheItem.executor !== null) {
      return Promise.resolve(cacheItem.executor);
    }

    return this.createUpdateQueries(docKeys, doc, docInfo)
      .then(queries => {
        if (queries.length === 1) {
          return this._setSingleExecutor(cacheItem, queries[0]);
        }

        return this._setBatchExecutor(cacheItem, queries);
      });
  }

  /**
   * Creates an Array containing the query and the params getter function for each table affected by the UPDATE.
   * @param {Array<String>} docKeys
   * @param {Object} doc
   * @param {Object} docInfo
   * @returns {Promise<Array<{query, paramsGetter, isIdempotent}>>}
   */
  createUpdateQueries(docKeys, doc, docInfo) {
    const propertiesInfo = DocInfoAdapter$1.getPropertiesInfo(docKeys, docInfo, doc, this.info);
    const ifExists = docInfo && docInfo.ifExists;
    const when = docInfo && docInfo.when
      ? DocInfoAdapter$1.getPropertiesInfo(Object.keys(docInfo.when), null, docInfo.when, this.info)
      : utils$1.emptyArray;

    if (when.length > 0 && ifExists) {
      throw new Error('Both when and ifExists conditions can not be applied to the same statement');
    }

    // Get all the tables affected
    return this._client.connect()
      .then(() => ObjectSelector.getForUpdate(this._client, this.info, propertiesInfo, when))
      .then(tables => {

        if (tables.length > 1 && (when.length > 0 || ifExists)) {
          throw new Error('Batch with when or ifExists conditions cannot span multiple tables');
        }

        // For each table affected, Generate query and parameter getters
        return tables.map(table =>
          QueryGenerator.getUpdate(table, this.info.keyspace, propertiesInfo, docInfo, when, ifExists));
      });
  }

  /**
   * Gets a function to be used to execute the DELETE queries with the provided document.
   * @param {Object} doc
   * @param {{when, ifExists, fields, deleteOnlyColumns}} docInfo
   * @return {Promise<Function>}
   */
  getDeleteExecutor(doc, docInfo) {
    const docKeys = Object.keys(doc);
    if (docKeys.length === 0) {
      return Promise.reject(new Error('Expected object with keys'));
    }

    const cacheKey = Cache.getRemoveKey(docKeys, doc, docInfo);
    const cacheItem = this._cache.remove.getOrCreate(cacheKey, () => ({ executor: null }));

    if (cacheItem.executor !== null) {
      return Promise.resolve(cacheItem.executor);
    }

    return this.createDeleteQueries(docKeys, doc, docInfo)
      .then(queries => {
        if (queries.length === 1) {
          return this._setSingleExecutor(cacheItem, queries[0]);
        }

        return this._setBatchExecutor(cacheItem, queries);
      });
  }

  /**
   * Creates an Array containing the query and the params getter function for each table affected by the DELETE.
   * @param {Array<String>} docKeys
   * @param {Object} doc
   * @param {{when, ifExists, fields, deleteOnlyColumns}} docInfo
   * @returns {Promise<Array<{query, paramsGetter}>>}
   */
  createDeleteQueries(docKeys, doc, docInfo) {
    const propertiesInfo = DocInfoAdapter$1.getPropertiesInfo(docKeys, docInfo, doc, this.info);
    const ifExists = docInfo && docInfo.ifExists;
    const when = docInfo && docInfo.when
      ? DocInfoAdapter$1.getPropertiesInfo(Object.keys(docInfo.when), null, docInfo.when, this.info)
      : utils$1.emptyArray;

    if (when.length > 0 && ifExists) {
      throw new Error('Both when and ifExists conditions can not be applied to the same statement');
    }

    // Get all the tables affected
    return this._client.connect()
      .then(() => ObjectSelector.getForDelete(this._client, this.info, propertiesInfo, when))
      .then(tables => {

        if (tables.length > 1 && (when.length > 0 || ifExists)) {
          throw new Error('Batch with when or ifExists conditions cannot span multiple tables');
        }

        // For each tables affected, Generate query and parameter getters
        return tables.map(table =>
          QueryGenerator.getDelete(table, this.info.keyspace, propertiesInfo, docInfo, when, ifExists));
      });
  }

  getExecutorFromQuery(query, paramsHandler, commonExecutionOptions) {
    // Use the current instance in the closure
    // as there is no guarantee of how the returned function will be invoked
    const self = this;
    const commonOptions = commonExecutionOptions ? DocInfoAdapter$1.adaptAllOptions(commonExecutionOptions) : null;

    return (function queryMappedExecutor(doc, executionOptions) {
      // When the executionOptions were already specified,
      // use it and skip the ones provided in each invocation
      const options = commonOptions
        ? commonOptions
        : DocInfoAdapter$1.adaptAllOptions(executionOptions);

      return self._client.execute(query, paramsHandler(doc), options).then(rs => {
        // Cache the resultAdapter based on the query
        let resultAdapter = self._cache.customQueries.get(query);

        if (resultAdapter === undefined) {
          const resultAdapterInfo = ResultMapper$1.getCustomQueryAdapter(self.info, rs);
          resultAdapter = resultAdapterInfo.fn;
          if (resultAdapterInfo.canCache) {
            // Avoid caching conditional updates results as the amount of columns change
            // depending on the parameter values.
            self._cache.customQueries.set(query, resultAdapter);

            if (self._cache.customQueries.size === cacheHighWaterMark) {
              self._client.log('warning',
                `Custom queries cache reached ${cacheHighWaterMark} items, this could be caused by ` +
                `hard-coding parameter values inside the query, which should be avoided`);
            }
          }
        }

        return new Result$1(rs, self.info, resultAdapter);
      });
    });
  }

  _setSingleExecutor(cacheItem, queryInfo) {
    // Parameters and this instance are part of the closure
    const self = this;

    // Set the function to execute the request in the cache
    cacheItem.executor = function singleExecutor(doc, docInfo, executionOptions) {
      const options = DocInfoAdapter$1.adaptOptions(executionOptions, queryInfo.isIdempotent);

      return self._client.execute(queryInfo.query, queryInfo.paramsGetter(doc, docInfo, self.info), options)
        .then(rs => new Result$1(rs, self.info, ResultMapper$1.getMutationAdapter(rs)));
    };

    return cacheItem.executor;
  }

  _setBatchExecutor(cacheItem, queries) {
    // Parameters and the following fields are part of the closure
    const self = this;
    const isIdempotent = queries.reduce((acc, q) => acc && q.isIdempotent, true);

    // Set the function to execute the batch request in the cache
    cacheItem.executor = function batchExecutor(doc, docInfo, executionOptions) {
      // Use the params getter function to obtain the parameters each time
      const queryAndParams = queries.map(q => ({
        query: q.query,
        params: q.paramsGetter(doc, docInfo, self.info)
      }));

      const options = DocInfoAdapter$1.adaptOptions(executionOptions, isIdempotent);

      // Execute using a Batch
      return self._client.batch(queryAndParams, options)
        .then(rs => new Result$1(rs, self.info, ResultMapper$1.getMutationAdapter(rs)));
    };

    return cacheItem.executor;
  }

  _validateCacheLength(length) {
    if (length !== cacheHighWaterMark) {
      return;
    }

    this._client.log('warning', `ModelMapper cache reached ${cacheHighWaterMark} items, this could be caused by ` +
      `building the object to map in different ways (with different shapes) each time. Use the same or few object ` +
      `structures for a model and represent unset values with undefined or types.unset`);
  }
};

var mappingHandler = MappingHandler$1;

var tableMappings = {};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Contains a set of methods to represent a row into a document and a document into a row.
 * @alias module:mapping~TableMappings
 * @interface
 */
let TableMappings$1 = class TableMappings {
  /**
   * Method that is called by the mapper to create the instance of the document.
   * @return {Object}
   */
  newObjectInstance() {
    return {};
  }

  /**
   * Gets the name of the column based on the document property name.
   * @param {String} propName The name of the property.
   * @returns {String}
   */
  getColumnName(propName) {
    return propName;
  }

  /**
   * Gets the name of the document property based on the column name.
   * @param {String} columnName The name of the column.
   * @returns {String}
   */
  getPropertyName(columnName) {
    return columnName;
  }
};

/**
 * A [TableMappings]{@link module:mapping~TableMappings} implementation that converts CQL column names in all-lowercase
 * identifiers with underscores (snake case) to camel case (initial lowercase letter) property names.
 * <p>
 *   The conversion is performed without any checks for the source format, you should make sure that the source
 *   format is snake case for CQL identifiers and camel case for properties.
 * </p>
 * @alias module:mapping~UnderscoreCqlToCamelCaseMappings
 * @implements {module:mapping~TableMappings}
 */
class UnderscoreCqlToCamelCaseMappings extends TableMappings$1 {
  /**
   * Creates a new instance of {@link UnderscoreCqlToCamelCaseMappings}
   */
  constructor() {
    super();
  }

  /**
   * Converts a property name in camel case to snake case.
   * @param {String} propName Name of the property to convert to snake case.
   * @return {String}
   */
  getColumnName(propName) {
    return propName.replace(/[a-z][A-Z]/g, (match, offset) => match.charAt(0) + '_' + match.charAt(1)).toLowerCase();
  }

  /**
   * Converts a column name in snake case to camel case.
   * @param {String} columnName The column name to convert to camel case.
   * @return {String}
   */
  getPropertyName(columnName) {
    return columnName.replace(/_[a-z]/g, (match, offset) => ((offset === 0) ? match : match.substr(1).toUpperCase()));
  }
}

/**
 * Default implementation of [TableMappings]{@link module:mapping~TableMappings} that doesn't perform any conversion.
 * @alias module:mapping~DefaultTableMappings
 * @implements {module:mapping~TableMappings}
 */
let DefaultTableMappings$1 = class DefaultTableMappings extends TableMappings$1 {
  /**
   * Creates a new instance of {@link DefaultTableMappings}.
   */
  constructor() {
    super();
  }

  /**  @override */
  getColumnName(propName) {
    return super.getColumnName(propName);
  }

  /** @override */
  getPropertyName(columnName) {
    return super.getPropertyName(columnName);
  }

  /**
   * Creates a new object instance, using object initializer.
   */
  newObjectInstance() {
    return super.newObjectInstance();
  }
};

tableMappings.TableMappings = TableMappings$1;
tableMappings.UnderscoreCqlToCamelCaseMappings = UnderscoreCqlToCamelCaseMappings;
tableMappings.DefaultTableMappings = DefaultTableMappings$1;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const tableMappingsModule$1 = tableMappings;
const TableMappings = tableMappingsModule$1.TableMappings;
const DefaultTableMappings = tableMappingsModule$1.DefaultTableMappings;

/**
 * Represents the parsed user information of the table mappings of a model.
 * @ignore
 */
let ModelMappingInfo$1 = class ModelMappingInfo {
  /**
   * @param {String} keyspace
   * @param {Array<{name, isView}>} tables
   * @param {TableMappings} mappings
   * @param {Map<String,ModelColumnInfo>} columns
   */
  constructor(keyspace, tables, mappings, columns) {
    this.keyspace = keyspace;
    this.tables = tables;
    this._mappings = mappings;
    this._columns = columns;

    // Define a map of column information per property name
    /** @type {Map<String, ModelColumnInfo>} */
    this._documentProperties = new Map();
    for (const modelColumnInfo of columns.values()) {
      this._documentProperties.set(modelColumnInfo.propertyName, modelColumnInfo);
    }
  }

  getColumnName(propName) {
    const modelColumnInfo = this._documentProperties.get(propName);
    if (modelColumnInfo !== undefined) {
      // There is an specific name transformation between the column name and the property name
      return modelColumnInfo.columnName;
    }
    // Rely on the TableMappings (i.e. maybe there is a convention defined for this property)
    return this._mappings.getColumnName(propName);
  }

  getPropertyName(columnName) {
    const modelColumnInfo = this._columns.get(columnName);
    if (modelColumnInfo !== undefined) {
      // There is an specific name transformation between the column name and the property name
      return modelColumnInfo.propertyName;
    }
    // Rely on the TableMappings (i.e. maybe there is a convention defined for this column)
    return this._mappings.getPropertyName(columnName);
  }

  getFromModelFn(propName) {
    const modelColumnInfo = this._documentProperties.get(propName);
    return modelColumnInfo !== undefined ? modelColumnInfo.fromModel : null;
  }

  getToModelFn(columnName) {
    const modelColumnInfo = this._columns.get(columnName);
    return modelColumnInfo !== undefined ? modelColumnInfo.toModel : null;
  }

  newInstance() {
    return this._mappings.newObjectInstance();
  }

  /**
   * Parses the user options into a map of model names and ModelMappingInfo.
   * @param {MappingOptions} options
   * @param {String} currentKeyspace
   * @returns {Map<String, ModelMappingInfo>}
   */
  static parse(options, currentKeyspace) {
    const result = new Map();
    if (!options || !options.models) {
      return result;
    }

    Object.keys(options.models).forEach(modelName => {
      const modelOptions = options.models[modelName];
      result.set(modelName, ModelMappingInfo._create(modelName, currentKeyspace, modelOptions));
    });

    return result;
  }

  static _create(modelName, currentKeyspace, modelOptions) {
    if (!currentKeyspace && (!modelOptions || !modelOptions.keyspace)) {
      throw new Error(
        'You should specify the keyspace of the model in the MappingOptions when the Client is not using a keyspace');
    }

    if (!modelOptions) {
      return ModelMappingInfo.createDefault(modelName, currentKeyspace);
    }

    let tables;

    if (modelOptions.tables && modelOptions.tables.length > 0) {
      tables = modelOptions.tables.map(item => {
        const table = { name: null, isView: false };
        if (typeof item === 'string') {
          table.name = item;
        } else if (item) {
          table.name = item.name;
          table.isView = !!item.isView;
        }

        if (!table.name) {
          throw new Error(`Table name not specified for model '${modelName}'`);
        }

        return table;
      });
    } else {
      tables = [ { name: modelName, isView: false }];
    }

    if (modelOptions.mappings && !(modelOptions.mappings instanceof TableMappings)) {
      throw new Error('mappings should be an instance of TableMappings');
    }

    const columns = new Map();
    if (modelOptions.columns !== null && typeof modelOptions.columns === 'object') {
      Object.keys(modelOptions.columns).forEach(columnName => {
        columns.set(columnName, ModelColumnInfo.parse(columnName, modelOptions.columns[columnName]));
      });
    }

    return new ModelMappingInfo(
      modelOptions.keyspace || currentKeyspace,
      tables,
      modelOptions.mappings || new DefaultTableMappings(),
      columns
    );
  }

  static createDefault(modelName, currentKeyspace) {
    return new ModelMappingInfo(
      currentKeyspace,
      [ { name: modelName, isView: false }],
      new DefaultTableMappings(),
      new Map());
  }
};

class ModelColumnInfo {
  constructor(columnName, propertyName, toModel, fromModel) {
    this.columnName = columnName;
    this.propertyName = propertyName;

    if (toModel && typeof toModel !== 'function') {
      throw new TypeError(`toModel type for property '${propertyName}' should be a function (obtained ${
        typeof toModel})`);
    }

    if (fromModel && typeof fromModel !== 'function') {
      throw new TypeError(`fromModel type for property '${propertyName}' should be a function (obtained ${
        typeof fromModel})`);
    }

    this.toModel = toModel;
    this.fromModel = fromModel;
  }

  static parse(columnName, value) {
    if (!value) {
      return new ModelColumnInfo(columnName, columnName);
    }

    if (typeof value === 'string') {
      return new ModelColumnInfo(columnName, value);
    }

    return new ModelColumnInfo(columnName, value.name || columnName, value.toModel, value.fromModel);
  }
}

var modelMappingInfo = ModelMappingInfo$1;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const ModelMapper = modelMapper;
const MappingHandler = mappingHandler;
const DocInfoAdapter = docInfoAdapter;
const errors = errors$n;
const Result = result;
const ResultMapper = resultMapper;
const ModelMappingInfo = modelMappingInfo;
const { ModelBatchItem } = modelBatchItem;

/**
 * Represents an object mapper for Apache Cassandra and DataStax Enterprise.
 * @alias module:mapping~Mapper
 * @example <caption>Creating a Mapper instance with some options for the model 'User'</caption>
 * const mappingOptions = {
 *   models: {
 *     'User': {
 *       tables: ['users'],
 *       mappings: new UnderscoreCqlToCamelCaseMappings(),
 *       columnNames: {
 *         'userid': 'id'
 *       }
 *     }
 *   }
 * };
 * const mapper = new Mapper(client, mappingOptions);
 * @example <caption>Creating a Mapper instance with other possible options for a model</caption>
 * const mappingOptions = {
 *   models: {
 *     'Video': {
 *       tables: ['videos', 'user_videos', 'latest_videos', { name: 'my_videos_view', isView: true }],
 *       mappings: new UnderscoreCqlToCamelCaseMappings(),
 *       columnNames: {
 *         'videoid': 'id'
 *       },
 *       keyspace: 'ks1'
 *     }
 *   }
 * };
 * const mapper = new Mapper(client, mappingOptions);
 */
class Mapper {
  /**
   * Creates a new instance of Mapper.
   * @param {Client} client The Client instance to use to execute the queries and fetch the metadata.
   * @param {MappingOptions} [options] The [MappingOptions]{@link module:mapping~MappingOptions} containing the
   * information of the models and table mappings.
   */
  constructor(client, options) {
    if (!client) {
      throw new Error('client must be defined');
    }

    /**
     * The Client instance used to create this Mapper instance.
     * @type {Client}
     */
    this.client = client;

    this._modelMappingInfos = ModelMappingInfo.parse(options, client.keyspace);
    this._modelMappers = new Map();
  }

  /**
   * Gets a [ModelMapper]{@link module:mapping~ModelMapper} that is able to map documents of a certain model into
   * CQL rows.
   * @param {String} name The name to identify the model. Note that the name is case-sensitive.
   * @returns {ModelMapper} A [ModelMapper]{@link module:mapping~ModelMapper} instance.
   */
  forModel(name) {
    let modelMapper = this._modelMappers.get(name);

    if (modelMapper === undefined) {
      let mappingInfo = this._modelMappingInfos.get(name);

      if (mappingInfo === undefined) {
        if (!this.client.keyspace) {
          throw new Error(`No mapping information found for model '${name}'. ` +
            `Mapper is unable to create default mappings without setting the keyspace`);
        }

        mappingInfo = ModelMappingInfo.createDefault(name, this.client.keyspace);
        this.client.log('info', `Mapping information for model '${name}' not found, creating default mapping. ` +
          `Keyspace: ${mappingInfo.keyspace}; Table: ${mappingInfo.tables[0].name}.`);
      } else {
        this.client.log('info', `Creating model mapper for '${name}' using mapping information. Keyspace: ${
          mappingInfo.keyspace}; Table${mappingInfo.tables.length > 1? 's' : ''}: ${
          mappingInfo.tables.map(t => t.name)}.`);
      }

      modelMapper = new ModelMapper(name, new MappingHandler(this.client, mappingInfo));
      this._modelMappers.set(name, modelMapper);
    }

    return modelMapper;
  }

  /**
   * Executes a batch of queries represented in the items.
   * @param {Array<ModelBatchItem>} items
   * @param {Object|String} [executionOptions] An object containing the options to be used for the requests
   * execution or a string representing the name of the execution profile.
   * @param {String} [executionOptions.executionProfile] The name of the execution profile.
   * @param {Boolean} [executionOptions.isIdempotent] Defines whether the query can be applied multiple times without
   * changing the result beyond the initial application.
   * <p>
   *   The mapper uses the generated queries to determine the default value. When an UPDATE is generated with a
   *   counter column or appending/prepending to a list column, the execution is marked as not idempotent.
   * </p>
   * <p>
   *   Additionally, the mapper uses the safest approach for queries with lightweight transactions (Compare and
   *   Set) by considering them as non-idempotent. Lightweight transactions at client level with transparent retries can
   *   break linearizability. If that is not an issue for your application, you can manually set this field to true.
   * </p>
   * @param {Boolean} [executionOptions.logged=true] Determines whether the batch should be written to the batchlog.
   * @param {Number|Long} [executionOptions.timestamp] The default timestamp for the query in microseconds from the
   * unix epoch (00:00:00, January 1st, 1970).
   * @returns {Promise<Result>} A Promise that resolves to a [Result]{@link module:mapping~Result}.
   */
  batch(items, executionOptions) {
    if (!Array.isArray(items) || !(items.length > 0)) {
      return Promise.reject(
        new errors.ArgumentError('First parameter items should be an Array with 1 or more ModelBatchItem instances'));
    }

    const queries = [];
    let isIdempotent = true;
    let isCounter;

    return Promise
      .all(items
        .map(item => {
          if (!(item instanceof ModelBatchItem)) {
            return Promise.reject(new Error(
              'Batch items must be instances of ModelBatchItem, use modelMapper.batching object to create each item'));
          }

          return item.pushQueries(queries)
            .then(options => {
              // The batch is idempotent when all the queries contained are idempotent
              isIdempotent = isIdempotent && options.isIdempotent;

              // Let it fail at server level when there is a mix of counter and normal mutations
              isCounter = options.isCounter;
            });
        }))
      .then(() =>
        this.client.batch(queries, DocInfoAdapter.adaptBatchOptions(executionOptions, isIdempotent, isCounter)))
      .then(rs => {
        // Results should only be adapted when the batch contains LWT (single table)
        const info = items[0].getMappingInfo();
        return new Result(rs, info, ResultMapper.getMutationAdapter(rs));
      });
  }
}

/**
 * Represents the mapping options.
 * @typedef {Object} module:mapping~MappingOptions
 * @property {Object<String, ModelOptions>} models An associative array containing the
 * name of the model as key and the table and column information as value.
 */

/**
 * Represents a set of options that applies to a certain model.
 * @typedef {Object} module:mapping~ModelOptions
 * @property {Array<String>|Array<{name, isView}>} tables An Array containing the name of the tables or An Array
 * containing the name and isView property to describe the table.
 * @property {TableMappings} mappings The TableMappings implementation instance that is used to convert from column
 * names to property names and the other way around.
 * @property {Object.<String, String>} [columnNames] An associative array containing the name of the columns and
 * properties that doesn't follow the convention defined in the <code>TableMappings</code>.
 * @property {String} [keyspace] The name of the keyspace. Only mandatory when the Client is not using a keyspace.
 */

var mapper = Mapper;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Module containing classes and fields related to the Mapper.
 * @module mapping
 */

mapping.Mapper = mapper;
mapping.ModelMapper = modelMapper;
mapping.ModelBatchMapper = modelBatchMapper;
mapping.ModelBatchItem = modelBatchItem.ModelBatchItem;
mapping.Result = result;
const tableMappingsModule = tableMappings;
mapping.TableMappings = tableMappingsModule.TableMappings;
mapping.DefaultTableMappings = tableMappingsModule.DefaultTableMappings;
mapping.UnderscoreCqlToCamelCaseMappings = tableMappingsModule.UnderscoreCqlToCamelCaseMappings;
mapping.q = q$1.q;

var concurrent = {};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const { Stream } = require$$0$1;
const utils = utils$K;

/**
 * Utilities for concurrent query execution with the DataStax Node.js Driver.
 * @module concurrent
 */

/**
 * Executes multiple queries concurrently at the defined concurrency level.
 * @static
 * @param {Client} client The {@link Client} instance.
 * @param {String|Array<{query, params}>} query The query to execute per each parameter item.
 * @param {Array<Array>|Stream|Object} parameters An {@link Array} or a readable {@link Stream} composed of {@link Array}
 * items representing each individual set of parameters. Per each item in the {@link Array} or {@link Stream}, an
 * execution is going to be made.
 * @param {Object} [options] The execution options.
 * @param {String} [options.executionProfile] The execution profile to be used.
 * @param {Number} [options.concurrencyLevel=100] The concurrency level to determine the maximum amount of in-flight
 * operations at any given time
 * @param {Boolean} [options.raiseOnFirstError=true] Determines whether execution should stop after the first failed
 * execution and the corresponding exception will be raised.
 * @param {Boolean} [options.collectResults=false] Determines whether each individual
 * [ResultSet]{@link module:types~ResultSet} instance should be collected in the grouped result.
 * @param {Number} [options.maxErrors=100] The maximum amount of errors to be collected before ignoring the rest of
 * the error results.
 * @returns {Promise<ResultSetGroup>} A <code>Promise</code> of {@link ResultSetGroup} that is resolved when all the
 * executions completed and it's rejected when <code>raiseOnFirstError</code> is <code>true</code> and there is one
 * or more failures.
 * @example <caption>Using a fixed query and an Array of Arrays as parameters</caption>
 * const query = 'INSERT INTO table1 (id, value) VALUES (?, ?)';
 * const parameters = [[1, 'a'], [2, 'b'], [3, 'c'], ]; // ...
 * const result = await executeConcurrent(client, query, parameters);
 * @example <caption>Using a fixed query and a readable stream</caption>
 * const stream = csvStream.pipe(transformLineToArrayStream);
 * const result = await executeConcurrent(client, query, stream);
 * @example <caption>Using a different queries</caption>
 * const queryAndParameters = [
 *   { query: 'INSERT INTO videos (id, name, user_id) VALUES (?, ?, ?)',
 *     params: [ id, name, userId ] },
 *   { query: 'INSERT INTO user_videos (user_id, id, name) VALUES (?, ?, ?)',
 *     params: [ userId, id, name ] },
 *   { query: 'INSERT INTO latest_videos (id, name, user_id) VALUES (?, ?, ?)',
 *     params: [ id, name, userId ] },
 * ];
 *
 * const result = await executeConcurrent(client, queryAndParameters);
 */
function executeConcurrent(client, query, parameters, options) {
  if (!client) {
    throw new TypeError('Client instance is not defined');
  }

  if (typeof query === 'string') {
    if (Array.isArray(parameters)) {
      return new ArrayBasedExecutor(client, query, parameters, options).execute();
    }

    if (parameters instanceof Stream) {
      return new StreamBasedExecutor(client, query, parameters, options).execute();
    }

    throw new TypeError('parameters should be an Array or a Stream instance');
  }

  if (Array.isArray(query)) {
    options = parameters;
    return new ArrayBasedExecutor(client, null, query, options).execute();
  }

  throw new TypeError('A string query or query and parameters array should be provided');
}

/**
 * Wraps the functionality to execute given an Array.
 * @ignore
 */
class ArrayBasedExecutor {

  /**
   * @param {Client} client
   * @param {String} query
   * @param {Array<Array>|Array<{query, params}>} parameters
   * @param {Object} [options] The execution options.
   * @private
   */
  constructor(client, query, parameters, options) {
    this._client = client;
    this._query = query;
    this._parameters = parameters;
    options = options || utils.emptyObject;
    this._raiseOnFirstError = options.raiseOnFirstError !== false;
    this._concurrencyLevel = Math.min(options.concurrencyLevel || 100, this._parameters.length);
    this._queryOptions = { prepare: true, executionProfile: options.executionProfile };
    this._result = new ResultSetGroup(options);
    this._stop = false;
  }

  execute() {
    const promises = new Array(this._concurrencyLevel);

    for (let i = 0; i < this._concurrencyLevel; i++) {
      promises[i] = this._executeOneAtATime(i, 0);
    }

    return Promise.all(promises).then(() => this._result);
  }

  _executeOneAtATime(initialIndex, iteration) {
    const index = initialIndex + this._concurrencyLevel * iteration;

    if (index >= this._parameters.length || this._stop) {
      return Promise.resolve();
    }

    const item = this._parameters[index];
    let query;
    let params;

    if (this._query === null) {
      query = item.query;
      params = item.params;
    } else {
      query = this._query;
      params = item;
    }

    return this._client.execute(query, params, this._queryOptions)
      .then(rs => this._result.setResultItem(index, rs))
      .catch(err => this._setError(index, err))
      .then(() => this._executeOneAtATime(initialIndex, iteration + 1));
  }

  _setError(index, err) {
    this._result.setError(index, err);

    if (this._raiseOnFirstError) {
      this._stop = true;
      throw err;
    }
  }
}

/**
 * Wraps the functionality to execute given a Stream.
 * @ignore
 */
class StreamBasedExecutor {

  /**
   * @param {Client} client
   * @param {String} query
   * @param {Stream} stream
   * @param {Object} [options] The execution options.
   * @private
   */
  constructor(client, query, stream, options) {
    this._client = client;
    this._query = query;
    this._stream = stream;
    options = options || utils.emptyObject;
    this._raiseOnFirstError = options.raiseOnFirstError !== false;
    this._concurrencyLevel = options.concurrencyLevel || 100;
    this._queryOptions = { prepare: true, executionProfile: options.executionProfile };
    this._inFlight = 0;
    this._index = 0;
    this._result = new ResultSetGroup(options);
    this._resolveCallback = null;
    this._rejectCallback = null;
    this._readEnded = false;
  }

  execute() {
    return new Promise((resolve, reject) => {
      this._resolveCallback = resolve;
      this._rejectCallback = reject;

      this._stream
        .on('data', params => this._executeOne(params))
        .on('error', err => this._setReadEnded(err))
        .on('end', () => this._setReadEnded());
    });
  }

  _executeOne(params) {
    if (!Array.isArray(params)) {
      return this._setReadEnded(new TypeError('Stream should be in objectMode and should emit Array instances'));
    }

    if (this._readEnded) {
      // Read ended abruptly because of incorrect format or error event being emitted.
      // We shouldn't consider additional items.
      return;
    }

    const index = this._index++;
    this._inFlight++;

    this._client.execute(this._query, params, this._queryOptions)
      .then(rs => {
        this._result.setResultItem(index, rs);
        this._inFlight--;
      })
      .catch(err => {
        this._inFlight--;
        this._setError(index, err);
      })
      .then(() => {
        if (this._stream.isPaused()) {
          this._stream.resume();
        }

        if (this._readEnded && this._inFlight === 0) {
          // When read ended and there are no more in-flight requests
          // We yield the result to the user.
          // It could have ended prematurely when there is a read error
          // or there was an execution error and raiseOnFirstError is true
          // In that case, calling the resolve callback has no effect
          this._resolveCallback(this._result);
        }
      });

    if (this._inFlight >= this._concurrencyLevel) {
      this._stream.pause();
    }
  }

  /**
   * Marks the stream read process as ended.
   * @param {Error} [err] The stream read error.
   * @private
   */
  _setReadEnded(err) {
    if (!this._readEnded) {
      this._readEnded = true;

      if (err) {
        // There was an error while reading from the input stream.
        // This should be surfaced as a failure
        this._rejectCallback(err);
      } else if (this._inFlight === 0) {
        // Ended signaled and there are no more pending messages.
        this._resolveCallback(this._result);
      }
    }
  }

  _setError(index, err) {
    this._result.setError(index, err);

    if (this._raiseOnFirstError) {
      this._readEnded = true;
      this._rejectCallback(err);
    }
  }
}

/**
 * Represents results from different related executions.
 */
class ResultSetGroup {

  /**
   * Creates a new instance of {@link ResultSetGroup}.
   * @ignore
   */
  constructor(options) {
    this._collectResults = options.collectResults;
    this._maxErrors = options.maxErrors || 100;
    this.totalExecuted = 0;
    this.errors = [];

    if (this._collectResults) {
      /**
       * Gets an {@link Array} containing the [ResultSet]{@link module:types~ResultSet} instances from each execution.
       * <p>
       *   Note that when <code>collectResults</code> is set to <code>false</code>, accessing this property will
       *   throw an error.
       * </p>
       * @type {Array}
       */
      this.resultItems = [];
    } else {
      Object.defineProperty(this, 'resultItems', { enumerable: false, get: () => {
        throw new Error('Property resultItems can not be accessed when collectResults is set to false');
      }});
    }
  }

  /** @ignore */
  setResultItem(index, rs) {
    this.totalExecuted++;

    if (this._collectResults) {
      this.resultItems[index] = rs;
    }
  }

  /**
   * Internal method to set the error of an execution.
   * @ignore
   */
  setError(index, err) {
    this.totalExecuted++;

    if (this.errors.length < this._maxErrors) {
      this.errors.push(err);
    }

    if (this._collectResults) {
      this.resultItems[index] = err;
    }
  }
}

concurrent.executeConcurrent = executeConcurrent;
concurrent.ResultSetGroup = ResultSetGroup;

var datastax = {};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * DataStax module.
 * <p>
 *   Contains modules and classes to represent functionality that is specific to DataStax products.
 * </p>
 * @module datastax
 */

datastax.graph = graph;
datastax.search = search;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const clientOptions = requireClientOptions();
cassandraDriver.Client = client;
cassandraDriver.ExecutionProfile = executionProfile.ExecutionProfile;
cassandraDriver.ExecutionOptions = executionOptions.ExecutionOptions;
cassandraDriver.types = requireTypes();
cassandraDriver.errors = errors$n;
cassandraDriver.policies = requirePolicies();
cassandraDriver.auth = auth;
cassandraDriver.mapping = mapping;
cassandraDriver.tracker = tracker;
cassandraDriver.metrics = metrics;
cassandraDriver.concurrent = concurrent;

const token = token$3;
cassandraDriver.token = {
  Token: token.Token,
  TokenRange: token.TokenRange
};
const Metadata = metadata;
cassandraDriver.metadata = {
  Metadata: Metadata
};
cassandraDriver.Encoder = encoder;
cassandraDriver.geometry = geometry$1;
cassandraDriver.datastax = datastax;
/**
 * Returns a new instance of the default [options]{@link ClientOptions} used by the driver.
 */
cassandraDriver.defaultOptions = function () {
  return clientOptions.defaultOptions();
};
cassandraDriver.version = require$$17.version;

//TEMP@DAY
function TODO() {
	return new Error('This functionality has not been implemented yet!!!');
}

class Client_Cassandra extends client$1 {
	_driver() {
		return cassandraDriver;
	}

	schemaCompiler() {
		return new SchemaCompiler_Cassandra(this, ...arguments);
	}

	queryCompiler(builder, formatter) {
		return new QueryCompiler_Cassandra(this, builder, formatter);
	}

	columnCompiler() {
		return new ColumnCompiler_Cassandra(this, ...arguments);
	}

	tableCompiler() {
		return new TableCompiler_Cassandra(this, ...arguments);
	}

	transaction() {
		throw TODO();
	}

	wrapIdentifier(value, queryContext) {
		return this.config.wrapIdentifier ? 
			this.config.wrapIdentifier(value, this.wrapIdentifierImpl, queryContext) :
			this.wrapIdentifierImpl(value); 
	}

	wrapIdentifierImpl(value) {
		if (value === '*') return value;
		return value.replace(/"/g, '""').replace(/'/g, `''`).replace(/--|\/\*|\*\/|\/\//g, '').replace(/[^a-zA-Z0-9_]/g, '_');
	}

	// get a raw connection, called by the `pool` whenever a new
	// connection needs to be added to the pool.
	// NOTE@DAY it seems that cassandra-driver already handles connection pooling, so we may be able to get around this completely?
	// (we may also have to figure out a way to fake it so that knex doesn't get angry)
	acquireRawConnection() {
		return new Promise((resolve, reject) => {
			const connection = new this.driver.Client(this.connectionSettings);
			connection.connect()
				.then(() => {
					console.log('Connected to cluster with %d host(s): %j', connection.hosts.length);
					resolve(connection);				
				})
				.catch((err) => {
					console.error('There was an error while connecting', err);
					reject(err);
				});
		});
	}

	async destroyRawConnection(connection) {
		return new Promise((resolve, reject) => {
			connection.shutdown()
				.then(() => resolve())
				.catch((err) => reject(err));
		});
	}

	// NOTE@DAY skipping over some functions here

	//Runs a query on the specified connection, providing the bindings and any other necessary prep work.
	_query(connection, obj) {
		if (!obj || typeof obj === 'string') obj = { sql: obj };
		if (!obj.sql) throw new Error('The query is empty');

		return new Promise((resolve, reject) => {
			if (!obj.sql) {
				resolve();
				return;
			}
			if (!obj.options) obj.options = {};
			obj.options.prepare = true;
			connection.execute(
				obj.sql,
				obj.bindings,
				obj.options,
				(err, result) => {
					if (err) return reject(err);
					//needs to be formatted as [rows, fields]
					obj.response = [result.rows, result.columns];
					resolve(obj);
				}
			);
		});
	}

	async processResponse(obj, runner) {
		if (!obj) return;

		const { response, method } = obj;
		if (obj.output) {
			return obj.output.call(runner, response);
		}

		const [rows, fields] = response;
		// TODO@Day fixBlobCallbacks?

		switch (method) {
			case 'first':
				return rows[0];
			default:
				return rows;
		}
	}
}

Object.assign(Client_Cassandra.prototype, {
	requestQueue: [],
	dialect: 'cassandra',
	driverName: 'cassandra-driver'
});

module.exports = Client_Cassandra;
//# sourceMappingURL=cassandra_knex.cjs.map
